
T9_L17_USBHostMSCTFTSlideShow.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028948  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000026a0  08028ae8  08028ae8  00038ae8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0802b188  0802b188  00040090  2**0
                  CONTENTS
  4 .ARM          00000008  0802b188  0802b188  0003b188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0802b190  0802b190  00040090  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0802b190  0802b190  0003b190  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0802b194  0802b194  0003b194  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000090  20000000  0802b198  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000142c  20000090  0802b228  00040090  2**3
                  ALLOC
 10 ._user_heap_stack 00001804  200014bc  0802b228  000414bc  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00040090  2**0
                  CONTENTS, READONLY
 12 .debug_info   0007713f  00000000  00000000  000400c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000accd  00000000  00000000  000b71ff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001d28  00000000  00000000  000c1ed0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 000019e8  00000000  00000000  000c3bf8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000f9dc  00000000  00000000  000c55e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00043761  00000000  00000000  000d4fbc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00095c5e  00000000  00000000  0011871d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  001ae37b  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000078d8  00000000  00000000  001ae3d0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000090 	.word	0x20000090
 80001bc:	00000000 	.word	0x00000000
 80001c0:	08028ad0 	.word	0x08028ad0

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000094 	.word	0x20000094
 80001dc:	08028ad0 	.word	0x08028ad0

080001e0 <memchr>:
 80001e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001e4:	2a10      	cmp	r2, #16
 80001e6:	db2b      	blt.n	8000240 <memchr+0x60>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	d008      	beq.n	8000200 <memchr+0x20>
 80001ee:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001f2:	3a01      	subs	r2, #1
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d02d      	beq.n	8000254 <memchr+0x74>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	b342      	cbz	r2, 8000250 <memchr+0x70>
 80001fe:	d1f6      	bne.n	80001ee <memchr+0xe>
 8000200:	b4f0      	push	{r4, r5, r6, r7}
 8000202:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000206:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800020a:	f022 0407 	bic.w	r4, r2, #7
 800020e:	f07f 0700 	mvns.w	r7, #0
 8000212:	2300      	movs	r3, #0
 8000214:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000218:	3c08      	subs	r4, #8
 800021a:	ea85 0501 	eor.w	r5, r5, r1
 800021e:	ea86 0601 	eor.w	r6, r6, r1
 8000222:	fa85 f547 	uadd8	r5, r5, r7
 8000226:	faa3 f587 	sel	r5, r3, r7
 800022a:	fa86 f647 	uadd8	r6, r6, r7
 800022e:	faa5 f687 	sel	r6, r5, r7
 8000232:	b98e      	cbnz	r6, 8000258 <memchr+0x78>
 8000234:	d1ee      	bne.n	8000214 <memchr+0x34>
 8000236:	bcf0      	pop	{r4, r5, r6, r7}
 8000238:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800023c:	f002 0207 	and.w	r2, r2, #7
 8000240:	b132      	cbz	r2, 8000250 <memchr+0x70>
 8000242:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000246:	3a01      	subs	r2, #1
 8000248:	ea83 0301 	eor.w	r3, r3, r1
 800024c:	b113      	cbz	r3, 8000254 <memchr+0x74>
 800024e:	d1f8      	bne.n	8000242 <memchr+0x62>
 8000250:	2000      	movs	r0, #0
 8000252:	4770      	bx	lr
 8000254:	3801      	subs	r0, #1
 8000256:	4770      	bx	lr
 8000258:	2d00      	cmp	r5, #0
 800025a:	bf06      	itte	eq
 800025c:	4635      	moveq	r5, r6
 800025e:	3803      	subeq	r0, #3
 8000260:	3807      	subne	r0, #7
 8000262:	f015 0f01 	tst.w	r5, #1
 8000266:	d107      	bne.n	8000278 <memchr+0x98>
 8000268:	3001      	adds	r0, #1
 800026a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800026e:	bf02      	ittt	eq
 8000270:	3001      	addeq	r0, #1
 8000272:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000276:	3001      	addeq	r0, #1
 8000278:	bcf0      	pop	{r4, r5, r6, r7}
 800027a:	3801      	subs	r0, #1
 800027c:	4770      	bx	lr
 800027e:	bf00      	nop

08000280 <__aeabi_drsub>:
 8000280:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000284:	e002      	b.n	800028c <__adddf3>
 8000286:	bf00      	nop

08000288 <__aeabi_dsub>:
 8000288:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800028c <__adddf3>:
 800028c:	b530      	push	{r4, r5, lr}
 800028e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000292:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000296:	ea94 0f05 	teq	r4, r5
 800029a:	bf08      	it	eq
 800029c:	ea90 0f02 	teqeq	r0, r2
 80002a0:	bf1f      	itttt	ne
 80002a2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002a6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002b2:	f000 80e2 	beq.w	800047a <__adddf3+0x1ee>
 80002b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002be:	bfb8      	it	lt
 80002c0:	426d      	neglt	r5, r5
 80002c2:	dd0c      	ble.n	80002de <__adddf3+0x52>
 80002c4:	442c      	add	r4, r5
 80002c6:	ea80 0202 	eor.w	r2, r0, r2
 80002ca:	ea81 0303 	eor.w	r3, r1, r3
 80002ce:	ea82 0000 	eor.w	r0, r2, r0
 80002d2:	ea83 0101 	eor.w	r1, r3, r1
 80002d6:	ea80 0202 	eor.w	r2, r0, r2
 80002da:	ea81 0303 	eor.w	r3, r1, r3
 80002de:	2d36      	cmp	r5, #54	; 0x36
 80002e0:	bf88      	it	hi
 80002e2:	bd30      	pophi	{r4, r5, pc}
 80002e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002f4:	d002      	beq.n	80002fc <__adddf3+0x70>
 80002f6:	4240      	negs	r0, r0
 80002f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000300:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000304:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000308:	d002      	beq.n	8000310 <__adddf3+0x84>
 800030a:	4252      	negs	r2, r2
 800030c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000310:	ea94 0f05 	teq	r4, r5
 8000314:	f000 80a7 	beq.w	8000466 <__adddf3+0x1da>
 8000318:	f1a4 0401 	sub.w	r4, r4, #1
 800031c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000320:	db0d      	blt.n	800033e <__adddf3+0xb2>
 8000322:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000326:	fa22 f205 	lsr.w	r2, r2, r5
 800032a:	1880      	adds	r0, r0, r2
 800032c:	f141 0100 	adc.w	r1, r1, #0
 8000330:	fa03 f20e 	lsl.w	r2, r3, lr
 8000334:	1880      	adds	r0, r0, r2
 8000336:	fa43 f305 	asr.w	r3, r3, r5
 800033a:	4159      	adcs	r1, r3
 800033c:	e00e      	b.n	800035c <__adddf3+0xd0>
 800033e:	f1a5 0520 	sub.w	r5, r5, #32
 8000342:	f10e 0e20 	add.w	lr, lr, #32
 8000346:	2a01      	cmp	r2, #1
 8000348:	fa03 fc0e 	lsl.w	ip, r3, lr
 800034c:	bf28      	it	cs
 800034e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000352:	fa43 f305 	asr.w	r3, r3, r5
 8000356:	18c0      	adds	r0, r0, r3
 8000358:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800035c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000360:	d507      	bpl.n	8000372 <__adddf3+0xe6>
 8000362:	f04f 0e00 	mov.w	lr, #0
 8000366:	f1dc 0c00 	rsbs	ip, ip, #0
 800036a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800036e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000372:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000376:	d31b      	bcc.n	80003b0 <__adddf3+0x124>
 8000378:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800037c:	d30c      	bcc.n	8000398 <__adddf3+0x10c>
 800037e:	0849      	lsrs	r1, r1, #1
 8000380:	ea5f 0030 	movs.w	r0, r0, rrx
 8000384:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000388:	f104 0401 	add.w	r4, r4, #1
 800038c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000390:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000394:	f080 809a 	bcs.w	80004cc <__adddf3+0x240>
 8000398:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800039c:	bf08      	it	eq
 800039e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003a2:	f150 0000 	adcs.w	r0, r0, #0
 80003a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003aa:	ea41 0105 	orr.w	r1, r1, r5
 80003ae:	bd30      	pop	{r4, r5, pc}
 80003b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003b4:	4140      	adcs	r0, r0
 80003b6:	eb41 0101 	adc.w	r1, r1, r1
 80003ba:	3c01      	subs	r4, #1
 80003bc:	bf28      	it	cs
 80003be:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80003c2:	d2e9      	bcs.n	8000398 <__adddf3+0x10c>
 80003c4:	f091 0f00 	teq	r1, #0
 80003c8:	bf04      	itt	eq
 80003ca:	4601      	moveq	r1, r0
 80003cc:	2000      	moveq	r0, #0
 80003ce:	fab1 f381 	clz	r3, r1
 80003d2:	bf08      	it	eq
 80003d4:	3320      	addeq	r3, #32
 80003d6:	f1a3 030b 	sub.w	r3, r3, #11
 80003da:	f1b3 0220 	subs.w	r2, r3, #32
 80003de:	da0c      	bge.n	80003fa <__adddf3+0x16e>
 80003e0:	320c      	adds	r2, #12
 80003e2:	dd08      	ble.n	80003f6 <__adddf3+0x16a>
 80003e4:	f102 0c14 	add.w	ip, r2, #20
 80003e8:	f1c2 020c 	rsb	r2, r2, #12
 80003ec:	fa01 f00c 	lsl.w	r0, r1, ip
 80003f0:	fa21 f102 	lsr.w	r1, r1, r2
 80003f4:	e00c      	b.n	8000410 <__adddf3+0x184>
 80003f6:	f102 0214 	add.w	r2, r2, #20
 80003fa:	bfd8      	it	le
 80003fc:	f1c2 0c20 	rsble	ip, r2, #32
 8000400:	fa01 f102 	lsl.w	r1, r1, r2
 8000404:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000408:	bfdc      	itt	le
 800040a:	ea41 010c 	orrle.w	r1, r1, ip
 800040e:	4090      	lslle	r0, r2
 8000410:	1ae4      	subs	r4, r4, r3
 8000412:	bfa2      	ittt	ge
 8000414:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000418:	4329      	orrge	r1, r5
 800041a:	bd30      	popge	{r4, r5, pc}
 800041c:	ea6f 0404 	mvn.w	r4, r4
 8000420:	3c1f      	subs	r4, #31
 8000422:	da1c      	bge.n	800045e <__adddf3+0x1d2>
 8000424:	340c      	adds	r4, #12
 8000426:	dc0e      	bgt.n	8000446 <__adddf3+0x1ba>
 8000428:	f104 0414 	add.w	r4, r4, #20
 800042c:	f1c4 0220 	rsb	r2, r4, #32
 8000430:	fa20 f004 	lsr.w	r0, r0, r4
 8000434:	fa01 f302 	lsl.w	r3, r1, r2
 8000438:	ea40 0003 	orr.w	r0, r0, r3
 800043c:	fa21 f304 	lsr.w	r3, r1, r4
 8000440:	ea45 0103 	orr.w	r1, r5, r3
 8000444:	bd30      	pop	{r4, r5, pc}
 8000446:	f1c4 040c 	rsb	r4, r4, #12
 800044a:	f1c4 0220 	rsb	r2, r4, #32
 800044e:	fa20 f002 	lsr.w	r0, r0, r2
 8000452:	fa01 f304 	lsl.w	r3, r1, r4
 8000456:	ea40 0003 	orr.w	r0, r0, r3
 800045a:	4629      	mov	r1, r5
 800045c:	bd30      	pop	{r4, r5, pc}
 800045e:	fa21 f004 	lsr.w	r0, r1, r4
 8000462:	4629      	mov	r1, r5
 8000464:	bd30      	pop	{r4, r5, pc}
 8000466:	f094 0f00 	teq	r4, #0
 800046a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800046e:	bf06      	itte	eq
 8000470:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000474:	3401      	addeq	r4, #1
 8000476:	3d01      	subne	r5, #1
 8000478:	e74e      	b.n	8000318 <__adddf3+0x8c>
 800047a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800047e:	bf18      	it	ne
 8000480:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000484:	d029      	beq.n	80004da <__adddf3+0x24e>
 8000486:	ea94 0f05 	teq	r4, r5
 800048a:	bf08      	it	eq
 800048c:	ea90 0f02 	teqeq	r0, r2
 8000490:	d005      	beq.n	800049e <__adddf3+0x212>
 8000492:	ea54 0c00 	orrs.w	ip, r4, r0
 8000496:	bf04      	itt	eq
 8000498:	4619      	moveq	r1, r3
 800049a:	4610      	moveq	r0, r2
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	ea91 0f03 	teq	r1, r3
 80004a2:	bf1e      	ittt	ne
 80004a4:	2100      	movne	r1, #0
 80004a6:	2000      	movne	r0, #0
 80004a8:	bd30      	popne	{r4, r5, pc}
 80004aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ae:	d105      	bne.n	80004bc <__adddf3+0x230>
 80004b0:	0040      	lsls	r0, r0, #1
 80004b2:	4149      	adcs	r1, r1
 80004b4:	bf28      	it	cs
 80004b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ba:	bd30      	pop	{r4, r5, pc}
 80004bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004c0:	bf3c      	itt	cc
 80004c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004c6:	bd30      	popcc	{r4, r5, pc}
 80004c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004d4:	f04f 0000 	mov.w	r0, #0
 80004d8:	bd30      	pop	{r4, r5, pc}
 80004da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004de:	bf1a      	itte	ne
 80004e0:	4619      	movne	r1, r3
 80004e2:	4610      	movne	r0, r2
 80004e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004e8:	bf1c      	itt	ne
 80004ea:	460b      	movne	r3, r1
 80004ec:	4602      	movne	r2, r0
 80004ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004f2:	bf06      	itte	eq
 80004f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004f8:	ea91 0f03 	teqeq	r1, r3
 80004fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000500:	bd30      	pop	{r4, r5, pc}
 8000502:	bf00      	nop

08000504 <__aeabi_ui2d>:
 8000504:	f090 0f00 	teq	r0, #0
 8000508:	bf04      	itt	eq
 800050a:	2100      	moveq	r1, #0
 800050c:	4770      	bxeq	lr
 800050e:	b530      	push	{r4, r5, lr}
 8000510:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000514:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000518:	f04f 0500 	mov.w	r5, #0
 800051c:	f04f 0100 	mov.w	r1, #0
 8000520:	e750      	b.n	80003c4 <__adddf3+0x138>
 8000522:	bf00      	nop

08000524 <__aeabi_i2d>:
 8000524:	f090 0f00 	teq	r0, #0
 8000528:	bf04      	itt	eq
 800052a:	2100      	moveq	r1, #0
 800052c:	4770      	bxeq	lr
 800052e:	b530      	push	{r4, r5, lr}
 8000530:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000534:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000538:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800053c:	bf48      	it	mi
 800053e:	4240      	negmi	r0, r0
 8000540:	f04f 0100 	mov.w	r1, #0
 8000544:	e73e      	b.n	80003c4 <__adddf3+0x138>
 8000546:	bf00      	nop

08000548 <__aeabi_f2d>:
 8000548:	0042      	lsls	r2, r0, #1
 800054a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800054e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000552:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000556:	bf1f      	itttt	ne
 8000558:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800055c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000560:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000564:	4770      	bxne	lr
 8000566:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800056a:	bf08      	it	eq
 800056c:	4770      	bxeq	lr
 800056e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000572:	bf04      	itt	eq
 8000574:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000578:	4770      	bxeq	lr
 800057a:	b530      	push	{r4, r5, lr}
 800057c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000580:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000584:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000588:	e71c      	b.n	80003c4 <__adddf3+0x138>
 800058a:	bf00      	nop

0800058c <__aeabi_ul2d>:
 800058c:	ea50 0201 	orrs.w	r2, r0, r1
 8000590:	bf08      	it	eq
 8000592:	4770      	bxeq	lr
 8000594:	b530      	push	{r4, r5, lr}
 8000596:	f04f 0500 	mov.w	r5, #0
 800059a:	e00a      	b.n	80005b2 <__aeabi_l2d+0x16>

0800059c <__aeabi_l2d>:
 800059c:	ea50 0201 	orrs.w	r2, r0, r1
 80005a0:	bf08      	it	eq
 80005a2:	4770      	bxeq	lr
 80005a4:	b530      	push	{r4, r5, lr}
 80005a6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005aa:	d502      	bpl.n	80005b2 <__aeabi_l2d+0x16>
 80005ac:	4240      	negs	r0, r0
 80005ae:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005b2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005b6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005ba:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005be:	f43f aed8 	beq.w	8000372 <__adddf3+0xe6>
 80005c2:	f04f 0203 	mov.w	r2, #3
 80005c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ca:	bf18      	it	ne
 80005cc:	3203      	addne	r2, #3
 80005ce:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005d2:	bf18      	it	ne
 80005d4:	3203      	addne	r2, #3
 80005d6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005da:	f1c2 0320 	rsb	r3, r2, #32
 80005de:	fa00 fc03 	lsl.w	ip, r0, r3
 80005e2:	fa20 f002 	lsr.w	r0, r0, r2
 80005e6:	fa01 fe03 	lsl.w	lr, r1, r3
 80005ea:	ea40 000e 	orr.w	r0, r0, lr
 80005ee:	fa21 f102 	lsr.w	r1, r1, r2
 80005f2:	4414      	add	r4, r2
 80005f4:	e6bd      	b.n	8000372 <__adddf3+0xe6>
 80005f6:	bf00      	nop

080005f8 <__aeabi_dmul>:
 80005f8:	b570      	push	{r4, r5, r6, lr}
 80005fa:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005fe:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000602:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000606:	bf1d      	ittte	ne
 8000608:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800060c:	ea94 0f0c 	teqne	r4, ip
 8000610:	ea95 0f0c 	teqne	r5, ip
 8000614:	f000 f8de 	bleq	80007d4 <__aeabi_dmul+0x1dc>
 8000618:	442c      	add	r4, r5
 800061a:	ea81 0603 	eor.w	r6, r1, r3
 800061e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000622:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000626:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800062a:	bf18      	it	ne
 800062c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000630:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000634:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000638:	d038      	beq.n	80006ac <__aeabi_dmul+0xb4>
 800063a:	fba0 ce02 	umull	ip, lr, r0, r2
 800063e:	f04f 0500 	mov.w	r5, #0
 8000642:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000646:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800064a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800064e:	f04f 0600 	mov.w	r6, #0
 8000652:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000656:	f09c 0f00 	teq	ip, #0
 800065a:	bf18      	it	ne
 800065c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000660:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000664:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000668:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800066c:	d204      	bcs.n	8000678 <__aeabi_dmul+0x80>
 800066e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000672:	416d      	adcs	r5, r5
 8000674:	eb46 0606 	adc.w	r6, r6, r6
 8000678:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800067c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000680:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000684:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000688:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800068c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000690:	bf88      	it	hi
 8000692:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000696:	d81e      	bhi.n	80006d6 <__aeabi_dmul+0xde>
 8000698:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800069c:	bf08      	it	eq
 800069e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006a2:	f150 0000 	adcs.w	r0, r0, #0
 80006a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006aa:	bd70      	pop	{r4, r5, r6, pc}
 80006ac:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006b0:	ea46 0101 	orr.w	r1, r6, r1
 80006b4:	ea40 0002 	orr.w	r0, r0, r2
 80006b8:	ea81 0103 	eor.w	r1, r1, r3
 80006bc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006c0:	bfc2      	ittt	gt
 80006c2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006c6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006ca:	bd70      	popgt	{r4, r5, r6, pc}
 80006cc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006d0:	f04f 0e00 	mov.w	lr, #0
 80006d4:	3c01      	subs	r4, #1
 80006d6:	f300 80ab 	bgt.w	8000830 <__aeabi_dmul+0x238>
 80006da:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006de:	bfde      	ittt	le
 80006e0:	2000      	movle	r0, #0
 80006e2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006e6:	bd70      	pople	{r4, r5, r6, pc}
 80006e8:	f1c4 0400 	rsb	r4, r4, #0
 80006ec:	3c20      	subs	r4, #32
 80006ee:	da35      	bge.n	800075c <__aeabi_dmul+0x164>
 80006f0:	340c      	adds	r4, #12
 80006f2:	dc1b      	bgt.n	800072c <__aeabi_dmul+0x134>
 80006f4:	f104 0414 	add.w	r4, r4, #20
 80006f8:	f1c4 0520 	rsb	r5, r4, #32
 80006fc:	fa00 f305 	lsl.w	r3, r0, r5
 8000700:	fa20 f004 	lsr.w	r0, r0, r4
 8000704:	fa01 f205 	lsl.w	r2, r1, r5
 8000708:	ea40 0002 	orr.w	r0, r0, r2
 800070c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000710:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000714:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000718:	fa21 f604 	lsr.w	r6, r1, r4
 800071c:	eb42 0106 	adc.w	r1, r2, r6
 8000720:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000724:	bf08      	it	eq
 8000726:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800072a:	bd70      	pop	{r4, r5, r6, pc}
 800072c:	f1c4 040c 	rsb	r4, r4, #12
 8000730:	f1c4 0520 	rsb	r5, r4, #32
 8000734:	fa00 f304 	lsl.w	r3, r0, r4
 8000738:	fa20 f005 	lsr.w	r0, r0, r5
 800073c:	fa01 f204 	lsl.w	r2, r1, r4
 8000740:	ea40 0002 	orr.w	r0, r0, r2
 8000744:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000748:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800074c:	f141 0100 	adc.w	r1, r1, #0
 8000750:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000754:	bf08      	it	eq
 8000756:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800075a:	bd70      	pop	{r4, r5, r6, pc}
 800075c:	f1c4 0520 	rsb	r5, r4, #32
 8000760:	fa00 f205 	lsl.w	r2, r0, r5
 8000764:	ea4e 0e02 	orr.w	lr, lr, r2
 8000768:	fa20 f304 	lsr.w	r3, r0, r4
 800076c:	fa01 f205 	lsl.w	r2, r1, r5
 8000770:	ea43 0302 	orr.w	r3, r3, r2
 8000774:	fa21 f004 	lsr.w	r0, r1, r4
 8000778:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800077c:	fa21 f204 	lsr.w	r2, r1, r4
 8000780:	ea20 0002 	bic.w	r0, r0, r2
 8000784:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000788:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800078c:	bf08      	it	eq
 800078e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000792:	bd70      	pop	{r4, r5, r6, pc}
 8000794:	f094 0f00 	teq	r4, #0
 8000798:	d10f      	bne.n	80007ba <__aeabi_dmul+0x1c2>
 800079a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800079e:	0040      	lsls	r0, r0, #1
 80007a0:	eb41 0101 	adc.w	r1, r1, r1
 80007a4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007a8:	bf08      	it	eq
 80007aa:	3c01      	subeq	r4, #1
 80007ac:	d0f7      	beq.n	800079e <__aeabi_dmul+0x1a6>
 80007ae:	ea41 0106 	orr.w	r1, r1, r6
 80007b2:	f095 0f00 	teq	r5, #0
 80007b6:	bf18      	it	ne
 80007b8:	4770      	bxne	lr
 80007ba:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007be:	0052      	lsls	r2, r2, #1
 80007c0:	eb43 0303 	adc.w	r3, r3, r3
 80007c4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007c8:	bf08      	it	eq
 80007ca:	3d01      	subeq	r5, #1
 80007cc:	d0f7      	beq.n	80007be <__aeabi_dmul+0x1c6>
 80007ce:	ea43 0306 	orr.w	r3, r3, r6
 80007d2:	4770      	bx	lr
 80007d4:	ea94 0f0c 	teq	r4, ip
 80007d8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007dc:	bf18      	it	ne
 80007de:	ea95 0f0c 	teqne	r5, ip
 80007e2:	d00c      	beq.n	80007fe <__aeabi_dmul+0x206>
 80007e4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007e8:	bf18      	it	ne
 80007ea:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007ee:	d1d1      	bne.n	8000794 <__aeabi_dmul+0x19c>
 80007f0:	ea81 0103 	eor.w	r1, r1, r3
 80007f4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007f8:	f04f 0000 	mov.w	r0, #0
 80007fc:	bd70      	pop	{r4, r5, r6, pc}
 80007fe:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000802:	bf06      	itte	eq
 8000804:	4610      	moveq	r0, r2
 8000806:	4619      	moveq	r1, r3
 8000808:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800080c:	d019      	beq.n	8000842 <__aeabi_dmul+0x24a>
 800080e:	ea94 0f0c 	teq	r4, ip
 8000812:	d102      	bne.n	800081a <__aeabi_dmul+0x222>
 8000814:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000818:	d113      	bne.n	8000842 <__aeabi_dmul+0x24a>
 800081a:	ea95 0f0c 	teq	r5, ip
 800081e:	d105      	bne.n	800082c <__aeabi_dmul+0x234>
 8000820:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000824:	bf1c      	itt	ne
 8000826:	4610      	movne	r0, r2
 8000828:	4619      	movne	r1, r3
 800082a:	d10a      	bne.n	8000842 <__aeabi_dmul+0x24a>
 800082c:	ea81 0103 	eor.w	r1, r1, r3
 8000830:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000834:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000838:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800083c:	f04f 0000 	mov.w	r0, #0
 8000840:	bd70      	pop	{r4, r5, r6, pc}
 8000842:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000846:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800084a:	bd70      	pop	{r4, r5, r6, pc}

0800084c <__aeabi_ddiv>:
 800084c:	b570      	push	{r4, r5, r6, lr}
 800084e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000852:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000856:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800085a:	bf1d      	ittte	ne
 800085c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000860:	ea94 0f0c 	teqne	r4, ip
 8000864:	ea95 0f0c 	teqne	r5, ip
 8000868:	f000 f8a7 	bleq	80009ba <__aeabi_ddiv+0x16e>
 800086c:	eba4 0405 	sub.w	r4, r4, r5
 8000870:	ea81 0e03 	eor.w	lr, r1, r3
 8000874:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000878:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800087c:	f000 8088 	beq.w	8000990 <__aeabi_ddiv+0x144>
 8000880:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000884:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000888:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800088c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000890:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000894:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000898:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800089c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008a0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008a4:	429d      	cmp	r5, r3
 80008a6:	bf08      	it	eq
 80008a8:	4296      	cmpeq	r6, r2
 80008aa:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008ae:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008b2:	d202      	bcs.n	80008ba <__aeabi_ddiv+0x6e>
 80008b4:	085b      	lsrs	r3, r3, #1
 80008b6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ba:	1ab6      	subs	r6, r6, r2
 80008bc:	eb65 0503 	sbc.w	r5, r5, r3
 80008c0:	085b      	lsrs	r3, r3, #1
 80008c2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008c6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008ca:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008ce:	ebb6 0e02 	subs.w	lr, r6, r2
 80008d2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008d6:	bf22      	ittt	cs
 80008d8:	1ab6      	subcs	r6, r6, r2
 80008da:	4675      	movcs	r5, lr
 80008dc:	ea40 000c 	orrcs.w	r0, r0, ip
 80008e0:	085b      	lsrs	r3, r3, #1
 80008e2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ea:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ee:	bf22      	ittt	cs
 80008f0:	1ab6      	subcs	r6, r6, r2
 80008f2:	4675      	movcs	r5, lr
 80008f4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008f8:	085b      	lsrs	r3, r3, #1
 80008fa:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fe:	ebb6 0e02 	subs.w	lr, r6, r2
 8000902:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000906:	bf22      	ittt	cs
 8000908:	1ab6      	subcs	r6, r6, r2
 800090a:	4675      	movcs	r5, lr
 800090c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	ebb6 0e02 	subs.w	lr, r6, r2
 800091a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800091e:	bf22      	ittt	cs
 8000920:	1ab6      	subcs	r6, r6, r2
 8000922:	4675      	movcs	r5, lr
 8000924:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000928:	ea55 0e06 	orrs.w	lr, r5, r6
 800092c:	d018      	beq.n	8000960 <__aeabi_ddiv+0x114>
 800092e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000932:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000936:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800093a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800093e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000942:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000946:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800094a:	d1c0      	bne.n	80008ce <__aeabi_ddiv+0x82>
 800094c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000950:	d10b      	bne.n	800096a <__aeabi_ddiv+0x11e>
 8000952:	ea41 0100 	orr.w	r1, r1, r0
 8000956:	f04f 0000 	mov.w	r0, #0
 800095a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800095e:	e7b6      	b.n	80008ce <__aeabi_ddiv+0x82>
 8000960:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000964:	bf04      	itt	eq
 8000966:	4301      	orreq	r1, r0
 8000968:	2000      	moveq	r0, #0
 800096a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800096e:	bf88      	it	hi
 8000970:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000974:	f63f aeaf 	bhi.w	80006d6 <__aeabi_dmul+0xde>
 8000978:	ebb5 0c03 	subs.w	ip, r5, r3
 800097c:	bf04      	itt	eq
 800097e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000982:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000986:	f150 0000 	adcs.w	r0, r0, #0
 800098a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800098e:	bd70      	pop	{r4, r5, r6, pc}
 8000990:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000994:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000998:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800099c:	bfc2      	ittt	gt
 800099e:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009a2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009a6:	bd70      	popgt	{r4, r5, r6, pc}
 80009a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009ac:	f04f 0e00 	mov.w	lr, #0
 80009b0:	3c01      	subs	r4, #1
 80009b2:	e690      	b.n	80006d6 <__aeabi_dmul+0xde>
 80009b4:	ea45 0e06 	orr.w	lr, r5, r6
 80009b8:	e68d      	b.n	80006d6 <__aeabi_dmul+0xde>
 80009ba:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009be:	ea94 0f0c 	teq	r4, ip
 80009c2:	bf08      	it	eq
 80009c4:	ea95 0f0c 	teqeq	r5, ip
 80009c8:	f43f af3b 	beq.w	8000842 <__aeabi_dmul+0x24a>
 80009cc:	ea94 0f0c 	teq	r4, ip
 80009d0:	d10a      	bne.n	80009e8 <__aeabi_ddiv+0x19c>
 80009d2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009d6:	f47f af34 	bne.w	8000842 <__aeabi_dmul+0x24a>
 80009da:	ea95 0f0c 	teq	r5, ip
 80009de:	f47f af25 	bne.w	800082c <__aeabi_dmul+0x234>
 80009e2:	4610      	mov	r0, r2
 80009e4:	4619      	mov	r1, r3
 80009e6:	e72c      	b.n	8000842 <__aeabi_dmul+0x24a>
 80009e8:	ea95 0f0c 	teq	r5, ip
 80009ec:	d106      	bne.n	80009fc <__aeabi_ddiv+0x1b0>
 80009ee:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009f2:	f43f aefd 	beq.w	80007f0 <__aeabi_dmul+0x1f8>
 80009f6:	4610      	mov	r0, r2
 80009f8:	4619      	mov	r1, r3
 80009fa:	e722      	b.n	8000842 <__aeabi_dmul+0x24a>
 80009fc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a00:	bf18      	it	ne
 8000a02:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a06:	f47f aec5 	bne.w	8000794 <__aeabi_dmul+0x19c>
 8000a0a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a0e:	f47f af0d 	bne.w	800082c <__aeabi_dmul+0x234>
 8000a12:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a16:	f47f aeeb 	bne.w	80007f0 <__aeabi_dmul+0x1f8>
 8000a1a:	e712      	b.n	8000842 <__aeabi_dmul+0x24a>

08000a1c <__aeabi_d2f>:
 8000a1c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a20:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a24:	bf24      	itt	cs
 8000a26:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a2a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a2e:	d90d      	bls.n	8000a4c <__aeabi_d2f+0x30>
 8000a30:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a34:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a38:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a3c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a40:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a44:	bf08      	it	eq
 8000a46:	f020 0001 	biceq.w	r0, r0, #1
 8000a4a:	4770      	bx	lr
 8000a4c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a50:	d121      	bne.n	8000a96 <__aeabi_d2f+0x7a>
 8000a52:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a56:	bfbc      	itt	lt
 8000a58:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a5c:	4770      	bxlt	lr
 8000a5e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a62:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a66:	f1c2 0218 	rsb	r2, r2, #24
 8000a6a:	f1c2 0c20 	rsb	ip, r2, #32
 8000a6e:	fa10 f30c 	lsls.w	r3, r0, ip
 8000a72:	fa20 f002 	lsr.w	r0, r0, r2
 8000a76:	bf18      	it	ne
 8000a78:	f040 0001 	orrne.w	r0, r0, #1
 8000a7c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a80:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000a84:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000a88:	ea40 000c 	orr.w	r0, r0, ip
 8000a8c:	fa23 f302 	lsr.w	r3, r3, r2
 8000a90:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000a94:	e7cc      	b.n	8000a30 <__aeabi_d2f+0x14>
 8000a96:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000a9a:	d107      	bne.n	8000aac <__aeabi_d2f+0x90>
 8000a9c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000aa0:	bf1e      	ittt	ne
 8000aa2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000aa6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000aaa:	4770      	bxne	lr
 8000aac:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000ab0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000ab4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ab8:	4770      	bx	lr
 8000aba:	bf00      	nop

08000abc <__aeabi_uldivmod>:
 8000abc:	b953      	cbnz	r3, 8000ad4 <__aeabi_uldivmod+0x18>
 8000abe:	b94a      	cbnz	r2, 8000ad4 <__aeabi_uldivmod+0x18>
 8000ac0:	2900      	cmp	r1, #0
 8000ac2:	bf08      	it	eq
 8000ac4:	2800      	cmpeq	r0, #0
 8000ac6:	bf1c      	itt	ne
 8000ac8:	f04f 31ff 	movne.w	r1, #4294967295
 8000acc:	f04f 30ff 	movne.w	r0, #4294967295
 8000ad0:	f000 b96e 	b.w	8000db0 <__aeabi_idiv0>
 8000ad4:	f1ad 0c08 	sub.w	ip, sp, #8
 8000ad8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000adc:	f000 f806 	bl	8000aec <__udivmoddi4>
 8000ae0:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000ae4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ae8:	b004      	add	sp, #16
 8000aea:	4770      	bx	lr

08000aec <__udivmoddi4>:
 8000aec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000af0:	9d08      	ldr	r5, [sp, #32]
 8000af2:	4604      	mov	r4, r0
 8000af4:	468c      	mov	ip, r1
 8000af6:	2b00      	cmp	r3, #0
 8000af8:	f040 8083 	bne.w	8000c02 <__udivmoddi4+0x116>
 8000afc:	428a      	cmp	r2, r1
 8000afe:	4617      	mov	r7, r2
 8000b00:	d947      	bls.n	8000b92 <__udivmoddi4+0xa6>
 8000b02:	fab2 f282 	clz	r2, r2
 8000b06:	b142      	cbz	r2, 8000b1a <__udivmoddi4+0x2e>
 8000b08:	f1c2 0020 	rsb	r0, r2, #32
 8000b0c:	fa24 f000 	lsr.w	r0, r4, r0
 8000b10:	4091      	lsls	r1, r2
 8000b12:	4097      	lsls	r7, r2
 8000b14:	ea40 0c01 	orr.w	ip, r0, r1
 8000b18:	4094      	lsls	r4, r2
 8000b1a:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000b1e:	0c23      	lsrs	r3, r4, #16
 8000b20:	fbbc f6f8 	udiv	r6, ip, r8
 8000b24:	fa1f fe87 	uxth.w	lr, r7
 8000b28:	fb08 c116 	mls	r1, r8, r6, ip
 8000b2c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b30:	fb06 f10e 	mul.w	r1, r6, lr
 8000b34:	4299      	cmp	r1, r3
 8000b36:	d909      	bls.n	8000b4c <__udivmoddi4+0x60>
 8000b38:	18fb      	adds	r3, r7, r3
 8000b3a:	f106 30ff 	add.w	r0, r6, #4294967295
 8000b3e:	f080 8119 	bcs.w	8000d74 <__udivmoddi4+0x288>
 8000b42:	4299      	cmp	r1, r3
 8000b44:	f240 8116 	bls.w	8000d74 <__udivmoddi4+0x288>
 8000b48:	3e02      	subs	r6, #2
 8000b4a:	443b      	add	r3, r7
 8000b4c:	1a5b      	subs	r3, r3, r1
 8000b4e:	b2a4      	uxth	r4, r4
 8000b50:	fbb3 f0f8 	udiv	r0, r3, r8
 8000b54:	fb08 3310 	mls	r3, r8, r0, r3
 8000b58:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000b5c:	fb00 fe0e 	mul.w	lr, r0, lr
 8000b60:	45a6      	cmp	lr, r4
 8000b62:	d909      	bls.n	8000b78 <__udivmoddi4+0x8c>
 8000b64:	193c      	adds	r4, r7, r4
 8000b66:	f100 33ff 	add.w	r3, r0, #4294967295
 8000b6a:	f080 8105 	bcs.w	8000d78 <__udivmoddi4+0x28c>
 8000b6e:	45a6      	cmp	lr, r4
 8000b70:	f240 8102 	bls.w	8000d78 <__udivmoddi4+0x28c>
 8000b74:	3802      	subs	r0, #2
 8000b76:	443c      	add	r4, r7
 8000b78:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000b7c:	eba4 040e 	sub.w	r4, r4, lr
 8000b80:	2600      	movs	r6, #0
 8000b82:	b11d      	cbz	r5, 8000b8c <__udivmoddi4+0xa0>
 8000b84:	40d4      	lsrs	r4, r2
 8000b86:	2300      	movs	r3, #0
 8000b88:	e9c5 4300 	strd	r4, r3, [r5]
 8000b8c:	4631      	mov	r1, r6
 8000b8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b92:	b902      	cbnz	r2, 8000b96 <__udivmoddi4+0xaa>
 8000b94:	deff      	udf	#255	; 0xff
 8000b96:	fab2 f282 	clz	r2, r2
 8000b9a:	2a00      	cmp	r2, #0
 8000b9c:	d150      	bne.n	8000c40 <__udivmoddi4+0x154>
 8000b9e:	1bcb      	subs	r3, r1, r7
 8000ba0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000ba4:	fa1f f887 	uxth.w	r8, r7
 8000ba8:	2601      	movs	r6, #1
 8000baa:	fbb3 fcfe 	udiv	ip, r3, lr
 8000bae:	0c21      	lsrs	r1, r4, #16
 8000bb0:	fb0e 331c 	mls	r3, lr, ip, r3
 8000bb4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000bb8:	fb08 f30c 	mul.w	r3, r8, ip
 8000bbc:	428b      	cmp	r3, r1
 8000bbe:	d907      	bls.n	8000bd0 <__udivmoddi4+0xe4>
 8000bc0:	1879      	adds	r1, r7, r1
 8000bc2:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000bc6:	d202      	bcs.n	8000bce <__udivmoddi4+0xe2>
 8000bc8:	428b      	cmp	r3, r1
 8000bca:	f200 80e9 	bhi.w	8000da0 <__udivmoddi4+0x2b4>
 8000bce:	4684      	mov	ip, r0
 8000bd0:	1ac9      	subs	r1, r1, r3
 8000bd2:	b2a3      	uxth	r3, r4
 8000bd4:	fbb1 f0fe 	udiv	r0, r1, lr
 8000bd8:	fb0e 1110 	mls	r1, lr, r0, r1
 8000bdc:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8000be0:	fb08 f800 	mul.w	r8, r8, r0
 8000be4:	45a0      	cmp	r8, r4
 8000be6:	d907      	bls.n	8000bf8 <__udivmoddi4+0x10c>
 8000be8:	193c      	adds	r4, r7, r4
 8000bea:	f100 33ff 	add.w	r3, r0, #4294967295
 8000bee:	d202      	bcs.n	8000bf6 <__udivmoddi4+0x10a>
 8000bf0:	45a0      	cmp	r8, r4
 8000bf2:	f200 80d9 	bhi.w	8000da8 <__udivmoddi4+0x2bc>
 8000bf6:	4618      	mov	r0, r3
 8000bf8:	eba4 0408 	sub.w	r4, r4, r8
 8000bfc:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000c00:	e7bf      	b.n	8000b82 <__udivmoddi4+0x96>
 8000c02:	428b      	cmp	r3, r1
 8000c04:	d909      	bls.n	8000c1a <__udivmoddi4+0x12e>
 8000c06:	2d00      	cmp	r5, #0
 8000c08:	f000 80b1 	beq.w	8000d6e <__udivmoddi4+0x282>
 8000c0c:	2600      	movs	r6, #0
 8000c0e:	e9c5 0100 	strd	r0, r1, [r5]
 8000c12:	4630      	mov	r0, r6
 8000c14:	4631      	mov	r1, r6
 8000c16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c1a:	fab3 f683 	clz	r6, r3
 8000c1e:	2e00      	cmp	r6, #0
 8000c20:	d14a      	bne.n	8000cb8 <__udivmoddi4+0x1cc>
 8000c22:	428b      	cmp	r3, r1
 8000c24:	d302      	bcc.n	8000c2c <__udivmoddi4+0x140>
 8000c26:	4282      	cmp	r2, r0
 8000c28:	f200 80b8 	bhi.w	8000d9c <__udivmoddi4+0x2b0>
 8000c2c:	1a84      	subs	r4, r0, r2
 8000c2e:	eb61 0103 	sbc.w	r1, r1, r3
 8000c32:	2001      	movs	r0, #1
 8000c34:	468c      	mov	ip, r1
 8000c36:	2d00      	cmp	r5, #0
 8000c38:	d0a8      	beq.n	8000b8c <__udivmoddi4+0xa0>
 8000c3a:	e9c5 4c00 	strd	r4, ip, [r5]
 8000c3e:	e7a5      	b.n	8000b8c <__udivmoddi4+0xa0>
 8000c40:	f1c2 0320 	rsb	r3, r2, #32
 8000c44:	fa20 f603 	lsr.w	r6, r0, r3
 8000c48:	4097      	lsls	r7, r2
 8000c4a:	fa01 f002 	lsl.w	r0, r1, r2
 8000c4e:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000c52:	40d9      	lsrs	r1, r3
 8000c54:	4330      	orrs	r0, r6
 8000c56:	0c03      	lsrs	r3, r0, #16
 8000c58:	fbb1 f6fe 	udiv	r6, r1, lr
 8000c5c:	fa1f f887 	uxth.w	r8, r7
 8000c60:	fb0e 1116 	mls	r1, lr, r6, r1
 8000c64:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000c68:	fb06 f108 	mul.w	r1, r6, r8
 8000c6c:	4299      	cmp	r1, r3
 8000c6e:	fa04 f402 	lsl.w	r4, r4, r2
 8000c72:	d909      	bls.n	8000c88 <__udivmoddi4+0x19c>
 8000c74:	18fb      	adds	r3, r7, r3
 8000c76:	f106 3cff 	add.w	ip, r6, #4294967295
 8000c7a:	f080 808d 	bcs.w	8000d98 <__udivmoddi4+0x2ac>
 8000c7e:	4299      	cmp	r1, r3
 8000c80:	f240 808a 	bls.w	8000d98 <__udivmoddi4+0x2ac>
 8000c84:	3e02      	subs	r6, #2
 8000c86:	443b      	add	r3, r7
 8000c88:	1a5b      	subs	r3, r3, r1
 8000c8a:	b281      	uxth	r1, r0
 8000c8c:	fbb3 f0fe 	udiv	r0, r3, lr
 8000c90:	fb0e 3310 	mls	r3, lr, r0, r3
 8000c94:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000c98:	fb00 f308 	mul.w	r3, r0, r8
 8000c9c:	428b      	cmp	r3, r1
 8000c9e:	d907      	bls.n	8000cb0 <__udivmoddi4+0x1c4>
 8000ca0:	1879      	adds	r1, r7, r1
 8000ca2:	f100 3cff 	add.w	ip, r0, #4294967295
 8000ca6:	d273      	bcs.n	8000d90 <__udivmoddi4+0x2a4>
 8000ca8:	428b      	cmp	r3, r1
 8000caa:	d971      	bls.n	8000d90 <__udivmoddi4+0x2a4>
 8000cac:	3802      	subs	r0, #2
 8000cae:	4439      	add	r1, r7
 8000cb0:	1acb      	subs	r3, r1, r3
 8000cb2:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000cb6:	e778      	b.n	8000baa <__udivmoddi4+0xbe>
 8000cb8:	f1c6 0c20 	rsb	ip, r6, #32
 8000cbc:	fa03 f406 	lsl.w	r4, r3, r6
 8000cc0:	fa22 f30c 	lsr.w	r3, r2, ip
 8000cc4:	431c      	orrs	r4, r3
 8000cc6:	fa20 f70c 	lsr.w	r7, r0, ip
 8000cca:	fa01 f306 	lsl.w	r3, r1, r6
 8000cce:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8000cd2:	fa21 f10c 	lsr.w	r1, r1, ip
 8000cd6:	431f      	orrs	r7, r3
 8000cd8:	0c3b      	lsrs	r3, r7, #16
 8000cda:	fbb1 f9fe 	udiv	r9, r1, lr
 8000cde:	fa1f f884 	uxth.w	r8, r4
 8000ce2:	fb0e 1119 	mls	r1, lr, r9, r1
 8000ce6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000cea:	fb09 fa08 	mul.w	sl, r9, r8
 8000cee:	458a      	cmp	sl, r1
 8000cf0:	fa02 f206 	lsl.w	r2, r2, r6
 8000cf4:	fa00 f306 	lsl.w	r3, r0, r6
 8000cf8:	d908      	bls.n	8000d0c <__udivmoddi4+0x220>
 8000cfa:	1861      	adds	r1, r4, r1
 8000cfc:	f109 30ff 	add.w	r0, r9, #4294967295
 8000d00:	d248      	bcs.n	8000d94 <__udivmoddi4+0x2a8>
 8000d02:	458a      	cmp	sl, r1
 8000d04:	d946      	bls.n	8000d94 <__udivmoddi4+0x2a8>
 8000d06:	f1a9 0902 	sub.w	r9, r9, #2
 8000d0a:	4421      	add	r1, r4
 8000d0c:	eba1 010a 	sub.w	r1, r1, sl
 8000d10:	b2bf      	uxth	r7, r7
 8000d12:	fbb1 f0fe 	udiv	r0, r1, lr
 8000d16:	fb0e 1110 	mls	r1, lr, r0, r1
 8000d1a:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8000d1e:	fb00 f808 	mul.w	r8, r0, r8
 8000d22:	45b8      	cmp	r8, r7
 8000d24:	d907      	bls.n	8000d36 <__udivmoddi4+0x24a>
 8000d26:	19e7      	adds	r7, r4, r7
 8000d28:	f100 31ff 	add.w	r1, r0, #4294967295
 8000d2c:	d22e      	bcs.n	8000d8c <__udivmoddi4+0x2a0>
 8000d2e:	45b8      	cmp	r8, r7
 8000d30:	d92c      	bls.n	8000d8c <__udivmoddi4+0x2a0>
 8000d32:	3802      	subs	r0, #2
 8000d34:	4427      	add	r7, r4
 8000d36:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000d3a:	eba7 0708 	sub.w	r7, r7, r8
 8000d3e:	fba0 8902 	umull	r8, r9, r0, r2
 8000d42:	454f      	cmp	r7, r9
 8000d44:	46c6      	mov	lr, r8
 8000d46:	4649      	mov	r1, r9
 8000d48:	d31a      	bcc.n	8000d80 <__udivmoddi4+0x294>
 8000d4a:	d017      	beq.n	8000d7c <__udivmoddi4+0x290>
 8000d4c:	b15d      	cbz	r5, 8000d66 <__udivmoddi4+0x27a>
 8000d4e:	ebb3 020e 	subs.w	r2, r3, lr
 8000d52:	eb67 0701 	sbc.w	r7, r7, r1
 8000d56:	fa07 fc0c 	lsl.w	ip, r7, ip
 8000d5a:	40f2      	lsrs	r2, r6
 8000d5c:	ea4c 0202 	orr.w	r2, ip, r2
 8000d60:	40f7      	lsrs	r7, r6
 8000d62:	e9c5 2700 	strd	r2, r7, [r5]
 8000d66:	2600      	movs	r6, #0
 8000d68:	4631      	mov	r1, r6
 8000d6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d6e:	462e      	mov	r6, r5
 8000d70:	4628      	mov	r0, r5
 8000d72:	e70b      	b.n	8000b8c <__udivmoddi4+0xa0>
 8000d74:	4606      	mov	r6, r0
 8000d76:	e6e9      	b.n	8000b4c <__udivmoddi4+0x60>
 8000d78:	4618      	mov	r0, r3
 8000d7a:	e6fd      	b.n	8000b78 <__udivmoddi4+0x8c>
 8000d7c:	4543      	cmp	r3, r8
 8000d7e:	d2e5      	bcs.n	8000d4c <__udivmoddi4+0x260>
 8000d80:	ebb8 0e02 	subs.w	lr, r8, r2
 8000d84:	eb69 0104 	sbc.w	r1, r9, r4
 8000d88:	3801      	subs	r0, #1
 8000d8a:	e7df      	b.n	8000d4c <__udivmoddi4+0x260>
 8000d8c:	4608      	mov	r0, r1
 8000d8e:	e7d2      	b.n	8000d36 <__udivmoddi4+0x24a>
 8000d90:	4660      	mov	r0, ip
 8000d92:	e78d      	b.n	8000cb0 <__udivmoddi4+0x1c4>
 8000d94:	4681      	mov	r9, r0
 8000d96:	e7b9      	b.n	8000d0c <__udivmoddi4+0x220>
 8000d98:	4666      	mov	r6, ip
 8000d9a:	e775      	b.n	8000c88 <__udivmoddi4+0x19c>
 8000d9c:	4630      	mov	r0, r6
 8000d9e:	e74a      	b.n	8000c36 <__udivmoddi4+0x14a>
 8000da0:	f1ac 0c02 	sub.w	ip, ip, #2
 8000da4:	4439      	add	r1, r7
 8000da6:	e713      	b.n	8000bd0 <__udivmoddi4+0xe4>
 8000da8:	3802      	subs	r0, #2
 8000daa:	443c      	add	r4, r7
 8000dac:	e724      	b.n	8000bf8 <__udivmoddi4+0x10c>
 8000dae:	bf00      	nop

08000db0 <__aeabi_idiv0>:
 8000db0:	4770      	bx	lr
 8000db2:	bf00      	nop

08000db4 <ILI9341_Delay>:
#endif
//
//  Basic function - write those for your MCU
//
static void ILI9341_Delay(uint32_t ms)
{
 8000db4:	b580      	push	{r7, lr}
 8000db6:	b082      	sub	sp, #8
 8000db8:	af00      	add	r7, sp, #0
 8000dba:	6078      	str	r0, [r7, #4]
	HAL_Delay(ms);
 8000dbc:	6878      	ldr	r0, [r7, #4]
 8000dbe:	f000 fecd 	bl	8001b5c <HAL_Delay>
}
 8000dc2:	bf00      	nop
 8000dc4:	3708      	adds	r7, #8
 8000dc6:	46bd      	mov	sp, r7
 8000dc8:	bd80      	pop	{r7, pc}
	...

08000dcc <ILI9341_SendToTFT>:

static void ILI9341_SendToTFT(uint8_t *Byte, uint32_t Length)
{
 8000dcc:	b480      	push	{r7}
 8000dce:	b083      	sub	sp, #12
 8000dd0:	af00      	add	r7, sp, #0
 8000dd2:	6078      	str	r0, [r7, #4]
 8000dd4:	6039      	str	r1, [r7, #0]
#if (ILI9341_OPTIMIZE_HAL_SP1 == 1)
	// That is taken from HAL Transmit function
    while (Length > 0U)
 8000dd6:	e014      	b.n	8000e02 <ILI9341_SendToTFT+0x36>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(Tft_hspi, SPI_FLAG_TXE))
 8000dd8:	4b13      	ldr	r3, [pc, #76]	; (8000e28 <ILI9341_SendToTFT+0x5c>)
 8000dda:	681b      	ldr	r3, [r3, #0]
 8000ddc:	681b      	ldr	r3, [r3, #0]
 8000dde:	689b      	ldr	r3, [r3, #8]
 8000de0:	f003 0302 	and.w	r3, r3, #2
 8000de4:	2b02      	cmp	r3, #2
 8000de6:	d10c      	bne.n	8000e02 <ILI9341_SendToTFT+0x36>
      {
    	//Fill Data Register in SPI
        *((__IO uint8_t *)&Tft_hspi->Instance->DR) = (*Byte);
 8000de8:	4b0f      	ldr	r3, [pc, #60]	; (8000e28 <ILI9341_SendToTFT+0x5c>)
 8000dea:	681b      	ldr	r3, [r3, #0]
 8000dec:	681b      	ldr	r3, [r3, #0]
 8000dee:	330c      	adds	r3, #12
 8000df0:	687a      	ldr	r2, [r7, #4]
 8000df2:	7812      	ldrb	r2, [r2, #0]
 8000df4:	701a      	strb	r2, [r3, #0]
        // Next byte
        Byte++;
 8000df6:	687b      	ldr	r3, [r7, #4]
 8000df8:	3301      	adds	r3, #1
 8000dfa:	607b      	str	r3, [r7, #4]
        // Length decrement
        Length--;
 8000dfc:	683b      	ldr	r3, [r7, #0]
 8000dfe:	3b01      	subs	r3, #1
 8000e00:	603b      	str	r3, [r7, #0]
    while (Length > 0U)
 8000e02:	683b      	ldr	r3, [r7, #0]
 8000e04:	2b00      	cmp	r3, #0
 8000e06:	d1e7      	bne.n	8000dd8 <ILI9341_SendToTFT+0xc>
      }
    }

    // Wait for Transfer end
	while(__HAL_SPI_GET_FLAG(Tft_hspi, SPI_FLAG_BSY) != RESET)
 8000e08:	bf00      	nop
 8000e0a:	4b07      	ldr	r3, [pc, #28]	; (8000e28 <ILI9341_SendToTFT+0x5c>)
 8000e0c:	681b      	ldr	r3, [r3, #0]
 8000e0e:	681b      	ldr	r3, [r3, #0]
 8000e10:	689b      	ldr	r3, [r3, #8]
 8000e12:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000e16:	2b80      	cmp	r3, #128	; 0x80
 8000e18:	d0f7      	beq.n	8000e0a <ILI9341_SendToTFT+0x3e>

	}
#else
	HAL_SPI_Transmit(Tft_hspi, Byte, Length, ILI9341_SPI_TIMEOUT); 	// Send the command byte
#endif
}
 8000e1a:	bf00      	nop
 8000e1c:	bf00      	nop
 8000e1e:	370c      	adds	r7, #12
 8000e20:	46bd      	mov	sp, r7
 8000e22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e26:	4770      	bx	lr
 8000e28:	20000380 	.word	0x20000380

08000e2c <ILI9341_SendCommand>:

static void ILI9341_SendCommand(uint8_t Command)
{
 8000e2c:	b580      	push	{r7, lr}
 8000e2e:	b082      	sub	sp, #8
 8000e30:	af00      	add	r7, sp, #0
 8000e32:	4603      	mov	r3, r0
 8000e34:	71fb      	strb	r3, [r7, #7]
	// CS Low
#if (ILI9341_USE_CS == 1)
	ILI9341_CS_LOW;
 8000e36:	2200      	movs	r2, #0
 8000e38:	2140      	movs	r1, #64	; 0x40
 8000e3a:	480b      	ldr	r0, [pc, #44]	; (8000e68 <ILI9341_SendCommand+0x3c>)
 8000e3c:	f001 f948 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
	// DC to Command - DC to Low
	ILI9341_DC_LOW;
 8000e40:	2200      	movs	r2, #0
 8000e42:	2180      	movs	r1, #128	; 0x80
 8000e44:	4809      	ldr	r0, [pc, #36]	; (8000e6c <ILI9341_SendCommand+0x40>)
 8000e46:	f001 f943 	bl	80020d0 <HAL_GPIO_WritePin>

	// Send to TFT 1 byte
	ILI9341_SendToTFT(&Command, 1);
 8000e4a:	1dfb      	adds	r3, r7, #7
 8000e4c:	2101      	movs	r1, #1
 8000e4e:	4618      	mov	r0, r3
 8000e50:	f7ff ffbc 	bl	8000dcc <ILI9341_SendToTFT>

	// CS High
#if (ILI9341_USE_CS == 1)
	ILI9341_CS_HIGH;
 8000e54:	2201      	movs	r2, #1
 8000e56:	2140      	movs	r1, #64	; 0x40
 8000e58:	4803      	ldr	r0, [pc, #12]	; (8000e68 <ILI9341_SendCommand+0x3c>)
 8000e5a:	f001 f939 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
}
 8000e5e:	bf00      	nop
 8000e60:	3708      	adds	r7, #8
 8000e62:	46bd      	mov	sp, r7
 8000e64:	bd80      	pop	{r7, pc}
 8000e66:	bf00      	nop
 8000e68:	40020400 	.word	0x40020400
 8000e6c:	40020800 	.word	0x40020800

08000e70 <ILI9341_SendCommandAndData>:

static void ILI9341_SendCommandAndData(uint8_t Command, uint8_t *Data, uint32_t Length)
{
 8000e70:	b580      	push	{r7, lr}
 8000e72:	b084      	sub	sp, #16
 8000e74:	af00      	add	r7, sp, #0
 8000e76:	4603      	mov	r3, r0
 8000e78:	60b9      	str	r1, [r7, #8]
 8000e7a:	607a      	str	r2, [r7, #4]
 8000e7c:	73fb      	strb	r3, [r7, #15]
	// CS Low
#if (ILI9341_USE_CS == 1)
	ILI9341_CS_LOW;
 8000e7e:	2200      	movs	r2, #0
 8000e80:	2140      	movs	r1, #64	; 0x40
 8000e82:	4810      	ldr	r0, [pc, #64]	; (8000ec4 <ILI9341_SendCommandAndData+0x54>)
 8000e84:	f001 f924 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
	// DC to Command - DC to Low
	ILI9341_DC_LOW;
 8000e88:	2200      	movs	r2, #0
 8000e8a:	2180      	movs	r1, #128	; 0x80
 8000e8c:	480e      	ldr	r0, [pc, #56]	; (8000ec8 <ILI9341_SendCommandAndData+0x58>)
 8000e8e:	f001 f91f 	bl	80020d0 <HAL_GPIO_WritePin>
	// Send to TFT 1 byte
	ILI9341_SendToTFT(&Command, 1);
 8000e92:	f107 030f 	add.w	r3, r7, #15
 8000e96:	2101      	movs	r1, #1
 8000e98:	4618      	mov	r0, r3
 8000e9a:	f7ff ff97 	bl	8000dcc <ILI9341_SendToTFT>

	// DC to Data - DC to High
	ILI9341_DC_HIGH;
 8000e9e:	2201      	movs	r2, #1
 8000ea0:	2180      	movs	r1, #128	; 0x80
 8000ea2:	4809      	ldr	r0, [pc, #36]	; (8000ec8 <ILI9341_SendCommandAndData+0x58>)
 8000ea4:	f001 f914 	bl	80020d0 <HAL_GPIO_WritePin>
	// Send to TFT Length byte
	ILI9341_SendToTFT(Data, Length);
 8000ea8:	6879      	ldr	r1, [r7, #4]
 8000eaa:	68b8      	ldr	r0, [r7, #8]
 8000eac:	f7ff ff8e 	bl	8000dcc <ILI9341_SendToTFT>

	// CS High
#if (ILI9341_USE_CS == 1)
	ILI9341_CS_HIGH;
 8000eb0:	2201      	movs	r2, #1
 8000eb2:	2140      	movs	r1, #64	; 0x40
 8000eb4:	4803      	ldr	r0, [pc, #12]	; (8000ec4 <ILI9341_SendCommandAndData+0x54>)
 8000eb6:	f001 f90b 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
}
 8000eba:	bf00      	nop
 8000ebc:	3710      	adds	r7, #16
 8000ebe:	46bd      	mov	sp, r7
 8000ec0:	bd80      	pop	{r7, pc}
 8000ec2:	bf00      	nop
 8000ec4:	40020400 	.word	0x40020400
 8000ec8:	40020800 	.word	0x40020800

08000ecc <ILI9341_SetRotation>:

//
// TFT Functions
//
void ILI9341_SetRotation(uint8_t Rotation)
{
 8000ecc:	b580      	push	{r7, lr}
 8000ece:	b082      	sub	sp, #8
 8000ed0:	af00      	add	r7, sp, #0
 8000ed2:	4603      	mov	r3, r0
 8000ed4:	71fb      	strb	r3, [r7, #7]
	if(Rotation > 3)
 8000ed6:	79fb      	ldrb	r3, [r7, #7]
 8000ed8:	2b03      	cmp	r3, #3
 8000eda:	d820      	bhi.n	8000f1e <ILI9341_SetRotation+0x52>
		return;

	//
	// Set appropriate bits for Rotation
	//
	switch(Rotation)
 8000edc:	79fb      	ldrb	r3, [r7, #7]
 8000ede:	2b03      	cmp	r3, #3
 8000ee0:	d816      	bhi.n	8000f10 <ILI9341_SetRotation+0x44>
 8000ee2:	a201      	add	r2, pc, #4	; (adr r2, 8000ee8 <ILI9341_SetRotation+0x1c>)
 8000ee4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000ee8:	08000ef9 	.word	0x08000ef9
 8000eec:	08000eff 	.word	0x08000eff
 8000ef0:	08000f05 	.word	0x08000f05
 8000ef4:	08000f0b 	.word	0x08000f0b
	{
	case 0:
		Rotation = (MADCTL_MX | MADCTL_BGR);
 8000ef8:	2348      	movs	r3, #72	; 0x48
 8000efa:	71fb      	strb	r3, [r7, #7]
		break;
 8000efc:	e008      	b.n	8000f10 <ILI9341_SetRotation+0x44>
	case 1:
		Rotation = (MADCTL_MV | MADCTL_BGR);
 8000efe:	2328      	movs	r3, #40	; 0x28
 8000f00:	71fb      	strb	r3, [r7, #7]
		break;
 8000f02:	e005      	b.n	8000f10 <ILI9341_SetRotation+0x44>
	case 2:
		Rotation = (MADCTL_MY | MADCTL_BGR);
 8000f04:	2388      	movs	r3, #136	; 0x88
 8000f06:	71fb      	strb	r3, [r7, #7]
		break;
 8000f08:	e002      	b.n	8000f10 <ILI9341_SetRotation+0x44>
	case 3:
		Rotation = (MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
 8000f0a:	23e8      	movs	r3, #232	; 0xe8
 8000f0c:	71fb      	strb	r3, [r7, #7]
		break;
 8000f0e:	bf00      	nop
	}

	// Write indo MAD Control register our Rotation data
	ILI9341_SendCommandAndData(ILI9341_MADCTL, &Rotation, 1);
 8000f10:	1dfb      	adds	r3, r7, #7
 8000f12:	2201      	movs	r2, #1
 8000f14:	4619      	mov	r1, r3
 8000f16:	2036      	movs	r0, #54	; 0x36
 8000f18:	f7ff ffaa 	bl	8000e70 <ILI9341_SendCommandAndData>
 8000f1c:	e000      	b.n	8000f20 <ILI9341_SetRotation+0x54>
		return;
 8000f1e:	bf00      	nop
}
 8000f20:	3708      	adds	r7, #8
 8000f22:	46bd      	mov	sp, r7
 8000f24:	bd80      	pop	{r7, pc}
 8000f26:	bf00      	nop

08000f28 <ILI9341_SetAddrWindow>:

void ILI9341_SetAddrWindow(uint16_t x1, uint16_t y1, uint16_t w, uint16_t h)
{
 8000f28:	b590      	push	{r4, r7, lr}
 8000f2a:	b085      	sub	sp, #20
 8000f2c:	af00      	add	r7, sp, #0
 8000f2e:	4604      	mov	r4, r0
 8000f30:	4608      	mov	r0, r1
 8000f32:	4611      	mov	r1, r2
 8000f34:	461a      	mov	r2, r3
 8000f36:	4623      	mov	r3, r4
 8000f38:	80fb      	strh	r3, [r7, #6]
 8000f3a:	4603      	mov	r3, r0
 8000f3c:	80bb      	strh	r3, [r7, #4]
 8000f3e:	460b      	mov	r3, r1
 8000f40:	807b      	strh	r3, [r7, #2]
 8000f42:	4613      	mov	r3, r2
 8000f44:	803b      	strh	r3, [r7, #0]
	uint8_t DataToTransfer[4];
	// Calculate end ranges
	uint16_t x2 = (x1 + w - 1), y2 = (y1 + h - 1);
 8000f46:	88fa      	ldrh	r2, [r7, #6]
 8000f48:	887b      	ldrh	r3, [r7, #2]
 8000f4a:	4413      	add	r3, r2
 8000f4c:	b29b      	uxth	r3, r3
 8000f4e:	3b01      	subs	r3, #1
 8000f50:	81fb      	strh	r3, [r7, #14]
 8000f52:	88ba      	ldrh	r2, [r7, #4]
 8000f54:	883b      	ldrh	r3, [r7, #0]
 8000f56:	4413      	add	r3, r2
 8000f58:	b29b      	uxth	r3, r3
 8000f5a:	3b01      	subs	r3, #1
 8000f5c:	81bb      	strh	r3, [r7, #12]

	// Fulfill X's buffer
	DataToTransfer[0] = x1 >> 8;
 8000f5e:	88fb      	ldrh	r3, [r7, #6]
 8000f60:	0a1b      	lsrs	r3, r3, #8
 8000f62:	b29b      	uxth	r3, r3
 8000f64:	b2db      	uxtb	r3, r3
 8000f66:	723b      	strb	r3, [r7, #8]
	DataToTransfer[1] = x1 & 0xFF;
 8000f68:	88fb      	ldrh	r3, [r7, #6]
 8000f6a:	b2db      	uxtb	r3, r3
 8000f6c:	727b      	strb	r3, [r7, #9]
	DataToTransfer[2] = x2 >> 8;
 8000f6e:	89fb      	ldrh	r3, [r7, #14]
 8000f70:	0a1b      	lsrs	r3, r3, #8
 8000f72:	b29b      	uxth	r3, r3
 8000f74:	b2db      	uxtb	r3, r3
 8000f76:	72bb      	strb	r3, [r7, #10]
	DataToTransfer[3] = x2 & 0xFF;
 8000f78:	89fb      	ldrh	r3, [r7, #14]
 8000f7a:	b2db      	uxtb	r3, r3
 8000f7c:	72fb      	strb	r3, [r7, #11]
	// Push X's buffer
	ILI9341_SendCommandAndData(ILI9341_CASET, DataToTransfer, 4);
 8000f7e:	f107 0308 	add.w	r3, r7, #8
 8000f82:	2204      	movs	r2, #4
 8000f84:	4619      	mov	r1, r3
 8000f86:	202a      	movs	r0, #42	; 0x2a
 8000f88:	f7ff ff72 	bl	8000e70 <ILI9341_SendCommandAndData>

	// Fulfill Y's buffer
	DataToTransfer[0] = y1 >> 8;
 8000f8c:	88bb      	ldrh	r3, [r7, #4]
 8000f8e:	0a1b      	lsrs	r3, r3, #8
 8000f90:	b29b      	uxth	r3, r3
 8000f92:	b2db      	uxtb	r3, r3
 8000f94:	723b      	strb	r3, [r7, #8]
	DataToTransfer[1] = y1 & 0xFF;
 8000f96:	88bb      	ldrh	r3, [r7, #4]
 8000f98:	b2db      	uxtb	r3, r3
 8000f9a:	727b      	strb	r3, [r7, #9]
	DataToTransfer[2] = y2 >> 8;
 8000f9c:	89bb      	ldrh	r3, [r7, #12]
 8000f9e:	0a1b      	lsrs	r3, r3, #8
 8000fa0:	b29b      	uxth	r3, r3
 8000fa2:	b2db      	uxtb	r3, r3
 8000fa4:	72bb      	strb	r3, [r7, #10]
	DataToTransfer[3] = y2 & 0xFF;
 8000fa6:	89bb      	ldrh	r3, [r7, #12]
 8000fa8:	b2db      	uxtb	r3, r3
 8000faa:	72fb      	strb	r3, [r7, #11]
	// Push Y's buffer
	ILI9341_SendCommandAndData(ILI9341_PASET, DataToTransfer, 4);
 8000fac:	f107 0308 	add.w	r3, r7, #8
 8000fb0:	2204      	movs	r2, #4
 8000fb2:	4619      	mov	r1, r3
 8000fb4:	202b      	movs	r0, #43	; 0x2b
 8000fb6:	f7ff ff5b 	bl	8000e70 <ILI9341_SendCommandAndData>
}
 8000fba:	bf00      	nop
 8000fbc:	3714      	adds	r7, #20
 8000fbe:	46bd      	mov	sp, r7
 8000fc0:	bd90      	pop	{r4, r7, pc}
	...

08000fc4 <ILI9341_ClearDisplay>:
		ILI9341_SendCommandAndData(ILI9341_RAMWR, (uint8_t *)img, (w*h*2));
	}
}

void ILI9341_ClearDisplay(uint16_t Color)
{
 8000fc4:	b580      	push	{r7, lr}
 8000fc6:	b084      	sub	sp, #16
 8000fc8:	af00      	add	r7, sp, #0
 8000fca:	4603      	mov	r3, r0
 8000fcc:	80fb      	strh	r3, [r7, #6]
	// Set window for whole screen
	ILI9341_SetAddrWindow(0, 0, ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT);
 8000fce:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8000fd2:	22f0      	movs	r2, #240	; 0xf0
 8000fd4:	2100      	movs	r1, #0
 8000fd6:	2000      	movs	r0, #0
 8000fd8:	f7ff ffa6 	bl	8000f28 <ILI9341_SetAddrWindow>
	// Set RAM writing
	ILI9341_SendCommand(ILI9341_RAMWR);
 8000fdc:	202c      	movs	r0, #44	; 0x2c
 8000fde:	f7ff ff25 	bl	8000e2c <ILI9341_SendCommand>

#if (ILI9341_OPTIMIZE_HAL_SP1 == 1)
	uint32_t Length = ILI9341_TFTWIDTH * ILI9341_TFTHEIGHT;
 8000fe2:	f44f 3396 	mov.w	r3, #76800	; 0x12c00
 8000fe6:	60fb      	str	r3, [r7, #12]

#if (ILI9341_USE_CS == 1)
	ILI9341_CS_LOW;
 8000fe8:	2200      	movs	r2, #0
 8000fea:	2140      	movs	r1, #64	; 0x40
 8000fec:	4820      	ldr	r0, [pc, #128]	; (8001070 <ILI9341_ClearDisplay+0xac>)
 8000fee:	f001 f86f 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
	ILI9341_DC_HIGH;	// Data mode
 8000ff2:	2201      	movs	r2, #1
 8000ff4:	2180      	movs	r1, #128	; 0x80
 8000ff6:	481f      	ldr	r0, [pc, #124]	; (8001074 <ILI9341_ClearDisplay+0xb0>)
 8000ff8:	f001 f86a 	bl	80020d0 <HAL_GPIO_WritePin>

    while (Length > 0U)
 8000ffc:	e023      	b.n	8001046 <ILI9341_ClearDisplay+0x82>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(Tft_hspi, SPI_FLAG_TXE))
 8000ffe:	4b1e      	ldr	r3, [pc, #120]	; (8001078 <ILI9341_ClearDisplay+0xb4>)
 8001000:	681b      	ldr	r3, [r3, #0]
 8001002:	681b      	ldr	r3, [r3, #0]
 8001004:	689b      	ldr	r3, [r3, #8]
 8001006:	f003 0302 	and.w	r3, r3, #2
 800100a:	2b02      	cmp	r3, #2
 800100c:	d11b      	bne.n	8001046 <ILI9341_ClearDisplay+0x82>
      {
    	  // Write higher byte of color to DR
        *((__IO uint8_t *)&Tft_hspi->Instance->DR) = (Color >> 8);
 800100e:	88fb      	ldrh	r3, [r7, #6]
 8001010:	0a1b      	lsrs	r3, r3, #8
 8001012:	b29a      	uxth	r2, r3
 8001014:	4b18      	ldr	r3, [pc, #96]	; (8001078 <ILI9341_ClearDisplay+0xb4>)
 8001016:	681b      	ldr	r3, [r3, #0]
 8001018:	681b      	ldr	r3, [r3, #0]
 800101a:	330c      	adds	r3, #12
 800101c:	b2d2      	uxtb	r2, r2
 800101e:	701a      	strb	r2, [r3, #0]
        // Wait for transfer
        while(__HAL_SPI_GET_FLAG(Tft_hspi, SPI_FLAG_TXE) != SET)
 8001020:	bf00      	nop
 8001022:	4b15      	ldr	r3, [pc, #84]	; (8001078 <ILI9341_ClearDisplay+0xb4>)
 8001024:	681b      	ldr	r3, [r3, #0]
 8001026:	681b      	ldr	r3, [r3, #0]
 8001028:	689b      	ldr	r3, [r3, #8]
 800102a:	f003 0302 	and.w	r3, r3, #2
 800102e:	2b02      	cmp	r3, #2
 8001030:	d1f7      	bne.n	8001022 <ILI9341_ClearDisplay+0x5e>
        {}
        // Write lower byt of color to DR
        *((__IO uint8_t *)&Tft_hspi->Instance->DR) = (Color & 0xFF);
 8001032:	4b11      	ldr	r3, [pc, #68]	; (8001078 <ILI9341_ClearDisplay+0xb4>)
 8001034:	681b      	ldr	r3, [r3, #0]
 8001036:	681b      	ldr	r3, [r3, #0]
 8001038:	330c      	adds	r3, #12
 800103a:	88fa      	ldrh	r2, [r7, #6]
 800103c:	b2d2      	uxtb	r2, r2
 800103e:	701a      	strb	r2, [r3, #0]
        // Decrease Lenght
        Length--;
 8001040:	68fb      	ldr	r3, [r7, #12]
 8001042:	3b01      	subs	r3, #1
 8001044:	60fb      	str	r3, [r7, #12]
    while (Length > 0U)
 8001046:	68fb      	ldr	r3, [r7, #12]
 8001048:	2b00      	cmp	r3, #0
 800104a:	d1d8      	bne.n	8000ffe <ILI9341_ClearDisplay+0x3a>
      }
    }

    // Wait for the end of transfer
	while(__HAL_SPI_GET_FLAG(Tft_hspi, SPI_FLAG_BSY) != RESET)
 800104c:	bf00      	nop
 800104e:	4b0a      	ldr	r3, [pc, #40]	; (8001078 <ILI9341_ClearDisplay+0xb4>)
 8001050:	681b      	ldr	r3, [r3, #0]
 8001052:	681b      	ldr	r3, [r3, #0]
 8001054:	689b      	ldr	r3, [r3, #8]
 8001056:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800105a:	2b80      	cmp	r3, #128	; 0x80
 800105c:	d0f7      	beq.n	800104e <ILI9341_ClearDisplay+0x8a>
	{

	}

#if (ILI9341_USE_CS == 1)
	ILI9341_CS_HIGH;
 800105e:	2201      	movs	r2, #1
 8001060:	2140      	movs	r1, #64	; 0x40
 8001062:	4803      	ldr	r0, [pc, #12]	; (8001070 <ILI9341_ClearDisplay+0xac>)
 8001064:	f001 f834 	bl	80020d0 <HAL_GPIO_WritePin>
	{
		// Send Color bytes
		ILI9341_SendData16(Color);
	}
#endif
}
 8001068:	bf00      	nop
 800106a:	3710      	adds	r7, #16
 800106c:	46bd      	mov	sp, r7
 800106e:	bd80      	pop	{r7, pc}
 8001070:	40020400 	.word	0x40020400
 8001074:	40020800 	.word	0x40020800
 8001078:	20000380 	.word	0x20000380

0800107c <ILI9341_Init>:
  ILI9341_DISPON  , 0x80,                // Display on
  0x00                                   // End of list
};

void ILI9341_Init(SPI_HandleTypeDef *hspi)
{
 800107c:	b580      	push	{r7, lr}
 800107e:	b084      	sub	sp, #16
 8001080:	af00      	add	r7, sp, #0
 8001082:	6078      	str	r0, [r7, #4]
	Tft_hspi = hspi;
 8001084:	4a25      	ldr	r2, [pc, #148]	; (800111c <ILI9341_Init+0xa0>)
 8001086:	687b      	ldr	r3, [r7, #4]
 8001088:	6013      	str	r3, [r2, #0]

    uint8_t cmd, x, numArgs;
    const uint8_t *addr = initcmd;
 800108a:	4b25      	ldr	r3, [pc, #148]	; (8001120 <ILI9341_Init+0xa4>)
 800108c:	60fb      	str	r3, [r7, #12]
#if (ILI9341_OPTIMIZE_HAL_SP1 == 1)
    __HAL_SPI_ENABLE(Tft_hspi);
 800108e:	4b23      	ldr	r3, [pc, #140]	; (800111c <ILI9341_Init+0xa0>)
 8001090:	681b      	ldr	r3, [r3, #0]
 8001092:	681b      	ldr	r3, [r3, #0]
 8001094:	681a      	ldr	r2, [r3, #0]
 8001096:	4b21      	ldr	r3, [pc, #132]	; (800111c <ILI9341_Init+0xa0>)
 8001098:	681b      	ldr	r3, [r3, #0]
 800109a:	681b      	ldr	r3, [r3, #0]
 800109c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80010a0:	601a      	str	r2, [r3, #0]
#endif

#if (ILI9341_USE_HW_RESET == 1)
	ILI9341_RST_LOW;
 80010a2:	2200      	movs	r2, #0
 80010a4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80010a8:	481e      	ldr	r0, [pc, #120]	; (8001124 <ILI9341_Init+0xa8>)
 80010aa:	f001 f811 	bl	80020d0 <HAL_GPIO_WritePin>
	ILI9341_Delay(10);
 80010ae:	200a      	movs	r0, #10
 80010b0:	f7ff fe80 	bl	8000db4 <ILI9341_Delay>
	ILI9341_RST_HIGH;
 80010b4:	2201      	movs	r2, #1
 80010b6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80010ba:	481a      	ldr	r0, [pc, #104]	; (8001124 <ILI9341_Init+0xa8>)
 80010bc:	f001 f808 	bl	80020d0 <HAL_GPIO_WritePin>
	ILI9341_Delay(10);
 80010c0:	200a      	movs	r0, #10
 80010c2:	f7ff fe77 	bl	8000db4 <ILI9341_Delay>
#else
	ILI9341_SendCommand(ILI9341_SWRESET); // Engage software reset
    ILI9341_Delay(150);
#endif

    while ((cmd = *(addr++)) > 0)
 80010c6:	e019      	b.n	80010fc <ILI9341_Init+0x80>
    {
      x = *(addr++);
 80010c8:	68fb      	ldr	r3, [r7, #12]
 80010ca:	1c5a      	adds	r2, r3, #1
 80010cc:	60fa      	str	r2, [r7, #12]
 80010ce:	781b      	ldrb	r3, [r3, #0]
 80010d0:	72bb      	strb	r3, [r7, #10]
      numArgs = x & 0x7F;
 80010d2:	7abb      	ldrb	r3, [r7, #10]
 80010d4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80010d8:	727b      	strb	r3, [r7, #9]
      // Push Init data
      ILI9341_SendCommandAndData(cmd, (uint8_t *)addr, numArgs);
 80010da:	7a7a      	ldrb	r2, [r7, #9]
 80010dc:	7afb      	ldrb	r3, [r7, #11]
 80010de:	68f9      	ldr	r1, [r7, #12]
 80010e0:	4618      	mov	r0, r3
 80010e2:	f7ff fec5 	bl	8000e70 <ILI9341_SendCommandAndData>

      addr += numArgs;
 80010e6:	7a7b      	ldrb	r3, [r7, #9]
 80010e8:	68fa      	ldr	r2, [r7, #12]
 80010ea:	4413      	add	r3, r2
 80010ec:	60fb      	str	r3, [r7, #12]

      if (x & 0x80)
 80010ee:	f997 300a 	ldrsb.w	r3, [r7, #10]
 80010f2:	2b00      	cmp	r3, #0
 80010f4:	da02      	bge.n	80010fc <ILI9341_Init+0x80>
      {
    	  ILI9341_Delay(150);
 80010f6:	2096      	movs	r0, #150	; 0x96
 80010f8:	f7ff fe5c 	bl	8000db4 <ILI9341_Delay>
    while ((cmd = *(addr++)) > 0)
 80010fc:	68fb      	ldr	r3, [r7, #12]
 80010fe:	1c5a      	adds	r2, r3, #1
 8001100:	60fa      	str	r2, [r7, #12]
 8001102:	781b      	ldrb	r3, [r3, #0]
 8001104:	72fb      	strb	r3, [r7, #11]
 8001106:	7afb      	ldrb	r3, [r7, #11]
 8001108:	2b00      	cmp	r3, #0
 800110a:	d1dd      	bne.n	80010c8 <ILI9341_Init+0x4c>
      }
    }

    // Set selected Rotation
    ILI9341_SetRotation(ILI9341_ROTATION);
 800110c:	2002      	movs	r0, #2
 800110e:	f7ff fedd 	bl	8000ecc <ILI9341_SetRotation>
}
 8001112:	bf00      	nop
 8001114:	3710      	adds	r7, #16
 8001116:	46bd      	mov	sp, r7
 8001118:	bd80      	pop	{r7, pc}
 800111a:	bf00      	nop
 800111c:	20000380 	.word	0x20000380
 8001120:	08029e7c 	.word	0x08029e7c
 8001124:	40020000 	.word	0x40020000

08001128 <ConvertRGB888toRGB565>:
#endif //ILI9341_USE_SD_CARD

#if(ILI9341_USE_JPEG == 1)

void ConvertRGB888toRGB565(uint8_t *OutputColor, uint32_t sourceColor)
{
 8001128:	b480      	push	{r7}
 800112a:	b087      	sub	sp, #28
 800112c:	af00      	add	r7, sp, #0
 800112e:	6078      	str	r0, [r7, #4]
 8001130:	6039      	str	r1, [r7, #0]
	uint32_t red = (sourceColor & 0x00FF0000) >> 16;
 8001132:	683b      	ldr	r3, [r7, #0]
 8001134:	0c1b      	lsrs	r3, r3, #16
 8001136:	b2db      	uxtb	r3, r3
 8001138:	617b      	str	r3, [r7, #20]
	uint32_t green = (sourceColor & 0x0000FF00) >> 8;
 800113a:	683b      	ldr	r3, [r7, #0]
 800113c:	0a1b      	lsrs	r3, r3, #8
 800113e:	b2db      	uxtb	r3, r3
 8001140:	613b      	str	r3, [r7, #16]
	uint32_t blue =  sourceColor & 0x000000FF;
 8001142:	683b      	ldr	r3, [r7, #0]
 8001144:	b2db      	uxtb	r3, r3
 8001146:	60fb      	str	r3, [r7, #12]
	uint16_t Color16b = ((red >> 3) << 11) + ((green >> 2) << 5) + (blue >> 3);
 8001148:	697b      	ldr	r3, [r7, #20]
 800114a:	08db      	lsrs	r3, r3, #3
 800114c:	b29b      	uxth	r3, r3
 800114e:	02db      	lsls	r3, r3, #11
 8001150:	b29a      	uxth	r2, r3
 8001152:	693b      	ldr	r3, [r7, #16]
 8001154:	089b      	lsrs	r3, r3, #2
 8001156:	b29b      	uxth	r3, r3
 8001158:	015b      	lsls	r3, r3, #5
 800115a:	b29b      	uxth	r3, r3
 800115c:	4413      	add	r3, r2
 800115e:	b29a      	uxth	r2, r3
 8001160:	68fb      	ldr	r3, [r7, #12]
 8001162:	08db      	lsrs	r3, r3, #3
 8001164:	b29b      	uxth	r3, r3
 8001166:	4413      	add	r3, r2
 8001168:	817b      	strh	r3, [r7, #10]
	OutputColor[1] = Color16b & 0xFF;
 800116a:	687b      	ldr	r3, [r7, #4]
 800116c:	3301      	adds	r3, #1
 800116e:	897a      	ldrh	r2, [r7, #10]
 8001170:	b2d2      	uxtb	r2, r2
 8001172:	701a      	strb	r2, [r3, #0]
	OutputColor[0] = Color16b >> 8;
 8001174:	897b      	ldrh	r3, [r7, #10]
 8001176:	0a1b      	lsrs	r3, r3, #8
 8001178:	b29b      	uxth	r3, r3
 800117a:	b2da      	uxtb	r2, r3
 800117c:	687b      	ldr	r3, [r7, #4]
 800117e:	701a      	strb	r2, [r3, #0]
}
 8001180:	bf00      	nop
 8001182:	371c      	adds	r7, #28
 8001184:	46bd      	mov	sp, r7
 8001186:	f85d 7b04 	ldr.w	r7, [sp], #4
 800118a:	4770      	bx	lr

0800118c <ILI9341_DrawJPEG>:


uint8_t ILI9341_DrawJPEG(uint16_t x, uint16_t y, const TCHAR* path)
{
 800118c:	b590      	push	{r4, r7, lr}
 800118e:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
 8001192:	af00      	add	r7, sp, #0
 8001194:	463b      	mov	r3, r7
 8001196:	601a      	str	r2, [r3, #0]
 8001198:	1dbb      	adds	r3, r7, #6
 800119a:	4602      	mov	r2, r0
 800119c:	801a      	strh	r2, [r3, #0]
 800119e:	1d3b      	adds	r3, r7, #4
 80011a0:	460a      	mov	r2, r1
 80011a2:	801a      	strh	r2, [r3, #0]
	FIL ImageFile;

	if(f_open(&ImageFile, path, FA_READ) == FR_OK)
 80011a4:	463b      	mov	r3, r7
 80011a6:	f107 0010 	add.w	r0, r7, #16
 80011aa:	2201      	movs	r2, #1
 80011ac:	6819      	ldr	r1, [r3, #0]
 80011ae:	f00a f8ff 	bl	800b3b0 <f_open>
 80011b2:	4603      	mov	r3, r0
 80011b4:	2b00      	cmp	r3, #0
 80011b6:	f040 80c8 	bne.w	800134a <ILI9341_DrawJPEG+0x1be>
	{
		/* Decode JPEG Image */
		JSAMPROW buffer[2] = {0}; /* Output row buffer */
 80011ba:	f107 0308 	add.w	r3, r7, #8
 80011be:	461a      	mov	r2, r3
 80011c0:	2300      	movs	r3, #0
 80011c2:	6013      	str	r3, [r2, #0]
 80011c4:	6053      	str	r3, [r2, #4]
		//uint32_t row_stride = 0; /* Physical row width in image buffer */

		buffer[0] = (JSAMPROW)&_aucLine;
 80011c6:	f107 0308 	add.w	r3, r7, #8
 80011ca:	4a63      	ldr	r2, [pc, #396]	; (8001358 <ILI9341_DrawJPEG+0x1cc>)
 80011cc:	601a      	str	r2, [r3, #0]

		/* Step 1: Allocate and initialize JPEG decompression object */
		cinfo.err = jpeg_std_error(&jerr);
 80011ce:	4863      	ldr	r0, [pc, #396]	; (800135c <ILI9341_DrawJPEG+0x1d0>)
 80011d0:	f016 fa08 	bl	80175e4 <jpeg_std_error>
 80011d4:	4603      	mov	r3, r0
 80011d6:	4a62      	ldr	r2, [pc, #392]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80011d8:	6013      	str	r3, [r2, #0]

		/* Step 2: Initialize the JPEG decompression object */
		jpeg_create_decompress(&cinfo);
 80011da:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 80011de:	2150      	movs	r1, #80	; 0x50
 80011e0:	485f      	ldr	r0, [pc, #380]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80011e2:	f00a ff36 	bl	800c052 <jpeg_CreateDecompress>

		jpeg_stdio_src (&cinfo, &ImageFile);
 80011e6:	f107 0310 	add.w	r3, r7, #16
 80011ea:	4619      	mov	r1, r3
 80011ec:	485c      	ldr	r0, [pc, #368]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80011ee:	f00c fc95 	bl	800db1c <jpeg_stdio_src>

		/* Step 3: read image parameters with jpeg_read_header() */
		jpeg_read_header(&cinfo, TRUE);
 80011f2:	2101      	movs	r1, #1
 80011f4:	485a      	ldr	r0, [pc, #360]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80011f6:	f00b f8e3 	bl	800c3c0 <jpeg_read_header>

		/* Step 4: set parameters for decompression */
		cinfo.dct_method = JDCT_FLOAT;
 80011fa:	4b59      	ldr	r3, [pc, #356]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80011fc:	2202      	movs	r2, #2
 80011fe:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

		/* Step 5: start decompressor */
		jpeg_start_decompress(&cinfo);
 8001202:	4857      	ldr	r0, [pc, #348]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001204:	f00b f9e9 	bl	800c5da <jpeg_start_decompress>

		//row_stride = cinfo.output_width * cinfo.output_components;

		ILI9341_SetAddrWindow(x, y, x+cinfo.output_width, y+cinfo.output_height);
 8001208:	4b55      	ldr	r3, [pc, #340]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 800120a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800120c:	b29a      	uxth	r2, r3
 800120e:	1dbb      	adds	r3, r7, #6
 8001210:	881b      	ldrh	r3, [r3, #0]
 8001212:	4413      	add	r3, r2
 8001214:	b29c      	uxth	r4, r3
 8001216:	4b52      	ldr	r3, [pc, #328]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001218:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800121a:	b29a      	uxth	r2, r3
 800121c:	1d3b      	adds	r3, r7, #4
 800121e:	881b      	ldrh	r3, [r3, #0]
 8001220:	4413      	add	r3, r2
 8001222:	b29a      	uxth	r2, r3
 8001224:	1d3b      	adds	r3, r7, #4
 8001226:	8819      	ldrh	r1, [r3, #0]
 8001228:	1dbb      	adds	r3, r7, #6
 800122a:	8818      	ldrh	r0, [r3, #0]
 800122c:	4613      	mov	r3, r2
 800122e:	4622      	mov	r2, r4
 8001230:	f7ff fe7a 	bl	8000f28 <ILI9341_SetAddrWindow>
		ILI9341_SendCommand(ILI9341_RAMWR);
 8001234:	202c      	movs	r0, #44	; 0x2c
 8001236:	f7ff fdf9 	bl	8000e2c <ILI9341_SendCommand>

		uint16_t RowNumber = 0;
 800123a:	2300      	movs	r3, #0
 800123c:	f8a7 3246 	strh.w	r3, [r7, #582]	; 0x246
		while (cinfo.output_scanline < cinfo.output_height)
 8001240:	e06d      	b.n	800131e <ILI9341_DrawJPEG+0x192>
		{
			(void) jpeg_read_scanlines(&cinfo, buffer, 1);
 8001242:	f107 0308 	add.w	r3, r7, #8
 8001246:	2201      	movs	r2, #1
 8001248:	4619      	mov	r1, r3
 800124a:	4845      	ldr	r0, [pc, #276]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 800124c:	f00b faad 	bl	800c7aa <jpeg_read_scanlines>

			RGB_matrix = (RGB_typedef*)buffer[0];
 8001250:	f107 0308 	add.w	r3, r7, #8
 8001254:	681b      	ldr	r3, [r3, #0]
 8001256:	4a43      	ldr	r2, [pc, #268]	; (8001364 <ILI9341_DrawJPEG+0x1d8>)
 8001258:	6013      	str	r3, [r2, #0]

			uint32_t counter = 0;
 800125a:	2300      	movs	r3, #0
 800125c:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240

			for(counter = 0; counter < cinfo.output_width; counter++)
 8001260:	2300      	movs	r3, #0
 8001262:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
 8001266:	e030      	b.n	80012ca <ILI9341_DrawJPEG+0x13e>
			{
				ConvertRGB888toRGB565((uint8_t*)buffer[0]+(counter*2),
 8001268:	f107 0308 	add.w	r3, r7, #8
 800126c:	681a      	ldr	r2, [r3, #0]
 800126e:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 8001272:	005b      	lsls	r3, r3, #1
 8001274:	18d4      	adds	r4, r2, r3
				(
					RGB_matrix[counter].R << 16 |
 8001276:	4b3b      	ldr	r3, [pc, #236]	; (8001364 <ILI9341_DrawJPEG+0x1d8>)
 8001278:	6819      	ldr	r1, [r3, #0]
 800127a:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 800127e:	4613      	mov	r3, r2
 8001280:	005b      	lsls	r3, r3, #1
 8001282:	4413      	add	r3, r2
 8001284:	440b      	add	r3, r1
 8001286:	781b      	ldrb	r3, [r3, #0]
 8001288:	0419      	lsls	r1, r3, #16
					RGB_matrix[counter].G << 8|
 800128a:	4b36      	ldr	r3, [pc, #216]	; (8001364 <ILI9341_DrawJPEG+0x1d8>)
 800128c:	6818      	ldr	r0, [r3, #0]
 800128e:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 8001292:	4613      	mov	r3, r2
 8001294:	005b      	lsls	r3, r3, #1
 8001296:	4413      	add	r3, r2
 8001298:	4403      	add	r3, r0
 800129a:	785b      	ldrb	r3, [r3, #1]
 800129c:	021b      	lsls	r3, r3, #8
					RGB_matrix[counter].R << 16 |
 800129e:	4319      	orrs	r1, r3
					RGB_matrix[counter].B | 0xFF000000)
 80012a0:	4b30      	ldr	r3, [pc, #192]	; (8001364 <ILI9341_DrawJPEG+0x1d8>)
 80012a2:	6818      	ldr	r0, [r3, #0]
 80012a4:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 80012a8:	4613      	mov	r3, r2
 80012aa:	005b      	lsls	r3, r3, #1
 80012ac:	4413      	add	r3, r2
 80012ae:	4403      	add	r3, r0
 80012b0:	789b      	ldrb	r3, [r3, #2]
					RGB_matrix[counter].G << 8|
 80012b2:	430b      	orrs	r3, r1
					RGB_matrix[counter].B | 0xFF000000)
 80012b4:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
				ConvertRGB888toRGB565((uint8_t*)buffer[0]+(counter*2),
 80012b8:	4619      	mov	r1, r3
 80012ba:	4620      	mov	r0, r4
 80012bc:	f7ff ff34 	bl	8001128 <ConvertRGB888toRGB565>
			for(counter = 0; counter < cinfo.output_width; counter++)
 80012c0:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 80012c4:	3301      	adds	r3, #1
 80012c6:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
 80012ca:	4b25      	ldr	r3, [pc, #148]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80012cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80012ce:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 80012d2:	429a      	cmp	r2, r3
 80012d4:	d3c8      	bcc.n	8001268 <ILI9341_DrawJPEG+0xdc>
				);
			}

#if (ILI9341_USE_CS == 1)
			ILI9341_CS_LOW;
 80012d6:	2200      	movs	r2, #0
 80012d8:	2140      	movs	r1, #64	; 0x40
 80012da:	4823      	ldr	r0, [pc, #140]	; (8001368 <ILI9341_DrawJPEG+0x1dc>)
 80012dc:	f000 fef8 	bl	80020d0 <HAL_GPIO_WritePin>
#endif

			ILI9341_DC_HIGH;
 80012e0:	2201      	movs	r2, #1
 80012e2:	2180      	movs	r1, #128	; 0x80
 80012e4:	4821      	ldr	r0, [pc, #132]	; (800136c <ILI9341_DrawJPEG+0x1e0>)
 80012e6:	f000 fef3 	bl	80020d0 <HAL_GPIO_WritePin>
			ILI9341_SendToTFT((uint8_t*)buffer[0], (cinfo.output_width)*2);
 80012ea:	f107 0308 	add.w	r3, r7, #8
 80012ee:	681a      	ldr	r2, [r3, #0]
 80012f0:	4b1b      	ldr	r3, [pc, #108]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 80012f2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80012f4:	005b      	lsls	r3, r3, #1
 80012f6:	4619      	mov	r1, r3
 80012f8:	4610      	mov	r0, r2
 80012fa:	f7ff fd67 	bl	8000dcc <ILI9341_SendToTFT>

#if (ILI9341_USE_CS == 1)
			ILI9341_CS_HIGH;
 80012fe:	2201      	movs	r2, #1
 8001300:	2140      	movs	r1, #64	; 0x40
 8001302:	4819      	ldr	r0, [pc, #100]	; (8001368 <ILI9341_DrawJPEG+0x1dc>)
 8001304:	f000 fee4 	bl	80020d0 <HAL_GPIO_WritePin>
#endif
		RowNumber++;
 8001308:	f8b7 3246 	ldrh.w	r3, [r7, #582]	; 0x246
 800130c:	3301      	adds	r3, #1
 800130e:	f8a7 3246 	strh.w	r3, [r7, #582]	; 0x246
		if(RowNumber == cinfo.output_height)
 8001312:	f8b7 2246 	ldrh.w	r2, [r7, #582]	; 0x246
 8001316:	4b12      	ldr	r3, [pc, #72]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001318:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800131a:	429a      	cmp	r2, r3
 800131c:	d007      	beq.n	800132e <ILI9341_DrawJPEG+0x1a2>
		while (cinfo.output_scanline < cinfo.output_height)
 800131e:	4b10      	ldr	r3, [pc, #64]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001320:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8001324:	4b0e      	ldr	r3, [pc, #56]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001326:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001328:	429a      	cmp	r2, r3
 800132a:	d38a      	bcc.n	8001242 <ILI9341_DrawJPEG+0xb6>
 800132c:	e000      	b.n	8001330 <ILI9341_DrawJPEG+0x1a4>
		{
			break;
 800132e:	bf00      	nop
		}
		}
		  /* Step 6: Finish decompression */
		  jpeg_finish_decompress(&cinfo);
 8001330:	480b      	ldr	r0, [pc, #44]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001332:	f00b f8ef 	bl	800c514 <jpeg_finish_decompress>

		  /* Step 7: Release JPEG decompression object */
		  jpeg_destroy_decompress(&cinfo);
 8001336:	480a      	ldr	r0, [pc, #40]	; (8001360 <ILI9341_DrawJPEG+0x1d4>)
 8001338:	f00a ff14 	bl	800c164 <jpeg_destroy_decompress>

		  f_close(&ImageFile);
 800133c:	f107 0310 	add.w	r3, r7, #16
 8001340:	4618      	mov	r0, r3
 8001342:	f00a fbb0 	bl	800baa6 <f_close>

		  return 0;
 8001346:	2300      	movs	r3, #0
 8001348:	e000      	b.n	800134c <ILI9341_DrawJPEG+0x1c0>
	}
	return 1;
 800134a:	2301      	movs	r3, #1
}
 800134c:	4618      	mov	r0, r3
 800134e:	f507 7713 	add.w	r7, r7, #588	; 0x24c
 8001352:	46bd      	mov	sp, r7
 8001354:	bd90      	pop	{r4, r7, pc}
 8001356:	bf00      	nop
 8001358:	20000570 	.word	0x20000570
 800135c:	200002f8 	.word	0x200002f8
 8001360:	20000388 	.word	0x20000388
 8001364:	2000037c 	.word	0x2000037c
 8001368:	40020400 	.word	0x40020400
 800136c:	40020800 	.word	0x40020800

08001370 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001370:	b580      	push	{r7, lr}
 8001372:	b08a      	sub	sp, #40	; 0x28
 8001374:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001376:	f107 0314 	add.w	r3, r7, #20
 800137a:	2200      	movs	r2, #0
 800137c:	601a      	str	r2, [r3, #0]
 800137e:	605a      	str	r2, [r3, #4]
 8001380:	609a      	str	r2, [r3, #8]
 8001382:	60da      	str	r2, [r3, #12]
 8001384:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001386:	2300      	movs	r3, #0
 8001388:	613b      	str	r3, [r7, #16]
 800138a:	4b41      	ldr	r3, [pc, #260]	; (8001490 <MX_GPIO_Init+0x120>)
 800138c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800138e:	4a40      	ldr	r2, [pc, #256]	; (8001490 <MX_GPIO_Init+0x120>)
 8001390:	f043 0304 	orr.w	r3, r3, #4
 8001394:	6313      	str	r3, [r2, #48]	; 0x30
 8001396:	4b3e      	ldr	r3, [pc, #248]	; (8001490 <MX_GPIO_Init+0x120>)
 8001398:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800139a:	f003 0304 	and.w	r3, r3, #4
 800139e:	613b      	str	r3, [r7, #16]
 80013a0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80013a2:	2300      	movs	r3, #0
 80013a4:	60fb      	str	r3, [r7, #12]
 80013a6:	4b3a      	ldr	r3, [pc, #232]	; (8001490 <MX_GPIO_Init+0x120>)
 80013a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013aa:	4a39      	ldr	r2, [pc, #228]	; (8001490 <MX_GPIO_Init+0x120>)
 80013ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80013b0:	6313      	str	r3, [r2, #48]	; 0x30
 80013b2:	4b37      	ldr	r3, [pc, #220]	; (8001490 <MX_GPIO_Init+0x120>)
 80013b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013b6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80013ba:	60fb      	str	r3, [r7, #12]
 80013bc:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80013be:	2300      	movs	r3, #0
 80013c0:	60bb      	str	r3, [r7, #8]
 80013c2:	4b33      	ldr	r3, [pc, #204]	; (8001490 <MX_GPIO_Init+0x120>)
 80013c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013c6:	4a32      	ldr	r2, [pc, #200]	; (8001490 <MX_GPIO_Init+0x120>)
 80013c8:	f043 0301 	orr.w	r3, r3, #1
 80013cc:	6313      	str	r3, [r2, #48]	; 0x30
 80013ce:	4b30      	ldr	r3, [pc, #192]	; (8001490 <MX_GPIO_Init+0x120>)
 80013d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013d2:	f003 0301 	and.w	r3, r3, #1
 80013d6:	60bb      	str	r3, [r7, #8]
 80013d8:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80013da:	2300      	movs	r3, #0
 80013dc:	607b      	str	r3, [r7, #4]
 80013de:	4b2c      	ldr	r3, [pc, #176]	; (8001490 <MX_GPIO_Init+0x120>)
 80013e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013e2:	4a2b      	ldr	r2, [pc, #172]	; (8001490 <MX_GPIO_Init+0x120>)
 80013e4:	f043 0302 	orr.w	r3, r3, #2
 80013e8:	6313      	str	r3, [r2, #48]	; 0x30
 80013ea:	4b29      	ldr	r3, [pc, #164]	; (8001490 <MX_GPIO_Init+0x120>)
 80013ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013ee:	f003 0302 	and.w	r3, r3, #2
 80013f2:	607b      	str	r3, [r7, #4]
 80013f4:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, LD2_Pin|TFT_DC_Pin, GPIO_PIN_RESET);
 80013f6:	2200      	movs	r2, #0
 80013f8:	2181      	movs	r1, #129	; 0x81
 80013fa:	4826      	ldr	r0, [pc, #152]	; (8001494 <MX_GPIO_Init+0x124>)
 80013fc:	f000 fe68 	bl	80020d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(TFT_RST_GPIO_Port, TFT_RST_Pin, GPIO_PIN_RESET);
 8001400:	2200      	movs	r2, #0
 8001402:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001406:	4824      	ldr	r0, [pc, #144]	; (8001498 <MX_GPIO_Init+0x128>)
 8001408:	f000 fe62 	bl	80020d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(TFT_CS_GPIO_Port, TFT_CS_Pin, GPIO_PIN_RESET);
 800140c:	2200      	movs	r2, #0
 800140e:	2140      	movs	r1, #64	; 0x40
 8001410:	4822      	ldr	r0, [pc, #136]	; (800149c <MX_GPIO_Init+0x12c>)
 8001412:	f000 fe5d 	bl	80020d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = B1_Pin;
 8001416:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800141a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800141c:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
 8001420:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001422:	2300      	movs	r3, #0
 8001424:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001426:	f107 0314 	add.w	r3, r7, #20
 800142a:	4619      	mov	r1, r3
 800142c:	4819      	ldr	r0, [pc, #100]	; (8001494 <MX_GPIO_Init+0x124>)
 800142e:	f000 fccb 	bl	8001dc8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = LD2_Pin|TFT_DC_Pin;
 8001432:	2381      	movs	r3, #129	; 0x81
 8001434:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001436:	2301      	movs	r3, #1
 8001438:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800143a:	2300      	movs	r3, #0
 800143c:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800143e:	2300      	movs	r3, #0
 8001440:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001442:	f107 0314 	add.w	r3, r7, #20
 8001446:	4619      	mov	r1, r3
 8001448:	4812      	ldr	r0, [pc, #72]	; (8001494 <MX_GPIO_Init+0x124>)
 800144a:	f000 fcbd 	bl	8001dc8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = TFT_RST_Pin;
 800144e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001452:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001454:	2301      	movs	r3, #1
 8001456:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001458:	2300      	movs	r3, #0
 800145a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800145c:	2300      	movs	r3, #0
 800145e:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(TFT_RST_GPIO_Port, &GPIO_InitStruct);
 8001460:	f107 0314 	add.w	r3, r7, #20
 8001464:	4619      	mov	r1, r3
 8001466:	480c      	ldr	r0, [pc, #48]	; (8001498 <MX_GPIO_Init+0x128>)
 8001468:	f000 fcae 	bl	8001dc8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = TFT_CS_Pin;
 800146c:	2340      	movs	r3, #64	; 0x40
 800146e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001470:	2301      	movs	r3, #1
 8001472:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001474:	2300      	movs	r3, #0
 8001476:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001478:	2300      	movs	r3, #0
 800147a:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(TFT_CS_GPIO_Port, &GPIO_InitStruct);
 800147c:	f107 0314 	add.w	r3, r7, #20
 8001480:	4619      	mov	r1, r3
 8001482:	4806      	ldr	r0, [pc, #24]	; (800149c <MX_GPIO_Init+0x12c>)
 8001484:	f000 fca0 	bl	8001dc8 <HAL_GPIO_Init>

}
 8001488:	bf00      	nop
 800148a:	3728      	adds	r7, #40	; 0x28
 800148c:	46bd      	mov	sp, r7
 800148e:	bd80      	pop	{r7, pc}
 8001490:	40023800 	.word	0x40023800
 8001494:	40020800 	.word	0x40020800
 8001498:	40020000 	.word	0x40020000
 800149c:	40020400 	.word	0x40020400

080014a0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80014a0:	b580      	push	{r7, lr}
 80014a2:	b0d6      	sub	sp, #344	; 0x158
 80014a4:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80014a6:	f000 fae7 	bl	8001a78 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80014aa:	f000 f8b9 	bl	8001620 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80014ae:	f7ff ff5f 	bl	8001370 <MX_GPIO_Init>
  MX_USART2_UART_Init();
 80014b2:	f000 fa45 	bl	8001940 <MX_USART2_UART_Init>
  MX_USB_HOST_Init();
 80014b6:	f026 fb97 	bl	8027be8 <MX_USB_HOST_Init>
  MX_FATFS_Init();
 80014ba:	f004 fb5d 	bl	8005b78 <MX_FATFS_Init>
  MX_SPI1_Init();
 80014be:	f000 f91d 	bl	80016fc <MX_SPI1_Init>
  MX_LIBJPEG_Init();
 80014c2:	f004 fc83 	bl	8005dcc <MX_LIBJPEG_Init>
  /* USER CODE BEGIN 2 */
  ILI9341_Init(&hspi1);
 80014c6:	484a      	ldr	r0, [pc, #296]	; (80015f0 <main+0x150>)
 80014c8:	f7ff fdd8 	bl	800107c <ILI9341_Init>
  ILI9341_ClearDisplay(ILI9341_CYAN);
 80014cc:	f240 70ff 	movw	r0, #2047	; 0x7ff
 80014d0:	f7ff fd78 	bl	8000fc4 <ILI9341_ClearDisplay>
  uint32_t Timer = HAL_GetTick();
 80014d4:	f000 fb36 	bl	8001b44 <HAL_GetTick>
 80014d8:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  switch(Appli_state) {
 80014dc:	4b45      	ldr	r3, [pc, #276]	; (80015f4 <main+0x154>)
 80014de:	781b      	ldrb	r3, [r3, #0]
 80014e0:	2b03      	cmp	r3, #3
 80014e2:	d87e      	bhi.n	80015e2 <main+0x142>
 80014e4:	a201      	add	r2, pc, #4	; (adr r2, 80014ec <main+0x4c>)
 80014e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80014ea:	bf00      	nop
 80014ec:	080015e3 	.word	0x080015e3
 80014f0:	080014fd 	.word	0x080014fd
 80014f4:	0800155f 	.word	0x0800155f
 80014f8:	080015e3 	.word	0x080015e3
	  case APPLICATION_IDLE:

		  break;
	  case APPLICATION_START:
		  retUSBH = f_mount(&USBHFatFS, (const TCHAR*)USBHPath, 0);
 80014fc:	2200      	movs	r2, #0
 80014fe:	493e      	ldr	r1, [pc, #248]	; (80015f8 <main+0x158>)
 8001500:	483e      	ldr	r0, [pc, #248]	; (80015fc <main+0x15c>)
 8001502:	f009 ff0f 	bl	800b324 <f_mount>
 8001506:	4603      	mov	r3, r0
 8001508:	461a      	mov	r2, r3
 800150a:	4b3d      	ldr	r3, [pc, #244]	; (8001600 <main+0x160>)
 800150c:	701a      	strb	r2, [r3, #0]
		  if(retUSBH != FR_OK)
 800150e:	4b3c      	ldr	r3, [pc, #240]	; (8001600 <main+0x160>)
 8001510:	781b      	ldrb	r3, [r3, #0]
 8001512:	2b00      	cmp	r3, #0
 8001514:	d011      	beq.n	800153a <main+0x9a>
		  {
		  	  Bytes = sprintf(Data, "FatFS mount error.\n\r");
 8001516:	493b      	ldr	r1, [pc, #236]	; (8001604 <main+0x164>)
 8001518:	483b      	ldr	r0, [pc, #236]	; (8001608 <main+0x168>)
 800151a:	f026 ff73 	bl	8028404 <siprintf>
 800151e:	4603      	mov	r3, r0
 8001520:	b2da      	uxtb	r2, r3
 8001522:	4b3a      	ldr	r3, [pc, #232]	; (800160c <main+0x16c>)
 8001524:	701a      	strb	r2, [r3, #0]
		  	  HAL_UART_Transmit(&huart2, (uint8_t*)Data, Bytes, 1000);
 8001526:	4b39      	ldr	r3, [pc, #228]	; (800160c <main+0x16c>)
 8001528:	781b      	ldrb	r3, [r3, #0]
 800152a:	b29a      	uxth	r2, r3
 800152c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001530:	4935      	ldr	r1, [pc, #212]	; (8001608 <main+0x168>)
 8001532:	4837      	ldr	r0, [pc, #220]	; (8001610 <main+0x170>)
 8001534:	f003 f8a0 	bl	8004678 <HAL_UART_Transmit>
		  else
		  {
			  Bytes = sprintf(Data, "FatFS mounted.\n\r");
			  HAL_UART_Transmit(&huart2, (uint8_t*)Data, Bytes, 1000);
		  }
		  break;
 8001538:	e056      	b.n	80015e8 <main+0x148>
			  Bytes = sprintf(Data, "FatFS mounted.\n\r");
 800153a:	4936      	ldr	r1, [pc, #216]	; (8001614 <main+0x174>)
 800153c:	4832      	ldr	r0, [pc, #200]	; (8001608 <main+0x168>)
 800153e:	f026 ff61 	bl	8028404 <siprintf>
 8001542:	4603      	mov	r3, r0
 8001544:	b2da      	uxtb	r2, r3
 8001546:	4b31      	ldr	r3, [pc, #196]	; (800160c <main+0x16c>)
 8001548:	701a      	strb	r2, [r3, #0]
			  HAL_UART_Transmit(&huart2, (uint8_t*)Data, Bytes, 1000);
 800154a:	4b30      	ldr	r3, [pc, #192]	; (800160c <main+0x16c>)
 800154c:	781b      	ldrb	r3, [r3, #0]
 800154e:	b29a      	uxth	r2, r3
 8001550:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001554:	492c      	ldr	r1, [pc, #176]	; (8001608 <main+0x168>)
 8001556:	482e      	ldr	r0, [pc, #184]	; (8001610 <main+0x170>)
 8001558:	f003 f88e 	bl	8004678 <HAL_UART_Transmit>
		  break;
 800155c:	e044      	b.n	80015e8 <main+0x148>
	  case APPLICATION_READY:
		  if(((HAL_GetTick() - Timer) > 1000) && (retUSBH == FR_OK))
 800155e:	f000 faf1 	bl	8001b44 <HAL_GetTick>
 8001562:	4602      	mov	r2, r0
 8001564:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8001568:	1ad3      	subs	r3, r2, r3
 800156a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800156e:	d93a      	bls.n	80015e6 <main+0x146>
 8001570:	4b23      	ldr	r3, [pc, #140]	; (8001600 <main+0x160>)
 8001572:	781b      	ldrb	r3, [r3, #0]
 8001574:	2b00      	cmp	r3, #0
 8001576:	d136      	bne.n	80015e6 <main+0x146>
		  {
			  Timer = HAL_GetTick();
 8001578:	f000 fae4 	bl	8001b44 <HAL_GetTick>
 800157c:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154
			  DIR dj;         /* Directory object */
			  FILINFO fno;    /* File information */

			  retUSBH = f_findfirst(&dj, &fno, "", "*.jpg");  /* Start to search for photo files */
 8001580:	f107 013c 	add.w	r1, r7, #60	; 0x3c
 8001584:	1d38      	adds	r0, r7, #4
 8001586:	4b24      	ldr	r3, [pc, #144]	; (8001618 <main+0x178>)
 8001588:	4a24      	ldr	r2, [pc, #144]	; (800161c <main+0x17c>)
 800158a:	f00a fbb4 	bl	800bcf6 <f_findfirst>
 800158e:	4603      	mov	r3, r0
 8001590:	461a      	mov	r2, r3
 8001592:	4b1b      	ldr	r3, [pc, #108]	; (8001600 <main+0x160>)
 8001594:	701a      	strb	r2, [r3, #0]

			  while (retUSBH == FR_OK && fno.fname[0])
 8001596:	e016      	b.n	80015c6 <main+0x126>
			  {         /* Repeat while an item is found */
				  ILI9341_DrawJPEG(0, 0, fno.fname);
 8001598:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800159c:	3316      	adds	r3, #22
 800159e:	461a      	mov	r2, r3
 80015a0:	2100      	movs	r1, #0
 80015a2:	2000      	movs	r0, #0
 80015a4:	f7ff fdf2 	bl	800118c <ILI9341_DrawJPEG>
				  retUSBH = f_findnext(&dj, &fno);               /* Search for next item */
 80015a8:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 80015ac:	1d3b      	adds	r3, r7, #4
 80015ae:	4611      	mov	r1, r2
 80015b0:	4618      	mov	r0, r3
 80015b2:	f00a fb78 	bl	800bca6 <f_findnext>
 80015b6:	4603      	mov	r3, r0
 80015b8:	461a      	mov	r2, r3
 80015ba:	4b11      	ldr	r3, [pc, #68]	; (8001600 <main+0x160>)
 80015bc:	701a      	strb	r2, [r3, #0]
				  HAL_Delay(1000);
 80015be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80015c2:	f000 facb 	bl	8001b5c <HAL_Delay>
			  while (retUSBH == FR_OK && fno.fname[0])
 80015c6:	4b0e      	ldr	r3, [pc, #56]	; (8001600 <main+0x160>)
 80015c8:	781b      	ldrb	r3, [r3, #0]
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d104      	bne.n	80015d8 <main+0x138>
 80015ce:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 80015d2:	7d9b      	ldrb	r3, [r3, #22]
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	d1df      	bne.n	8001598 <main+0xf8>
			  }
			  f_closedir(&dj);
 80015d8:	1d3b      	adds	r3, r7, #4
 80015da:	4618      	mov	r0, r3
 80015dc:	f00a fb00 	bl	800bbe0 <f_closedir>
		  }
		  break;
 80015e0:	e001      	b.n	80015e6 <main+0x146>
	  case APPLICATION_DISCONNECT:

		  break;
	  default:
		  break;
 80015e2:	bf00      	nop
 80015e4:	e000      	b.n	80015e8 <main+0x148>
		  break;
 80015e6:	bf00      	nop
	  }

    /* USER CODE END WHILE */
    MX_USB_HOST_Process();
 80015e8:	f026 fb24 	bl	8027c34 <MX_USB_HOST_Process>
	  switch(Appli_state) {
 80015ec:	e776      	b.n	80014dc <main+0x3c>
 80015ee:	bf00      	nop
 80015f0:	200008c4 	.word	0x200008c4
 80015f4:	200002e8 	.word	0x200002e8
 80015f8:	20000964 	.word	0x20000964
 80015fc:	20000b98 	.word	0x20000b98
 8001600:	20000dcc 	.word	0x20000dcc
 8001604:	08028ae8 	.word	0x08028ae8
 8001608:	20000840 	.word	0x20000840
 800160c:	200008c0 	.word	0x200008c0
 8001610:	2000091c 	.word	0x2000091c
 8001614:	08028b00 	.word	0x08028b00
 8001618:	08028b14 	.word	0x08028b14
 800161c:	08028b1c 	.word	0x08028b1c

08001620 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001620:	b580      	push	{r7, lr}
 8001622:	b094      	sub	sp, #80	; 0x50
 8001624:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001626:	f107 0320 	add.w	r3, r7, #32
 800162a:	2230      	movs	r2, #48	; 0x30
 800162c:	2100      	movs	r1, #0
 800162e:	4618      	mov	r0, r3
 8001630:	f026 fe26 	bl	8028280 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001634:	f107 030c 	add.w	r3, r7, #12
 8001638:	2200      	movs	r2, #0
 800163a:	601a      	str	r2, [r3, #0]
 800163c:	605a      	str	r2, [r3, #4]
 800163e:	609a      	str	r2, [r3, #8]
 8001640:	60da      	str	r2, [r3, #12]
 8001642:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8001644:	2300      	movs	r3, #0
 8001646:	60bb      	str	r3, [r7, #8]
 8001648:	4b27      	ldr	r3, [pc, #156]	; (80016e8 <SystemClock_Config+0xc8>)
 800164a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800164c:	4a26      	ldr	r2, [pc, #152]	; (80016e8 <SystemClock_Config+0xc8>)
 800164e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001652:	6413      	str	r3, [r2, #64]	; 0x40
 8001654:	4b24      	ldr	r3, [pc, #144]	; (80016e8 <SystemClock_Config+0xc8>)
 8001656:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001658:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800165c:	60bb      	str	r3, [r7, #8]
 800165e:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001660:	2300      	movs	r3, #0
 8001662:	607b      	str	r3, [r7, #4]
 8001664:	4b21      	ldr	r3, [pc, #132]	; (80016ec <SystemClock_Config+0xcc>)
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	4a20      	ldr	r2, [pc, #128]	; (80016ec <SystemClock_Config+0xcc>)
 800166a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800166e:	6013      	str	r3, [r2, #0]
 8001670:	4b1e      	ldr	r3, [pc, #120]	; (80016ec <SystemClock_Config+0xcc>)
 8001672:	681b      	ldr	r3, [r3, #0]
 8001674:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8001678:	607b      	str	r3, [r7, #4]
 800167a:	687b      	ldr	r3, [r7, #4]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800167c:	2301      	movs	r3, #1
 800167e:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8001680:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8001684:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001686:	2302      	movs	r3, #2
 8001688:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800168a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800168e:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 4;
 8001690:	2304      	movs	r3, #4
 8001692:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 72;
 8001694:	2348      	movs	r3, #72	; 0x48
 8001696:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8001698:	2302      	movs	r3, #2
 800169a:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 3;
 800169c:	2303      	movs	r3, #3
 800169e:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80016a0:	f107 0320 	add.w	r3, r7, #32
 80016a4:	4618      	mov	r0, r3
 80016a6:	f002 fa9d 	bl	8003be4 <HAL_RCC_OscConfig>
 80016aa:	4603      	mov	r3, r0
 80016ac:	2b00      	cmp	r3, #0
 80016ae:	d001      	beq.n	80016b4 <SystemClock_Config+0x94>
  {
    Error_Handler();
 80016b0:	f000 f81e 	bl	80016f0 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80016b4:	230f      	movs	r3, #15
 80016b6:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80016b8:	2302      	movs	r3, #2
 80016ba:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80016bc:	2300      	movs	r3, #0
 80016be:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80016c0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80016c4:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80016c6:	2300      	movs	r3, #0
 80016c8:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 80016ca:	f107 030c 	add.w	r3, r7, #12
 80016ce:	2102      	movs	r1, #2
 80016d0:	4618      	mov	r0, r3
 80016d2:	f002 fcff 	bl	80040d4 <HAL_RCC_ClockConfig>
 80016d6:	4603      	mov	r3, r0
 80016d8:	2b00      	cmp	r3, #0
 80016da:	d001      	beq.n	80016e0 <SystemClock_Config+0xc0>
  {
    Error_Handler();
 80016dc:	f000 f808 	bl	80016f0 <Error_Handler>
  }
}
 80016e0:	bf00      	nop
 80016e2:	3750      	adds	r7, #80	; 0x50
 80016e4:	46bd      	mov	sp, r7
 80016e6:	bd80      	pop	{r7, pc}
 80016e8:	40023800 	.word	0x40023800
 80016ec:	40007000 	.word	0x40007000

080016f0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80016f0:	b480      	push	{r7}
 80016f2:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016f4:	b672      	cpsid	i
}
 80016f6:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80016f8:	e7fe      	b.n	80016f8 <Error_Handler+0x8>
	...

080016fc <MX_SPI1_Init>:

SPI_HandleTypeDef hspi1;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 80016fc:	b580      	push	{r7, lr}
 80016fe:	af00      	add	r7, sp, #0
  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
 8001700:	4b17      	ldr	r3, [pc, #92]	; (8001760 <MX_SPI1_Init+0x64>)
 8001702:	4a18      	ldr	r2, [pc, #96]	; (8001764 <MX_SPI1_Init+0x68>)
 8001704:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8001706:	4b16      	ldr	r3, [pc, #88]	; (8001760 <MX_SPI1_Init+0x64>)
 8001708:	f44f 7282 	mov.w	r2, #260	; 0x104
 800170c:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800170e:	4b14      	ldr	r3, [pc, #80]	; (8001760 <MX_SPI1_Init+0x64>)
 8001710:	2200      	movs	r2, #0
 8001712:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8001714:	4b12      	ldr	r3, [pc, #72]	; (8001760 <MX_SPI1_Init+0x64>)
 8001716:	2200      	movs	r2, #0
 8001718:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800171a:	4b11      	ldr	r3, [pc, #68]	; (8001760 <MX_SPI1_Init+0x64>)
 800171c:	2200      	movs	r2, #0
 800171e:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8001720:	4b0f      	ldr	r3, [pc, #60]	; (8001760 <MX_SPI1_Init+0x64>)
 8001722:	2200      	movs	r2, #0
 8001724:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8001726:	4b0e      	ldr	r3, [pc, #56]	; (8001760 <MX_SPI1_Init+0x64>)
 8001728:	f44f 7200 	mov.w	r2, #512	; 0x200
 800172c:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 800172e:	4b0c      	ldr	r3, [pc, #48]	; (8001760 <MX_SPI1_Init+0x64>)
 8001730:	2210      	movs	r2, #16
 8001732:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8001734:	4b0a      	ldr	r3, [pc, #40]	; (8001760 <MX_SPI1_Init+0x64>)
 8001736:	2200      	movs	r2, #0
 8001738:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800173a:	4b09      	ldr	r3, [pc, #36]	; (8001760 <MX_SPI1_Init+0x64>)
 800173c:	2200      	movs	r2, #0
 800173e:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001740:	4b07      	ldr	r3, [pc, #28]	; (8001760 <MX_SPI1_Init+0x64>)
 8001742:	2200      	movs	r2, #0
 8001744:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 8001746:	4b06      	ldr	r3, [pc, #24]	; (8001760 <MX_SPI1_Init+0x64>)
 8001748:	220a      	movs	r2, #10
 800174a:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800174c:	4804      	ldr	r0, [pc, #16]	; (8001760 <MX_SPI1_Init+0x64>)
 800174e:	f002 febd 	bl	80044cc <HAL_SPI_Init>
 8001752:	4603      	mov	r3, r0
 8001754:	2b00      	cmp	r3, #0
 8001756:	d001      	beq.n	800175c <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 8001758:	f7ff ffca 	bl	80016f0 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 800175c:	bf00      	nop
 800175e:	bd80      	pop	{r7, pc}
 8001760:	200008c4 	.word	0x200008c4
 8001764:	40013000 	.word	0x40013000

08001768 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8001768:	b580      	push	{r7, lr}
 800176a:	b08a      	sub	sp, #40	; 0x28
 800176c:	af00      	add	r7, sp, #0
 800176e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001770:	f107 0314 	add.w	r3, r7, #20
 8001774:	2200      	movs	r2, #0
 8001776:	601a      	str	r2, [r3, #0]
 8001778:	605a      	str	r2, [r3, #4]
 800177a:	609a      	str	r2, [r3, #8]
 800177c:	60da      	str	r2, [r3, #12]
 800177e:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 8001780:	687b      	ldr	r3, [r7, #4]
 8001782:	681b      	ldr	r3, [r3, #0]
 8001784:	4a19      	ldr	r2, [pc, #100]	; (80017ec <HAL_SPI_MspInit+0x84>)
 8001786:	4293      	cmp	r3, r2
 8001788:	d12b      	bne.n	80017e2 <HAL_SPI_MspInit+0x7a>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 800178a:	2300      	movs	r3, #0
 800178c:	613b      	str	r3, [r7, #16]
 800178e:	4b18      	ldr	r3, [pc, #96]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 8001790:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001792:	4a17      	ldr	r2, [pc, #92]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 8001794:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001798:	6453      	str	r3, [r2, #68]	; 0x44
 800179a:	4b15      	ldr	r3, [pc, #84]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 800179c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800179e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80017a2:	613b      	str	r3, [r7, #16]
 80017a4:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80017a6:	2300      	movs	r3, #0
 80017a8:	60fb      	str	r3, [r7, #12]
 80017aa:	4b11      	ldr	r3, [pc, #68]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 80017ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80017ae:	4a10      	ldr	r2, [pc, #64]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 80017b0:	f043 0301 	orr.w	r3, r3, #1
 80017b4:	6313      	str	r3, [r2, #48]	; 0x30
 80017b6:	4b0e      	ldr	r3, [pc, #56]	; (80017f0 <HAL_SPI_MspInit+0x88>)
 80017b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80017ba:	f003 0301 	and.w	r3, r3, #1
 80017be:	60fb      	str	r3, [r7, #12]
 80017c0:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 80017c2:	23e0      	movs	r3, #224	; 0xe0
 80017c4:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80017c6:	2302      	movs	r3, #2
 80017c8:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80017ca:	2300      	movs	r3, #0
 80017cc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80017ce:	2303      	movs	r3, #3
 80017d0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80017d2:	2305      	movs	r3, #5
 80017d4:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80017d6:	f107 0314 	add.w	r3, r7, #20
 80017da:	4619      	mov	r1, r3
 80017dc:	4805      	ldr	r0, [pc, #20]	; (80017f4 <HAL_SPI_MspInit+0x8c>)
 80017de:	f000 faf3 	bl	8001dc8 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
}
 80017e2:	bf00      	nop
 80017e4:	3728      	adds	r7, #40	; 0x28
 80017e6:	46bd      	mov	sp, r7
 80017e8:	bd80      	pop	{r7, pc}
 80017ea:	bf00      	nop
 80017ec:	40013000 	.word	0x40013000
 80017f0:	40023800 	.word	0x40023800
 80017f4:	40020000 	.word	0x40020000

080017f8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80017f8:	b580      	push	{r7, lr}
 80017fa:	b082      	sub	sp, #8
 80017fc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80017fe:	2300      	movs	r3, #0
 8001800:	607b      	str	r3, [r7, #4]
 8001802:	4b10      	ldr	r3, [pc, #64]	; (8001844 <HAL_MspInit+0x4c>)
 8001804:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001806:	4a0f      	ldr	r2, [pc, #60]	; (8001844 <HAL_MspInit+0x4c>)
 8001808:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800180c:	6453      	str	r3, [r2, #68]	; 0x44
 800180e:	4b0d      	ldr	r3, [pc, #52]	; (8001844 <HAL_MspInit+0x4c>)
 8001810:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001812:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001816:	607b      	str	r3, [r7, #4]
 8001818:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800181a:	2300      	movs	r3, #0
 800181c:	603b      	str	r3, [r7, #0]
 800181e:	4b09      	ldr	r3, [pc, #36]	; (8001844 <HAL_MspInit+0x4c>)
 8001820:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001822:	4a08      	ldr	r2, [pc, #32]	; (8001844 <HAL_MspInit+0x4c>)
 8001824:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001828:	6413      	str	r3, [r2, #64]	; 0x40
 800182a:	4b06      	ldr	r3, [pc, #24]	; (8001844 <HAL_MspInit+0x4c>)
 800182c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800182e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001832:	603b      	str	r3, [r7, #0]
 8001834:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8001836:	2007      	movs	r0, #7
 8001838:	f000 fa84 	bl	8001d44 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800183c:	bf00      	nop
 800183e:	3708      	adds	r7, #8
 8001840:	46bd      	mov	sp, r7
 8001842:	bd80      	pop	{r7, pc}
 8001844:	40023800 	.word	0x40023800

08001848 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001848:	b480      	push	{r7}
 800184a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800184c:	e7fe      	b.n	800184c <NMI_Handler+0x4>

0800184e <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800184e:	b480      	push	{r7}
 8001850:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001852:	e7fe      	b.n	8001852 <HardFault_Handler+0x4>

08001854 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001854:	b480      	push	{r7}
 8001856:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001858:	e7fe      	b.n	8001858 <MemManage_Handler+0x4>

0800185a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800185a:	b480      	push	{r7}
 800185c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800185e:	e7fe      	b.n	800185e <BusFault_Handler+0x4>

08001860 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001860:	b480      	push	{r7}
 8001862:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001864:	e7fe      	b.n	8001864 <UsageFault_Handler+0x4>

08001866 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8001866:	b480      	push	{r7}
 8001868:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800186a:	bf00      	nop
 800186c:	46bd      	mov	sp, r7
 800186e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001872:	4770      	bx	lr

08001874 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001874:	b480      	push	{r7}
 8001876:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001878:	bf00      	nop
 800187a:	46bd      	mov	sp, r7
 800187c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001880:	4770      	bx	lr

08001882 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001882:	b480      	push	{r7}
 8001884:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8001886:	bf00      	nop
 8001888:	46bd      	mov	sp, r7
 800188a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800188e:	4770      	bx	lr

08001890 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001890:	b580      	push	{r7, lr}
 8001892:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001894:	f000 f942 	bl	8001b1c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001898:	bf00      	nop
 800189a:	bd80      	pop	{r7, pc}

0800189c <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 800189c:	b580      	push	{r7, lr}
 800189e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 80018a0:	4802      	ldr	r0, [pc, #8]	; (80018ac <OTG_FS_IRQHandler+0x10>)
 80018a2:	f000 fe99 	bl	80025d8 <HAL_HCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 80018a6:	bf00      	nop
 80018a8:	bd80      	pop	{r7, pc}
 80018aa:	bf00      	nop
 80018ac:	200011a8 	.word	0x200011a8

080018b0 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80018b0:	b580      	push	{r7, lr}
 80018b2:	b086      	sub	sp, #24
 80018b4:	af00      	add	r7, sp, #0
 80018b6:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80018b8:	4a14      	ldr	r2, [pc, #80]	; (800190c <_sbrk+0x5c>)
 80018ba:	4b15      	ldr	r3, [pc, #84]	; (8001910 <_sbrk+0x60>)
 80018bc:	1ad3      	subs	r3, r2, r3
 80018be:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80018c0:	697b      	ldr	r3, [r7, #20]
 80018c2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80018c4:	4b13      	ldr	r3, [pc, #76]	; (8001914 <_sbrk+0x64>)
 80018c6:	681b      	ldr	r3, [r3, #0]
 80018c8:	2b00      	cmp	r3, #0
 80018ca:	d102      	bne.n	80018d2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 80018cc:	4b11      	ldr	r3, [pc, #68]	; (8001914 <_sbrk+0x64>)
 80018ce:	4a12      	ldr	r2, [pc, #72]	; (8001918 <_sbrk+0x68>)
 80018d0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80018d2:	4b10      	ldr	r3, [pc, #64]	; (8001914 <_sbrk+0x64>)
 80018d4:	681a      	ldr	r2, [r3, #0]
 80018d6:	687b      	ldr	r3, [r7, #4]
 80018d8:	4413      	add	r3, r2
 80018da:	693a      	ldr	r2, [r7, #16]
 80018dc:	429a      	cmp	r2, r3
 80018de:	d207      	bcs.n	80018f0 <_sbrk+0x40>
  {
    errno = ENOMEM;
 80018e0:	f026 fc86 	bl	80281f0 <__errno>
 80018e4:	4603      	mov	r3, r0
 80018e6:	220c      	movs	r2, #12
 80018e8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80018ea:	f04f 33ff 	mov.w	r3, #4294967295
 80018ee:	e009      	b.n	8001904 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80018f0:	4b08      	ldr	r3, [pc, #32]	; (8001914 <_sbrk+0x64>)
 80018f2:	681b      	ldr	r3, [r3, #0]
 80018f4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80018f6:	4b07      	ldr	r3, [pc, #28]	; (8001914 <_sbrk+0x64>)
 80018f8:	681a      	ldr	r2, [r3, #0]
 80018fa:	687b      	ldr	r3, [r7, #4]
 80018fc:	4413      	add	r3, r2
 80018fe:	4a05      	ldr	r2, [pc, #20]	; (8001914 <_sbrk+0x64>)
 8001900:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8001902:	68fb      	ldr	r3, [r7, #12]
}
 8001904:	4618      	mov	r0, r3
 8001906:	3718      	adds	r7, #24
 8001908:	46bd      	mov	sp, r7
 800190a:	bd80      	pop	{r7, pc}
 800190c:	20020000 	.word	0x20020000
 8001910:	00001000 	.word	0x00001000
 8001914:	200000ac 	.word	0x200000ac
 8001918:	200014c0 	.word	0x200014c0

0800191c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800191c:	b480      	push	{r7}
 800191e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001920:	4b06      	ldr	r3, [pc, #24]	; (800193c <SystemInit+0x20>)
 8001922:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8001926:	4a05      	ldr	r2, [pc, #20]	; (800193c <SystemInit+0x20>)
 8001928:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800192c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001930:	bf00      	nop
 8001932:	46bd      	mov	sp, r7
 8001934:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001938:	4770      	bx	lr
 800193a:	bf00      	nop
 800193c:	e000ed00 	.word	0xe000ed00

08001940 <MX_USART2_UART_Init>:
UART_HandleTypeDef huart2;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8001940:	b580      	push	{r7, lr}
 8001942:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 8001944:	4b11      	ldr	r3, [pc, #68]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001946:	4a12      	ldr	r2, [pc, #72]	; (8001990 <MX_USART2_UART_Init+0x50>)
 8001948:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 800194a:	4b10      	ldr	r3, [pc, #64]	; (800198c <MX_USART2_UART_Init+0x4c>)
 800194c:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8001950:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001952:	4b0e      	ldr	r3, [pc, #56]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001954:	2200      	movs	r2, #0
 8001956:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001958:	4b0c      	ldr	r3, [pc, #48]	; (800198c <MX_USART2_UART_Init+0x4c>)
 800195a:	2200      	movs	r2, #0
 800195c:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800195e:	4b0b      	ldr	r3, [pc, #44]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001960:	2200      	movs	r2, #0
 8001962:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001964:	4b09      	ldr	r3, [pc, #36]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001966:	220c      	movs	r2, #12
 8001968:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800196a:	4b08      	ldr	r3, [pc, #32]	; (800198c <MX_USART2_UART_Init+0x4c>)
 800196c:	2200      	movs	r2, #0
 800196e:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001970:	4b06      	ldr	r3, [pc, #24]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001972:	2200      	movs	r2, #0
 8001974:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001976:	4805      	ldr	r0, [pc, #20]	; (800198c <MX_USART2_UART_Init+0x4c>)
 8001978:	f002 fe31 	bl	80045de <HAL_UART_Init>
 800197c:	4603      	mov	r3, r0
 800197e:	2b00      	cmp	r3, #0
 8001980:	d001      	beq.n	8001986 <MX_USART2_UART_Init+0x46>
  {
    Error_Handler();
 8001982:	f7ff feb5 	bl	80016f0 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8001986:	bf00      	nop
 8001988:	bd80      	pop	{r7, pc}
 800198a:	bf00      	nop
 800198c:	2000091c 	.word	0x2000091c
 8001990:	40004400 	.word	0x40004400

08001994 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001994:	b580      	push	{r7, lr}
 8001996:	b08a      	sub	sp, #40	; 0x28
 8001998:	af00      	add	r7, sp, #0
 800199a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800199c:	f107 0314 	add.w	r3, r7, #20
 80019a0:	2200      	movs	r2, #0
 80019a2:	601a      	str	r2, [r3, #0]
 80019a4:	605a      	str	r2, [r3, #4]
 80019a6:	609a      	str	r2, [r3, #8]
 80019a8:	60da      	str	r2, [r3, #12]
 80019aa:	611a      	str	r2, [r3, #16]
  if(uartHandle->Instance==USART2)
 80019ac:	687b      	ldr	r3, [r7, #4]
 80019ae:	681b      	ldr	r3, [r3, #0]
 80019b0:	4a19      	ldr	r2, [pc, #100]	; (8001a18 <HAL_UART_MspInit+0x84>)
 80019b2:	4293      	cmp	r3, r2
 80019b4:	d12b      	bne.n	8001a0e <HAL_UART_MspInit+0x7a>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* USART2 clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 80019b6:	2300      	movs	r3, #0
 80019b8:	613b      	str	r3, [r7, #16]
 80019ba:	4b18      	ldr	r3, [pc, #96]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80019be:	4a17      	ldr	r2, [pc, #92]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80019c4:	6413      	str	r3, [r2, #64]	; 0x40
 80019c6:	4b15      	ldr	r3, [pc, #84]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80019ca:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80019ce:	613b      	str	r3, [r7, #16]
 80019d0:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80019d2:	2300      	movs	r3, #0
 80019d4:	60fb      	str	r3, [r7, #12]
 80019d6:	4b11      	ldr	r3, [pc, #68]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80019da:	4a10      	ldr	r2, [pc, #64]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019dc:	f043 0301 	orr.w	r3, r3, #1
 80019e0:	6313      	str	r3, [r2, #48]	; 0x30
 80019e2:	4b0e      	ldr	r3, [pc, #56]	; (8001a1c <HAL_UART_MspInit+0x88>)
 80019e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80019e6:	f003 0301 	and.w	r3, r3, #1
 80019ea:	60fb      	str	r3, [r7, #12]
 80019ec:	68fb      	ldr	r3, [r7, #12]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 80019ee:	230c      	movs	r3, #12
 80019f0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80019f2:	2302      	movs	r3, #2
 80019f4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80019f6:	2300      	movs	r3, #0
 80019f8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80019fa:	2303      	movs	r3, #3
 80019fc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80019fe:	2307      	movs	r3, #7
 8001a00:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001a02:	f107 0314 	add.w	r3, r7, #20
 8001a06:	4619      	mov	r1, r3
 8001a08:	4805      	ldr	r0, [pc, #20]	; (8001a20 <HAL_UART_MspInit+0x8c>)
 8001a0a:	f000 f9dd 	bl	8001dc8 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 8001a0e:	bf00      	nop
 8001a10:	3728      	adds	r7, #40	; 0x28
 8001a12:	46bd      	mov	sp, r7
 8001a14:	bd80      	pop	{r7, pc}
 8001a16:	bf00      	nop
 8001a18:	40004400 	.word	0x40004400
 8001a1c:	40023800 	.word	0x40023800
 8001a20:	40020000 	.word	0x40020000

08001a24 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001a24:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001a5c <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001a28:	480d      	ldr	r0, [pc, #52]	; (8001a60 <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 8001a2a:	490e      	ldr	r1, [pc, #56]	; (8001a64 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 8001a2c:	4a0e      	ldr	r2, [pc, #56]	; (8001a68 <LoopFillZerobss+0x1e>)
  movs r3, #0
 8001a2e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001a30:	e002      	b.n	8001a38 <LoopCopyDataInit>

08001a32 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001a32:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001a34:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001a36:	3304      	adds	r3, #4

08001a38 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001a38:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001a3a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001a3c:	d3f9      	bcc.n	8001a32 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001a3e:	4a0b      	ldr	r2, [pc, #44]	; (8001a6c <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 8001a40:	4c0b      	ldr	r4, [pc, #44]	; (8001a70 <LoopFillZerobss+0x26>)
  movs r3, #0
 8001a42:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001a44:	e001      	b.n	8001a4a <LoopFillZerobss>

08001a46 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001a46:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001a48:	3204      	adds	r2, #4

08001a4a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001a4a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001a4c:	d3fb      	bcc.n	8001a46 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8001a4e:	f7ff ff65 	bl	800191c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001a52:	f026 fbd3 	bl	80281fc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001a56:	f7ff fd23 	bl	80014a0 <main>
  bx  lr    
 8001a5a:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001a5c:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001a60:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001a64:	20000090 	.word	0x20000090
  ldr r2, =_sidata
 8001a68:	0802b198 	.word	0x0802b198
  ldr r2, =_sbss
 8001a6c:	20000090 	.word	0x20000090
  ldr r4, =_ebss
 8001a70:	200014bc 	.word	0x200014bc

08001a74 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001a74:	e7fe      	b.n	8001a74 <ADC_IRQHandler>
	...

08001a78 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001a78:	b580      	push	{r7, lr}
 8001a7a:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001a7c:	4b0e      	ldr	r3, [pc, #56]	; (8001ab8 <HAL_Init+0x40>)
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	4a0d      	ldr	r2, [pc, #52]	; (8001ab8 <HAL_Init+0x40>)
 8001a82:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001a86:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001a88:	4b0b      	ldr	r3, [pc, #44]	; (8001ab8 <HAL_Init+0x40>)
 8001a8a:	681b      	ldr	r3, [r3, #0]
 8001a8c:	4a0a      	ldr	r2, [pc, #40]	; (8001ab8 <HAL_Init+0x40>)
 8001a8e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001a92:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001a94:	4b08      	ldr	r3, [pc, #32]	; (8001ab8 <HAL_Init+0x40>)
 8001a96:	681b      	ldr	r3, [r3, #0]
 8001a98:	4a07      	ldr	r2, [pc, #28]	; (8001ab8 <HAL_Init+0x40>)
 8001a9a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001a9e:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001aa0:	2003      	movs	r0, #3
 8001aa2:	f000 f94f 	bl	8001d44 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001aa6:	2000      	movs	r0, #0
 8001aa8:	f000 f808 	bl	8001abc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001aac:	f7ff fea4 	bl	80017f8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001ab0:	2300      	movs	r3, #0
}
 8001ab2:	4618      	mov	r0, r3
 8001ab4:	bd80      	pop	{r7, pc}
 8001ab6:	bf00      	nop
 8001ab8:	40023c00 	.word	0x40023c00

08001abc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001abc:	b580      	push	{r7, lr}
 8001abe:	b082      	sub	sp, #8
 8001ac0:	af00      	add	r7, sp, #0
 8001ac2:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001ac4:	4b12      	ldr	r3, [pc, #72]	; (8001b10 <HAL_InitTick+0x54>)
 8001ac6:	681a      	ldr	r2, [r3, #0]
 8001ac8:	4b12      	ldr	r3, [pc, #72]	; (8001b14 <HAL_InitTick+0x58>)
 8001aca:	781b      	ldrb	r3, [r3, #0]
 8001acc:	4619      	mov	r1, r3
 8001ace:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001ad2:	fbb3 f3f1 	udiv	r3, r3, r1
 8001ad6:	fbb2 f3f3 	udiv	r3, r2, r3
 8001ada:	4618      	mov	r0, r3
 8001adc:	f000 f967 	bl	8001dae <HAL_SYSTICK_Config>
 8001ae0:	4603      	mov	r3, r0
 8001ae2:	2b00      	cmp	r3, #0
 8001ae4:	d001      	beq.n	8001aea <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001ae6:	2301      	movs	r3, #1
 8001ae8:	e00e      	b.n	8001b08 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001aea:	687b      	ldr	r3, [r7, #4]
 8001aec:	2b0f      	cmp	r3, #15
 8001aee:	d80a      	bhi.n	8001b06 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001af0:	2200      	movs	r2, #0
 8001af2:	6879      	ldr	r1, [r7, #4]
 8001af4:	f04f 30ff 	mov.w	r0, #4294967295
 8001af8:	f000 f92f 	bl	8001d5a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001afc:	4a06      	ldr	r2, [pc, #24]	; (8001b18 <HAL_InitTick+0x5c>)
 8001afe:	687b      	ldr	r3, [r7, #4]
 8001b00:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001b02:	2300      	movs	r3, #0
 8001b04:	e000      	b.n	8001b08 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001b06:	2301      	movs	r3, #1
}
 8001b08:	4618      	mov	r0, r3
 8001b0a:	3708      	adds	r7, #8
 8001b0c:	46bd      	mov	sp, r7
 8001b0e:	bd80      	pop	{r7, pc}
 8001b10:	20000000 	.word	0x20000000
 8001b14:	20000008 	.word	0x20000008
 8001b18:	20000004 	.word	0x20000004

08001b1c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001b1c:	b480      	push	{r7}
 8001b1e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001b20:	4b06      	ldr	r3, [pc, #24]	; (8001b3c <HAL_IncTick+0x20>)
 8001b22:	781b      	ldrb	r3, [r3, #0]
 8001b24:	461a      	mov	r2, r3
 8001b26:	4b06      	ldr	r3, [pc, #24]	; (8001b40 <HAL_IncTick+0x24>)
 8001b28:	681b      	ldr	r3, [r3, #0]
 8001b2a:	4413      	add	r3, r2
 8001b2c:	4a04      	ldr	r2, [pc, #16]	; (8001b40 <HAL_IncTick+0x24>)
 8001b2e:	6013      	str	r3, [r2, #0]
}
 8001b30:	bf00      	nop
 8001b32:	46bd      	mov	sp, r7
 8001b34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b38:	4770      	bx	lr
 8001b3a:	bf00      	nop
 8001b3c:	20000008 	.word	0x20000008
 8001b40:	20000960 	.word	0x20000960

08001b44 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001b44:	b480      	push	{r7}
 8001b46:	af00      	add	r7, sp, #0
  return uwTick;
 8001b48:	4b03      	ldr	r3, [pc, #12]	; (8001b58 <HAL_GetTick+0x14>)
 8001b4a:	681b      	ldr	r3, [r3, #0]
}
 8001b4c:	4618      	mov	r0, r3
 8001b4e:	46bd      	mov	sp, r7
 8001b50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b54:	4770      	bx	lr
 8001b56:	bf00      	nop
 8001b58:	20000960 	.word	0x20000960

08001b5c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001b5c:	b580      	push	{r7, lr}
 8001b5e:	b084      	sub	sp, #16
 8001b60:	af00      	add	r7, sp, #0
 8001b62:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001b64:	f7ff ffee 	bl	8001b44 <HAL_GetTick>
 8001b68:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8001b6a:	687b      	ldr	r3, [r7, #4]
 8001b6c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001b6e:	68fb      	ldr	r3, [r7, #12]
 8001b70:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001b74:	d005      	beq.n	8001b82 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8001b76:	4b0a      	ldr	r3, [pc, #40]	; (8001ba0 <HAL_Delay+0x44>)
 8001b78:	781b      	ldrb	r3, [r3, #0]
 8001b7a:	461a      	mov	r2, r3
 8001b7c:	68fb      	ldr	r3, [r7, #12]
 8001b7e:	4413      	add	r3, r2
 8001b80:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8001b82:	bf00      	nop
 8001b84:	f7ff ffde 	bl	8001b44 <HAL_GetTick>
 8001b88:	4602      	mov	r2, r0
 8001b8a:	68bb      	ldr	r3, [r7, #8]
 8001b8c:	1ad3      	subs	r3, r2, r3
 8001b8e:	68fa      	ldr	r2, [r7, #12]
 8001b90:	429a      	cmp	r2, r3
 8001b92:	d8f7      	bhi.n	8001b84 <HAL_Delay+0x28>
  {
  }
}
 8001b94:	bf00      	nop
 8001b96:	bf00      	nop
 8001b98:	3710      	adds	r7, #16
 8001b9a:	46bd      	mov	sp, r7
 8001b9c:	bd80      	pop	{r7, pc}
 8001b9e:	bf00      	nop
 8001ba0:	20000008 	.word	0x20000008

08001ba4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001ba4:	b480      	push	{r7}
 8001ba6:	b085      	sub	sp, #20
 8001ba8:	af00      	add	r7, sp, #0
 8001baa:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001bac:	687b      	ldr	r3, [r7, #4]
 8001bae:	f003 0307 	and.w	r3, r3, #7
 8001bb2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001bb4:	4b0c      	ldr	r3, [pc, #48]	; (8001be8 <__NVIC_SetPriorityGrouping+0x44>)
 8001bb6:	68db      	ldr	r3, [r3, #12]
 8001bb8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001bba:	68ba      	ldr	r2, [r7, #8]
 8001bbc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8001bc0:	4013      	ands	r3, r2
 8001bc2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001bc4:	68fb      	ldr	r3, [r7, #12]
 8001bc6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001bc8:	68bb      	ldr	r3, [r7, #8]
 8001bca:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001bcc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001bd0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001bd4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001bd6:	4a04      	ldr	r2, [pc, #16]	; (8001be8 <__NVIC_SetPriorityGrouping+0x44>)
 8001bd8:	68bb      	ldr	r3, [r7, #8]
 8001bda:	60d3      	str	r3, [r2, #12]
}
 8001bdc:	bf00      	nop
 8001bde:	3714      	adds	r7, #20
 8001be0:	46bd      	mov	sp, r7
 8001be2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001be6:	4770      	bx	lr
 8001be8:	e000ed00 	.word	0xe000ed00

08001bec <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001bec:	b480      	push	{r7}
 8001bee:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001bf0:	4b04      	ldr	r3, [pc, #16]	; (8001c04 <__NVIC_GetPriorityGrouping+0x18>)
 8001bf2:	68db      	ldr	r3, [r3, #12]
 8001bf4:	0a1b      	lsrs	r3, r3, #8
 8001bf6:	f003 0307 	and.w	r3, r3, #7
}
 8001bfa:	4618      	mov	r0, r3
 8001bfc:	46bd      	mov	sp, r7
 8001bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c02:	4770      	bx	lr
 8001c04:	e000ed00 	.word	0xe000ed00

08001c08 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001c08:	b480      	push	{r7}
 8001c0a:	b083      	sub	sp, #12
 8001c0c:	af00      	add	r7, sp, #0
 8001c0e:	4603      	mov	r3, r0
 8001c10:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001c12:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c16:	2b00      	cmp	r3, #0
 8001c18:	db0b      	blt.n	8001c32 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001c1a:	79fb      	ldrb	r3, [r7, #7]
 8001c1c:	f003 021f 	and.w	r2, r3, #31
 8001c20:	4907      	ldr	r1, [pc, #28]	; (8001c40 <__NVIC_EnableIRQ+0x38>)
 8001c22:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c26:	095b      	lsrs	r3, r3, #5
 8001c28:	2001      	movs	r0, #1
 8001c2a:	fa00 f202 	lsl.w	r2, r0, r2
 8001c2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8001c32:	bf00      	nop
 8001c34:	370c      	adds	r7, #12
 8001c36:	46bd      	mov	sp, r7
 8001c38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c3c:	4770      	bx	lr
 8001c3e:	bf00      	nop
 8001c40:	e000e100 	.word	0xe000e100

08001c44 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001c44:	b480      	push	{r7}
 8001c46:	b083      	sub	sp, #12
 8001c48:	af00      	add	r7, sp, #0
 8001c4a:	4603      	mov	r3, r0
 8001c4c:	6039      	str	r1, [r7, #0]
 8001c4e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001c50:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c54:	2b00      	cmp	r3, #0
 8001c56:	db0a      	blt.n	8001c6e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001c58:	683b      	ldr	r3, [r7, #0]
 8001c5a:	b2da      	uxtb	r2, r3
 8001c5c:	490c      	ldr	r1, [pc, #48]	; (8001c90 <__NVIC_SetPriority+0x4c>)
 8001c5e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001c62:	0112      	lsls	r2, r2, #4
 8001c64:	b2d2      	uxtb	r2, r2
 8001c66:	440b      	add	r3, r1
 8001c68:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001c6c:	e00a      	b.n	8001c84 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001c6e:	683b      	ldr	r3, [r7, #0]
 8001c70:	b2da      	uxtb	r2, r3
 8001c72:	4908      	ldr	r1, [pc, #32]	; (8001c94 <__NVIC_SetPriority+0x50>)
 8001c74:	79fb      	ldrb	r3, [r7, #7]
 8001c76:	f003 030f 	and.w	r3, r3, #15
 8001c7a:	3b04      	subs	r3, #4
 8001c7c:	0112      	lsls	r2, r2, #4
 8001c7e:	b2d2      	uxtb	r2, r2
 8001c80:	440b      	add	r3, r1
 8001c82:	761a      	strb	r2, [r3, #24]
}
 8001c84:	bf00      	nop
 8001c86:	370c      	adds	r7, #12
 8001c88:	46bd      	mov	sp, r7
 8001c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c8e:	4770      	bx	lr
 8001c90:	e000e100 	.word	0xe000e100
 8001c94:	e000ed00 	.word	0xe000ed00

08001c98 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001c98:	b480      	push	{r7}
 8001c9a:	b089      	sub	sp, #36	; 0x24
 8001c9c:	af00      	add	r7, sp, #0
 8001c9e:	60f8      	str	r0, [r7, #12]
 8001ca0:	60b9      	str	r1, [r7, #8]
 8001ca2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001ca4:	68fb      	ldr	r3, [r7, #12]
 8001ca6:	f003 0307 	and.w	r3, r3, #7
 8001caa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001cac:	69fb      	ldr	r3, [r7, #28]
 8001cae:	f1c3 0307 	rsb	r3, r3, #7
 8001cb2:	2b04      	cmp	r3, #4
 8001cb4:	bf28      	it	cs
 8001cb6:	2304      	movcs	r3, #4
 8001cb8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001cba:	69fb      	ldr	r3, [r7, #28]
 8001cbc:	3304      	adds	r3, #4
 8001cbe:	2b06      	cmp	r3, #6
 8001cc0:	d902      	bls.n	8001cc8 <NVIC_EncodePriority+0x30>
 8001cc2:	69fb      	ldr	r3, [r7, #28]
 8001cc4:	3b03      	subs	r3, #3
 8001cc6:	e000      	b.n	8001cca <NVIC_EncodePriority+0x32>
 8001cc8:	2300      	movs	r3, #0
 8001cca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001ccc:	f04f 32ff 	mov.w	r2, #4294967295
 8001cd0:	69bb      	ldr	r3, [r7, #24]
 8001cd2:	fa02 f303 	lsl.w	r3, r2, r3
 8001cd6:	43da      	mvns	r2, r3
 8001cd8:	68bb      	ldr	r3, [r7, #8]
 8001cda:	401a      	ands	r2, r3
 8001cdc:	697b      	ldr	r3, [r7, #20]
 8001cde:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001ce0:	f04f 31ff 	mov.w	r1, #4294967295
 8001ce4:	697b      	ldr	r3, [r7, #20]
 8001ce6:	fa01 f303 	lsl.w	r3, r1, r3
 8001cea:	43d9      	mvns	r1, r3
 8001cec:	687b      	ldr	r3, [r7, #4]
 8001cee:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001cf0:	4313      	orrs	r3, r2
         );
}
 8001cf2:	4618      	mov	r0, r3
 8001cf4:	3724      	adds	r7, #36	; 0x24
 8001cf6:	46bd      	mov	sp, r7
 8001cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cfc:	4770      	bx	lr
	...

08001d00 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001d00:	b580      	push	{r7, lr}
 8001d02:	b082      	sub	sp, #8
 8001d04:	af00      	add	r7, sp, #0
 8001d06:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001d08:	687b      	ldr	r3, [r7, #4]
 8001d0a:	3b01      	subs	r3, #1
 8001d0c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8001d10:	d301      	bcc.n	8001d16 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001d12:	2301      	movs	r3, #1
 8001d14:	e00f      	b.n	8001d36 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001d16:	4a0a      	ldr	r2, [pc, #40]	; (8001d40 <SysTick_Config+0x40>)
 8001d18:	687b      	ldr	r3, [r7, #4]
 8001d1a:	3b01      	subs	r3, #1
 8001d1c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001d1e:	210f      	movs	r1, #15
 8001d20:	f04f 30ff 	mov.w	r0, #4294967295
 8001d24:	f7ff ff8e 	bl	8001c44 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001d28:	4b05      	ldr	r3, [pc, #20]	; (8001d40 <SysTick_Config+0x40>)
 8001d2a:	2200      	movs	r2, #0
 8001d2c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001d2e:	4b04      	ldr	r3, [pc, #16]	; (8001d40 <SysTick_Config+0x40>)
 8001d30:	2207      	movs	r2, #7
 8001d32:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001d34:	2300      	movs	r3, #0
}
 8001d36:	4618      	mov	r0, r3
 8001d38:	3708      	adds	r7, #8
 8001d3a:	46bd      	mov	sp, r7
 8001d3c:	bd80      	pop	{r7, pc}
 8001d3e:	bf00      	nop
 8001d40:	e000e010 	.word	0xe000e010

08001d44 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001d44:	b580      	push	{r7, lr}
 8001d46:	b082      	sub	sp, #8
 8001d48:	af00      	add	r7, sp, #0
 8001d4a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8001d4c:	6878      	ldr	r0, [r7, #4]
 8001d4e:	f7ff ff29 	bl	8001ba4 <__NVIC_SetPriorityGrouping>
}
 8001d52:	bf00      	nop
 8001d54:	3708      	adds	r7, #8
 8001d56:	46bd      	mov	sp, r7
 8001d58:	bd80      	pop	{r7, pc}

08001d5a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001d5a:	b580      	push	{r7, lr}
 8001d5c:	b086      	sub	sp, #24
 8001d5e:	af00      	add	r7, sp, #0
 8001d60:	4603      	mov	r3, r0
 8001d62:	60b9      	str	r1, [r7, #8]
 8001d64:	607a      	str	r2, [r7, #4]
 8001d66:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001d68:	2300      	movs	r3, #0
 8001d6a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8001d6c:	f7ff ff3e 	bl	8001bec <__NVIC_GetPriorityGrouping>
 8001d70:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8001d72:	687a      	ldr	r2, [r7, #4]
 8001d74:	68b9      	ldr	r1, [r7, #8]
 8001d76:	6978      	ldr	r0, [r7, #20]
 8001d78:	f7ff ff8e 	bl	8001c98 <NVIC_EncodePriority>
 8001d7c:	4602      	mov	r2, r0
 8001d7e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001d82:	4611      	mov	r1, r2
 8001d84:	4618      	mov	r0, r3
 8001d86:	f7ff ff5d 	bl	8001c44 <__NVIC_SetPriority>
}
 8001d8a:	bf00      	nop
 8001d8c:	3718      	adds	r7, #24
 8001d8e:	46bd      	mov	sp, r7
 8001d90:	bd80      	pop	{r7, pc}

08001d92 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001d92:	b580      	push	{r7, lr}
 8001d94:	b082      	sub	sp, #8
 8001d96:	af00      	add	r7, sp, #0
 8001d98:	4603      	mov	r3, r0
 8001d9a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001d9c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001da0:	4618      	mov	r0, r3
 8001da2:	f7ff ff31 	bl	8001c08 <__NVIC_EnableIRQ>
}
 8001da6:	bf00      	nop
 8001da8:	3708      	adds	r7, #8
 8001daa:	46bd      	mov	sp, r7
 8001dac:	bd80      	pop	{r7, pc}

08001dae <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8001dae:	b580      	push	{r7, lr}
 8001db0:	b082      	sub	sp, #8
 8001db2:	af00      	add	r7, sp, #0
 8001db4:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8001db6:	6878      	ldr	r0, [r7, #4]
 8001db8:	f7ff ffa2 	bl	8001d00 <SysTick_Config>
 8001dbc:	4603      	mov	r3, r0
}
 8001dbe:	4618      	mov	r0, r3
 8001dc0:	3708      	adds	r7, #8
 8001dc2:	46bd      	mov	sp, r7
 8001dc4:	bd80      	pop	{r7, pc}
	...

08001dc8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001dc8:	b480      	push	{r7}
 8001dca:	b089      	sub	sp, #36	; 0x24
 8001dcc:	af00      	add	r7, sp, #0
 8001dce:	6078      	str	r0, [r7, #4]
 8001dd0:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8001dd2:	2300      	movs	r3, #0
 8001dd4:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8001dd6:	2300      	movs	r3, #0
 8001dd8:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8001dda:	2300      	movs	r3, #0
 8001ddc:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001dde:	2300      	movs	r3, #0
 8001de0:	61fb      	str	r3, [r7, #28]
 8001de2:	e159      	b.n	8002098 <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8001de4:	2201      	movs	r2, #1
 8001de6:	69fb      	ldr	r3, [r7, #28]
 8001de8:	fa02 f303 	lsl.w	r3, r2, r3
 8001dec:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001dee:	683b      	ldr	r3, [r7, #0]
 8001df0:	681b      	ldr	r3, [r3, #0]
 8001df2:	697a      	ldr	r2, [r7, #20]
 8001df4:	4013      	ands	r3, r2
 8001df6:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8001df8:	693a      	ldr	r2, [r7, #16]
 8001dfa:	697b      	ldr	r3, [r7, #20]
 8001dfc:	429a      	cmp	r2, r3
 8001dfe:	f040 8148 	bne.w	8002092 <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8001e02:	683b      	ldr	r3, [r7, #0]
 8001e04:	685b      	ldr	r3, [r3, #4]
 8001e06:	f003 0303 	and.w	r3, r3, #3
 8001e0a:	2b01      	cmp	r3, #1
 8001e0c:	d005      	beq.n	8001e1a <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8001e0e:	683b      	ldr	r3, [r7, #0]
 8001e10:	685b      	ldr	r3, [r3, #4]
 8001e12:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8001e16:	2b02      	cmp	r3, #2
 8001e18:	d130      	bne.n	8001e7c <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001e1a:	687b      	ldr	r3, [r7, #4]
 8001e1c:	689b      	ldr	r3, [r3, #8]
 8001e1e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001e20:	69fb      	ldr	r3, [r7, #28]
 8001e22:	005b      	lsls	r3, r3, #1
 8001e24:	2203      	movs	r2, #3
 8001e26:	fa02 f303 	lsl.w	r3, r2, r3
 8001e2a:	43db      	mvns	r3, r3
 8001e2c:	69ba      	ldr	r2, [r7, #24]
 8001e2e:	4013      	ands	r3, r2
 8001e30:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001e32:	683b      	ldr	r3, [r7, #0]
 8001e34:	68da      	ldr	r2, [r3, #12]
 8001e36:	69fb      	ldr	r3, [r7, #28]
 8001e38:	005b      	lsls	r3, r3, #1
 8001e3a:	fa02 f303 	lsl.w	r3, r2, r3
 8001e3e:	69ba      	ldr	r2, [r7, #24]
 8001e40:	4313      	orrs	r3, r2
 8001e42:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8001e44:	687b      	ldr	r3, [r7, #4]
 8001e46:	69ba      	ldr	r2, [r7, #24]
 8001e48:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001e4a:	687b      	ldr	r3, [r7, #4]
 8001e4c:	685b      	ldr	r3, [r3, #4]
 8001e4e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001e50:	2201      	movs	r2, #1
 8001e52:	69fb      	ldr	r3, [r7, #28]
 8001e54:	fa02 f303 	lsl.w	r3, r2, r3
 8001e58:	43db      	mvns	r3, r3
 8001e5a:	69ba      	ldr	r2, [r7, #24]
 8001e5c:	4013      	ands	r3, r2
 8001e5e:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8001e60:	683b      	ldr	r3, [r7, #0]
 8001e62:	685b      	ldr	r3, [r3, #4]
 8001e64:	091b      	lsrs	r3, r3, #4
 8001e66:	f003 0201 	and.w	r2, r3, #1
 8001e6a:	69fb      	ldr	r3, [r7, #28]
 8001e6c:	fa02 f303 	lsl.w	r3, r2, r3
 8001e70:	69ba      	ldr	r2, [r7, #24]
 8001e72:	4313      	orrs	r3, r2
 8001e74:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8001e76:	687b      	ldr	r3, [r7, #4]
 8001e78:	69ba      	ldr	r2, [r7, #24]
 8001e7a:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8001e7c:	683b      	ldr	r3, [r7, #0]
 8001e7e:	685b      	ldr	r3, [r3, #4]
 8001e80:	f003 0303 	and.w	r3, r3, #3
 8001e84:	2b03      	cmp	r3, #3
 8001e86:	d017      	beq.n	8001eb8 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8001e88:	687b      	ldr	r3, [r7, #4]
 8001e8a:	68db      	ldr	r3, [r3, #12]
 8001e8c:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001e8e:	69fb      	ldr	r3, [r7, #28]
 8001e90:	005b      	lsls	r3, r3, #1
 8001e92:	2203      	movs	r2, #3
 8001e94:	fa02 f303 	lsl.w	r3, r2, r3
 8001e98:	43db      	mvns	r3, r3
 8001e9a:	69ba      	ldr	r2, [r7, #24]
 8001e9c:	4013      	ands	r3, r2
 8001e9e:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001ea0:	683b      	ldr	r3, [r7, #0]
 8001ea2:	689a      	ldr	r2, [r3, #8]
 8001ea4:	69fb      	ldr	r3, [r7, #28]
 8001ea6:	005b      	lsls	r3, r3, #1
 8001ea8:	fa02 f303 	lsl.w	r3, r2, r3
 8001eac:	69ba      	ldr	r2, [r7, #24]
 8001eae:	4313      	orrs	r3, r2
 8001eb0:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 8001eb2:	687b      	ldr	r3, [r7, #4]
 8001eb4:	69ba      	ldr	r2, [r7, #24]
 8001eb6:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8001eb8:	683b      	ldr	r3, [r7, #0]
 8001eba:	685b      	ldr	r3, [r3, #4]
 8001ebc:	f003 0303 	and.w	r3, r3, #3
 8001ec0:	2b02      	cmp	r3, #2
 8001ec2:	d123      	bne.n	8001f0c <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001ec4:	69fb      	ldr	r3, [r7, #28]
 8001ec6:	08da      	lsrs	r2, r3, #3
 8001ec8:	687b      	ldr	r3, [r7, #4]
 8001eca:	3208      	adds	r2, #8
 8001ecc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001ed0:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001ed2:	69fb      	ldr	r3, [r7, #28]
 8001ed4:	f003 0307 	and.w	r3, r3, #7
 8001ed8:	009b      	lsls	r3, r3, #2
 8001eda:	220f      	movs	r2, #15
 8001edc:	fa02 f303 	lsl.w	r3, r2, r3
 8001ee0:	43db      	mvns	r3, r3
 8001ee2:	69ba      	ldr	r2, [r7, #24]
 8001ee4:	4013      	ands	r3, r2
 8001ee6:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8001ee8:	683b      	ldr	r3, [r7, #0]
 8001eea:	691a      	ldr	r2, [r3, #16]
 8001eec:	69fb      	ldr	r3, [r7, #28]
 8001eee:	f003 0307 	and.w	r3, r3, #7
 8001ef2:	009b      	lsls	r3, r3, #2
 8001ef4:	fa02 f303 	lsl.w	r3, r2, r3
 8001ef8:	69ba      	ldr	r2, [r7, #24]
 8001efa:	4313      	orrs	r3, r2
 8001efc:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8001efe:	69fb      	ldr	r3, [r7, #28]
 8001f00:	08da      	lsrs	r2, r3, #3
 8001f02:	687b      	ldr	r3, [r7, #4]
 8001f04:	3208      	adds	r2, #8
 8001f06:	69b9      	ldr	r1, [r7, #24]
 8001f08:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001f0c:	687b      	ldr	r3, [r7, #4]
 8001f0e:	681b      	ldr	r3, [r3, #0]
 8001f10:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001f12:	69fb      	ldr	r3, [r7, #28]
 8001f14:	005b      	lsls	r3, r3, #1
 8001f16:	2203      	movs	r2, #3
 8001f18:	fa02 f303 	lsl.w	r3, r2, r3
 8001f1c:	43db      	mvns	r3, r3
 8001f1e:	69ba      	ldr	r2, [r7, #24]
 8001f20:	4013      	ands	r3, r2
 8001f22:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001f24:	683b      	ldr	r3, [r7, #0]
 8001f26:	685b      	ldr	r3, [r3, #4]
 8001f28:	f003 0203 	and.w	r2, r3, #3
 8001f2c:	69fb      	ldr	r3, [r7, #28]
 8001f2e:	005b      	lsls	r3, r3, #1
 8001f30:	fa02 f303 	lsl.w	r3, r2, r3
 8001f34:	69ba      	ldr	r2, [r7, #24]
 8001f36:	4313      	orrs	r3, r2
 8001f38:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8001f3a:	687b      	ldr	r3, [r7, #4]
 8001f3c:	69ba      	ldr	r2, [r7, #24]
 8001f3e:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8001f40:	683b      	ldr	r3, [r7, #0]
 8001f42:	685b      	ldr	r3, [r3, #4]
 8001f44:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001f48:	2b00      	cmp	r3, #0
 8001f4a:	f000 80a2 	beq.w	8002092 <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001f4e:	2300      	movs	r3, #0
 8001f50:	60fb      	str	r3, [r7, #12]
 8001f52:	4b57      	ldr	r3, [pc, #348]	; (80020b0 <HAL_GPIO_Init+0x2e8>)
 8001f54:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001f56:	4a56      	ldr	r2, [pc, #344]	; (80020b0 <HAL_GPIO_Init+0x2e8>)
 8001f58:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001f5c:	6453      	str	r3, [r2, #68]	; 0x44
 8001f5e:	4b54      	ldr	r3, [pc, #336]	; (80020b0 <HAL_GPIO_Init+0x2e8>)
 8001f60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001f62:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001f66:	60fb      	str	r3, [r7, #12]
 8001f68:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8001f6a:	4a52      	ldr	r2, [pc, #328]	; (80020b4 <HAL_GPIO_Init+0x2ec>)
 8001f6c:	69fb      	ldr	r3, [r7, #28]
 8001f6e:	089b      	lsrs	r3, r3, #2
 8001f70:	3302      	adds	r3, #2
 8001f72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001f76:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8001f78:	69fb      	ldr	r3, [r7, #28]
 8001f7a:	f003 0303 	and.w	r3, r3, #3
 8001f7e:	009b      	lsls	r3, r3, #2
 8001f80:	220f      	movs	r2, #15
 8001f82:	fa02 f303 	lsl.w	r3, r2, r3
 8001f86:	43db      	mvns	r3, r3
 8001f88:	69ba      	ldr	r2, [r7, #24]
 8001f8a:	4013      	ands	r3, r2
 8001f8c:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001f8e:	687b      	ldr	r3, [r7, #4]
 8001f90:	4a49      	ldr	r2, [pc, #292]	; (80020b8 <HAL_GPIO_Init+0x2f0>)
 8001f92:	4293      	cmp	r3, r2
 8001f94:	d019      	beq.n	8001fca <HAL_GPIO_Init+0x202>
 8001f96:	687b      	ldr	r3, [r7, #4]
 8001f98:	4a48      	ldr	r2, [pc, #288]	; (80020bc <HAL_GPIO_Init+0x2f4>)
 8001f9a:	4293      	cmp	r3, r2
 8001f9c:	d013      	beq.n	8001fc6 <HAL_GPIO_Init+0x1fe>
 8001f9e:	687b      	ldr	r3, [r7, #4]
 8001fa0:	4a47      	ldr	r2, [pc, #284]	; (80020c0 <HAL_GPIO_Init+0x2f8>)
 8001fa2:	4293      	cmp	r3, r2
 8001fa4:	d00d      	beq.n	8001fc2 <HAL_GPIO_Init+0x1fa>
 8001fa6:	687b      	ldr	r3, [r7, #4]
 8001fa8:	4a46      	ldr	r2, [pc, #280]	; (80020c4 <HAL_GPIO_Init+0x2fc>)
 8001faa:	4293      	cmp	r3, r2
 8001fac:	d007      	beq.n	8001fbe <HAL_GPIO_Init+0x1f6>
 8001fae:	687b      	ldr	r3, [r7, #4]
 8001fb0:	4a45      	ldr	r2, [pc, #276]	; (80020c8 <HAL_GPIO_Init+0x300>)
 8001fb2:	4293      	cmp	r3, r2
 8001fb4:	d101      	bne.n	8001fba <HAL_GPIO_Init+0x1f2>
 8001fb6:	2304      	movs	r3, #4
 8001fb8:	e008      	b.n	8001fcc <HAL_GPIO_Init+0x204>
 8001fba:	2307      	movs	r3, #7
 8001fbc:	e006      	b.n	8001fcc <HAL_GPIO_Init+0x204>
 8001fbe:	2303      	movs	r3, #3
 8001fc0:	e004      	b.n	8001fcc <HAL_GPIO_Init+0x204>
 8001fc2:	2302      	movs	r3, #2
 8001fc4:	e002      	b.n	8001fcc <HAL_GPIO_Init+0x204>
 8001fc6:	2301      	movs	r3, #1
 8001fc8:	e000      	b.n	8001fcc <HAL_GPIO_Init+0x204>
 8001fca:	2300      	movs	r3, #0
 8001fcc:	69fa      	ldr	r2, [r7, #28]
 8001fce:	f002 0203 	and.w	r2, r2, #3
 8001fd2:	0092      	lsls	r2, r2, #2
 8001fd4:	4093      	lsls	r3, r2
 8001fd6:	69ba      	ldr	r2, [r7, #24]
 8001fd8:	4313      	orrs	r3, r2
 8001fda:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001fdc:	4935      	ldr	r1, [pc, #212]	; (80020b4 <HAL_GPIO_Init+0x2ec>)
 8001fde:	69fb      	ldr	r3, [r7, #28]
 8001fe0:	089b      	lsrs	r3, r3, #2
 8001fe2:	3302      	adds	r3, #2
 8001fe4:	69ba      	ldr	r2, [r7, #24]
 8001fe6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001fea:	4b38      	ldr	r3, [pc, #224]	; (80020cc <HAL_GPIO_Init+0x304>)
 8001fec:	681b      	ldr	r3, [r3, #0]
 8001fee:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001ff0:	693b      	ldr	r3, [r7, #16]
 8001ff2:	43db      	mvns	r3, r3
 8001ff4:	69ba      	ldr	r2, [r7, #24]
 8001ff6:	4013      	ands	r3, r2
 8001ff8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8001ffa:	683b      	ldr	r3, [r7, #0]
 8001ffc:	685b      	ldr	r3, [r3, #4]
 8001ffe:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002002:	2b00      	cmp	r3, #0
 8002004:	d003      	beq.n	800200e <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 8002006:	69ba      	ldr	r2, [r7, #24]
 8002008:	693b      	ldr	r3, [r7, #16]
 800200a:	4313      	orrs	r3, r2
 800200c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800200e:	4a2f      	ldr	r2, [pc, #188]	; (80020cc <HAL_GPIO_Init+0x304>)
 8002010:	69bb      	ldr	r3, [r7, #24]
 8002012:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8002014:	4b2d      	ldr	r3, [pc, #180]	; (80020cc <HAL_GPIO_Init+0x304>)
 8002016:	685b      	ldr	r3, [r3, #4]
 8002018:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800201a:	693b      	ldr	r3, [r7, #16]
 800201c:	43db      	mvns	r3, r3
 800201e:	69ba      	ldr	r2, [r7, #24]
 8002020:	4013      	ands	r3, r2
 8002022:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002024:	683b      	ldr	r3, [r7, #0]
 8002026:	685b      	ldr	r3, [r3, #4]
 8002028:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800202c:	2b00      	cmp	r3, #0
 800202e:	d003      	beq.n	8002038 <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 8002030:	69ba      	ldr	r2, [r7, #24]
 8002032:	693b      	ldr	r3, [r7, #16]
 8002034:	4313      	orrs	r3, r2
 8002036:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8002038:	4a24      	ldr	r2, [pc, #144]	; (80020cc <HAL_GPIO_Init+0x304>)
 800203a:	69bb      	ldr	r3, [r7, #24]
 800203c:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800203e:	4b23      	ldr	r3, [pc, #140]	; (80020cc <HAL_GPIO_Init+0x304>)
 8002040:	689b      	ldr	r3, [r3, #8]
 8002042:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8002044:	693b      	ldr	r3, [r7, #16]
 8002046:	43db      	mvns	r3, r3
 8002048:	69ba      	ldr	r2, [r7, #24]
 800204a:	4013      	ands	r3, r2
 800204c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800204e:	683b      	ldr	r3, [r7, #0]
 8002050:	685b      	ldr	r3, [r3, #4]
 8002052:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002056:	2b00      	cmp	r3, #0
 8002058:	d003      	beq.n	8002062 <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 800205a:	69ba      	ldr	r2, [r7, #24]
 800205c:	693b      	ldr	r3, [r7, #16]
 800205e:	4313      	orrs	r3, r2
 8002060:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8002062:	4a1a      	ldr	r2, [pc, #104]	; (80020cc <HAL_GPIO_Init+0x304>)
 8002064:	69bb      	ldr	r3, [r7, #24]
 8002066:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8002068:	4b18      	ldr	r3, [pc, #96]	; (80020cc <HAL_GPIO_Init+0x304>)
 800206a:	68db      	ldr	r3, [r3, #12]
 800206c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800206e:	693b      	ldr	r3, [r7, #16]
 8002070:	43db      	mvns	r3, r3
 8002072:	69ba      	ldr	r2, [r7, #24]
 8002074:	4013      	ands	r3, r2
 8002076:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002078:	683b      	ldr	r3, [r7, #0]
 800207a:	685b      	ldr	r3, [r3, #4]
 800207c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002080:	2b00      	cmp	r3, #0
 8002082:	d003      	beq.n	800208c <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 8002084:	69ba      	ldr	r2, [r7, #24]
 8002086:	693b      	ldr	r3, [r7, #16]
 8002088:	4313      	orrs	r3, r2
 800208a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800208c:	4a0f      	ldr	r2, [pc, #60]	; (80020cc <HAL_GPIO_Init+0x304>)
 800208e:	69bb      	ldr	r3, [r7, #24]
 8002090:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002092:	69fb      	ldr	r3, [r7, #28]
 8002094:	3301      	adds	r3, #1
 8002096:	61fb      	str	r3, [r7, #28]
 8002098:	69fb      	ldr	r3, [r7, #28]
 800209a:	2b0f      	cmp	r3, #15
 800209c:	f67f aea2 	bls.w	8001de4 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 80020a0:	bf00      	nop
 80020a2:	bf00      	nop
 80020a4:	3724      	adds	r7, #36	; 0x24
 80020a6:	46bd      	mov	sp, r7
 80020a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020ac:	4770      	bx	lr
 80020ae:	bf00      	nop
 80020b0:	40023800 	.word	0x40023800
 80020b4:	40013800 	.word	0x40013800
 80020b8:	40020000 	.word	0x40020000
 80020bc:	40020400 	.word	0x40020400
 80020c0:	40020800 	.word	0x40020800
 80020c4:	40020c00 	.word	0x40020c00
 80020c8:	40021000 	.word	0x40021000
 80020cc:	40013c00 	.word	0x40013c00

080020d0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80020d0:	b480      	push	{r7}
 80020d2:	b083      	sub	sp, #12
 80020d4:	af00      	add	r7, sp, #0
 80020d6:	6078      	str	r0, [r7, #4]
 80020d8:	460b      	mov	r3, r1
 80020da:	807b      	strh	r3, [r7, #2]
 80020dc:	4613      	mov	r3, r2
 80020de:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80020e0:	787b      	ldrb	r3, [r7, #1]
 80020e2:	2b00      	cmp	r3, #0
 80020e4:	d003      	beq.n	80020ee <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80020e6:	887a      	ldrh	r2, [r7, #2]
 80020e8:	687b      	ldr	r3, [r7, #4]
 80020ea:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 80020ec:	e003      	b.n	80020f6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80020ee:	887b      	ldrh	r3, [r7, #2]
 80020f0:	041a      	lsls	r2, r3, #16
 80020f2:	687b      	ldr	r3, [r7, #4]
 80020f4:	619a      	str	r2, [r3, #24]
}
 80020f6:	bf00      	nop
 80020f8:	370c      	adds	r7, #12
 80020fa:	46bd      	mov	sp, r7
 80020fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002100:	4770      	bx	lr

08002102 <HAL_HCD_Init>:
  * @brief  Initialize the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
{
 8002102:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002104:	b08f      	sub	sp, #60	; 0x3c
 8002106:	af0a      	add	r7, sp, #40	; 0x28
 8002108:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx;

  /* Check the HCD handle allocation */
  if (hhcd == NULL)
 800210a:	687b      	ldr	r3, [r7, #4]
 800210c:	2b00      	cmp	r3, #0
 800210e:	d101      	bne.n	8002114 <HAL_HCD_Init+0x12>
  {
    return HAL_ERROR;
 8002110:	2301      	movs	r3, #1
 8002112:	e054      	b.n	80021be <HAL_HCD_Init+0xbc>
  }

  /* Check the parameters */
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));

  USBx = hhcd->Instance;
 8002114:	687b      	ldr	r3, [r7, #4]
 8002116:	681b      	ldr	r3, [r3, #0]
 8002118:	60fb      	str	r3, [r7, #12]

  if (hhcd->State == HAL_HCD_STATE_RESET)
 800211a:	687b      	ldr	r3, [r7, #4]
 800211c:	f893 32f9 	ldrb.w	r3, [r3, #761]	; 0x2f9
 8002120:	b2db      	uxtb	r3, r3
 8002122:	2b00      	cmp	r3, #0
 8002124:	d106      	bne.n	8002134 <HAL_HCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hhcd->Lock = HAL_UNLOCKED;
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	2200      	movs	r2, #0
 800212a:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8

    /* Init the low level hardware */
    hhcd->MspInitCallback(hhcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_HCD_MspInit(hhcd);
 800212e:	6878      	ldr	r0, [r7, #4]
 8002130:	f025 fdb8 	bl	8027ca4 <HAL_HCD_MspInit>
#endif /* (USE_HAL_HCD_REGISTER_CALLBACKS) */
  }

  hhcd->State = HAL_HCD_STATE_BUSY;
 8002134:	687b      	ldr	r3, [r7, #4]
 8002136:	2203      	movs	r2, #3
 8002138:	f883 22f9 	strb.w	r2, [r3, #761]	; 0x2f9

  /* Disable DMA mode for FS instance */
  if ((USBx->CID & (0x1U << 8)) == 0U)
 800213c:	68fb      	ldr	r3, [r7, #12]
 800213e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002140:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002144:	2b00      	cmp	r3, #0
 8002146:	d102      	bne.n	800214e <HAL_HCD_Init+0x4c>
  {
    hhcd->Init.dma_enable = 0U;
 8002148:	687b      	ldr	r3, [r7, #4]
 800214a:	2200      	movs	r2, #0
 800214c:	611a      	str	r2, [r3, #16]
  }

  /* Disable the Interrupts */
  __HAL_HCD_DISABLE(hhcd);
 800214e:	687b      	ldr	r3, [r7, #4]
 8002150:	681b      	ldr	r3, [r3, #0]
 8002152:	4618      	mov	r0, r3
 8002154:	f002 fdca 	bl	8004cec <USB_DisableGlobalInt>

  /* Init the Core (common init.) */
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8002158:	687b      	ldr	r3, [r7, #4]
 800215a:	681b      	ldr	r3, [r3, #0]
 800215c:	603b      	str	r3, [r7, #0]
 800215e:	687e      	ldr	r6, [r7, #4]
 8002160:	466d      	mov	r5, sp
 8002162:	f106 0410 	add.w	r4, r6, #16
 8002166:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002168:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800216a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800216c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800216e:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002172:	e885 0003 	stmia.w	r5, {r0, r1}
 8002176:	1d33      	adds	r3, r6, #4
 8002178:	cb0e      	ldmia	r3, {r1, r2, r3}
 800217a:	6838      	ldr	r0, [r7, #0]
 800217c:	f002 fd44 	bl	8004c08 <USB_CoreInit>

  /* Force Host Mode*/
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
 8002180:	687b      	ldr	r3, [r7, #4]
 8002182:	681b      	ldr	r3, [r3, #0]
 8002184:	2101      	movs	r1, #1
 8002186:	4618      	mov	r0, r3
 8002188:	f002 fdc1 	bl	8004d0e <USB_SetCurrentMode>

  /* Init Host */
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 800218c:	687b      	ldr	r3, [r7, #4]
 800218e:	681b      	ldr	r3, [r3, #0]
 8002190:	603b      	str	r3, [r7, #0]
 8002192:	687e      	ldr	r6, [r7, #4]
 8002194:	466d      	mov	r5, sp
 8002196:	f106 0410 	add.w	r4, r6, #16
 800219a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800219c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800219e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80021a0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80021a2:	e894 0003 	ldmia.w	r4, {r0, r1}
 80021a6:	e885 0003 	stmia.w	r5, {r0, r1}
 80021aa:	1d33      	adds	r3, r6, #4
 80021ac:	cb0e      	ldmia	r3, {r1, r2, r3}
 80021ae:	6838      	ldr	r0, [r7, #0]
 80021b0:	f002 ff28 	bl	8005004 <USB_HostInit>

  hhcd->State = HAL_HCD_STATE_READY;
 80021b4:	687b      	ldr	r3, [r7, #4]
 80021b6:	2201      	movs	r2, #1
 80021b8:	f883 22f9 	strb.w	r2, [r3, #761]	; 0x2f9

  return HAL_OK;
 80021bc:	2300      	movs	r3, #0
}
 80021be:	4618      	mov	r0, r3
 80021c0:	3714      	adds	r7, #20
 80021c2:	46bd      	mov	sp, r7
 80021c4:	bdf0      	pop	{r4, r5, r6, r7, pc}

080021c6 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
 80021c6:	b590      	push	{r4, r7, lr}
 80021c8:	b089      	sub	sp, #36	; 0x24
 80021ca:	af04      	add	r7, sp, #16
 80021cc:	6078      	str	r0, [r7, #4]
 80021ce:	4608      	mov	r0, r1
 80021d0:	4611      	mov	r1, r2
 80021d2:	461a      	mov	r2, r3
 80021d4:	4603      	mov	r3, r0
 80021d6:	70fb      	strb	r3, [r7, #3]
 80021d8:	460b      	mov	r3, r1
 80021da:	70bb      	strb	r3, [r7, #2]
 80021dc:	4613      	mov	r3, r2
 80021de:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
 80021e0:	687b      	ldr	r3, [r7, #4]
 80021e2:	f893 32f8 	ldrb.w	r3, [r3, #760]	; 0x2f8
 80021e6:	2b01      	cmp	r3, #1
 80021e8:	d101      	bne.n	80021ee <HAL_HCD_HC_Init+0x28>
 80021ea:	2302      	movs	r3, #2
 80021ec:	e076      	b.n	80022dc <HAL_HCD_HC_Init+0x116>
 80021ee:	687b      	ldr	r3, [r7, #4]
 80021f0:	2201      	movs	r2, #1
 80021f2:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8
  hhcd->hc[ch_num].do_ping = 0U;
 80021f6:	78fb      	ldrb	r3, [r7, #3]
 80021f8:	687a      	ldr	r2, [r7, #4]
 80021fa:	212c      	movs	r1, #44	; 0x2c
 80021fc:	fb01 f303 	mul.w	r3, r1, r3
 8002200:	4413      	add	r3, r2
 8002202:	333d      	adds	r3, #61	; 0x3d
 8002204:	2200      	movs	r2, #0
 8002206:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].dev_addr = dev_address;
 8002208:	78fb      	ldrb	r3, [r7, #3]
 800220a:	687a      	ldr	r2, [r7, #4]
 800220c:	212c      	movs	r1, #44	; 0x2c
 800220e:	fb01 f303 	mul.w	r3, r1, r3
 8002212:	4413      	add	r3, r2
 8002214:	3338      	adds	r3, #56	; 0x38
 8002216:	787a      	ldrb	r2, [r7, #1]
 8002218:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].max_packet = mps;
 800221a:	78fb      	ldrb	r3, [r7, #3]
 800221c:	687a      	ldr	r2, [r7, #4]
 800221e:	212c      	movs	r1, #44	; 0x2c
 8002220:	fb01 f303 	mul.w	r3, r1, r3
 8002224:	4413      	add	r3, r2
 8002226:	3340      	adds	r3, #64	; 0x40
 8002228:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800222a:	801a      	strh	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 800222c:	78fb      	ldrb	r3, [r7, #3]
 800222e:	687a      	ldr	r2, [r7, #4]
 8002230:	212c      	movs	r1, #44	; 0x2c
 8002232:	fb01 f303 	mul.w	r3, r1, r3
 8002236:	4413      	add	r3, r2
 8002238:	3339      	adds	r3, #57	; 0x39
 800223a:	78fa      	ldrb	r2, [r7, #3]
 800223c:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type = ep_type;
 800223e:	78fb      	ldrb	r3, [r7, #3]
 8002240:	687a      	ldr	r2, [r7, #4]
 8002242:	212c      	movs	r1, #44	; 0x2c
 8002244:	fb01 f303 	mul.w	r3, r1, r3
 8002248:	4413      	add	r3, r2
 800224a:	333f      	adds	r3, #63	; 0x3f
 800224c:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 8002250:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 8002252:	78fb      	ldrb	r3, [r7, #3]
 8002254:	78ba      	ldrb	r2, [r7, #2]
 8002256:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800225a:	b2d0      	uxtb	r0, r2
 800225c:	687a      	ldr	r2, [r7, #4]
 800225e:	212c      	movs	r1, #44	; 0x2c
 8002260:	fb01 f303 	mul.w	r3, r1, r3
 8002264:	4413      	add	r3, r2
 8002266:	333a      	adds	r3, #58	; 0x3a
 8002268:	4602      	mov	r2, r0
 800226a:	701a      	strb	r2, [r3, #0]

  if ((epnum & 0x80U) == 0x80U)
 800226c:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8002270:	2b00      	cmp	r3, #0
 8002272:	da09      	bge.n	8002288 <HAL_HCD_HC_Init+0xc2>
  {
    hhcd->hc[ch_num].ep_is_in = 1U;
 8002274:	78fb      	ldrb	r3, [r7, #3]
 8002276:	687a      	ldr	r2, [r7, #4]
 8002278:	212c      	movs	r1, #44	; 0x2c
 800227a:	fb01 f303 	mul.w	r3, r1, r3
 800227e:	4413      	add	r3, r2
 8002280:	333b      	adds	r3, #59	; 0x3b
 8002282:	2201      	movs	r2, #1
 8002284:	701a      	strb	r2, [r3, #0]
 8002286:	e008      	b.n	800229a <HAL_HCD_HC_Init+0xd4>
  }
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
 8002288:	78fb      	ldrb	r3, [r7, #3]
 800228a:	687a      	ldr	r2, [r7, #4]
 800228c:	212c      	movs	r1, #44	; 0x2c
 800228e:	fb01 f303 	mul.w	r3, r1, r3
 8002292:	4413      	add	r3, r2
 8002294:	333b      	adds	r3, #59	; 0x3b
 8002296:	2200      	movs	r2, #0
 8002298:	701a      	strb	r2, [r3, #0]
  }

  hhcd->hc[ch_num].speed = speed;
 800229a:	78fb      	ldrb	r3, [r7, #3]
 800229c:	687a      	ldr	r2, [r7, #4]
 800229e:	212c      	movs	r1, #44	; 0x2c
 80022a0:	fb01 f303 	mul.w	r3, r1, r3
 80022a4:	4413      	add	r3, r2
 80022a6:	333c      	adds	r3, #60	; 0x3c
 80022a8:	f897 2020 	ldrb.w	r2, [r7, #32]
 80022ac:	701a      	strb	r2, [r3, #0]

  status =  USB_HC_Init(hhcd->Instance,
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	6818      	ldr	r0, [r3, #0]
 80022b2:	787c      	ldrb	r4, [r7, #1]
 80022b4:	78ba      	ldrb	r2, [r7, #2]
 80022b6:	78f9      	ldrb	r1, [r7, #3]
 80022b8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80022ba:	9302      	str	r3, [sp, #8]
 80022bc:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80022c0:	9301      	str	r3, [sp, #4]
 80022c2:	f897 3020 	ldrb.w	r3, [r7, #32]
 80022c6:	9300      	str	r3, [sp, #0]
 80022c8:	4623      	mov	r3, r4
 80022ca:	f003 f815 	bl	80052f8 <USB_HC_Init>
 80022ce:	4603      	mov	r3, r0
 80022d0:	73fb      	strb	r3, [r7, #15]
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
 80022d2:	687b      	ldr	r3, [r7, #4]
 80022d4:	2200      	movs	r2, #0
 80022d6:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8

  return status;
 80022da:	7bfb      	ldrb	r3, [r7, #15]
}
 80022dc:	4618      	mov	r0, r3
 80022de:	3714      	adds	r7, #20
 80022e0:	46bd      	mov	sp, r7
 80022e2:	bd90      	pop	{r4, r7, pc}

080022e4 <HAL_HCD_HC_Halt>:
  * @param  ch_num Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
 80022e4:	b580      	push	{r7, lr}
 80022e6:	b084      	sub	sp, #16
 80022e8:	af00      	add	r7, sp, #0
 80022ea:	6078      	str	r0, [r7, #4]
 80022ec:	460b      	mov	r3, r1
 80022ee:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
 80022f0:	2300      	movs	r3, #0
 80022f2:	73fb      	strb	r3, [r7, #15]

  __HAL_LOCK(hhcd);
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	f893 32f8 	ldrb.w	r3, [r3, #760]	; 0x2f8
 80022fa:	2b01      	cmp	r3, #1
 80022fc:	d101      	bne.n	8002302 <HAL_HCD_HC_Halt+0x1e>
 80022fe:	2302      	movs	r3, #2
 8002300:	e00f      	b.n	8002322 <HAL_HCD_HC_Halt+0x3e>
 8002302:	687b      	ldr	r3, [r7, #4]
 8002304:	2201      	movs	r2, #1
 8002306:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800230a:	687b      	ldr	r3, [r7, #4]
 800230c:	681b      	ldr	r3, [r3, #0]
 800230e:	78fa      	ldrb	r2, [r7, #3]
 8002310:	4611      	mov	r1, r2
 8002312:	4618      	mov	r0, r3
 8002314:	f003 fa51 	bl	80057ba <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 8002318:	687b      	ldr	r3, [r7, #4]
 800231a:	2200      	movs	r2, #0
 800231c:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8

  return status;
 8002320:	7bfb      	ldrb	r3, [r7, #15]
}
 8002322:	4618      	mov	r0, r3
 8002324:	3710      	adds	r7, #16
 8002326:	46bd      	mov	sp, r7
 8002328:	bd80      	pop	{r7, pc}
	...

0800232c <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 800232c:	b580      	push	{r7, lr}
 800232e:	b082      	sub	sp, #8
 8002330:	af00      	add	r7, sp, #0
 8002332:	6078      	str	r0, [r7, #4]
 8002334:	4608      	mov	r0, r1
 8002336:	4611      	mov	r1, r2
 8002338:	461a      	mov	r2, r3
 800233a:	4603      	mov	r3, r0
 800233c:	70fb      	strb	r3, [r7, #3]
 800233e:	460b      	mov	r3, r1
 8002340:	70bb      	strb	r3, [r7, #2]
 8002342:	4613      	mov	r3, r2
 8002344:	707b      	strb	r3, [r7, #1]
  hhcd->hc[ch_num].ep_is_in = direction;
 8002346:	78fb      	ldrb	r3, [r7, #3]
 8002348:	687a      	ldr	r2, [r7, #4]
 800234a:	212c      	movs	r1, #44	; 0x2c
 800234c:	fb01 f303 	mul.w	r3, r1, r3
 8002350:	4413      	add	r3, r2
 8002352:	333b      	adds	r3, #59	; 0x3b
 8002354:	78ba      	ldrb	r2, [r7, #2]
 8002356:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].ep_type  = ep_type;
 8002358:	78fb      	ldrb	r3, [r7, #3]
 800235a:	687a      	ldr	r2, [r7, #4]
 800235c:	212c      	movs	r1, #44	; 0x2c
 800235e:	fb01 f303 	mul.w	r3, r1, r3
 8002362:	4413      	add	r3, r2
 8002364:	333f      	adds	r3, #63	; 0x3f
 8002366:	787a      	ldrb	r2, [r7, #1]
 8002368:	701a      	strb	r2, [r3, #0]

  if (token == 0U)
 800236a:	7c3b      	ldrb	r3, [r7, #16]
 800236c:	2b00      	cmp	r3, #0
 800236e:	d112      	bne.n	8002396 <HAL_HCD_HC_SubmitRequest+0x6a>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 8002370:	78fb      	ldrb	r3, [r7, #3]
 8002372:	687a      	ldr	r2, [r7, #4]
 8002374:	212c      	movs	r1, #44	; 0x2c
 8002376:	fb01 f303 	mul.w	r3, r1, r3
 800237a:	4413      	add	r3, r2
 800237c:	3342      	adds	r3, #66	; 0x42
 800237e:	2203      	movs	r2, #3
 8002380:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].do_ping = do_ping;
 8002382:	78fb      	ldrb	r3, [r7, #3]
 8002384:	687a      	ldr	r2, [r7, #4]
 8002386:	212c      	movs	r1, #44	; 0x2c
 8002388:	fb01 f303 	mul.w	r3, r1, r3
 800238c:	4413      	add	r3, r2
 800238e:	333d      	adds	r3, #61	; 0x3d
 8002390:	7f3a      	ldrb	r2, [r7, #28]
 8002392:	701a      	strb	r2, [r3, #0]
 8002394:	e008      	b.n	80023a8 <HAL_HCD_HC_SubmitRequest+0x7c>
  }
  else
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8002396:	78fb      	ldrb	r3, [r7, #3]
 8002398:	687a      	ldr	r2, [r7, #4]
 800239a:	212c      	movs	r1, #44	; 0x2c
 800239c:	fb01 f303 	mul.w	r3, r1, r3
 80023a0:	4413      	add	r3, r2
 80023a2:	3342      	adds	r3, #66	; 0x42
 80023a4:	2202      	movs	r2, #2
 80023a6:	701a      	strb	r2, [r3, #0]
  }

  /* Manage Data Toggle */
  switch (ep_type)
 80023a8:	787b      	ldrb	r3, [r7, #1]
 80023aa:	2b03      	cmp	r3, #3
 80023ac:	f200 80c6 	bhi.w	800253c <HAL_HCD_HC_SubmitRequest+0x210>
 80023b0:	a201      	add	r2, pc, #4	; (adr r2, 80023b8 <HAL_HCD_HC_SubmitRequest+0x8c>)
 80023b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80023b6:	bf00      	nop
 80023b8:	080023c9 	.word	0x080023c9
 80023bc:	08002529 	.word	0x08002529
 80023c0:	0800242d 	.word	0x0800242d
 80023c4:	080024ab 	.word	0x080024ab
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
 80023c8:	7c3b      	ldrb	r3, [r7, #16]
 80023ca:	2b01      	cmp	r3, #1
 80023cc:	f040 80b8 	bne.w	8002540 <HAL_HCD_HC_SubmitRequest+0x214>
 80023d0:	78bb      	ldrb	r3, [r7, #2]
 80023d2:	2b00      	cmp	r3, #0
 80023d4:	f040 80b4 	bne.w	8002540 <HAL_HCD_HC_SubmitRequest+0x214>
      {
        if (length == 0U)
 80023d8:	8b3b      	ldrh	r3, [r7, #24]
 80023da:	2b00      	cmp	r3, #0
 80023dc:	d108      	bne.n	80023f0 <HAL_HCD_HC_SubmitRequest+0xc4>
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
 80023de:	78fb      	ldrb	r3, [r7, #3]
 80023e0:	687a      	ldr	r2, [r7, #4]
 80023e2:	212c      	movs	r1, #44	; 0x2c
 80023e4:	fb01 f303 	mul.w	r3, r1, r3
 80023e8:	4413      	add	r3, r2
 80023ea:	3355      	adds	r3, #85	; 0x55
 80023ec:	2201      	movs	r2, #1
 80023ee:	701a      	strb	r2, [r3, #0]
        }

        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80023f0:	78fb      	ldrb	r3, [r7, #3]
 80023f2:	687a      	ldr	r2, [r7, #4]
 80023f4:	212c      	movs	r1, #44	; 0x2c
 80023f6:	fb01 f303 	mul.w	r3, r1, r3
 80023fa:	4413      	add	r3, r2
 80023fc:	3355      	adds	r3, #85	; 0x55
 80023fe:	781b      	ldrb	r3, [r3, #0]
 8002400:	2b00      	cmp	r3, #0
 8002402:	d109      	bne.n	8002418 <HAL_HCD_HC_SubmitRequest+0xec>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002404:	78fb      	ldrb	r3, [r7, #3]
 8002406:	687a      	ldr	r2, [r7, #4]
 8002408:	212c      	movs	r1, #44	; 0x2c
 800240a:	fb01 f303 	mul.w	r3, r1, r3
 800240e:	4413      	add	r3, r2
 8002410:	3342      	adds	r3, #66	; 0x42
 8002412:	2200      	movs	r2, #0
 8002414:	701a      	strb	r2, [r3, #0]
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }
      break;
 8002416:	e093      	b.n	8002540 <HAL_HCD_HC_SubmitRequest+0x214>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8002418:	78fb      	ldrb	r3, [r7, #3]
 800241a:	687a      	ldr	r2, [r7, #4]
 800241c:	212c      	movs	r1, #44	; 0x2c
 800241e:	fb01 f303 	mul.w	r3, r1, r3
 8002422:	4413      	add	r3, r2
 8002424:	3342      	adds	r3, #66	; 0x42
 8002426:	2202      	movs	r2, #2
 8002428:	701a      	strb	r2, [r3, #0]
      break;
 800242a:	e089      	b.n	8002540 <HAL_HCD_HC_SubmitRequest+0x214>

    case EP_TYPE_BULK:
      if (direction == 0U)
 800242c:	78bb      	ldrb	r3, [r7, #2]
 800242e:	2b00      	cmp	r3, #0
 8002430:	d11d      	bne.n	800246e <HAL_HCD_HC_SubmitRequest+0x142>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8002432:	78fb      	ldrb	r3, [r7, #3]
 8002434:	687a      	ldr	r2, [r7, #4]
 8002436:	212c      	movs	r1, #44	; 0x2c
 8002438:	fb01 f303 	mul.w	r3, r1, r3
 800243c:	4413      	add	r3, r2
 800243e:	3355      	adds	r3, #85	; 0x55
 8002440:	781b      	ldrb	r3, [r3, #0]
 8002442:	2b00      	cmp	r3, #0
 8002444:	d109      	bne.n	800245a <HAL_HCD_HC_SubmitRequest+0x12e>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002446:	78fb      	ldrb	r3, [r7, #3]
 8002448:	687a      	ldr	r2, [r7, #4]
 800244a:	212c      	movs	r1, #44	; 0x2c
 800244c:	fb01 f303 	mul.w	r3, r1, r3
 8002450:	4413      	add	r3, r2
 8002452:	3342      	adds	r3, #66	; 0x42
 8002454:	2200      	movs	r2, #0
 8002456:	701a      	strb	r2, [r3, #0]
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }

      break;
 8002458:	e073      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800245a:	78fb      	ldrb	r3, [r7, #3]
 800245c:	687a      	ldr	r2, [r7, #4]
 800245e:	212c      	movs	r1, #44	; 0x2c
 8002460:	fb01 f303 	mul.w	r3, r1, r3
 8002464:	4413      	add	r3, r2
 8002466:	3342      	adds	r3, #66	; 0x42
 8002468:	2202      	movs	r2, #2
 800246a:	701a      	strb	r2, [r3, #0]
      break;
 800246c:	e069      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 800246e:	78fb      	ldrb	r3, [r7, #3]
 8002470:	687a      	ldr	r2, [r7, #4]
 8002472:	212c      	movs	r1, #44	; 0x2c
 8002474:	fb01 f303 	mul.w	r3, r1, r3
 8002478:	4413      	add	r3, r2
 800247a:	3354      	adds	r3, #84	; 0x54
 800247c:	781b      	ldrb	r3, [r3, #0]
 800247e:	2b00      	cmp	r3, #0
 8002480:	d109      	bne.n	8002496 <HAL_HCD_HC_SubmitRequest+0x16a>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002482:	78fb      	ldrb	r3, [r7, #3]
 8002484:	687a      	ldr	r2, [r7, #4]
 8002486:	212c      	movs	r1, #44	; 0x2c
 8002488:	fb01 f303 	mul.w	r3, r1, r3
 800248c:	4413      	add	r3, r2
 800248e:	3342      	adds	r3, #66	; 0x42
 8002490:	2200      	movs	r2, #0
 8002492:	701a      	strb	r2, [r3, #0]
      break;
 8002494:	e055      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8002496:	78fb      	ldrb	r3, [r7, #3]
 8002498:	687a      	ldr	r2, [r7, #4]
 800249a:	212c      	movs	r1, #44	; 0x2c
 800249c:	fb01 f303 	mul.w	r3, r1, r3
 80024a0:	4413      	add	r3, r2
 80024a2:	3342      	adds	r3, #66	; 0x42
 80024a4:	2202      	movs	r2, #2
 80024a6:	701a      	strb	r2, [r3, #0]
      break;
 80024a8:	e04b      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
    case EP_TYPE_INTR:
      if (direction == 0U)
 80024aa:	78bb      	ldrb	r3, [r7, #2]
 80024ac:	2b00      	cmp	r3, #0
 80024ae:	d11d      	bne.n	80024ec <HAL_HCD_HC_SubmitRequest+0x1c0>
      {
        /* Set the Data Toggle bit as per the Flag */
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80024b0:	78fb      	ldrb	r3, [r7, #3]
 80024b2:	687a      	ldr	r2, [r7, #4]
 80024b4:	212c      	movs	r1, #44	; 0x2c
 80024b6:	fb01 f303 	mul.w	r3, r1, r3
 80024ba:	4413      	add	r3, r2
 80024bc:	3355      	adds	r3, #85	; 0x55
 80024be:	781b      	ldrb	r3, [r3, #0]
 80024c0:	2b00      	cmp	r3, #0
 80024c2:	d109      	bne.n	80024d8 <HAL_HCD_HC_SubmitRequest+0x1ac>
        {
          /* Put the PID 0 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 80024c4:	78fb      	ldrb	r3, [r7, #3]
 80024c6:	687a      	ldr	r2, [r7, #4]
 80024c8:	212c      	movs	r1, #44	; 0x2c
 80024ca:	fb01 f303 	mul.w	r3, r1, r3
 80024ce:	4413      	add	r3, r2
 80024d0:	3342      	adds	r3, #66	; 0x42
 80024d2:	2200      	movs	r2, #0
 80024d4:	701a      	strb	r2, [r3, #0]
        else
        {
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
        }
      }
      break;
 80024d6:	e034      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 80024d8:	78fb      	ldrb	r3, [r7, #3]
 80024da:	687a      	ldr	r2, [r7, #4]
 80024dc:	212c      	movs	r1, #44	; 0x2c
 80024de:	fb01 f303 	mul.w	r3, r1, r3
 80024e2:	4413      	add	r3, r2
 80024e4:	3342      	adds	r3, #66	; 0x42
 80024e6:	2202      	movs	r2, #2
 80024e8:	701a      	strb	r2, [r3, #0]
      break;
 80024ea:	e02a      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 80024ec:	78fb      	ldrb	r3, [r7, #3]
 80024ee:	687a      	ldr	r2, [r7, #4]
 80024f0:	212c      	movs	r1, #44	; 0x2c
 80024f2:	fb01 f303 	mul.w	r3, r1, r3
 80024f6:	4413      	add	r3, r2
 80024f8:	3354      	adds	r3, #84	; 0x54
 80024fa:	781b      	ldrb	r3, [r3, #0]
 80024fc:	2b00      	cmp	r3, #0
 80024fe:	d109      	bne.n	8002514 <HAL_HCD_HC_SubmitRequest+0x1e8>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002500:	78fb      	ldrb	r3, [r7, #3]
 8002502:	687a      	ldr	r2, [r7, #4]
 8002504:	212c      	movs	r1, #44	; 0x2c
 8002506:	fb01 f303 	mul.w	r3, r1, r3
 800250a:	4413      	add	r3, r2
 800250c:	3342      	adds	r3, #66	; 0x42
 800250e:	2200      	movs	r2, #0
 8002510:	701a      	strb	r2, [r3, #0]
      break;
 8002512:	e016      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8002514:	78fb      	ldrb	r3, [r7, #3]
 8002516:	687a      	ldr	r2, [r7, #4]
 8002518:	212c      	movs	r1, #44	; 0x2c
 800251a:	fb01 f303 	mul.w	r3, r1, r3
 800251e:	4413      	add	r3, r2
 8002520:	3342      	adds	r3, #66	; 0x42
 8002522:	2202      	movs	r2, #2
 8002524:	701a      	strb	r2, [r3, #0]
      break;
 8002526:	e00c      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>

    case EP_TYPE_ISOC:
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8002528:	78fb      	ldrb	r3, [r7, #3]
 800252a:	687a      	ldr	r2, [r7, #4]
 800252c:	212c      	movs	r1, #44	; 0x2c
 800252e:	fb01 f303 	mul.w	r3, r1, r3
 8002532:	4413      	add	r3, r2
 8002534:	3342      	adds	r3, #66	; 0x42
 8002536:	2200      	movs	r2, #0
 8002538:	701a      	strb	r2, [r3, #0]
      break;
 800253a:	e002      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>

    default:
      break;
 800253c:	bf00      	nop
 800253e:	e000      	b.n	8002542 <HAL_HCD_HC_SubmitRequest+0x216>
      break;
 8002540:	bf00      	nop
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 8002542:	78fb      	ldrb	r3, [r7, #3]
 8002544:	687a      	ldr	r2, [r7, #4]
 8002546:	212c      	movs	r1, #44	; 0x2c
 8002548:	fb01 f303 	mul.w	r3, r1, r3
 800254c:	4413      	add	r3, r2
 800254e:	3344      	adds	r3, #68	; 0x44
 8002550:	697a      	ldr	r2, [r7, #20]
 8002552:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_len  = length;
 8002554:	78fb      	ldrb	r3, [r7, #3]
 8002556:	8b3a      	ldrh	r2, [r7, #24]
 8002558:	6879      	ldr	r1, [r7, #4]
 800255a:	202c      	movs	r0, #44	; 0x2c
 800255c:	fb00 f303 	mul.w	r3, r0, r3
 8002560:	440b      	add	r3, r1
 8002562:	334c      	adds	r3, #76	; 0x4c
 8002564:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8002566:	78fb      	ldrb	r3, [r7, #3]
 8002568:	687a      	ldr	r2, [r7, #4]
 800256a:	212c      	movs	r1, #44	; 0x2c
 800256c:	fb01 f303 	mul.w	r3, r1, r3
 8002570:	4413      	add	r3, r2
 8002572:	3360      	adds	r3, #96	; 0x60
 8002574:	2200      	movs	r2, #0
 8002576:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].xfer_count = 0U;
 8002578:	78fb      	ldrb	r3, [r7, #3]
 800257a:	687a      	ldr	r2, [r7, #4]
 800257c:	212c      	movs	r1, #44	; 0x2c
 800257e:	fb01 f303 	mul.w	r3, r1, r3
 8002582:	4413      	add	r3, r2
 8002584:	3350      	adds	r3, #80	; 0x50
 8002586:	2200      	movs	r2, #0
 8002588:	601a      	str	r2, [r3, #0]
  hhcd->hc[ch_num].ch_num = ch_num;
 800258a:	78fb      	ldrb	r3, [r7, #3]
 800258c:	687a      	ldr	r2, [r7, #4]
 800258e:	212c      	movs	r1, #44	; 0x2c
 8002590:	fb01 f303 	mul.w	r3, r1, r3
 8002594:	4413      	add	r3, r2
 8002596:	3339      	adds	r3, #57	; 0x39
 8002598:	78fa      	ldrb	r2, [r7, #3]
 800259a:	701a      	strb	r2, [r3, #0]
  hhcd->hc[ch_num].state = HC_IDLE;
 800259c:	78fb      	ldrb	r3, [r7, #3]
 800259e:	687a      	ldr	r2, [r7, #4]
 80025a0:	212c      	movs	r1, #44	; 0x2c
 80025a2:	fb01 f303 	mul.w	r3, r1, r3
 80025a6:	4413      	add	r3, r2
 80025a8:	3361      	adds	r3, #97	; 0x61
 80025aa:	2200      	movs	r2, #0
 80025ac:	701a      	strb	r2, [r3, #0]

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 80025ae:	687b      	ldr	r3, [r7, #4]
 80025b0:	6818      	ldr	r0, [r3, #0]
 80025b2:	78fb      	ldrb	r3, [r7, #3]
 80025b4:	222c      	movs	r2, #44	; 0x2c
 80025b6:	fb02 f303 	mul.w	r3, r2, r3
 80025ba:	3338      	adds	r3, #56	; 0x38
 80025bc:	687a      	ldr	r2, [r7, #4]
 80025be:	18d1      	adds	r1, r2, r3
 80025c0:	687b      	ldr	r3, [r7, #4]
 80025c2:	691b      	ldr	r3, [r3, #16]
 80025c4:	b2db      	uxtb	r3, r3
 80025c6:	461a      	mov	r2, r3
 80025c8:	f002 ffa4 	bl	8005514 <USB_HC_StartXfer>
 80025cc:	4603      	mov	r3, r0
}
 80025ce:	4618      	mov	r0, r3
 80025d0:	3708      	adds	r7, #8
 80025d2:	46bd      	mov	sp, r7
 80025d4:	bd80      	pop	{r7, pc}
 80025d6:	bf00      	nop

080025d8 <HAL_HCD_IRQHandler>:
  * @brief  Handle HCD interrupt request.
  * @param  hhcd HCD handle
  * @retval None
  */
void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 80025d8:	b580      	push	{r7, lr}
 80025da:	b086      	sub	sp, #24
 80025dc:	af00      	add	r7, sp, #0
 80025de:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80025e0:	687b      	ldr	r3, [r7, #4]
 80025e2:	681b      	ldr	r3, [r3, #0]
 80025e4:	613b      	str	r3, [r7, #16]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80025e6:	693b      	ldr	r3, [r7, #16]
 80025e8:	60fb      	str	r3, [r7, #12]
  uint32_t i;
  uint32_t interrupt;

  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	681b      	ldr	r3, [r3, #0]
 80025ee:	4618      	mov	r0, r3
 80025f0:	f002 fcc7 	bl	8004f82 <USB_GetMode>
 80025f4:	4603      	mov	r3, r0
 80025f6:	2b01      	cmp	r3, #1
 80025f8:	f040 80f6 	bne.w	80027e8 <HAL_HCD_IRQHandler+0x210>
  {
    /* Avoid spurious interrupt */
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	4618      	mov	r0, r3
 8002602:	f002 fcab 	bl	8004f5c <USB_ReadInterrupts>
 8002606:	4603      	mov	r3, r0
 8002608:	2b00      	cmp	r3, #0
 800260a:	f000 80ec 	beq.w	80027e6 <HAL_HCD_IRQHandler+0x20e>
    {
      return;
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 800260e:	687b      	ldr	r3, [r7, #4]
 8002610:	681b      	ldr	r3, [r3, #0]
 8002612:	4618      	mov	r0, r3
 8002614:	f002 fca2 	bl	8004f5c <USB_ReadInterrupts>
 8002618:	4603      	mov	r3, r0
 800261a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800261e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8002622:	d104      	bne.n	800262e <HAL_HCD_IRQHandler+0x56>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002624:	687b      	ldr	r3, [r7, #4]
 8002626:	681b      	ldr	r3, [r3, #0]
 8002628:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 800262c:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	681b      	ldr	r3, [r3, #0]
 8002632:	4618      	mov	r0, r3
 8002634:	f002 fc92 	bl	8004f5c <USB_ReadInterrupts>
 8002638:	4603      	mov	r3, r0
 800263a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800263e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8002642:	d104      	bne.n	800264e <HAL_HCD_IRQHandler+0x76>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	681b      	ldr	r3, [r3, #0]
 8002648:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800264c:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	681b      	ldr	r3, [r3, #0]
 8002652:	4618      	mov	r0, r3
 8002654:	f002 fc82 	bl	8004f5c <USB_ReadInterrupts>
 8002658:	4603      	mov	r3, r0
 800265a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800265e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8002662:	d104      	bne.n	800266e <HAL_HCD_IRQHandler+0x96>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8002664:	687b      	ldr	r3, [r7, #4]
 8002666:	681b      	ldr	r3, [r3, #0]
 8002668:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800266c:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 800266e:	687b      	ldr	r3, [r7, #4]
 8002670:	681b      	ldr	r3, [r3, #0]
 8002672:	4618      	mov	r0, r3
 8002674:	f002 fc72 	bl	8004f5c <USB_ReadInterrupts>
 8002678:	4603      	mov	r3, r0
 800267a:	f003 0302 	and.w	r3, r3, #2
 800267e:	2b02      	cmp	r3, #2
 8002680:	d103      	bne.n	800268a <HAL_HCD_IRQHandler+0xb2>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8002682:	687b      	ldr	r3, [r7, #4]
 8002684:	681b      	ldr	r3, [r3, #0]
 8002686:	2202      	movs	r2, #2
 8002688:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host Disconnect Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 800268a:	687b      	ldr	r3, [r7, #4]
 800268c:	681b      	ldr	r3, [r3, #0]
 800268e:	4618      	mov	r0, r3
 8002690:	f002 fc64 	bl	8004f5c <USB_ReadInterrupts>
 8002694:	4603      	mov	r3, r0
 8002696:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800269a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800269e:	d11c      	bne.n	80026da <HAL_HCD_IRQHandler+0x102>
    {
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 80026a0:	687b      	ldr	r3, [r7, #4]
 80026a2:	681b      	ldr	r3, [r3, #0]
 80026a4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 80026a8:	615a      	str	r2, [r3, #20]

      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 80026aa:	68fb      	ldr	r3, [r7, #12]
 80026ac:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80026b0:	681b      	ldr	r3, [r3, #0]
 80026b2:	f003 0301 	and.w	r3, r3, #1
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d10f      	bne.n	80026da <HAL_HCD_IRQHandler+0x102>
      {
        /* Flush USB Fifo */
        (void)USB_FlushTxFifo(USBx, 0x10U);
 80026ba:	2110      	movs	r1, #16
 80026bc:	6938      	ldr	r0, [r7, #16]
 80026be:	f002 fb73 	bl	8004da8 <USB_FlushTxFifo>
        (void)USB_FlushRxFifo(USBx);
 80026c2:	6938      	ldr	r0, [r7, #16]
 80026c4:	f002 fb94 	bl	8004df0 <USB_FlushRxFifo>

        /* Restore FS Clock */
        (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80026c8:	687b      	ldr	r3, [r7, #4]
 80026ca:	681b      	ldr	r3, [r3, #0]
 80026cc:	2101      	movs	r1, #1
 80026ce:	4618      	mov	r0, r3
 80026d0:	f002 fd4c 	bl	800516c <USB_InitFSLSPClkSel>

        /* Handle Host Port Disconnect Interrupt */
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
        hhcd->DisconnectCallback(hhcd);
#else
        HAL_HCD_Disconnect_Callback(hhcd);
 80026d4:	6878      	ldr	r0, [r7, #4]
 80026d6:	f025 fb55 	bl	8027d84 <HAL_HCD_Disconnect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Host Port Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	681b      	ldr	r3, [r3, #0]
 80026de:	4618      	mov	r0, r3
 80026e0:	f002 fc3c 	bl	8004f5c <USB_ReadInterrupts>
 80026e4:	4603      	mov	r3, r0
 80026e6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80026ea:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80026ee:	d102      	bne.n	80026f6 <HAL_HCD_IRQHandler+0x11e>
    {
      HCD_Port_IRQHandler(hhcd);
 80026f0:	6878      	ldr	r0, [r7, #4]
 80026f2:	f001 fa03 	bl	8003afc <HCD_Port_IRQHandler>
    }

    /* Handle Host SOF Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 80026f6:	687b      	ldr	r3, [r7, #4]
 80026f8:	681b      	ldr	r3, [r3, #0]
 80026fa:	4618      	mov	r0, r3
 80026fc:	f002 fc2e 	bl	8004f5c <USB_ReadInterrupts>
 8002700:	4603      	mov	r3, r0
 8002702:	f003 0308 	and.w	r3, r3, #8
 8002706:	2b08      	cmp	r3, #8
 8002708:	d106      	bne.n	8002718 <HAL_HCD_IRQHandler+0x140>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->SOFCallback(hhcd);
#else
      HAL_HCD_SOF_Callback(hhcd);
 800270a:	6878      	ldr	r0, [r7, #4]
 800270c:	f025 fb1e 	bl	8027d4c <HAL_HCD_SOF_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8002710:	687b      	ldr	r3, [r7, #4]
 8002712:	681b      	ldr	r3, [r3, #0]
 8002714:	2208      	movs	r2, #8
 8002716:	615a      	str	r2, [r3, #20]
    }

    /* Handle Rx Queue Level Interrupts */
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 8002718:	687b      	ldr	r3, [r7, #4]
 800271a:	681b      	ldr	r3, [r3, #0]
 800271c:	4618      	mov	r0, r3
 800271e:	f002 fc1d 	bl	8004f5c <USB_ReadInterrupts>
 8002722:	4603      	mov	r3, r0
 8002724:	f003 0310 	and.w	r3, r3, #16
 8002728:	2b10      	cmp	r3, #16
 800272a:	d101      	bne.n	8002730 <HAL_HCD_IRQHandler+0x158>
 800272c:	2301      	movs	r3, #1
 800272e:	e000      	b.n	8002732 <HAL_HCD_IRQHandler+0x15a>
 8002730:	2300      	movs	r3, #0
 8002732:	2b00      	cmp	r3, #0
 8002734:	d012      	beq.n	800275c <HAL_HCD_IRQHandler+0x184>
    {
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002736:	687b      	ldr	r3, [r7, #4]
 8002738:	681b      	ldr	r3, [r3, #0]
 800273a:	699a      	ldr	r2, [r3, #24]
 800273c:	687b      	ldr	r3, [r7, #4]
 800273e:	681b      	ldr	r3, [r3, #0]
 8002740:	f022 0210 	bic.w	r2, r2, #16
 8002744:	619a      	str	r2, [r3, #24]

      HCD_RXQLVL_IRQHandler(hhcd);
 8002746:	6878      	ldr	r0, [r7, #4]
 8002748:	f001 f906 	bl	8003958 <HCD_RXQLVL_IRQHandler>

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800274c:	687b      	ldr	r3, [r7, #4]
 800274e:	681b      	ldr	r3, [r3, #0]
 8002750:	699a      	ldr	r2, [r3, #24]
 8002752:	687b      	ldr	r3, [r7, #4]
 8002754:	681b      	ldr	r3, [r3, #0]
 8002756:	f042 0210 	orr.w	r2, r2, #16
 800275a:	619a      	str	r2, [r3, #24]
    }

    /* Handle Host channel Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 800275c:	687b      	ldr	r3, [r7, #4]
 800275e:	681b      	ldr	r3, [r3, #0]
 8002760:	4618      	mov	r0, r3
 8002762:	f002 fbfb 	bl	8004f5c <USB_ReadInterrupts>
 8002766:	4603      	mov	r3, r0
 8002768:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800276c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8002770:	d13a      	bne.n	80027e8 <HAL_HCD_IRQHandler+0x210>
    {
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	4618      	mov	r0, r3
 8002778:	f003 f80e 	bl	8005798 <USB_HC_ReadInterrupt>
 800277c:	60b8      	str	r0, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800277e:	2300      	movs	r3, #0
 8002780:	617b      	str	r3, [r7, #20]
 8002782:	e025      	b.n	80027d0 <HAL_HCD_IRQHandler+0x1f8>
      {
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8002784:	697b      	ldr	r3, [r7, #20]
 8002786:	f003 030f 	and.w	r3, r3, #15
 800278a:	68ba      	ldr	r2, [r7, #8]
 800278c:	fa22 f303 	lsr.w	r3, r2, r3
 8002790:	f003 0301 	and.w	r3, r3, #1
 8002794:	2b00      	cmp	r3, #0
 8002796:	d018      	beq.n	80027ca <HAL_HCD_IRQHandler+0x1f2>
        {
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8002798:	697b      	ldr	r3, [r7, #20]
 800279a:	015a      	lsls	r2, r3, #5
 800279c:	68fb      	ldr	r3, [r7, #12]
 800279e:	4413      	add	r3, r2
 80027a0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80027a4:	681b      	ldr	r3, [r3, #0]
 80027a6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80027aa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80027ae:	d106      	bne.n	80027be <HAL_HCD_IRQHandler+0x1e6>
          {
            HCD_HC_IN_IRQHandler(hhcd, (uint8_t)i);
 80027b0:	697b      	ldr	r3, [r7, #20]
 80027b2:	b2db      	uxtb	r3, r3
 80027b4:	4619      	mov	r1, r3
 80027b6:	6878      	ldr	r0, [r7, #4]
 80027b8:	f000 f8ab 	bl	8002912 <HCD_HC_IN_IRQHandler>
 80027bc:	e005      	b.n	80027ca <HAL_HCD_IRQHandler+0x1f2>
          }
          else
          {
            HCD_HC_OUT_IRQHandler(hhcd, (uint8_t)i);
 80027be:	697b      	ldr	r3, [r7, #20]
 80027c0:	b2db      	uxtb	r3, r3
 80027c2:	4619      	mov	r1, r3
 80027c4:	6878      	ldr	r0, [r7, #4]
 80027c6:	f000 fcc6 	bl	8003156 <HCD_HC_OUT_IRQHandler>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 80027ca:	697b      	ldr	r3, [r7, #20]
 80027cc:	3301      	adds	r3, #1
 80027ce:	617b      	str	r3, [r7, #20]
 80027d0:	687b      	ldr	r3, [r7, #4]
 80027d2:	689b      	ldr	r3, [r3, #8]
 80027d4:	697a      	ldr	r2, [r7, #20]
 80027d6:	429a      	cmp	r2, r3
 80027d8:	d3d4      	bcc.n	8002784 <HAL_HCD_IRQHandler+0x1ac>
          }
        }
      }
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 80027da:	687b      	ldr	r3, [r7, #4]
 80027dc:	681b      	ldr	r3, [r3, #0]
 80027de:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80027e2:	615a      	str	r2, [r3, #20]
 80027e4:	e000      	b.n	80027e8 <HAL_HCD_IRQHandler+0x210>
      return;
 80027e6:	bf00      	nop
    }
  }
}
 80027e8:	3718      	adds	r7, #24
 80027ea:	46bd      	mov	sp, r7
 80027ec:	bd80      	pop	{r7, pc}

080027ee <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
 80027ee:	b580      	push	{r7, lr}
 80027f0:	b082      	sub	sp, #8
 80027f2:	af00      	add	r7, sp, #0
 80027f4:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	f893 32f8 	ldrb.w	r3, [r3, #760]	; 0x2f8
 80027fc:	2b01      	cmp	r3, #1
 80027fe:	d101      	bne.n	8002804 <HAL_HCD_Start+0x16>
 8002800:	2302      	movs	r3, #2
 8002802:	e013      	b.n	800282c <HAL_HCD_Start+0x3e>
 8002804:	687b      	ldr	r3, [r7, #4]
 8002806:	2201      	movs	r2, #1
 8002808:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8
  /* Enable port power */
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 800280c:	687b      	ldr	r3, [r7, #4]
 800280e:	681b      	ldr	r3, [r3, #0]
 8002810:	2101      	movs	r1, #1
 8002812:	4618      	mov	r0, r3
 8002814:	f002 fd0e 	bl	8005234 <USB_DriveVbus>

  /* Enable global interrupt */
  __HAL_HCD_ENABLE(hhcd);
 8002818:	687b      	ldr	r3, [r7, #4]
 800281a:	681b      	ldr	r3, [r3, #0]
 800281c:	4618      	mov	r0, r3
 800281e:	f002 fa54 	bl	8004cca <USB_EnableGlobalInt>
  __HAL_UNLOCK(hhcd);
 8002822:	687b      	ldr	r3, [r7, #4]
 8002824:	2200      	movs	r2, #0
 8002826:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8

  return HAL_OK;
 800282a:	2300      	movs	r3, #0
}
 800282c:	4618      	mov	r0, r3
 800282e:	3708      	adds	r7, #8
 8002830:	46bd      	mov	sp, r7
 8002832:	bd80      	pop	{r7, pc}

08002834 <HAL_HCD_Stop>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
 8002834:	b580      	push	{r7, lr}
 8002836:	b082      	sub	sp, #8
 8002838:	af00      	add	r7, sp, #0
 800283a:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hhcd);
 800283c:	687b      	ldr	r3, [r7, #4]
 800283e:	f893 32f8 	ldrb.w	r3, [r3, #760]	; 0x2f8
 8002842:	2b01      	cmp	r3, #1
 8002844:	d101      	bne.n	800284a <HAL_HCD_Stop+0x16>
 8002846:	2302      	movs	r3, #2
 8002848:	e00d      	b.n	8002866 <HAL_HCD_Stop+0x32>
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	2201      	movs	r2, #1
 800284e:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8
  (void)USB_StopHost(hhcd->Instance);
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	681b      	ldr	r3, [r3, #0]
 8002856:	4618      	mov	r0, r3
 8002858:	f003 f908 	bl	8005a6c <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800285c:	687b      	ldr	r3, [r7, #4]
 800285e:	2200      	movs	r2, #0
 8002860:	f883 22f8 	strb.w	r2, [r3, #760]	; 0x2f8

  return HAL_OK;
 8002864:	2300      	movs	r3, #0
}
 8002866:	4618      	mov	r0, r3
 8002868:	3708      	adds	r7, #8
 800286a:	46bd      	mov	sp, r7
 800286c:	bd80      	pop	{r7, pc}

0800286e <HAL_HCD_ResetPort>:
  * @brief  Reset the host port.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
 800286e:	b580      	push	{r7, lr}
 8002870:	b082      	sub	sp, #8
 8002872:	af00      	add	r7, sp, #0
 8002874:	6078      	str	r0, [r7, #4]
  return (USB_ResetPort(hhcd->Instance));
 8002876:	687b      	ldr	r3, [r7, #4]
 8002878:	681b      	ldr	r3, [r3, #0]
 800287a:	4618      	mov	r0, r3
 800287c:	f002 fcb0 	bl	80051e0 <USB_ResetPort>
 8002880:	4603      	mov	r3, r0
}
 8002882:	4618      	mov	r0, r3
 8002884:	3708      	adds	r7, #8
 8002886:	46bd      	mov	sp, r7
 8002888:	bd80      	pop	{r7, pc}

0800288a <HAL_HCD_HC_GetURBState>:
  *            URB_NYET/
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 800288a:	b480      	push	{r7}
 800288c:	b083      	sub	sp, #12
 800288e:	af00      	add	r7, sp, #0
 8002890:	6078      	str	r0, [r7, #4]
 8002892:	460b      	mov	r3, r1
 8002894:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].urb_state;
 8002896:	78fb      	ldrb	r3, [r7, #3]
 8002898:	687a      	ldr	r2, [r7, #4]
 800289a:	212c      	movs	r1, #44	; 0x2c
 800289c:	fb01 f303 	mul.w	r3, r1, r3
 80028a0:	4413      	add	r3, r2
 80028a2:	3360      	adds	r3, #96	; 0x60
 80028a4:	781b      	ldrb	r3, [r3, #0]
}
 80028a6:	4618      	mov	r0, r3
 80028a8:	370c      	adds	r7, #12
 80028aa:	46bd      	mov	sp, r7
 80028ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028b0:	4770      	bx	lr

080028b2 <HAL_HCD_HC_GetXferCount>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 80028b2:	b480      	push	{r7}
 80028b4:	b083      	sub	sp, #12
 80028b6:	af00      	add	r7, sp, #0
 80028b8:	6078      	str	r0, [r7, #4]
 80028ba:	460b      	mov	r3, r1
 80028bc:	70fb      	strb	r3, [r7, #3]
  return hhcd->hc[chnum].xfer_count;
 80028be:	78fb      	ldrb	r3, [r7, #3]
 80028c0:	687a      	ldr	r2, [r7, #4]
 80028c2:	212c      	movs	r1, #44	; 0x2c
 80028c4:	fb01 f303 	mul.w	r3, r1, r3
 80028c8:	4413      	add	r3, r2
 80028ca:	3350      	adds	r3, #80	; 0x50
 80028cc:	681b      	ldr	r3, [r3, #0]
}
 80028ce:	4618      	mov	r0, r3
 80028d0:	370c      	adds	r7, #12
 80028d2:	46bd      	mov	sp, r7
 80028d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028d8:	4770      	bx	lr

080028da <HAL_HCD_GetCurrentFrame>:
  * @brief  Return the current Host frame number.
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
 80028da:	b580      	push	{r7, lr}
 80028dc:	b082      	sub	sp, #8
 80028de:	af00      	add	r7, sp, #0
 80028e0:	6078      	str	r0, [r7, #4]
  return (USB_GetCurrentFrame(hhcd->Instance));
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	681b      	ldr	r3, [r3, #0]
 80028e6:	4618      	mov	r0, r3
 80028e8:	f002 fcf4 	bl	80052d4 <USB_GetCurrentFrame>
 80028ec:	4603      	mov	r3, r0
}
 80028ee:	4618      	mov	r0, r3
 80028f0:	3708      	adds	r7, #8
 80028f2:	46bd      	mov	sp, r7
 80028f4:	bd80      	pop	{r7, pc}

080028f6 <HAL_HCD_GetCurrentSpeed>:
  * @brief  Return the Host enumeration speed.
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
 80028f6:	b580      	push	{r7, lr}
 80028f8:	b082      	sub	sp, #8
 80028fa:	af00      	add	r7, sp, #0
 80028fc:	6078      	str	r0, [r7, #4]
  return (USB_GetHostSpeed(hhcd->Instance));
 80028fe:	687b      	ldr	r3, [r7, #4]
 8002900:	681b      	ldr	r3, [r3, #0]
 8002902:	4618      	mov	r0, r3
 8002904:	f002 fccf 	bl	80052a6 <USB_GetHostSpeed>
 8002908:	4603      	mov	r3, r0
}
 800290a:	4618      	mov	r0, r3
 800290c:	3708      	adds	r7, #8
 800290e:	46bd      	mov	sp, r7
 8002910:	bd80      	pop	{r7, pc}

08002912 <HCD_HC_IN_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8002912:	b580      	push	{r7, lr}
 8002914:	b086      	sub	sp, #24
 8002916:	af00      	add	r7, sp, #0
 8002918:	6078      	str	r0, [r7, #4]
 800291a:	460b      	mov	r3, r1
 800291c:	70fb      	strb	r3, [r7, #3]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800291e:	687b      	ldr	r3, [r7, #4]
 8002920:	681b      	ldr	r3, [r3, #0]
 8002922:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8002924:	697b      	ldr	r3, [r7, #20]
 8002926:	613b      	str	r3, [r7, #16]
  uint32_t ch_num = (uint32_t)chnum;
 8002928:	78fb      	ldrb	r3, [r7, #3]
 800292a:	60fb      	str	r3, [r7, #12]

  uint32_t tmpreg;

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 800292c:	68fb      	ldr	r3, [r7, #12]
 800292e:	015a      	lsls	r2, r3, #5
 8002930:	693b      	ldr	r3, [r7, #16]
 8002932:	4413      	add	r3, r2
 8002934:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002938:	689b      	ldr	r3, [r3, #8]
 800293a:	f003 0304 	and.w	r3, r3, #4
 800293e:	2b04      	cmp	r3, #4
 8002940:	d119      	bne.n	8002976 <HCD_HC_IN_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8002942:	68fb      	ldr	r3, [r7, #12]
 8002944:	015a      	lsls	r2, r3, #5
 8002946:	693b      	ldr	r3, [r7, #16]
 8002948:	4413      	add	r3, r2
 800294a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800294e:	461a      	mov	r2, r3
 8002950:	2304      	movs	r3, #4
 8002952:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002954:	68fb      	ldr	r3, [r7, #12]
 8002956:	015a      	lsls	r2, r3, #5
 8002958:	693b      	ldr	r3, [r7, #16]
 800295a:	4413      	add	r3, r2
 800295c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002960:	68db      	ldr	r3, [r3, #12]
 8002962:	68fa      	ldr	r2, [r7, #12]
 8002964:	0151      	lsls	r1, r2, #5
 8002966:	693a      	ldr	r2, [r7, #16]
 8002968:	440a      	add	r2, r1
 800296a:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800296e:	f043 0302 	orr.w	r3, r3, #2
 8002972:	60d3      	str	r3, [r2, #12]
 8002974:	e101      	b.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_BBERR) == USB_OTG_HCINT_BBERR)
 8002976:	68fb      	ldr	r3, [r7, #12]
 8002978:	015a      	lsls	r2, r3, #5
 800297a:	693b      	ldr	r3, [r7, #16]
 800297c:	4413      	add	r3, r2
 800297e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002982:	689b      	ldr	r3, [r3, #8]
 8002984:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002988:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800298c:	d12b      	bne.n	80029e6 <HCD_HC_IN_IRQHandler+0xd4>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_BBERR);
 800298e:	68fb      	ldr	r3, [r7, #12]
 8002990:	015a      	lsls	r2, r3, #5
 8002992:	693b      	ldr	r3, [r7, #16]
 8002994:	4413      	add	r3, r2
 8002996:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800299a:	461a      	mov	r2, r3
 800299c:	f44f 7380 	mov.w	r3, #256	; 0x100
 80029a0:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_BBLERR;
 80029a2:	687a      	ldr	r2, [r7, #4]
 80029a4:	68fb      	ldr	r3, [r7, #12]
 80029a6:	212c      	movs	r1, #44	; 0x2c
 80029a8:	fb01 f303 	mul.w	r3, r1, r3
 80029ac:	4413      	add	r3, r2
 80029ae:	3361      	adds	r3, #97	; 0x61
 80029b0:	2207      	movs	r2, #7
 80029b2:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80029b4:	68fb      	ldr	r3, [r7, #12]
 80029b6:	015a      	lsls	r2, r3, #5
 80029b8:	693b      	ldr	r3, [r7, #16]
 80029ba:	4413      	add	r3, r2
 80029bc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80029c0:	68db      	ldr	r3, [r3, #12]
 80029c2:	68fa      	ldr	r2, [r7, #12]
 80029c4:	0151      	lsls	r1, r2, #5
 80029c6:	693a      	ldr	r2, [r7, #16]
 80029c8:	440a      	add	r2, r1
 80029ca:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80029ce:	f043 0302 	orr.w	r3, r3, #2
 80029d2:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	68fa      	ldr	r2, [r7, #12]
 80029da:	b2d2      	uxtb	r2, r2
 80029dc:	4611      	mov	r1, r2
 80029de:	4618      	mov	r0, r3
 80029e0:	f002 feeb 	bl	80057ba <USB_HC_Halt>
 80029e4:	e0c9      	b.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 80029e6:	68fb      	ldr	r3, [r7, #12]
 80029e8:	015a      	lsls	r2, r3, #5
 80029ea:	693b      	ldr	r3, [r7, #16]
 80029ec:	4413      	add	r3, r2
 80029ee:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80029f2:	689b      	ldr	r3, [r3, #8]
 80029f4:	f003 0320 	and.w	r3, r3, #32
 80029f8:	2b20      	cmp	r3, #32
 80029fa:	d109      	bne.n	8002a10 <HCD_HC_IN_IRQHandler+0xfe>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 80029fc:	68fb      	ldr	r3, [r7, #12]
 80029fe:	015a      	lsls	r2, r3, #5
 8002a00:	693b      	ldr	r3, [r7, #16]
 8002a02:	4413      	add	r3, r2
 8002a04:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a08:	461a      	mov	r2, r3
 8002a0a:	2320      	movs	r3, #32
 8002a0c:	6093      	str	r3, [r2, #8]
 8002a0e:	e0b4      	b.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8002a10:	68fb      	ldr	r3, [r7, #12]
 8002a12:	015a      	lsls	r2, r3, #5
 8002a14:	693b      	ldr	r3, [r7, #16]
 8002a16:	4413      	add	r3, r2
 8002a18:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a1c:	689b      	ldr	r3, [r3, #8]
 8002a1e:	f003 0308 	and.w	r3, r3, #8
 8002a22:	2b08      	cmp	r3, #8
 8002a24:	d133      	bne.n	8002a8e <HCD_HC_IN_IRQHandler+0x17c>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002a26:	68fb      	ldr	r3, [r7, #12]
 8002a28:	015a      	lsls	r2, r3, #5
 8002a2a:	693b      	ldr	r3, [r7, #16]
 8002a2c:	4413      	add	r3, r2
 8002a2e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a32:	68db      	ldr	r3, [r3, #12]
 8002a34:	68fa      	ldr	r2, [r7, #12]
 8002a36:	0151      	lsls	r1, r2, #5
 8002a38:	693a      	ldr	r2, [r7, #16]
 8002a3a:	440a      	add	r2, r1
 8002a3c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002a40:	f043 0302 	orr.w	r3, r3, #2
 8002a44:	60d3      	str	r3, [r2, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8002a46:	687a      	ldr	r2, [r7, #4]
 8002a48:	68fb      	ldr	r3, [r7, #12]
 8002a4a:	212c      	movs	r1, #44	; 0x2c
 8002a4c:	fb01 f303 	mul.w	r3, r1, r3
 8002a50:	4413      	add	r3, r2
 8002a52:	3361      	adds	r3, #97	; 0x61
 8002a54:	2205      	movs	r2, #5
 8002a56:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002a58:	68fb      	ldr	r3, [r7, #12]
 8002a5a:	015a      	lsls	r2, r3, #5
 8002a5c:	693b      	ldr	r3, [r7, #16]
 8002a5e:	4413      	add	r3, r2
 8002a60:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a64:	461a      	mov	r2, r3
 8002a66:	2310      	movs	r3, #16
 8002a68:	6093      	str	r3, [r2, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8002a6a:	68fb      	ldr	r3, [r7, #12]
 8002a6c:	015a      	lsls	r2, r3, #5
 8002a6e:	693b      	ldr	r3, [r7, #16]
 8002a70:	4413      	add	r3, r2
 8002a72:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a76:	461a      	mov	r2, r3
 8002a78:	2308      	movs	r3, #8
 8002a7a:	6093      	str	r3, [r2, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	681b      	ldr	r3, [r3, #0]
 8002a80:	68fa      	ldr	r2, [r7, #12]
 8002a82:	b2d2      	uxtb	r2, r2
 8002a84:	4611      	mov	r1, r2
 8002a86:	4618      	mov	r0, r3
 8002a88:	f002 fe97 	bl	80057ba <USB_HC_Halt>
 8002a8c:	e075      	b.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8002a8e:	68fb      	ldr	r3, [r7, #12]
 8002a90:	015a      	lsls	r2, r3, #5
 8002a92:	693b      	ldr	r3, [r7, #16]
 8002a94:	4413      	add	r3, r2
 8002a96:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a9a:	689b      	ldr	r3, [r3, #8]
 8002a9c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002aa0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002aa4:	d134      	bne.n	8002b10 <HCD_HC_IN_IRQHandler+0x1fe>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002aa6:	68fb      	ldr	r3, [r7, #12]
 8002aa8:	015a      	lsls	r2, r3, #5
 8002aaa:	693b      	ldr	r3, [r7, #16]
 8002aac:	4413      	add	r3, r2
 8002aae:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002ab2:	68db      	ldr	r3, [r3, #12]
 8002ab4:	68fa      	ldr	r2, [r7, #12]
 8002ab6:	0151      	lsls	r1, r2, #5
 8002ab8:	693a      	ldr	r2, [r7, #16]
 8002aba:	440a      	add	r2, r1
 8002abc:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002ac0:	f043 0302 	orr.w	r3, r3, #2
 8002ac4:	60d3      	str	r3, [r2, #12]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8002ac6:	687a      	ldr	r2, [r7, #4]
 8002ac8:	68fb      	ldr	r3, [r7, #12]
 8002aca:	212c      	movs	r1, #44	; 0x2c
 8002acc:	fb01 f303 	mul.w	r3, r1, r3
 8002ad0:	4413      	add	r3, r2
 8002ad2:	3361      	adds	r3, #97	; 0x61
 8002ad4:	2208      	movs	r2, #8
 8002ad6:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002ad8:	68fb      	ldr	r3, [r7, #12]
 8002ada:	015a      	lsls	r2, r3, #5
 8002adc:	693b      	ldr	r3, [r7, #16]
 8002ade:	4413      	add	r3, r2
 8002ae0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002ae4:	461a      	mov	r2, r3
 8002ae6:	2310      	movs	r3, #16
 8002ae8:	6093      	str	r3, [r2, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002aea:	68fb      	ldr	r3, [r7, #12]
 8002aec:	015a      	lsls	r2, r3, #5
 8002aee:	693b      	ldr	r3, [r7, #16]
 8002af0:	4413      	add	r3, r2
 8002af2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002af6:	461a      	mov	r2, r3
 8002af8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002afc:	6093      	str	r3, [r2, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002afe:	687b      	ldr	r3, [r7, #4]
 8002b00:	681b      	ldr	r3, [r3, #0]
 8002b02:	68fa      	ldr	r2, [r7, #12]
 8002b04:	b2d2      	uxtb	r2, r2
 8002b06:	4611      	mov	r1, r2
 8002b08:	4618      	mov	r0, r3
 8002b0a:	f002 fe56 	bl	80057ba <USB_HC_Halt>
 8002b0e:	e034      	b.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8002b10:	68fb      	ldr	r3, [r7, #12]
 8002b12:	015a      	lsls	r2, r3, #5
 8002b14:	693b      	ldr	r3, [r7, #16]
 8002b16:	4413      	add	r3, r2
 8002b18:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b1c:	689b      	ldr	r3, [r3, #8]
 8002b1e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002b22:	2b80      	cmp	r3, #128	; 0x80
 8002b24:	d129      	bne.n	8002b7a <HCD_HC_IN_IRQHandler+0x268>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002b26:	68fb      	ldr	r3, [r7, #12]
 8002b28:	015a      	lsls	r2, r3, #5
 8002b2a:	693b      	ldr	r3, [r7, #16]
 8002b2c:	4413      	add	r3, r2
 8002b2e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b32:	68db      	ldr	r3, [r3, #12]
 8002b34:	68fa      	ldr	r2, [r7, #12]
 8002b36:	0151      	lsls	r1, r2, #5
 8002b38:	693a      	ldr	r2, [r7, #16]
 8002b3a:	440a      	add	r2, r1
 8002b3c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002b40:	f043 0302 	orr.w	r3, r3, #2
 8002b44:	60d3      	str	r3, [r2, #12]
    hhcd->hc[ch_num].state = HC_XACTERR;
 8002b46:	687a      	ldr	r2, [r7, #4]
 8002b48:	68fb      	ldr	r3, [r7, #12]
 8002b4a:	212c      	movs	r1, #44	; 0x2c
 8002b4c:	fb01 f303 	mul.w	r3, r1, r3
 8002b50:	4413      	add	r3, r2
 8002b52:	3361      	adds	r3, #97	; 0x61
 8002b54:	2206      	movs	r2, #6
 8002b56:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002b58:	687b      	ldr	r3, [r7, #4]
 8002b5a:	681b      	ldr	r3, [r3, #0]
 8002b5c:	68fa      	ldr	r2, [r7, #12]
 8002b5e:	b2d2      	uxtb	r2, r2
 8002b60:	4611      	mov	r1, r2
 8002b62:	4618      	mov	r0, r3
 8002b64:	f002 fe29 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8002b68:	68fb      	ldr	r3, [r7, #12]
 8002b6a:	015a      	lsls	r2, r3, #5
 8002b6c:	693b      	ldr	r3, [r7, #16]
 8002b6e:	4413      	add	r3, r2
 8002b70:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b74:	461a      	mov	r2, r3
 8002b76:	2380      	movs	r3, #128	; 0x80
 8002b78:	6093      	str	r3, [r2, #8]
  else
  {
    /* ... */
  }

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8002b7a:	68fb      	ldr	r3, [r7, #12]
 8002b7c:	015a      	lsls	r2, r3, #5
 8002b7e:	693b      	ldr	r3, [r7, #16]
 8002b80:	4413      	add	r3, r2
 8002b82:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b86:	689b      	ldr	r3, [r3, #8]
 8002b88:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002b8c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002b90:	d122      	bne.n	8002bd8 <HCD_HC_IN_IRQHandler+0x2c6>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002b92:	68fb      	ldr	r3, [r7, #12]
 8002b94:	015a      	lsls	r2, r3, #5
 8002b96:	693b      	ldr	r3, [r7, #16]
 8002b98:	4413      	add	r3, r2
 8002b9a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b9e:	68db      	ldr	r3, [r3, #12]
 8002ba0:	68fa      	ldr	r2, [r7, #12]
 8002ba2:	0151      	lsls	r1, r2, #5
 8002ba4:	693a      	ldr	r2, [r7, #16]
 8002ba6:	440a      	add	r2, r1
 8002ba8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002bac:	f043 0302 	orr.w	r3, r3, #2
 8002bb0:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002bb2:	687b      	ldr	r3, [r7, #4]
 8002bb4:	681b      	ldr	r3, [r3, #0]
 8002bb6:	68fa      	ldr	r2, [r7, #12]
 8002bb8:	b2d2      	uxtb	r2, r2
 8002bba:	4611      	mov	r1, r2
 8002bbc:	4618      	mov	r0, r3
 8002bbe:	f002 fdfc 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8002bc2:	68fb      	ldr	r3, [r7, #12]
 8002bc4:	015a      	lsls	r2, r3, #5
 8002bc6:	693b      	ldr	r3, [r7, #16]
 8002bc8:	4413      	add	r3, r2
 8002bca:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002bce:	461a      	mov	r2, r3
 8002bd0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002bd4:	6093      	str	r3, [r2, #8]
  }
  else
  {
    /* ... */
  }
}
 8002bd6:	e2ba      	b.n	800314e <HCD_HC_IN_IRQHandler+0x83c>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8002bd8:	68fb      	ldr	r3, [r7, #12]
 8002bda:	015a      	lsls	r2, r3, #5
 8002bdc:	693b      	ldr	r3, [r7, #16]
 8002bde:	4413      	add	r3, r2
 8002be0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002be4:	689b      	ldr	r3, [r3, #8]
 8002be6:	f003 0301 	and.w	r3, r3, #1
 8002bea:	2b01      	cmp	r3, #1
 8002bec:	f040 811b 	bne.w	8002e26 <HCD_HC_IN_IRQHandler+0x514>
    if (hhcd->Init.dma_enable != 0U)
 8002bf0:	687b      	ldr	r3, [r7, #4]
 8002bf2:	691b      	ldr	r3, [r3, #16]
 8002bf4:	2b00      	cmp	r3, #0
 8002bf6:	d019      	beq.n	8002c2c <HCD_HC_IN_IRQHandler+0x31a>
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].XferSize - \
 8002bf8:	687a      	ldr	r2, [r7, #4]
 8002bfa:	68fb      	ldr	r3, [r7, #12]
 8002bfc:	212c      	movs	r1, #44	; 0x2c
 8002bfe:	fb01 f303 	mul.w	r3, r1, r3
 8002c02:	4413      	add	r3, r2
 8002c04:	3348      	adds	r3, #72	; 0x48
 8002c06:	681a      	ldr	r2, [r3, #0]
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8002c08:	68fb      	ldr	r3, [r7, #12]
 8002c0a:	0159      	lsls	r1, r3, #5
 8002c0c:	693b      	ldr	r3, [r7, #16]
 8002c0e:	440b      	add	r3, r1
 8002c10:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c14:	691b      	ldr	r3, [r3, #16]
 8002c16:	f3c3 0312 	ubfx	r3, r3, #0, #19
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].XferSize - \
 8002c1a:	1ad2      	subs	r2, r2, r3
 8002c1c:	6879      	ldr	r1, [r7, #4]
 8002c1e:	68fb      	ldr	r3, [r7, #12]
 8002c20:	202c      	movs	r0, #44	; 0x2c
 8002c22:	fb00 f303 	mul.w	r3, r0, r3
 8002c26:	440b      	add	r3, r1
 8002c28:	3350      	adds	r3, #80	; 0x50
 8002c2a:	601a      	str	r2, [r3, #0]
    hhcd->hc[ch_num].state = HC_XFRC;
 8002c2c:	687a      	ldr	r2, [r7, #4]
 8002c2e:	68fb      	ldr	r3, [r7, #12]
 8002c30:	212c      	movs	r1, #44	; 0x2c
 8002c32:	fb01 f303 	mul.w	r3, r1, r3
 8002c36:	4413      	add	r3, r2
 8002c38:	3361      	adds	r3, #97	; 0x61
 8002c3a:	2201      	movs	r2, #1
 8002c3c:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002c3e:	687a      	ldr	r2, [r7, #4]
 8002c40:	68fb      	ldr	r3, [r7, #12]
 8002c42:	212c      	movs	r1, #44	; 0x2c
 8002c44:	fb01 f303 	mul.w	r3, r1, r3
 8002c48:	4413      	add	r3, r2
 8002c4a:	335c      	adds	r3, #92	; 0x5c
 8002c4c:	2200      	movs	r2, #0
 8002c4e:	601a      	str	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8002c50:	68fb      	ldr	r3, [r7, #12]
 8002c52:	015a      	lsls	r2, r3, #5
 8002c54:	693b      	ldr	r3, [r7, #16]
 8002c56:	4413      	add	r3, r2
 8002c58:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c5c:	461a      	mov	r2, r3
 8002c5e:	2301      	movs	r3, #1
 8002c60:	6093      	str	r3, [r2, #8]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002c62:	687a      	ldr	r2, [r7, #4]
 8002c64:	68fb      	ldr	r3, [r7, #12]
 8002c66:	212c      	movs	r1, #44	; 0x2c
 8002c68:	fb01 f303 	mul.w	r3, r1, r3
 8002c6c:	4413      	add	r3, r2
 8002c6e:	333f      	adds	r3, #63	; 0x3f
 8002c70:	781b      	ldrb	r3, [r3, #0]
 8002c72:	2b00      	cmp	r3, #0
 8002c74:	d009      	beq.n	8002c8a <HCD_HC_IN_IRQHandler+0x378>
        (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
 8002c76:	687a      	ldr	r2, [r7, #4]
 8002c78:	68fb      	ldr	r3, [r7, #12]
 8002c7a:	212c      	movs	r1, #44	; 0x2c
 8002c7c:	fb01 f303 	mul.w	r3, r1, r3
 8002c80:	4413      	add	r3, r2
 8002c82:	333f      	adds	r3, #63	; 0x3f
 8002c84:	781b      	ldrb	r3, [r3, #0]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002c86:	2b02      	cmp	r3, #2
 8002c88:	d121      	bne.n	8002cce <HCD_HC_IN_IRQHandler+0x3bc>
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002c8a:	68fb      	ldr	r3, [r7, #12]
 8002c8c:	015a      	lsls	r2, r3, #5
 8002c8e:	693b      	ldr	r3, [r7, #16]
 8002c90:	4413      	add	r3, r2
 8002c92:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c96:	68db      	ldr	r3, [r3, #12]
 8002c98:	68fa      	ldr	r2, [r7, #12]
 8002c9a:	0151      	lsls	r1, r2, #5
 8002c9c:	693a      	ldr	r2, [r7, #16]
 8002c9e:	440a      	add	r2, r1
 8002ca0:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002ca4:	f043 0302 	orr.w	r3, r3, #2
 8002ca8:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002caa:	687b      	ldr	r3, [r7, #4]
 8002cac:	681b      	ldr	r3, [r3, #0]
 8002cae:	68fa      	ldr	r2, [r7, #12]
 8002cb0:	b2d2      	uxtb	r2, r2
 8002cb2:	4611      	mov	r1, r2
 8002cb4:	4618      	mov	r0, r3
 8002cb6:	f002 fd80 	bl	80057ba <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002cba:	68fb      	ldr	r3, [r7, #12]
 8002cbc:	015a      	lsls	r2, r3, #5
 8002cbe:	693b      	ldr	r3, [r7, #16]
 8002cc0:	4413      	add	r3, r2
 8002cc2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002cc6:	461a      	mov	r2, r3
 8002cc8:	2310      	movs	r3, #16
 8002cca:	6093      	str	r3, [r2, #8]
 8002ccc:	e066      	b.n	8002d9c <HCD_HC_IN_IRQHandler+0x48a>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8002cce:	687a      	ldr	r2, [r7, #4]
 8002cd0:	68fb      	ldr	r3, [r7, #12]
 8002cd2:	212c      	movs	r1, #44	; 0x2c
 8002cd4:	fb01 f303 	mul.w	r3, r1, r3
 8002cd8:	4413      	add	r3, r2
 8002cda:	333f      	adds	r3, #63	; 0x3f
 8002cdc:	781b      	ldrb	r3, [r3, #0]
 8002cde:	2b03      	cmp	r3, #3
 8002ce0:	d127      	bne.n	8002d32 <HCD_HC_IN_IRQHandler+0x420>
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8002ce2:	68fb      	ldr	r3, [r7, #12]
 8002ce4:	015a      	lsls	r2, r3, #5
 8002ce6:	693b      	ldr	r3, [r7, #16]
 8002ce8:	4413      	add	r3, r2
 8002cea:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002cee:	681b      	ldr	r3, [r3, #0]
 8002cf0:	68fa      	ldr	r2, [r7, #12]
 8002cf2:	0151      	lsls	r1, r2, #5
 8002cf4:	693a      	ldr	r2, [r7, #16]
 8002cf6:	440a      	add	r2, r1
 8002cf8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002cfc:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002d00:	6013      	str	r3, [r2, #0]
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8002d02:	687a      	ldr	r2, [r7, #4]
 8002d04:	68fb      	ldr	r3, [r7, #12]
 8002d06:	212c      	movs	r1, #44	; 0x2c
 8002d08:	fb01 f303 	mul.w	r3, r1, r3
 8002d0c:	4413      	add	r3, r2
 8002d0e:	3360      	adds	r3, #96	; 0x60
 8002d10:	2201      	movs	r2, #1
 8002d12:	701a      	strb	r2, [r3, #0]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002d14:	68fb      	ldr	r3, [r7, #12]
 8002d16:	b2d9      	uxtb	r1, r3
 8002d18:	687a      	ldr	r2, [r7, #4]
 8002d1a:	68fb      	ldr	r3, [r7, #12]
 8002d1c:	202c      	movs	r0, #44	; 0x2c
 8002d1e:	fb00 f303 	mul.w	r3, r0, r3
 8002d22:	4413      	add	r3, r2
 8002d24:	3360      	adds	r3, #96	; 0x60
 8002d26:	781b      	ldrb	r3, [r3, #0]
 8002d28:	461a      	mov	r2, r3
 8002d2a:	6878      	ldr	r0, [r7, #4]
 8002d2c:	f025 f838 	bl	8027da0 <HAL_HCD_HC_NotifyURBChange_Callback>
 8002d30:	e034      	b.n	8002d9c <HCD_HC_IN_IRQHandler+0x48a>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_ISOC)
 8002d32:	687a      	ldr	r2, [r7, #4]
 8002d34:	68fb      	ldr	r3, [r7, #12]
 8002d36:	212c      	movs	r1, #44	; 0x2c
 8002d38:	fb01 f303 	mul.w	r3, r1, r3
 8002d3c:	4413      	add	r3, r2
 8002d3e:	333f      	adds	r3, #63	; 0x3f
 8002d40:	781b      	ldrb	r3, [r3, #0]
 8002d42:	2b01      	cmp	r3, #1
 8002d44:	d12a      	bne.n	8002d9c <HCD_HC_IN_IRQHandler+0x48a>
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8002d46:	687a      	ldr	r2, [r7, #4]
 8002d48:	68fb      	ldr	r3, [r7, #12]
 8002d4a:	212c      	movs	r1, #44	; 0x2c
 8002d4c:	fb01 f303 	mul.w	r3, r1, r3
 8002d50:	4413      	add	r3, r2
 8002d52:	3360      	adds	r3, #96	; 0x60
 8002d54:	2201      	movs	r2, #1
 8002d56:	701a      	strb	r2, [r3, #0]
      hhcd->hc[ch_num].toggle_in ^= 1U;
 8002d58:	687a      	ldr	r2, [r7, #4]
 8002d5a:	68fb      	ldr	r3, [r7, #12]
 8002d5c:	212c      	movs	r1, #44	; 0x2c
 8002d5e:	fb01 f303 	mul.w	r3, r1, r3
 8002d62:	4413      	add	r3, r2
 8002d64:	3354      	adds	r3, #84	; 0x54
 8002d66:	781b      	ldrb	r3, [r3, #0]
 8002d68:	f083 0301 	eor.w	r3, r3, #1
 8002d6c:	b2d8      	uxtb	r0, r3
 8002d6e:	687a      	ldr	r2, [r7, #4]
 8002d70:	68fb      	ldr	r3, [r7, #12]
 8002d72:	212c      	movs	r1, #44	; 0x2c
 8002d74:	fb01 f303 	mul.w	r3, r1, r3
 8002d78:	4413      	add	r3, r2
 8002d7a:	3354      	adds	r3, #84	; 0x54
 8002d7c:	4602      	mov	r2, r0
 8002d7e:	701a      	strb	r2, [r3, #0]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8002d80:	68fb      	ldr	r3, [r7, #12]
 8002d82:	b2d9      	uxtb	r1, r3
 8002d84:	687a      	ldr	r2, [r7, #4]
 8002d86:	68fb      	ldr	r3, [r7, #12]
 8002d88:	202c      	movs	r0, #44	; 0x2c
 8002d8a:	fb00 f303 	mul.w	r3, r0, r3
 8002d8e:	4413      	add	r3, r2
 8002d90:	3360      	adds	r3, #96	; 0x60
 8002d92:	781b      	ldrb	r3, [r3, #0]
 8002d94:	461a      	mov	r2, r3
 8002d96:	6878      	ldr	r0, [r7, #4]
 8002d98:	f025 f802 	bl	8027da0 <HAL_HCD_HC_NotifyURBChange_Callback>
    if (hhcd->Init.dma_enable == 1U)
 8002d9c:	687b      	ldr	r3, [r7, #4]
 8002d9e:	691b      	ldr	r3, [r3, #16]
 8002da0:	2b01      	cmp	r3, #1
 8002da2:	d12b      	bne.n	8002dfc <HCD_HC_IN_IRQHandler+0x4ea>
      if (((hhcd->hc[ch_num].XferSize / hhcd->hc[ch_num].max_packet) & 1U) != 0U)
 8002da4:	687a      	ldr	r2, [r7, #4]
 8002da6:	68fb      	ldr	r3, [r7, #12]
 8002da8:	212c      	movs	r1, #44	; 0x2c
 8002daa:	fb01 f303 	mul.w	r3, r1, r3
 8002dae:	4413      	add	r3, r2
 8002db0:	3348      	adds	r3, #72	; 0x48
 8002db2:	681b      	ldr	r3, [r3, #0]
 8002db4:	6879      	ldr	r1, [r7, #4]
 8002db6:	68fa      	ldr	r2, [r7, #12]
 8002db8:	202c      	movs	r0, #44	; 0x2c
 8002dba:	fb00 f202 	mul.w	r2, r0, r2
 8002dbe:	440a      	add	r2, r1
 8002dc0:	3240      	adds	r2, #64	; 0x40
 8002dc2:	8812      	ldrh	r2, [r2, #0]
 8002dc4:	fbb3 f3f2 	udiv	r3, r3, r2
 8002dc8:	f003 0301 	and.w	r3, r3, #1
 8002dcc:	2b00      	cmp	r3, #0
 8002dce:	f000 81be 	beq.w	800314e <HCD_HC_IN_IRQHandler+0x83c>
        hhcd->hc[ch_num].toggle_in ^= 1U;
 8002dd2:	687a      	ldr	r2, [r7, #4]
 8002dd4:	68fb      	ldr	r3, [r7, #12]
 8002dd6:	212c      	movs	r1, #44	; 0x2c
 8002dd8:	fb01 f303 	mul.w	r3, r1, r3
 8002ddc:	4413      	add	r3, r2
 8002dde:	3354      	adds	r3, #84	; 0x54
 8002de0:	781b      	ldrb	r3, [r3, #0]
 8002de2:	f083 0301 	eor.w	r3, r3, #1
 8002de6:	b2d8      	uxtb	r0, r3
 8002de8:	687a      	ldr	r2, [r7, #4]
 8002dea:	68fb      	ldr	r3, [r7, #12]
 8002dec:	212c      	movs	r1, #44	; 0x2c
 8002dee:	fb01 f303 	mul.w	r3, r1, r3
 8002df2:	4413      	add	r3, r2
 8002df4:	3354      	adds	r3, #84	; 0x54
 8002df6:	4602      	mov	r2, r0
 8002df8:	701a      	strb	r2, [r3, #0]
}
 8002dfa:	e1a8      	b.n	800314e <HCD_HC_IN_IRQHandler+0x83c>
      hhcd->hc[ch_num].toggle_in ^= 1U;
 8002dfc:	687a      	ldr	r2, [r7, #4]
 8002dfe:	68fb      	ldr	r3, [r7, #12]
 8002e00:	212c      	movs	r1, #44	; 0x2c
 8002e02:	fb01 f303 	mul.w	r3, r1, r3
 8002e06:	4413      	add	r3, r2
 8002e08:	3354      	adds	r3, #84	; 0x54
 8002e0a:	781b      	ldrb	r3, [r3, #0]
 8002e0c:	f083 0301 	eor.w	r3, r3, #1
 8002e10:	b2d8      	uxtb	r0, r3
 8002e12:	687a      	ldr	r2, [r7, #4]
 8002e14:	68fb      	ldr	r3, [r7, #12]
 8002e16:	212c      	movs	r1, #44	; 0x2c
 8002e18:	fb01 f303 	mul.w	r3, r1, r3
 8002e1c:	4413      	add	r3, r2
 8002e1e:	3354      	adds	r3, #84	; 0x54
 8002e20:	4602      	mov	r2, r0
 8002e22:	701a      	strb	r2, [r3, #0]
}
 8002e24:	e193      	b.n	800314e <HCD_HC_IN_IRQHandler+0x83c>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 8002e26:	68fb      	ldr	r3, [r7, #12]
 8002e28:	015a      	lsls	r2, r3, #5
 8002e2a:	693b      	ldr	r3, [r7, #16]
 8002e2c:	4413      	add	r3, r2
 8002e2e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e32:	689b      	ldr	r3, [r3, #8]
 8002e34:	f003 0302 	and.w	r3, r3, #2
 8002e38:	2b02      	cmp	r3, #2
 8002e3a:	f040 8106 	bne.w	800304a <HCD_HC_IN_IRQHandler+0x738>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8002e3e:	68fb      	ldr	r3, [r7, #12]
 8002e40:	015a      	lsls	r2, r3, #5
 8002e42:	693b      	ldr	r3, [r7, #16]
 8002e44:	4413      	add	r3, r2
 8002e46:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e4a:	68db      	ldr	r3, [r3, #12]
 8002e4c:	68fa      	ldr	r2, [r7, #12]
 8002e4e:	0151      	lsls	r1, r2, #5
 8002e50:	693a      	ldr	r2, [r7, #16]
 8002e52:	440a      	add	r2, r1
 8002e54:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002e58:	f023 0302 	bic.w	r3, r3, #2
 8002e5c:	60d3      	str	r3, [r2, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002e5e:	687a      	ldr	r2, [r7, #4]
 8002e60:	68fb      	ldr	r3, [r7, #12]
 8002e62:	212c      	movs	r1, #44	; 0x2c
 8002e64:	fb01 f303 	mul.w	r3, r1, r3
 8002e68:	4413      	add	r3, r2
 8002e6a:	3361      	adds	r3, #97	; 0x61
 8002e6c:	781b      	ldrb	r3, [r3, #0]
 8002e6e:	2b01      	cmp	r3, #1
 8002e70:	d109      	bne.n	8002e86 <HCD_HC_IN_IRQHandler+0x574>
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8002e72:	687a      	ldr	r2, [r7, #4]
 8002e74:	68fb      	ldr	r3, [r7, #12]
 8002e76:	212c      	movs	r1, #44	; 0x2c
 8002e78:	fb01 f303 	mul.w	r3, r1, r3
 8002e7c:	4413      	add	r3, r2
 8002e7e:	3360      	adds	r3, #96	; 0x60
 8002e80:	2201      	movs	r2, #1
 8002e82:	701a      	strb	r2, [r3, #0]
 8002e84:	e0c9      	b.n	800301a <HCD_HC_IN_IRQHandler+0x708>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8002e86:	687a      	ldr	r2, [r7, #4]
 8002e88:	68fb      	ldr	r3, [r7, #12]
 8002e8a:	212c      	movs	r1, #44	; 0x2c
 8002e8c:	fb01 f303 	mul.w	r3, r1, r3
 8002e90:	4413      	add	r3, r2
 8002e92:	3361      	adds	r3, #97	; 0x61
 8002e94:	781b      	ldrb	r3, [r3, #0]
 8002e96:	2b05      	cmp	r3, #5
 8002e98:	d109      	bne.n	8002eae <HCD_HC_IN_IRQHandler+0x59c>
      hhcd->hc[ch_num].urb_state = URB_STALL;
 8002e9a:	687a      	ldr	r2, [r7, #4]
 8002e9c:	68fb      	ldr	r3, [r7, #12]
 8002e9e:	212c      	movs	r1, #44	; 0x2c
 8002ea0:	fb01 f303 	mul.w	r3, r1, r3
 8002ea4:	4413      	add	r3, r2
 8002ea6:	3360      	adds	r3, #96	; 0x60
 8002ea8:	2205      	movs	r2, #5
 8002eaa:	701a      	strb	r2, [r3, #0]
 8002eac:	e0b5      	b.n	800301a <HCD_HC_IN_IRQHandler+0x708>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002eae:	687a      	ldr	r2, [r7, #4]
 8002eb0:	68fb      	ldr	r3, [r7, #12]
 8002eb2:	212c      	movs	r1, #44	; 0x2c
 8002eb4:	fb01 f303 	mul.w	r3, r1, r3
 8002eb8:	4413      	add	r3, r2
 8002eba:	3361      	adds	r3, #97	; 0x61
 8002ebc:	781b      	ldrb	r3, [r3, #0]
 8002ebe:	2b06      	cmp	r3, #6
 8002ec0:	d009      	beq.n	8002ed6 <HCD_HC_IN_IRQHandler+0x5c4>
             (hhcd->hc[ch_num].state == HC_DATATGLERR))
 8002ec2:	687a      	ldr	r2, [r7, #4]
 8002ec4:	68fb      	ldr	r3, [r7, #12]
 8002ec6:	212c      	movs	r1, #44	; 0x2c
 8002ec8:	fb01 f303 	mul.w	r3, r1, r3
 8002ecc:	4413      	add	r3, r2
 8002ece:	3361      	adds	r3, #97	; 0x61
 8002ed0:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002ed2:	2b08      	cmp	r3, #8
 8002ed4:	d150      	bne.n	8002f78 <HCD_HC_IN_IRQHandler+0x666>
      hhcd->hc[ch_num].ErrCnt++;
 8002ed6:	687a      	ldr	r2, [r7, #4]
 8002ed8:	68fb      	ldr	r3, [r7, #12]
 8002eda:	212c      	movs	r1, #44	; 0x2c
 8002edc:	fb01 f303 	mul.w	r3, r1, r3
 8002ee0:	4413      	add	r3, r2
 8002ee2:	335c      	adds	r3, #92	; 0x5c
 8002ee4:	681b      	ldr	r3, [r3, #0]
 8002ee6:	1c5a      	adds	r2, r3, #1
 8002ee8:	6879      	ldr	r1, [r7, #4]
 8002eea:	68fb      	ldr	r3, [r7, #12]
 8002eec:	202c      	movs	r0, #44	; 0x2c
 8002eee:	fb00 f303 	mul.w	r3, r0, r3
 8002ef2:	440b      	add	r3, r1
 8002ef4:	335c      	adds	r3, #92	; 0x5c
 8002ef6:	601a      	str	r2, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002ef8:	687a      	ldr	r2, [r7, #4]
 8002efa:	68fb      	ldr	r3, [r7, #12]
 8002efc:	212c      	movs	r1, #44	; 0x2c
 8002efe:	fb01 f303 	mul.w	r3, r1, r3
 8002f02:	4413      	add	r3, r2
 8002f04:	335c      	adds	r3, #92	; 0x5c
 8002f06:	681b      	ldr	r3, [r3, #0]
 8002f08:	2b02      	cmp	r3, #2
 8002f0a:	d912      	bls.n	8002f32 <HCD_HC_IN_IRQHandler+0x620>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002f0c:	687a      	ldr	r2, [r7, #4]
 8002f0e:	68fb      	ldr	r3, [r7, #12]
 8002f10:	212c      	movs	r1, #44	; 0x2c
 8002f12:	fb01 f303 	mul.w	r3, r1, r3
 8002f16:	4413      	add	r3, r2
 8002f18:	335c      	adds	r3, #92	; 0x5c
 8002f1a:	2200      	movs	r2, #0
 8002f1c:	601a      	str	r2, [r3, #0]
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002f1e:	687a      	ldr	r2, [r7, #4]
 8002f20:	68fb      	ldr	r3, [r7, #12]
 8002f22:	212c      	movs	r1, #44	; 0x2c
 8002f24:	fb01 f303 	mul.w	r3, r1, r3
 8002f28:	4413      	add	r3, r2
 8002f2a:	3360      	adds	r3, #96	; 0x60
 8002f2c:	2204      	movs	r2, #4
 8002f2e:	701a      	strb	r2, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002f30:	e073      	b.n	800301a <HCD_HC_IN_IRQHandler+0x708>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002f32:	687a      	ldr	r2, [r7, #4]
 8002f34:	68fb      	ldr	r3, [r7, #12]
 8002f36:	212c      	movs	r1, #44	; 0x2c
 8002f38:	fb01 f303 	mul.w	r3, r1, r3
 8002f3c:	4413      	add	r3, r2
 8002f3e:	3360      	adds	r3, #96	; 0x60
 8002f40:	2202      	movs	r2, #2
 8002f42:	701a      	strb	r2, [r3, #0]
        tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002f44:	68fb      	ldr	r3, [r7, #12]
 8002f46:	015a      	lsls	r2, r3, #5
 8002f48:	693b      	ldr	r3, [r7, #16]
 8002f4a:	4413      	add	r3, r2
 8002f4c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002f50:	681b      	ldr	r3, [r3, #0]
 8002f52:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002f54:	68bb      	ldr	r3, [r7, #8]
 8002f56:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002f5a:	60bb      	str	r3, [r7, #8]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002f5c:	68bb      	ldr	r3, [r7, #8]
 8002f5e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002f62:	60bb      	str	r3, [r7, #8]
        USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002f64:	68fb      	ldr	r3, [r7, #12]
 8002f66:	015a      	lsls	r2, r3, #5
 8002f68:	693b      	ldr	r3, [r7, #16]
 8002f6a:	4413      	add	r3, r2
 8002f6c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002f70:	461a      	mov	r2, r3
 8002f72:	68bb      	ldr	r3, [r7, #8]
 8002f74:	6013      	str	r3, [r2, #0]
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 8002f76:	e050      	b.n	800301a <HCD_HC_IN_IRQHandler+0x708>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8002f78:	687a      	ldr	r2, [r7, #4]
 8002f7a:	68fb      	ldr	r3, [r7, #12]
 8002f7c:	212c      	movs	r1, #44	; 0x2c
 8002f7e:	fb01 f303 	mul.w	r3, r1, r3
 8002f82:	4413      	add	r3, r2
 8002f84:	3361      	adds	r3, #97	; 0x61
 8002f86:	781b      	ldrb	r3, [r3, #0]
 8002f88:	2b03      	cmp	r3, #3
 8002f8a:	d122      	bne.n	8002fd2 <HCD_HC_IN_IRQHandler+0x6c0>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8002f8c:	687a      	ldr	r2, [r7, #4]
 8002f8e:	68fb      	ldr	r3, [r7, #12]
 8002f90:	212c      	movs	r1, #44	; 0x2c
 8002f92:	fb01 f303 	mul.w	r3, r1, r3
 8002f96:	4413      	add	r3, r2
 8002f98:	3360      	adds	r3, #96	; 0x60
 8002f9a:	2202      	movs	r2, #2
 8002f9c:	701a      	strb	r2, [r3, #0]
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 8002f9e:	68fb      	ldr	r3, [r7, #12]
 8002fa0:	015a      	lsls	r2, r3, #5
 8002fa2:	693b      	ldr	r3, [r7, #16]
 8002fa4:	4413      	add	r3, r2
 8002fa6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002faa:	681b      	ldr	r3, [r3, #0]
 8002fac:	60bb      	str	r3, [r7, #8]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8002fae:	68bb      	ldr	r3, [r7, #8]
 8002fb0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002fb4:	60bb      	str	r3, [r7, #8]
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002fb6:	68bb      	ldr	r3, [r7, #8]
 8002fb8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002fbc:	60bb      	str	r3, [r7, #8]
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 8002fbe:	68fb      	ldr	r3, [r7, #12]
 8002fc0:	015a      	lsls	r2, r3, #5
 8002fc2:	693b      	ldr	r3, [r7, #16]
 8002fc4:	4413      	add	r3, r2
 8002fc6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002fca:	461a      	mov	r2, r3
 8002fcc:	68bb      	ldr	r3, [r7, #8]
 8002fce:	6013      	str	r3, [r2, #0]
 8002fd0:	e023      	b.n	800301a <HCD_HC_IN_IRQHandler+0x708>
    else if (hhcd->hc[ch_num].state == HC_BBLERR)
 8002fd2:	687a      	ldr	r2, [r7, #4]
 8002fd4:	68fb      	ldr	r3, [r7, #12]
 8002fd6:	212c      	movs	r1, #44	; 0x2c
 8002fd8:	fb01 f303 	mul.w	r3, r1, r3
 8002fdc:	4413      	add	r3, r2
 8002fde:	3361      	adds	r3, #97	; 0x61
 8002fe0:	781b      	ldrb	r3, [r3, #0]
 8002fe2:	2b07      	cmp	r3, #7
 8002fe4:	d119      	bne.n	800301a <HCD_HC_IN_IRQHandler+0x708>
      hhcd->hc[ch_num].ErrCnt++;
 8002fe6:	687a      	ldr	r2, [r7, #4]
 8002fe8:	68fb      	ldr	r3, [r7, #12]
 8002fea:	212c      	movs	r1, #44	; 0x2c
 8002fec:	fb01 f303 	mul.w	r3, r1, r3
 8002ff0:	4413      	add	r3, r2
 8002ff2:	335c      	adds	r3, #92	; 0x5c
 8002ff4:	681b      	ldr	r3, [r3, #0]
 8002ff6:	1c5a      	adds	r2, r3, #1
 8002ff8:	6879      	ldr	r1, [r7, #4]
 8002ffa:	68fb      	ldr	r3, [r7, #12]
 8002ffc:	202c      	movs	r0, #44	; 0x2c
 8002ffe:	fb00 f303 	mul.w	r3, r0, r3
 8003002:	440b      	add	r3, r1
 8003004:	335c      	adds	r3, #92	; 0x5c
 8003006:	601a      	str	r2, [r3, #0]
      hhcd->hc[ch_num].urb_state = URB_ERROR;
 8003008:	687a      	ldr	r2, [r7, #4]
 800300a:	68fb      	ldr	r3, [r7, #12]
 800300c:	212c      	movs	r1, #44	; 0x2c
 800300e:	fb01 f303 	mul.w	r3, r1, r3
 8003012:	4413      	add	r3, r2
 8003014:	3360      	adds	r3, #96	; 0x60
 8003016:	2204      	movs	r2, #4
 8003018:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 800301a:	68fb      	ldr	r3, [r7, #12]
 800301c:	015a      	lsls	r2, r3, #5
 800301e:	693b      	ldr	r3, [r7, #16]
 8003020:	4413      	add	r3, r2
 8003022:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003026:	461a      	mov	r2, r3
 8003028:	2302      	movs	r3, #2
 800302a:	6093      	str	r3, [r2, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 800302c:	68fb      	ldr	r3, [r7, #12]
 800302e:	b2d9      	uxtb	r1, r3
 8003030:	687a      	ldr	r2, [r7, #4]
 8003032:	68fb      	ldr	r3, [r7, #12]
 8003034:	202c      	movs	r0, #44	; 0x2c
 8003036:	fb00 f303 	mul.w	r3, r0, r3
 800303a:	4413      	add	r3, r2
 800303c:	3360      	adds	r3, #96	; 0x60
 800303e:	781b      	ldrb	r3, [r3, #0]
 8003040:	461a      	mov	r2, r3
 8003042:	6878      	ldr	r0, [r7, #4]
 8003044:	f024 feac 	bl	8027da0 <HAL_HCD_HC_NotifyURBChange_Callback>
}
 8003048:	e081      	b.n	800314e <HCD_HC_IN_IRQHandler+0x83c>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 800304a:	68fb      	ldr	r3, [r7, #12]
 800304c:	015a      	lsls	r2, r3, #5
 800304e:	693b      	ldr	r3, [r7, #16]
 8003050:	4413      	add	r3, r2
 8003052:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003056:	689b      	ldr	r3, [r3, #8]
 8003058:	f003 0310 	and.w	r3, r3, #16
 800305c:	2b10      	cmp	r3, #16
 800305e:	d176      	bne.n	800314e <HCD_HC_IN_IRQHandler+0x83c>
    if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8003060:	687a      	ldr	r2, [r7, #4]
 8003062:	68fb      	ldr	r3, [r7, #12]
 8003064:	212c      	movs	r1, #44	; 0x2c
 8003066:	fb01 f303 	mul.w	r3, r1, r3
 800306a:	4413      	add	r3, r2
 800306c:	333f      	adds	r3, #63	; 0x3f
 800306e:	781b      	ldrb	r3, [r3, #0]
 8003070:	2b03      	cmp	r3, #3
 8003072:	d121      	bne.n	80030b8 <HCD_HC_IN_IRQHandler+0x7a6>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8003074:	687a      	ldr	r2, [r7, #4]
 8003076:	68fb      	ldr	r3, [r7, #12]
 8003078:	212c      	movs	r1, #44	; 0x2c
 800307a:	fb01 f303 	mul.w	r3, r1, r3
 800307e:	4413      	add	r3, r2
 8003080:	335c      	adds	r3, #92	; 0x5c
 8003082:	2200      	movs	r2, #0
 8003084:	601a      	str	r2, [r3, #0]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8003086:	68fb      	ldr	r3, [r7, #12]
 8003088:	015a      	lsls	r2, r3, #5
 800308a:	693b      	ldr	r3, [r7, #16]
 800308c:	4413      	add	r3, r2
 800308e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003092:	68db      	ldr	r3, [r3, #12]
 8003094:	68fa      	ldr	r2, [r7, #12]
 8003096:	0151      	lsls	r1, r2, #5
 8003098:	693a      	ldr	r2, [r7, #16]
 800309a:	440a      	add	r2, r1
 800309c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80030a0:	f043 0302 	orr.w	r3, r3, #2
 80030a4:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80030a6:	687b      	ldr	r3, [r7, #4]
 80030a8:	681b      	ldr	r3, [r3, #0]
 80030aa:	68fa      	ldr	r2, [r7, #12]
 80030ac:	b2d2      	uxtb	r2, r2
 80030ae:	4611      	mov	r1, r2
 80030b0:	4618      	mov	r0, r3
 80030b2:	f002 fb82 	bl	80057ba <USB_HC_Halt>
 80030b6:	e041      	b.n	800313c <HCD_HC_IN_IRQHandler+0x82a>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 80030b8:	687a      	ldr	r2, [r7, #4]
 80030ba:	68fb      	ldr	r3, [r7, #12]
 80030bc:	212c      	movs	r1, #44	; 0x2c
 80030be:	fb01 f303 	mul.w	r3, r1, r3
 80030c2:	4413      	add	r3, r2
 80030c4:	333f      	adds	r3, #63	; 0x3f
 80030c6:	781b      	ldrb	r3, [r3, #0]
 80030c8:	2b00      	cmp	r3, #0
 80030ca:	d009      	beq.n	80030e0 <HCD_HC_IN_IRQHandler+0x7ce>
             (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
 80030cc:	687a      	ldr	r2, [r7, #4]
 80030ce:	68fb      	ldr	r3, [r7, #12]
 80030d0:	212c      	movs	r1, #44	; 0x2c
 80030d2:	fb01 f303 	mul.w	r3, r1, r3
 80030d6:	4413      	add	r3, r2
 80030d8:	333f      	adds	r3, #63	; 0x3f
 80030da:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 80030dc:	2b02      	cmp	r3, #2
 80030de:	d12d      	bne.n	800313c <HCD_HC_IN_IRQHandler+0x82a>
      hhcd->hc[ch_num].ErrCnt = 0U;
 80030e0:	687a      	ldr	r2, [r7, #4]
 80030e2:	68fb      	ldr	r3, [r7, #12]
 80030e4:	212c      	movs	r1, #44	; 0x2c
 80030e6:	fb01 f303 	mul.w	r3, r1, r3
 80030ea:	4413      	add	r3, r2
 80030ec:	335c      	adds	r3, #92	; 0x5c
 80030ee:	2200      	movs	r2, #0
 80030f0:	601a      	str	r2, [r3, #0]
      if (hhcd->Init.dma_enable == 0U)
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	691b      	ldr	r3, [r3, #16]
 80030f6:	2b00      	cmp	r3, #0
 80030f8:	d120      	bne.n	800313c <HCD_HC_IN_IRQHandler+0x82a>
        hhcd->hc[ch_num].state = HC_NAK;
 80030fa:	687a      	ldr	r2, [r7, #4]
 80030fc:	68fb      	ldr	r3, [r7, #12]
 80030fe:	212c      	movs	r1, #44	; 0x2c
 8003100:	fb01 f303 	mul.w	r3, r1, r3
 8003104:	4413      	add	r3, r2
 8003106:	3361      	adds	r3, #97	; 0x61
 8003108:	2203      	movs	r2, #3
 800310a:	701a      	strb	r2, [r3, #0]
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800310c:	68fb      	ldr	r3, [r7, #12]
 800310e:	015a      	lsls	r2, r3, #5
 8003110:	693b      	ldr	r3, [r7, #16]
 8003112:	4413      	add	r3, r2
 8003114:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003118:	68db      	ldr	r3, [r3, #12]
 800311a:	68fa      	ldr	r2, [r7, #12]
 800311c:	0151      	lsls	r1, r2, #5
 800311e:	693a      	ldr	r2, [r7, #16]
 8003120:	440a      	add	r2, r1
 8003122:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003126:	f043 0302 	orr.w	r3, r3, #2
 800312a:	60d3      	str	r3, [r2, #12]
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800312c:	687b      	ldr	r3, [r7, #4]
 800312e:	681b      	ldr	r3, [r3, #0]
 8003130:	68fa      	ldr	r2, [r7, #12]
 8003132:	b2d2      	uxtb	r2, r2
 8003134:	4611      	mov	r1, r2
 8003136:	4618      	mov	r0, r3
 8003138:	f002 fb3f 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 800313c:	68fb      	ldr	r3, [r7, #12]
 800313e:	015a      	lsls	r2, r3, #5
 8003140:	693b      	ldr	r3, [r7, #16]
 8003142:	4413      	add	r3, r2
 8003144:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003148:	461a      	mov	r2, r3
 800314a:	2310      	movs	r3, #16
 800314c:	6093      	str	r3, [r2, #8]
}
 800314e:	bf00      	nop
 8003150:	3718      	adds	r7, #24
 8003152:	46bd      	mov	sp, r7
 8003154:	bd80      	pop	{r7, pc}

08003156 <HCD_HC_OUT_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8003156:	b580      	push	{r7, lr}
 8003158:	b088      	sub	sp, #32
 800315a:	af00      	add	r7, sp, #0
 800315c:	6078      	str	r0, [r7, #4]
 800315e:	460b      	mov	r3, r1
 8003160:	70fb      	strb	r3, [r7, #3]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8003162:	687b      	ldr	r3, [r7, #4]
 8003164:	681b      	ldr	r3, [r3, #0]
 8003166:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003168:	69fb      	ldr	r3, [r7, #28]
 800316a:	61bb      	str	r3, [r7, #24]
  uint32_t ch_num = (uint32_t)chnum;
 800316c:	78fb      	ldrb	r3, [r7, #3]
 800316e:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t num_packets;

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8003170:	697b      	ldr	r3, [r7, #20]
 8003172:	015a      	lsls	r2, r3, #5
 8003174:	69bb      	ldr	r3, [r7, #24]
 8003176:	4413      	add	r3, r2
 8003178:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800317c:	689b      	ldr	r3, [r3, #8]
 800317e:	f003 0304 	and.w	r3, r3, #4
 8003182:	2b04      	cmp	r3, #4
 8003184:	d119      	bne.n	80031ba <HCD_HC_OUT_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8003186:	697b      	ldr	r3, [r7, #20]
 8003188:	015a      	lsls	r2, r3, #5
 800318a:	69bb      	ldr	r3, [r7, #24]
 800318c:	4413      	add	r3, r2
 800318e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003192:	461a      	mov	r2, r3
 8003194:	2304      	movs	r3, #4
 8003196:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8003198:	697b      	ldr	r3, [r7, #20]
 800319a:	015a      	lsls	r2, r3, #5
 800319c:	69bb      	ldr	r3, [r7, #24]
 800319e:	4413      	add	r3, r2
 80031a0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80031a4:	68db      	ldr	r3, [r3, #12]
 80031a6:	697a      	ldr	r2, [r7, #20]
 80031a8:	0151      	lsls	r1, r2, #5
 80031aa:	69ba      	ldr	r2, [r7, #24]
 80031ac:	440a      	add	r2, r1
 80031ae:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80031b2:	f043 0302 	orr.w	r3, r3, #2
 80031b6:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    /* ... */
  }
}
 80031b8:	e3ca      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 80031ba:	697b      	ldr	r3, [r7, #20]
 80031bc:	015a      	lsls	r2, r3, #5
 80031be:	69bb      	ldr	r3, [r7, #24]
 80031c0:	4413      	add	r3, r2
 80031c2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80031c6:	689b      	ldr	r3, [r3, #8]
 80031c8:	f003 0320 	and.w	r3, r3, #32
 80031cc:	2b20      	cmp	r3, #32
 80031ce:	d13e      	bne.n	800324e <HCD_HC_OUT_IRQHandler+0xf8>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 80031d0:	697b      	ldr	r3, [r7, #20]
 80031d2:	015a      	lsls	r2, r3, #5
 80031d4:	69bb      	ldr	r3, [r7, #24]
 80031d6:	4413      	add	r3, r2
 80031d8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80031dc:	461a      	mov	r2, r3
 80031de:	2320      	movs	r3, #32
 80031e0:	6093      	str	r3, [r2, #8]
    if (hhcd->hc[ch_num].do_ping == 1U)
 80031e2:	687a      	ldr	r2, [r7, #4]
 80031e4:	697b      	ldr	r3, [r7, #20]
 80031e6:	212c      	movs	r1, #44	; 0x2c
 80031e8:	fb01 f303 	mul.w	r3, r1, r3
 80031ec:	4413      	add	r3, r2
 80031ee:	333d      	adds	r3, #61	; 0x3d
 80031f0:	781b      	ldrb	r3, [r3, #0]
 80031f2:	2b01      	cmp	r3, #1
 80031f4:	f040 83ac 	bne.w	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
      hhcd->hc[ch_num].do_ping = 0U;
 80031f8:	687a      	ldr	r2, [r7, #4]
 80031fa:	697b      	ldr	r3, [r7, #20]
 80031fc:	212c      	movs	r1, #44	; 0x2c
 80031fe:	fb01 f303 	mul.w	r3, r1, r3
 8003202:	4413      	add	r3, r2
 8003204:	333d      	adds	r3, #61	; 0x3d
 8003206:	2200      	movs	r2, #0
 8003208:	701a      	strb	r2, [r3, #0]
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 800320a:	687a      	ldr	r2, [r7, #4]
 800320c:	697b      	ldr	r3, [r7, #20]
 800320e:	212c      	movs	r1, #44	; 0x2c
 8003210:	fb01 f303 	mul.w	r3, r1, r3
 8003214:	4413      	add	r3, r2
 8003216:	3360      	adds	r3, #96	; 0x60
 8003218:	2202      	movs	r2, #2
 800321a:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800321c:	697b      	ldr	r3, [r7, #20]
 800321e:	015a      	lsls	r2, r3, #5
 8003220:	69bb      	ldr	r3, [r7, #24]
 8003222:	4413      	add	r3, r2
 8003224:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003228:	68db      	ldr	r3, [r3, #12]
 800322a:	697a      	ldr	r2, [r7, #20]
 800322c:	0151      	lsls	r1, r2, #5
 800322e:	69ba      	ldr	r2, [r7, #24]
 8003230:	440a      	add	r2, r1
 8003232:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003236:	f043 0302 	orr.w	r3, r3, #2
 800323a:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800323c:	687b      	ldr	r3, [r7, #4]
 800323e:	681b      	ldr	r3, [r3, #0]
 8003240:	697a      	ldr	r2, [r7, #20]
 8003242:	b2d2      	uxtb	r2, r2
 8003244:	4611      	mov	r1, r2
 8003246:	4618      	mov	r0, r3
 8003248:	f002 fab7 	bl	80057ba <USB_HC_Halt>
}
 800324c:	e380      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 800324e:	697b      	ldr	r3, [r7, #20]
 8003250:	015a      	lsls	r2, r3, #5
 8003252:	69bb      	ldr	r3, [r7, #24]
 8003254:	4413      	add	r3, r2
 8003256:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800325a:	689b      	ldr	r3, [r3, #8]
 800325c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8003260:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003264:	d122      	bne.n	80032ac <HCD_HC_OUT_IRQHandler+0x156>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8003266:	697b      	ldr	r3, [r7, #20]
 8003268:	015a      	lsls	r2, r3, #5
 800326a:	69bb      	ldr	r3, [r7, #24]
 800326c:	4413      	add	r3, r2
 800326e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003272:	68db      	ldr	r3, [r3, #12]
 8003274:	697a      	ldr	r2, [r7, #20]
 8003276:	0151      	lsls	r1, r2, #5
 8003278:	69ba      	ldr	r2, [r7, #24]
 800327a:	440a      	add	r2, r1
 800327c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003280:	f043 0302 	orr.w	r3, r3, #2
 8003284:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8003286:	687b      	ldr	r3, [r7, #4]
 8003288:	681b      	ldr	r3, [r3, #0]
 800328a:	697a      	ldr	r2, [r7, #20]
 800328c:	b2d2      	uxtb	r2, r2
 800328e:	4611      	mov	r1, r2
 8003290:	4618      	mov	r0, r3
 8003292:	f002 fa92 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8003296:	697b      	ldr	r3, [r7, #20]
 8003298:	015a      	lsls	r2, r3, #5
 800329a:	69bb      	ldr	r3, [r7, #24]
 800329c:	4413      	add	r3, r2
 800329e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80032a2:	461a      	mov	r2, r3
 80032a4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80032a8:	6093      	str	r3, [r2, #8]
}
 80032aa:	e351      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 80032ac:	697b      	ldr	r3, [r7, #20]
 80032ae:	015a      	lsls	r2, r3, #5
 80032b0:	69bb      	ldr	r3, [r7, #24]
 80032b2:	4413      	add	r3, r2
 80032b4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80032b8:	689b      	ldr	r3, [r3, #8]
 80032ba:	f003 0301 	and.w	r3, r3, #1
 80032be:	2b01      	cmp	r3, #1
 80032c0:	d150      	bne.n	8003364 <HCD_HC_OUT_IRQHandler+0x20e>
    hhcd->hc[ch_num].ErrCnt = 0U;
 80032c2:	687a      	ldr	r2, [r7, #4]
 80032c4:	697b      	ldr	r3, [r7, #20]
 80032c6:	212c      	movs	r1, #44	; 0x2c
 80032c8:	fb01 f303 	mul.w	r3, r1, r3
 80032cc:	4413      	add	r3, r2
 80032ce:	335c      	adds	r3, #92	; 0x5c
 80032d0:	2200      	movs	r2, #0
 80032d2:	601a      	str	r2, [r3, #0]
    if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
 80032d4:	697b      	ldr	r3, [r7, #20]
 80032d6:	015a      	lsls	r2, r3, #5
 80032d8:	69bb      	ldr	r3, [r7, #24]
 80032da:	4413      	add	r3, r2
 80032dc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80032e0:	689b      	ldr	r3, [r3, #8]
 80032e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80032e6:	2b40      	cmp	r3, #64	; 0x40
 80032e8:	d111      	bne.n	800330e <HCD_HC_OUT_IRQHandler+0x1b8>
      hhcd->hc[ch_num].do_ping = 1U;
 80032ea:	687a      	ldr	r2, [r7, #4]
 80032ec:	697b      	ldr	r3, [r7, #20]
 80032ee:	212c      	movs	r1, #44	; 0x2c
 80032f0:	fb01 f303 	mul.w	r3, r1, r3
 80032f4:	4413      	add	r3, r2
 80032f6:	333d      	adds	r3, #61	; 0x3d
 80032f8:	2201      	movs	r2, #1
 80032fa:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 80032fc:	697b      	ldr	r3, [r7, #20]
 80032fe:	015a      	lsls	r2, r3, #5
 8003300:	69bb      	ldr	r3, [r7, #24]
 8003302:	4413      	add	r3, r2
 8003304:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003308:	461a      	mov	r2, r3
 800330a:	2340      	movs	r3, #64	; 0x40
 800330c:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800330e:	697b      	ldr	r3, [r7, #20]
 8003310:	015a      	lsls	r2, r3, #5
 8003312:	69bb      	ldr	r3, [r7, #24]
 8003314:	4413      	add	r3, r2
 8003316:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800331a:	68db      	ldr	r3, [r3, #12]
 800331c:	697a      	ldr	r2, [r7, #20]
 800331e:	0151      	lsls	r1, r2, #5
 8003320:	69ba      	ldr	r2, [r7, #24]
 8003322:	440a      	add	r2, r1
 8003324:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003328:	f043 0302 	orr.w	r3, r3, #2
 800332c:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800332e:	687b      	ldr	r3, [r7, #4]
 8003330:	681b      	ldr	r3, [r3, #0]
 8003332:	697a      	ldr	r2, [r7, #20]
 8003334:	b2d2      	uxtb	r2, r2
 8003336:	4611      	mov	r1, r2
 8003338:	4618      	mov	r0, r3
 800333a:	f002 fa3e 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 800333e:	697b      	ldr	r3, [r7, #20]
 8003340:	015a      	lsls	r2, r3, #5
 8003342:	69bb      	ldr	r3, [r7, #24]
 8003344:	4413      	add	r3, r2
 8003346:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800334a:	461a      	mov	r2, r3
 800334c:	2301      	movs	r3, #1
 800334e:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_XFRC;
 8003350:	687a      	ldr	r2, [r7, #4]
 8003352:	697b      	ldr	r3, [r7, #20]
 8003354:	212c      	movs	r1, #44	; 0x2c
 8003356:	fb01 f303 	mul.w	r3, r1, r3
 800335a:	4413      	add	r3, r2
 800335c:	3361      	adds	r3, #97	; 0x61
 800335e:	2201      	movs	r2, #1
 8003360:	701a      	strb	r2, [r3, #0]
}
 8003362:	e2f5      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
 8003364:	697b      	ldr	r3, [r7, #20]
 8003366:	015a      	lsls	r2, r3, #5
 8003368:	69bb      	ldr	r3, [r7, #24]
 800336a:	4413      	add	r3, r2
 800336c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003370:	689b      	ldr	r3, [r3, #8]
 8003372:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003376:	2b40      	cmp	r3, #64	; 0x40
 8003378:	d13c      	bne.n	80033f4 <HCD_HC_OUT_IRQHandler+0x29e>
    hhcd->hc[ch_num].state = HC_NYET;
 800337a:	687a      	ldr	r2, [r7, #4]
 800337c:	697b      	ldr	r3, [r7, #20]
 800337e:	212c      	movs	r1, #44	; 0x2c
 8003380:	fb01 f303 	mul.w	r3, r1, r3
 8003384:	4413      	add	r3, r2
 8003386:	3361      	adds	r3, #97	; 0x61
 8003388:	2204      	movs	r2, #4
 800338a:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].do_ping = 1U;
 800338c:	687a      	ldr	r2, [r7, #4]
 800338e:	697b      	ldr	r3, [r7, #20]
 8003390:	212c      	movs	r1, #44	; 0x2c
 8003392:	fb01 f303 	mul.w	r3, r1, r3
 8003396:	4413      	add	r3, r2
 8003398:	333d      	adds	r3, #61	; 0x3d
 800339a:	2201      	movs	r2, #1
 800339c:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].ErrCnt = 0U;
 800339e:	687a      	ldr	r2, [r7, #4]
 80033a0:	697b      	ldr	r3, [r7, #20]
 80033a2:	212c      	movs	r1, #44	; 0x2c
 80033a4:	fb01 f303 	mul.w	r3, r1, r3
 80033a8:	4413      	add	r3, r2
 80033aa:	335c      	adds	r3, #92	; 0x5c
 80033ac:	2200      	movs	r2, #0
 80033ae:	601a      	str	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80033b0:	697b      	ldr	r3, [r7, #20]
 80033b2:	015a      	lsls	r2, r3, #5
 80033b4:	69bb      	ldr	r3, [r7, #24]
 80033b6:	4413      	add	r3, r2
 80033b8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80033bc:	68db      	ldr	r3, [r3, #12]
 80033be:	697a      	ldr	r2, [r7, #20]
 80033c0:	0151      	lsls	r1, r2, #5
 80033c2:	69ba      	ldr	r2, [r7, #24]
 80033c4:	440a      	add	r2, r1
 80033c6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80033ca:	f043 0302 	orr.w	r3, r3, #2
 80033ce:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80033d0:	687b      	ldr	r3, [r7, #4]
 80033d2:	681b      	ldr	r3, [r3, #0]
 80033d4:	697a      	ldr	r2, [r7, #20]
 80033d6:	b2d2      	uxtb	r2, r2
 80033d8:	4611      	mov	r1, r2
 80033da:	4618      	mov	r0, r3
 80033dc:	f002 f9ed 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 80033e0:	697b      	ldr	r3, [r7, #20]
 80033e2:	015a      	lsls	r2, r3, #5
 80033e4:	69bb      	ldr	r3, [r7, #24]
 80033e6:	4413      	add	r3, r2
 80033e8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80033ec:	461a      	mov	r2, r3
 80033ee:	2340      	movs	r3, #64	; 0x40
 80033f0:	6093      	str	r3, [r2, #8]
}
 80033f2:	e2ad      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 80033f4:	697b      	ldr	r3, [r7, #20]
 80033f6:	015a      	lsls	r2, r3, #5
 80033f8:	69bb      	ldr	r3, [r7, #24]
 80033fa:	4413      	add	r3, r2
 80033fc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003400:	689b      	ldr	r3, [r3, #8]
 8003402:	f003 0308 	and.w	r3, r3, #8
 8003406:	2b08      	cmp	r3, #8
 8003408:	d12a      	bne.n	8003460 <HCD_HC_OUT_IRQHandler+0x30a>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 800340a:	697b      	ldr	r3, [r7, #20]
 800340c:	015a      	lsls	r2, r3, #5
 800340e:	69bb      	ldr	r3, [r7, #24]
 8003410:	4413      	add	r3, r2
 8003412:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003416:	461a      	mov	r2, r3
 8003418:	2308      	movs	r3, #8
 800341a:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800341c:	697b      	ldr	r3, [r7, #20]
 800341e:	015a      	lsls	r2, r3, #5
 8003420:	69bb      	ldr	r3, [r7, #24]
 8003422:	4413      	add	r3, r2
 8003424:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003428:	68db      	ldr	r3, [r3, #12]
 800342a:	697a      	ldr	r2, [r7, #20]
 800342c:	0151      	lsls	r1, r2, #5
 800342e:	69ba      	ldr	r2, [r7, #24]
 8003430:	440a      	add	r2, r1
 8003432:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003436:	f043 0302 	orr.w	r3, r3, #2
 800343a:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800343c:	687b      	ldr	r3, [r7, #4]
 800343e:	681b      	ldr	r3, [r3, #0]
 8003440:	697a      	ldr	r2, [r7, #20]
 8003442:	b2d2      	uxtb	r2, r2
 8003444:	4611      	mov	r1, r2
 8003446:	4618      	mov	r0, r3
 8003448:	f002 f9b7 	bl	80057ba <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_STALL;
 800344c:	687a      	ldr	r2, [r7, #4]
 800344e:	697b      	ldr	r3, [r7, #20]
 8003450:	212c      	movs	r1, #44	; 0x2c
 8003452:	fb01 f303 	mul.w	r3, r1, r3
 8003456:	4413      	add	r3, r2
 8003458:	3361      	adds	r3, #97	; 0x61
 800345a:	2205      	movs	r2, #5
 800345c:	701a      	strb	r2, [r3, #0]
}
 800345e:	e277      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8003460:	697b      	ldr	r3, [r7, #20]
 8003462:	015a      	lsls	r2, r3, #5
 8003464:	69bb      	ldr	r3, [r7, #24]
 8003466:	4413      	add	r3, r2
 8003468:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800346c:	689b      	ldr	r3, [r3, #8]
 800346e:	f003 0310 	and.w	r3, r3, #16
 8003472:	2b10      	cmp	r3, #16
 8003474:	d150      	bne.n	8003518 <HCD_HC_OUT_IRQHandler+0x3c2>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8003476:	687a      	ldr	r2, [r7, #4]
 8003478:	697b      	ldr	r3, [r7, #20]
 800347a:	212c      	movs	r1, #44	; 0x2c
 800347c:	fb01 f303 	mul.w	r3, r1, r3
 8003480:	4413      	add	r3, r2
 8003482:	335c      	adds	r3, #92	; 0x5c
 8003484:	2200      	movs	r2, #0
 8003486:	601a      	str	r2, [r3, #0]
    hhcd->hc[ch_num].state = HC_NAK;
 8003488:	687a      	ldr	r2, [r7, #4]
 800348a:	697b      	ldr	r3, [r7, #20]
 800348c:	212c      	movs	r1, #44	; 0x2c
 800348e:	fb01 f303 	mul.w	r3, r1, r3
 8003492:	4413      	add	r3, r2
 8003494:	3361      	adds	r3, #97	; 0x61
 8003496:	2203      	movs	r2, #3
 8003498:	701a      	strb	r2, [r3, #0]
    if (hhcd->hc[ch_num].do_ping == 0U)
 800349a:	687a      	ldr	r2, [r7, #4]
 800349c:	697b      	ldr	r3, [r7, #20]
 800349e:	212c      	movs	r1, #44	; 0x2c
 80034a0:	fb01 f303 	mul.w	r3, r1, r3
 80034a4:	4413      	add	r3, r2
 80034a6:	333d      	adds	r3, #61	; 0x3d
 80034a8:	781b      	ldrb	r3, [r3, #0]
 80034aa:	2b00      	cmp	r3, #0
 80034ac:	d112      	bne.n	80034d4 <HCD_HC_OUT_IRQHandler+0x37e>
      if (hhcd->hc[ch_num].speed == HCD_DEVICE_SPEED_HIGH)
 80034ae:	687a      	ldr	r2, [r7, #4]
 80034b0:	697b      	ldr	r3, [r7, #20]
 80034b2:	212c      	movs	r1, #44	; 0x2c
 80034b4:	fb01 f303 	mul.w	r3, r1, r3
 80034b8:	4413      	add	r3, r2
 80034ba:	333c      	adds	r3, #60	; 0x3c
 80034bc:	781b      	ldrb	r3, [r3, #0]
 80034be:	2b00      	cmp	r3, #0
 80034c0:	d108      	bne.n	80034d4 <HCD_HC_OUT_IRQHandler+0x37e>
        hhcd->hc[ch_num].do_ping = 1U;
 80034c2:	687a      	ldr	r2, [r7, #4]
 80034c4:	697b      	ldr	r3, [r7, #20]
 80034c6:	212c      	movs	r1, #44	; 0x2c
 80034c8:	fb01 f303 	mul.w	r3, r1, r3
 80034cc:	4413      	add	r3, r2
 80034ce:	333d      	adds	r3, #61	; 0x3d
 80034d0:	2201      	movs	r2, #1
 80034d2:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80034d4:	697b      	ldr	r3, [r7, #20]
 80034d6:	015a      	lsls	r2, r3, #5
 80034d8:	69bb      	ldr	r3, [r7, #24]
 80034da:	4413      	add	r3, r2
 80034dc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80034e0:	68db      	ldr	r3, [r3, #12]
 80034e2:	697a      	ldr	r2, [r7, #20]
 80034e4:	0151      	lsls	r1, r2, #5
 80034e6:	69ba      	ldr	r2, [r7, #24]
 80034e8:	440a      	add	r2, r1
 80034ea:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80034ee:	f043 0302 	orr.w	r3, r3, #2
 80034f2:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80034f4:	687b      	ldr	r3, [r7, #4]
 80034f6:	681b      	ldr	r3, [r3, #0]
 80034f8:	697a      	ldr	r2, [r7, #20]
 80034fa:	b2d2      	uxtb	r2, r2
 80034fc:	4611      	mov	r1, r2
 80034fe:	4618      	mov	r0, r3
 8003500:	f002 f95b 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8003504:	697b      	ldr	r3, [r7, #20]
 8003506:	015a      	lsls	r2, r3, #5
 8003508:	69bb      	ldr	r3, [r7, #24]
 800350a:	4413      	add	r3, r2
 800350c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003510:	461a      	mov	r2, r3
 8003512:	2310      	movs	r3, #16
 8003514:	6093      	str	r3, [r2, #8]
}
 8003516:	e21b      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8003518:	697b      	ldr	r3, [r7, #20]
 800351a:	015a      	lsls	r2, r3, #5
 800351c:	69bb      	ldr	r3, [r7, #24]
 800351e:	4413      	add	r3, r2
 8003520:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003524:	689b      	ldr	r3, [r3, #8]
 8003526:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800352a:	2b80      	cmp	r3, #128	; 0x80
 800352c:	d174      	bne.n	8003618 <HCD_HC_OUT_IRQHandler+0x4c2>
    if (hhcd->Init.dma_enable == 0U)
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	691b      	ldr	r3, [r3, #16]
 8003532:	2b00      	cmp	r3, #0
 8003534:	d121      	bne.n	800357a <HCD_HC_OUT_IRQHandler+0x424>
      hhcd->hc[ch_num].state = HC_XACTERR;
 8003536:	687a      	ldr	r2, [r7, #4]
 8003538:	697b      	ldr	r3, [r7, #20]
 800353a:	212c      	movs	r1, #44	; 0x2c
 800353c:	fb01 f303 	mul.w	r3, r1, r3
 8003540:	4413      	add	r3, r2
 8003542:	3361      	adds	r3, #97	; 0x61
 8003544:	2206      	movs	r2, #6
 8003546:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8003548:	697b      	ldr	r3, [r7, #20]
 800354a:	015a      	lsls	r2, r3, #5
 800354c:	69bb      	ldr	r3, [r7, #24]
 800354e:	4413      	add	r3, r2
 8003550:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003554:	68db      	ldr	r3, [r3, #12]
 8003556:	697a      	ldr	r2, [r7, #20]
 8003558:	0151      	lsls	r1, r2, #5
 800355a:	69ba      	ldr	r2, [r7, #24]
 800355c:	440a      	add	r2, r1
 800355e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8003562:	f043 0302 	orr.w	r3, r3, #2
 8003566:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8003568:	687b      	ldr	r3, [r7, #4]
 800356a:	681b      	ldr	r3, [r3, #0]
 800356c:	697a      	ldr	r2, [r7, #20]
 800356e:	b2d2      	uxtb	r2, r2
 8003570:	4611      	mov	r1, r2
 8003572:	4618      	mov	r0, r3
 8003574:	f002 f921 	bl	80057ba <USB_HC_Halt>
 8003578:	e044      	b.n	8003604 <HCD_HC_OUT_IRQHandler+0x4ae>
      hhcd->hc[ch_num].ErrCnt++;
 800357a:	687a      	ldr	r2, [r7, #4]
 800357c:	697b      	ldr	r3, [r7, #20]
 800357e:	212c      	movs	r1, #44	; 0x2c
 8003580:	fb01 f303 	mul.w	r3, r1, r3
 8003584:	4413      	add	r3, r2
 8003586:	335c      	adds	r3, #92	; 0x5c
 8003588:	681b      	ldr	r3, [r3, #0]
 800358a:	1c5a      	adds	r2, r3, #1
 800358c:	6879      	ldr	r1, [r7, #4]
 800358e:	697b      	ldr	r3, [r7, #20]
 8003590:	202c      	movs	r0, #44	; 0x2c
 8003592:	fb00 f303 	mul.w	r3, r0, r3
 8003596:	440b      	add	r3, r1
 8003598:	335c      	adds	r3, #92	; 0x5c
 800359a:	601a      	str	r2, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 800359c:	687a      	ldr	r2, [r7, #4]
 800359e:	697b      	ldr	r3, [r7, #20]
 80035a0:	212c      	movs	r1, #44	; 0x2c
 80035a2:	fb01 f303 	mul.w	r3, r1, r3
 80035a6:	4413      	add	r3, r2
 80035a8:	335c      	adds	r3, #92	; 0x5c
 80035aa:	681b      	ldr	r3, [r3, #0]
 80035ac:	2b02      	cmp	r3, #2
 80035ae:	d920      	bls.n	80035f2 <HCD_HC_OUT_IRQHandler+0x49c>
        hhcd->hc[ch_num].ErrCnt = 0U;
 80035b0:	687a      	ldr	r2, [r7, #4]
 80035b2:	697b      	ldr	r3, [r7, #20]
 80035b4:	212c      	movs	r1, #44	; 0x2c
 80035b6:	fb01 f303 	mul.w	r3, r1, r3
 80035ba:	4413      	add	r3, r2
 80035bc:	335c      	adds	r3, #92	; 0x5c
 80035be:	2200      	movs	r2, #0
 80035c0:	601a      	str	r2, [r3, #0]
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 80035c2:	687a      	ldr	r2, [r7, #4]
 80035c4:	697b      	ldr	r3, [r7, #20]
 80035c6:	212c      	movs	r1, #44	; 0x2c
 80035c8:	fb01 f303 	mul.w	r3, r1, r3
 80035cc:	4413      	add	r3, r2
 80035ce:	3360      	adds	r3, #96	; 0x60
 80035d0:	2204      	movs	r2, #4
 80035d2:	701a      	strb	r2, [r3, #0]
        HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num,
 80035d4:	697b      	ldr	r3, [r7, #20]
 80035d6:	b2d9      	uxtb	r1, r3
 80035d8:	687a      	ldr	r2, [r7, #4]
 80035da:	697b      	ldr	r3, [r7, #20]
 80035dc:	202c      	movs	r0, #44	; 0x2c
 80035de:	fb00 f303 	mul.w	r3, r0, r3
 80035e2:	4413      	add	r3, r2
 80035e4:	3360      	adds	r3, #96	; 0x60
 80035e6:	781b      	ldrb	r3, [r3, #0]
 80035e8:	461a      	mov	r2, r3
 80035ea:	6878      	ldr	r0, [r7, #4]
 80035ec:	f024 fbd8 	bl	8027da0 <HAL_HCD_HC_NotifyURBChange_Callback>
 80035f0:	e008      	b.n	8003604 <HCD_HC_OUT_IRQHandler+0x4ae>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 80035f2:	687a      	ldr	r2, [r7, #4]
 80035f4:	697b      	ldr	r3, [r7, #20]
 80035f6:	212c      	movs	r1, #44	; 0x2c
 80035f8:	fb01 f303 	mul.w	r3, r1, r3
 80035fc:	4413      	add	r3, r2
 80035fe:	3360      	adds	r3, #96	; 0x60
 8003600:	2202      	movs	r2, #2
 8003602:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8003604:	697b      	ldr	r3, [r7, #20]
 8003606:	015a      	lsls	r2, r3, #5
 8003608:	69bb      	ldr	r3, [r7, #24]
 800360a:	4413      	add	r3, r2
 800360c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003610:	461a      	mov	r2, r3
 8003612:	2380      	movs	r3, #128	; 0x80
 8003614:	6093      	str	r3, [r2, #8]
}
 8003616:	e19b      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8003618:	697b      	ldr	r3, [r7, #20]
 800361a:	015a      	lsls	r2, r3, #5
 800361c:	69bb      	ldr	r3, [r7, #24]
 800361e:	4413      	add	r3, r2
 8003620:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003624:	689b      	ldr	r3, [r3, #8]
 8003626:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800362a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800362e:	d134      	bne.n	800369a <HCD_HC_OUT_IRQHandler+0x544>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8003630:	697b      	ldr	r3, [r7, #20]
 8003632:	015a      	lsls	r2, r3, #5
 8003634:	69bb      	ldr	r3, [r7, #24]
 8003636:	4413      	add	r3, r2
 8003638:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800363c:	68db      	ldr	r3, [r3, #12]
 800363e:	697a      	ldr	r2, [r7, #20]
 8003640:	0151      	lsls	r1, r2, #5
 8003642:	69ba      	ldr	r2, [r7, #24]
 8003644:	440a      	add	r2, r1
 8003646:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800364a:	f043 0302 	orr.w	r3, r3, #2
 800364e:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8003650:	687b      	ldr	r3, [r7, #4]
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	697a      	ldr	r2, [r7, #20]
 8003656:	b2d2      	uxtb	r2, r2
 8003658:	4611      	mov	r1, r2
 800365a:	4618      	mov	r0, r3
 800365c:	f002 f8ad 	bl	80057ba <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8003660:	697b      	ldr	r3, [r7, #20]
 8003662:	015a      	lsls	r2, r3, #5
 8003664:	69bb      	ldr	r3, [r7, #24]
 8003666:	4413      	add	r3, r2
 8003668:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800366c:	461a      	mov	r2, r3
 800366e:	2310      	movs	r3, #16
 8003670:	6093      	str	r3, [r2, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8003672:	697b      	ldr	r3, [r7, #20]
 8003674:	015a      	lsls	r2, r3, #5
 8003676:	69bb      	ldr	r3, [r7, #24]
 8003678:	4413      	add	r3, r2
 800367a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800367e:	461a      	mov	r2, r3
 8003680:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003684:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8003686:	687a      	ldr	r2, [r7, #4]
 8003688:	697b      	ldr	r3, [r7, #20]
 800368a:	212c      	movs	r1, #44	; 0x2c
 800368c:	fb01 f303 	mul.w	r3, r1, r3
 8003690:	4413      	add	r3, r2
 8003692:	3361      	adds	r3, #97	; 0x61
 8003694:	2208      	movs	r2, #8
 8003696:	701a      	strb	r2, [r3, #0]
}
 8003698:	e15a      	b.n	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 800369a:	697b      	ldr	r3, [r7, #20]
 800369c:	015a      	lsls	r2, r3, #5
 800369e:	69bb      	ldr	r3, [r7, #24]
 80036a0:	4413      	add	r3, r2
 80036a2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80036a6:	689b      	ldr	r3, [r3, #8]
 80036a8:	f003 0302 	and.w	r3, r3, #2
 80036ac:	2b02      	cmp	r3, #2
 80036ae:	f040 814f 	bne.w	8003950 <HCD_HC_OUT_IRQHandler+0x7fa>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 80036b2:	697b      	ldr	r3, [r7, #20]
 80036b4:	015a      	lsls	r2, r3, #5
 80036b6:	69bb      	ldr	r3, [r7, #24]
 80036b8:	4413      	add	r3, r2
 80036ba:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80036be:	68db      	ldr	r3, [r3, #12]
 80036c0:	697a      	ldr	r2, [r7, #20]
 80036c2:	0151      	lsls	r1, r2, #5
 80036c4:	69ba      	ldr	r2, [r7, #24]
 80036c6:	440a      	add	r2, r1
 80036c8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80036cc:	f023 0302 	bic.w	r3, r3, #2
 80036d0:	60d3      	str	r3, [r2, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 80036d2:	687a      	ldr	r2, [r7, #4]
 80036d4:	697b      	ldr	r3, [r7, #20]
 80036d6:	212c      	movs	r1, #44	; 0x2c
 80036d8:	fb01 f303 	mul.w	r3, r1, r3
 80036dc:	4413      	add	r3, r2
 80036de:	3361      	adds	r3, #97	; 0x61
 80036e0:	781b      	ldrb	r3, [r3, #0]
 80036e2:	2b01      	cmp	r3, #1
 80036e4:	d17d      	bne.n	80037e2 <HCD_HC_OUT_IRQHandler+0x68c>
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 80036e6:	687a      	ldr	r2, [r7, #4]
 80036e8:	697b      	ldr	r3, [r7, #20]
 80036ea:	212c      	movs	r1, #44	; 0x2c
 80036ec:	fb01 f303 	mul.w	r3, r1, r3
 80036f0:	4413      	add	r3, r2
 80036f2:	3360      	adds	r3, #96	; 0x60
 80036f4:	2201      	movs	r2, #1
 80036f6:	701a      	strb	r2, [r3, #0]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 80036f8:	687a      	ldr	r2, [r7, #4]
 80036fa:	697b      	ldr	r3, [r7, #20]
 80036fc:	212c      	movs	r1, #44	; 0x2c
 80036fe:	fb01 f303 	mul.w	r3, r1, r3
 8003702:	4413      	add	r3, r2
 8003704:	333f      	adds	r3, #63	; 0x3f
 8003706:	781b      	ldrb	r3, [r3, #0]
 8003708:	2b02      	cmp	r3, #2
 800370a:	d00a      	beq.n	8003722 <HCD_HC_OUT_IRQHandler+0x5cc>
          (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR))
 800370c:	687a      	ldr	r2, [r7, #4]
 800370e:	697b      	ldr	r3, [r7, #20]
 8003710:	212c      	movs	r1, #44	; 0x2c
 8003712:	fb01 f303 	mul.w	r3, r1, r3
 8003716:	4413      	add	r3, r2
 8003718:	333f      	adds	r3, #63	; 0x3f
 800371a:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 800371c:	2b03      	cmp	r3, #3
 800371e:	f040 8100 	bne.w	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
        if (hhcd->Init.dma_enable == 0U)
 8003722:	687b      	ldr	r3, [r7, #4]
 8003724:	691b      	ldr	r3, [r3, #16]
 8003726:	2b00      	cmp	r3, #0
 8003728:	d113      	bne.n	8003752 <HCD_HC_OUT_IRQHandler+0x5fc>
          hhcd->hc[ch_num].toggle_out ^= 1U;
 800372a:	687a      	ldr	r2, [r7, #4]
 800372c:	697b      	ldr	r3, [r7, #20]
 800372e:	212c      	movs	r1, #44	; 0x2c
 8003730:	fb01 f303 	mul.w	r3, r1, r3
 8003734:	4413      	add	r3, r2
 8003736:	3355      	adds	r3, #85	; 0x55
 8003738:	781b      	ldrb	r3, [r3, #0]
 800373a:	f083 0301 	eor.w	r3, r3, #1
 800373e:	b2d8      	uxtb	r0, r3
 8003740:	687a      	ldr	r2, [r7, #4]
 8003742:	697b      	ldr	r3, [r7, #20]
 8003744:	212c      	movs	r1, #44	; 0x2c
 8003746:	fb01 f303 	mul.w	r3, r1, r3
 800374a:	4413      	add	r3, r2
 800374c:	3355      	adds	r3, #85	; 0x55
 800374e:	4602      	mov	r2, r0
 8003750:	701a      	strb	r2, [r3, #0]
        if ((hhcd->Init.dma_enable == 1U) && (hhcd->hc[ch_num].xfer_len > 0U))
 8003752:	687b      	ldr	r3, [r7, #4]
 8003754:	691b      	ldr	r3, [r3, #16]
 8003756:	2b01      	cmp	r3, #1
 8003758:	f040 80e3 	bne.w	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
 800375c:	687a      	ldr	r2, [r7, #4]
 800375e:	697b      	ldr	r3, [r7, #20]
 8003760:	212c      	movs	r1, #44	; 0x2c
 8003762:	fb01 f303 	mul.w	r3, r1, r3
 8003766:	4413      	add	r3, r2
 8003768:	334c      	adds	r3, #76	; 0x4c
 800376a:	681b      	ldr	r3, [r3, #0]
 800376c:	2b00      	cmp	r3, #0
 800376e:	f000 80d8 	beq.w	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
          num_packets = (hhcd->hc[ch_num].xfer_len + hhcd->hc[ch_num].max_packet - 1U) / hhcd->hc[ch_num].max_packet;
 8003772:	687a      	ldr	r2, [r7, #4]
 8003774:	697b      	ldr	r3, [r7, #20]
 8003776:	212c      	movs	r1, #44	; 0x2c
 8003778:	fb01 f303 	mul.w	r3, r1, r3
 800377c:	4413      	add	r3, r2
 800377e:	334c      	adds	r3, #76	; 0x4c
 8003780:	681b      	ldr	r3, [r3, #0]
 8003782:	6879      	ldr	r1, [r7, #4]
 8003784:	697a      	ldr	r2, [r7, #20]
 8003786:	202c      	movs	r0, #44	; 0x2c
 8003788:	fb00 f202 	mul.w	r2, r0, r2
 800378c:	440a      	add	r2, r1
 800378e:	3240      	adds	r2, #64	; 0x40
 8003790:	8812      	ldrh	r2, [r2, #0]
 8003792:	4413      	add	r3, r2
 8003794:	3b01      	subs	r3, #1
 8003796:	6879      	ldr	r1, [r7, #4]
 8003798:	697a      	ldr	r2, [r7, #20]
 800379a:	202c      	movs	r0, #44	; 0x2c
 800379c:	fb00 f202 	mul.w	r2, r0, r2
 80037a0:	440a      	add	r2, r1
 80037a2:	3240      	adds	r2, #64	; 0x40
 80037a4:	8812      	ldrh	r2, [r2, #0]
 80037a6:	fbb3 f3f2 	udiv	r3, r3, r2
 80037aa:	60fb      	str	r3, [r7, #12]
          if ((num_packets & 1U) != 0U)
 80037ac:	68fb      	ldr	r3, [r7, #12]
 80037ae:	f003 0301 	and.w	r3, r3, #1
 80037b2:	2b00      	cmp	r3, #0
 80037b4:	f000 80b5 	beq.w	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
            hhcd->hc[ch_num].toggle_out ^= 1U;
 80037b8:	687a      	ldr	r2, [r7, #4]
 80037ba:	697b      	ldr	r3, [r7, #20]
 80037bc:	212c      	movs	r1, #44	; 0x2c
 80037be:	fb01 f303 	mul.w	r3, r1, r3
 80037c2:	4413      	add	r3, r2
 80037c4:	3355      	adds	r3, #85	; 0x55
 80037c6:	781b      	ldrb	r3, [r3, #0]
 80037c8:	f083 0301 	eor.w	r3, r3, #1
 80037cc:	b2d8      	uxtb	r0, r3
 80037ce:	687a      	ldr	r2, [r7, #4]
 80037d0:	697b      	ldr	r3, [r7, #20]
 80037d2:	212c      	movs	r1, #44	; 0x2c
 80037d4:	fb01 f303 	mul.w	r3, r1, r3
 80037d8:	4413      	add	r3, r2
 80037da:	3355      	adds	r3, #85	; 0x55
 80037dc:	4602      	mov	r2, r0
 80037de:	701a      	strb	r2, [r3, #0]
 80037e0:	e09f      	b.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 80037e2:	687a      	ldr	r2, [r7, #4]
 80037e4:	697b      	ldr	r3, [r7, #20]
 80037e6:	212c      	movs	r1, #44	; 0x2c
 80037e8:	fb01 f303 	mul.w	r3, r1, r3
 80037ec:	4413      	add	r3, r2
 80037ee:	3361      	adds	r3, #97	; 0x61
 80037f0:	781b      	ldrb	r3, [r3, #0]
 80037f2:	2b03      	cmp	r3, #3
 80037f4:	d109      	bne.n	800380a <HCD_HC_OUT_IRQHandler+0x6b4>
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 80037f6:	687a      	ldr	r2, [r7, #4]
 80037f8:	697b      	ldr	r3, [r7, #20]
 80037fa:	212c      	movs	r1, #44	; 0x2c
 80037fc:	fb01 f303 	mul.w	r3, r1, r3
 8003800:	4413      	add	r3, r2
 8003802:	3360      	adds	r3, #96	; 0x60
 8003804:	2202      	movs	r2, #2
 8003806:	701a      	strb	r2, [r3, #0]
 8003808:	e08b      	b.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 800380a:	687a      	ldr	r2, [r7, #4]
 800380c:	697b      	ldr	r3, [r7, #20]
 800380e:	212c      	movs	r1, #44	; 0x2c
 8003810:	fb01 f303 	mul.w	r3, r1, r3
 8003814:	4413      	add	r3, r2
 8003816:	3361      	adds	r3, #97	; 0x61
 8003818:	781b      	ldrb	r3, [r3, #0]
 800381a:	2b04      	cmp	r3, #4
 800381c:	d109      	bne.n	8003832 <HCD_HC_OUT_IRQHandler+0x6dc>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 800381e:	687a      	ldr	r2, [r7, #4]
 8003820:	697b      	ldr	r3, [r7, #20]
 8003822:	212c      	movs	r1, #44	; 0x2c
 8003824:	fb01 f303 	mul.w	r3, r1, r3
 8003828:	4413      	add	r3, r2
 800382a:	3360      	adds	r3, #96	; 0x60
 800382c:	2202      	movs	r2, #2
 800382e:	701a      	strb	r2, [r3, #0]
 8003830:	e077      	b.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8003832:	687a      	ldr	r2, [r7, #4]
 8003834:	697b      	ldr	r3, [r7, #20]
 8003836:	212c      	movs	r1, #44	; 0x2c
 8003838:	fb01 f303 	mul.w	r3, r1, r3
 800383c:	4413      	add	r3, r2
 800383e:	3361      	adds	r3, #97	; 0x61
 8003840:	781b      	ldrb	r3, [r3, #0]
 8003842:	2b05      	cmp	r3, #5
 8003844:	d109      	bne.n	800385a <HCD_HC_OUT_IRQHandler+0x704>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8003846:	687a      	ldr	r2, [r7, #4]
 8003848:	697b      	ldr	r3, [r7, #20]
 800384a:	212c      	movs	r1, #44	; 0x2c
 800384c:	fb01 f303 	mul.w	r3, r1, r3
 8003850:	4413      	add	r3, r2
 8003852:	3360      	adds	r3, #96	; 0x60
 8003854:	2205      	movs	r2, #5
 8003856:	701a      	strb	r2, [r3, #0]
 8003858:	e063      	b.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 800385a:	687a      	ldr	r2, [r7, #4]
 800385c:	697b      	ldr	r3, [r7, #20]
 800385e:	212c      	movs	r1, #44	; 0x2c
 8003860:	fb01 f303 	mul.w	r3, r1, r3
 8003864:	4413      	add	r3, r2
 8003866:	3361      	adds	r3, #97	; 0x61
 8003868:	781b      	ldrb	r3, [r3, #0]
 800386a:	2b06      	cmp	r3, #6
 800386c:	d009      	beq.n	8003882 <HCD_HC_OUT_IRQHandler+0x72c>
             (hhcd->hc[ch_num].state == HC_DATATGLERR))
 800386e:	687a      	ldr	r2, [r7, #4]
 8003870:	697b      	ldr	r3, [r7, #20]
 8003872:	212c      	movs	r1, #44	; 0x2c
 8003874:	fb01 f303 	mul.w	r3, r1, r3
 8003878:	4413      	add	r3, r2
 800387a:	3361      	adds	r3, #97	; 0x61
 800387c:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 800387e:	2b08      	cmp	r3, #8
 8003880:	d14f      	bne.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
      hhcd->hc[ch_num].ErrCnt++;
 8003882:	687a      	ldr	r2, [r7, #4]
 8003884:	697b      	ldr	r3, [r7, #20]
 8003886:	212c      	movs	r1, #44	; 0x2c
 8003888:	fb01 f303 	mul.w	r3, r1, r3
 800388c:	4413      	add	r3, r2
 800388e:	335c      	adds	r3, #92	; 0x5c
 8003890:	681b      	ldr	r3, [r3, #0]
 8003892:	1c5a      	adds	r2, r3, #1
 8003894:	6879      	ldr	r1, [r7, #4]
 8003896:	697b      	ldr	r3, [r7, #20]
 8003898:	202c      	movs	r0, #44	; 0x2c
 800389a:	fb00 f303 	mul.w	r3, r0, r3
 800389e:	440b      	add	r3, r1
 80038a0:	335c      	adds	r3, #92	; 0x5c
 80038a2:	601a      	str	r2, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 2U)
 80038a4:	687a      	ldr	r2, [r7, #4]
 80038a6:	697b      	ldr	r3, [r7, #20]
 80038a8:	212c      	movs	r1, #44	; 0x2c
 80038aa:	fb01 f303 	mul.w	r3, r1, r3
 80038ae:	4413      	add	r3, r2
 80038b0:	335c      	adds	r3, #92	; 0x5c
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	2b02      	cmp	r3, #2
 80038b6:	d912      	bls.n	80038de <HCD_HC_OUT_IRQHandler+0x788>
        hhcd->hc[ch_num].ErrCnt = 0U;
 80038b8:	687a      	ldr	r2, [r7, #4]
 80038ba:	697b      	ldr	r3, [r7, #20]
 80038bc:	212c      	movs	r1, #44	; 0x2c
 80038be:	fb01 f303 	mul.w	r3, r1, r3
 80038c2:	4413      	add	r3, r2
 80038c4:	335c      	adds	r3, #92	; 0x5c
 80038c6:	2200      	movs	r2, #0
 80038c8:	601a      	str	r2, [r3, #0]
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 80038ca:	687a      	ldr	r2, [r7, #4]
 80038cc:	697b      	ldr	r3, [r7, #20]
 80038ce:	212c      	movs	r1, #44	; 0x2c
 80038d0:	fb01 f303 	mul.w	r3, r1, r3
 80038d4:	4413      	add	r3, r2
 80038d6:	3360      	adds	r3, #96	; 0x60
 80038d8:	2204      	movs	r2, #4
 80038da:	701a      	strb	r2, [r3, #0]
 80038dc:	e021      	b.n	8003922 <HCD_HC_OUT_IRQHandler+0x7cc>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 80038de:	687a      	ldr	r2, [r7, #4]
 80038e0:	697b      	ldr	r3, [r7, #20]
 80038e2:	212c      	movs	r1, #44	; 0x2c
 80038e4:	fb01 f303 	mul.w	r3, r1, r3
 80038e8:	4413      	add	r3, r2
 80038ea:	3360      	adds	r3, #96	; 0x60
 80038ec:	2202      	movs	r2, #2
 80038ee:	701a      	strb	r2, [r3, #0]
        tmpreg = USBx_HC(ch_num)->HCCHAR;
 80038f0:	697b      	ldr	r3, [r7, #20]
 80038f2:	015a      	lsls	r2, r3, #5
 80038f4:	69bb      	ldr	r3, [r7, #24]
 80038f6:	4413      	add	r3, r2
 80038f8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80038fc:	681b      	ldr	r3, [r3, #0]
 80038fe:	613b      	str	r3, [r7, #16]
        tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8003900:	693b      	ldr	r3, [r7, #16]
 8003902:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003906:	613b      	str	r3, [r7, #16]
        tmpreg |= USB_OTG_HCCHAR_CHENA;
 8003908:	693b      	ldr	r3, [r7, #16]
 800390a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800390e:	613b      	str	r3, [r7, #16]
        USBx_HC(ch_num)->HCCHAR = tmpreg;
 8003910:	697b      	ldr	r3, [r7, #20]
 8003912:	015a      	lsls	r2, r3, #5
 8003914:	69bb      	ldr	r3, [r7, #24]
 8003916:	4413      	add	r3, r2
 8003918:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800391c:	461a      	mov	r2, r3
 800391e:	693b      	ldr	r3, [r7, #16]
 8003920:	6013      	str	r3, [r2, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8003922:	697b      	ldr	r3, [r7, #20]
 8003924:	015a      	lsls	r2, r3, #5
 8003926:	69bb      	ldr	r3, [r7, #24]
 8003928:	4413      	add	r3, r2
 800392a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800392e:	461a      	mov	r2, r3
 8003930:	2302      	movs	r3, #2
 8003932:	6093      	str	r3, [r2, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8003934:	697b      	ldr	r3, [r7, #20]
 8003936:	b2d9      	uxtb	r1, r3
 8003938:	687a      	ldr	r2, [r7, #4]
 800393a:	697b      	ldr	r3, [r7, #20]
 800393c:	202c      	movs	r0, #44	; 0x2c
 800393e:	fb00 f303 	mul.w	r3, r0, r3
 8003942:	4413      	add	r3, r2
 8003944:	3360      	adds	r3, #96	; 0x60
 8003946:	781b      	ldrb	r3, [r3, #0]
 8003948:	461a      	mov	r2, r3
 800394a:	6878      	ldr	r0, [r7, #4]
 800394c:	f024 fa28 	bl	8027da0 <HAL_HCD_HC_NotifyURBChange_Callback>
}
 8003950:	bf00      	nop
 8003952:	3720      	adds	r7, #32
 8003954:	46bd      	mov	sp, r7
 8003956:	bd80      	pop	{r7, pc}

08003958 <HCD_RXQLVL_IRQHandler>:
  * @brief  Handle Rx Queue Level interrupt requests.
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8003958:	b580      	push	{r7, lr}
 800395a:	b08a      	sub	sp, #40	; 0x28
 800395c:	af00      	add	r7, sp, #0
 800395e:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8003960:	687b      	ldr	r3, [r7, #4]
 8003962:	681b      	ldr	r3, [r3, #0]
 8003964:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003966:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003968:	623b      	str	r3, [r7, #32]
  uint32_t GrxstspReg;
  uint32_t xferSizePktCnt;
  uint32_t tmpreg;
  uint32_t ch_num;

  GrxstspReg = hhcd->Instance->GRXSTSP;
 800396a:	687b      	ldr	r3, [r7, #4]
 800396c:	681b      	ldr	r3, [r3, #0]
 800396e:	6a1b      	ldr	r3, [r3, #32]
 8003970:	61fb      	str	r3, [r7, #28]
  ch_num = GrxstspReg & USB_OTG_GRXSTSP_EPNUM;
 8003972:	69fb      	ldr	r3, [r7, #28]
 8003974:	f003 030f 	and.w	r3, r3, #15
 8003978:	61bb      	str	r3, [r7, #24]
  pktsts = (GrxstspReg & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 800397a:	69fb      	ldr	r3, [r7, #28]
 800397c:	0c5b      	lsrs	r3, r3, #17
 800397e:	f003 030f 	and.w	r3, r3, #15
 8003982:	617b      	str	r3, [r7, #20]
  pktcnt = (GrxstspReg & USB_OTG_GRXSTSP_BCNT) >> 4;
 8003984:	69fb      	ldr	r3, [r7, #28]
 8003986:	091b      	lsrs	r3, r3, #4
 8003988:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800398c:	613b      	str	r3, [r7, #16]

  switch (pktsts)
 800398e:	697b      	ldr	r3, [r7, #20]
 8003990:	2b02      	cmp	r3, #2
 8003992:	d004      	beq.n	800399e <HCD_RXQLVL_IRQHandler+0x46>
 8003994:	697b      	ldr	r3, [r7, #20]
 8003996:	2b05      	cmp	r3, #5
 8003998:	f000 80a9 	beq.w	8003aee <HCD_RXQLVL_IRQHandler+0x196>
      break;

    case GRXSTS_PKTSTS_IN_XFER_COMP:
    case GRXSTS_PKTSTS_CH_HALTED:
    default:
      break;
 800399c:	e0aa      	b.n	8003af4 <HCD_RXQLVL_IRQHandler+0x19c>
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 800399e:	693b      	ldr	r3, [r7, #16]
 80039a0:	2b00      	cmp	r3, #0
 80039a2:	f000 80a6 	beq.w	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
 80039a6:	687a      	ldr	r2, [r7, #4]
 80039a8:	69bb      	ldr	r3, [r7, #24]
 80039aa:	212c      	movs	r1, #44	; 0x2c
 80039ac:	fb01 f303 	mul.w	r3, r1, r3
 80039b0:	4413      	add	r3, r2
 80039b2:	3344      	adds	r3, #68	; 0x44
 80039b4:	681b      	ldr	r3, [r3, #0]
 80039b6:	2b00      	cmp	r3, #0
 80039b8:	f000 809b 	beq.w	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
        if ((hhcd->hc[ch_num].xfer_count + pktcnt) <= hhcd->hc[ch_num].xfer_len)
 80039bc:	687a      	ldr	r2, [r7, #4]
 80039be:	69bb      	ldr	r3, [r7, #24]
 80039c0:	212c      	movs	r1, #44	; 0x2c
 80039c2:	fb01 f303 	mul.w	r3, r1, r3
 80039c6:	4413      	add	r3, r2
 80039c8:	3350      	adds	r3, #80	; 0x50
 80039ca:	681a      	ldr	r2, [r3, #0]
 80039cc:	693b      	ldr	r3, [r7, #16]
 80039ce:	441a      	add	r2, r3
 80039d0:	6879      	ldr	r1, [r7, #4]
 80039d2:	69bb      	ldr	r3, [r7, #24]
 80039d4:	202c      	movs	r0, #44	; 0x2c
 80039d6:	fb00 f303 	mul.w	r3, r0, r3
 80039da:	440b      	add	r3, r1
 80039dc:	334c      	adds	r3, #76	; 0x4c
 80039de:	681b      	ldr	r3, [r3, #0]
 80039e0:	429a      	cmp	r2, r3
 80039e2:	d87a      	bhi.n	8003ada <HCD_RXQLVL_IRQHandler+0x182>
          (void)USB_ReadPacket(hhcd->Instance,
 80039e4:	687b      	ldr	r3, [r7, #4]
 80039e6:	6818      	ldr	r0, [r3, #0]
 80039e8:	687a      	ldr	r2, [r7, #4]
 80039ea:	69bb      	ldr	r3, [r7, #24]
 80039ec:	212c      	movs	r1, #44	; 0x2c
 80039ee:	fb01 f303 	mul.w	r3, r1, r3
 80039f2:	4413      	add	r3, r2
 80039f4:	3344      	adds	r3, #68	; 0x44
 80039f6:	681b      	ldr	r3, [r3, #0]
 80039f8:	693a      	ldr	r2, [r7, #16]
 80039fa:	b292      	uxth	r2, r2
 80039fc:	4619      	mov	r1, r3
 80039fe:	f001 fa55 	bl	8004eac <USB_ReadPacket>
          hhcd->hc[ch_num].xfer_buff += pktcnt;
 8003a02:	687a      	ldr	r2, [r7, #4]
 8003a04:	69bb      	ldr	r3, [r7, #24]
 8003a06:	212c      	movs	r1, #44	; 0x2c
 8003a08:	fb01 f303 	mul.w	r3, r1, r3
 8003a0c:	4413      	add	r3, r2
 8003a0e:	3344      	adds	r3, #68	; 0x44
 8003a10:	681a      	ldr	r2, [r3, #0]
 8003a12:	693b      	ldr	r3, [r7, #16]
 8003a14:	441a      	add	r2, r3
 8003a16:	6879      	ldr	r1, [r7, #4]
 8003a18:	69bb      	ldr	r3, [r7, #24]
 8003a1a:	202c      	movs	r0, #44	; 0x2c
 8003a1c:	fb00 f303 	mul.w	r3, r0, r3
 8003a20:	440b      	add	r3, r1
 8003a22:	3344      	adds	r3, #68	; 0x44
 8003a24:	601a      	str	r2, [r3, #0]
          hhcd->hc[ch_num].xfer_count += pktcnt;
 8003a26:	687a      	ldr	r2, [r7, #4]
 8003a28:	69bb      	ldr	r3, [r7, #24]
 8003a2a:	212c      	movs	r1, #44	; 0x2c
 8003a2c:	fb01 f303 	mul.w	r3, r1, r3
 8003a30:	4413      	add	r3, r2
 8003a32:	3350      	adds	r3, #80	; 0x50
 8003a34:	681a      	ldr	r2, [r3, #0]
 8003a36:	693b      	ldr	r3, [r7, #16]
 8003a38:	441a      	add	r2, r3
 8003a3a:	6879      	ldr	r1, [r7, #4]
 8003a3c:	69bb      	ldr	r3, [r7, #24]
 8003a3e:	202c      	movs	r0, #44	; 0x2c
 8003a40:	fb00 f303 	mul.w	r3, r0, r3
 8003a44:	440b      	add	r3, r1
 8003a46:	3350      	adds	r3, #80	; 0x50
 8003a48:	601a      	str	r2, [r3, #0]
          xferSizePktCnt = (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) >> 19;
 8003a4a:	69bb      	ldr	r3, [r7, #24]
 8003a4c:	015a      	lsls	r2, r3, #5
 8003a4e:	6a3b      	ldr	r3, [r7, #32]
 8003a50:	4413      	add	r3, r2
 8003a52:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003a56:	691b      	ldr	r3, [r3, #16]
 8003a58:	0cdb      	lsrs	r3, r3, #19
 8003a5a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8003a5e:	60fb      	str	r3, [r7, #12]
          if ((hhcd->hc[ch_num].max_packet == pktcnt) && (xferSizePktCnt > 0U))
 8003a60:	687a      	ldr	r2, [r7, #4]
 8003a62:	69bb      	ldr	r3, [r7, #24]
 8003a64:	212c      	movs	r1, #44	; 0x2c
 8003a66:	fb01 f303 	mul.w	r3, r1, r3
 8003a6a:	4413      	add	r3, r2
 8003a6c:	3340      	adds	r3, #64	; 0x40
 8003a6e:	881b      	ldrh	r3, [r3, #0]
 8003a70:	461a      	mov	r2, r3
 8003a72:	693b      	ldr	r3, [r7, #16]
 8003a74:	4293      	cmp	r3, r2
 8003a76:	d13c      	bne.n	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
 8003a78:	68fb      	ldr	r3, [r7, #12]
 8003a7a:	2b00      	cmp	r3, #0
 8003a7c:	d039      	beq.n	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
            tmpreg = USBx_HC(ch_num)->HCCHAR;
 8003a7e:	69bb      	ldr	r3, [r7, #24]
 8003a80:	015a      	lsls	r2, r3, #5
 8003a82:	6a3b      	ldr	r3, [r7, #32]
 8003a84:	4413      	add	r3, r2
 8003a86:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003a8a:	681b      	ldr	r3, [r3, #0]
 8003a8c:	60bb      	str	r3, [r7, #8]
            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8003a8e:	68bb      	ldr	r3, [r7, #8]
 8003a90:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003a94:	60bb      	str	r3, [r7, #8]
            tmpreg |= USB_OTG_HCCHAR_CHENA;
 8003a96:	68bb      	ldr	r3, [r7, #8]
 8003a98:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003a9c:	60bb      	str	r3, [r7, #8]
            USBx_HC(ch_num)->HCCHAR = tmpreg;
 8003a9e:	69bb      	ldr	r3, [r7, #24]
 8003aa0:	015a      	lsls	r2, r3, #5
 8003aa2:	6a3b      	ldr	r3, [r7, #32]
 8003aa4:	4413      	add	r3, r2
 8003aa6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003aaa:	461a      	mov	r2, r3
 8003aac:	68bb      	ldr	r3, [r7, #8]
 8003aae:	6013      	str	r3, [r2, #0]
            hhcd->hc[ch_num].toggle_in ^= 1U;
 8003ab0:	687a      	ldr	r2, [r7, #4]
 8003ab2:	69bb      	ldr	r3, [r7, #24]
 8003ab4:	212c      	movs	r1, #44	; 0x2c
 8003ab6:	fb01 f303 	mul.w	r3, r1, r3
 8003aba:	4413      	add	r3, r2
 8003abc:	3354      	adds	r3, #84	; 0x54
 8003abe:	781b      	ldrb	r3, [r3, #0]
 8003ac0:	f083 0301 	eor.w	r3, r3, #1
 8003ac4:	b2d8      	uxtb	r0, r3
 8003ac6:	687a      	ldr	r2, [r7, #4]
 8003ac8:	69bb      	ldr	r3, [r7, #24]
 8003aca:	212c      	movs	r1, #44	; 0x2c
 8003acc:	fb01 f303 	mul.w	r3, r1, r3
 8003ad0:	4413      	add	r3, r2
 8003ad2:	3354      	adds	r3, #84	; 0x54
 8003ad4:	4602      	mov	r2, r0
 8003ad6:	701a      	strb	r2, [r3, #0]
      break;
 8003ad8:	e00b      	b.n	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
          hhcd->hc[ch_num].urb_state = URB_ERROR;
 8003ada:	687a      	ldr	r2, [r7, #4]
 8003adc:	69bb      	ldr	r3, [r7, #24]
 8003ade:	212c      	movs	r1, #44	; 0x2c
 8003ae0:	fb01 f303 	mul.w	r3, r1, r3
 8003ae4:	4413      	add	r3, r2
 8003ae6:	3360      	adds	r3, #96	; 0x60
 8003ae8:	2204      	movs	r2, #4
 8003aea:	701a      	strb	r2, [r3, #0]
      break;
 8003aec:	e001      	b.n	8003af2 <HCD_RXQLVL_IRQHandler+0x19a>
      break;
 8003aee:	bf00      	nop
 8003af0:	e000      	b.n	8003af4 <HCD_RXQLVL_IRQHandler+0x19c>
      break;
 8003af2:	bf00      	nop
  }
}
 8003af4:	bf00      	nop
 8003af6:	3728      	adds	r7, #40	; 0x28
 8003af8:	46bd      	mov	sp, r7
 8003afa:	bd80      	pop	{r7, pc}

08003afc <HCD_Port_IRQHandler>:
  * @brief  Handle Host Port interrupt requests.
  * @param  hhcd HCD handle
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8003afc:	b580      	push	{r7, lr}
 8003afe:	b086      	sub	sp, #24
 8003b00:	af00      	add	r7, sp, #0
 8003b02:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8003b04:	687b      	ldr	r3, [r7, #4]
 8003b06:	681b      	ldr	r3, [r3, #0]
 8003b08:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003b0a:	697b      	ldr	r3, [r7, #20]
 8003b0c:	613b      	str	r3, [r7, #16]
  __IO uint32_t hprt0;
  __IO uint32_t hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 8003b0e:	693b      	ldr	r3, [r7, #16]
 8003b10:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 8003b14:	681b      	ldr	r3, [r3, #0]
 8003b16:	60fb      	str	r3, [r7, #12]
  hprt0_dup = USBx_HPRT0;
 8003b18:	693b      	ldr	r3, [r7, #16]
 8003b1a:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 8003b1e:	681b      	ldr	r3, [r3, #0]
 8003b20:	60bb      	str	r3, [r7, #8]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 8003b22:	68bb      	ldr	r3, [r7, #8]
 8003b24:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8003b28:	60bb      	str	r3, [r7, #8]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8003b2a:	68fb      	ldr	r3, [r7, #12]
 8003b2c:	f003 0302 	and.w	r3, r3, #2
 8003b30:	2b02      	cmp	r3, #2
 8003b32:	d10b      	bne.n	8003b4c <HCD_Port_IRQHandler+0x50>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8003b34:	68fb      	ldr	r3, [r7, #12]
 8003b36:	f003 0301 	and.w	r3, r3, #1
 8003b3a:	2b01      	cmp	r3, #1
 8003b3c:	d102      	bne.n	8003b44 <HCD_Port_IRQHandler+0x48>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
 8003b3e:	6878      	ldr	r0, [r7, #4]
 8003b40:	f024 f912 	bl	8027d68 <HAL_HCD_Connect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup |= USB_OTG_HPRT_PCDET;
 8003b44:	68bb      	ldr	r3, [r7, #8]
 8003b46:	f043 0302 	orr.w	r3, r3, #2
 8003b4a:	60bb      	str	r3, [r7, #8]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8003b4c:	68fb      	ldr	r3, [r7, #12]
 8003b4e:	f003 0308 	and.w	r3, r3, #8
 8003b52:	2b08      	cmp	r3, #8
 8003b54:	d132      	bne.n	8003bbc <HCD_Port_IRQHandler+0xc0>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8003b56:	68bb      	ldr	r3, [r7, #8]
 8003b58:	f043 0308 	orr.w	r3, r3, #8
 8003b5c:	60bb      	str	r3, [r7, #8]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8003b5e:	68fb      	ldr	r3, [r7, #12]
 8003b60:	f003 0304 	and.w	r3, r3, #4
 8003b64:	2b04      	cmp	r3, #4
 8003b66:	d126      	bne.n	8003bb6 <HCD_Port_IRQHandler+0xba>
    {
      if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
 8003b68:	687b      	ldr	r3, [r7, #4]
 8003b6a:	699b      	ldr	r3, [r3, #24]
 8003b6c:	2b02      	cmp	r3, #2
 8003b6e:	d113      	bne.n	8003b98 <HCD_Port_IRQHandler+0x9c>
      {
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8003b70:	68fb      	ldr	r3, [r7, #12]
 8003b72:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 8003b76:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003b7a:	d106      	bne.n	8003b8a <HCD_Port_IRQHandler+0x8e>
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
 8003b7c:	687b      	ldr	r3, [r7, #4]
 8003b7e:	681b      	ldr	r3, [r3, #0]
 8003b80:	2102      	movs	r1, #2
 8003b82:	4618      	mov	r0, r3
 8003b84:	f001 faf2 	bl	800516c <USB_InitFSLSPClkSel>
 8003b88:	e011      	b.n	8003bae <HCD_Port_IRQHandler+0xb2>
        }
        else
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8003b8a:	687b      	ldr	r3, [r7, #4]
 8003b8c:	681b      	ldr	r3, [r3, #0]
 8003b8e:	2101      	movs	r1, #1
 8003b90:	4618      	mov	r0, r3
 8003b92:	f001 faeb 	bl	800516c <USB_InitFSLSPClkSel>
 8003b96:	e00a      	b.n	8003bae <HCD_Port_IRQHandler+0xb2>
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 8003b98:	687b      	ldr	r3, [r7, #4]
 8003b9a:	68db      	ldr	r3, [r3, #12]
 8003b9c:	2b01      	cmp	r3, #1
 8003b9e:	d106      	bne.n	8003bae <HCD_Port_IRQHandler+0xb2>
        {
          USBx_HOST->HFIR = 60000U;
 8003ba0:	693b      	ldr	r3, [r7, #16]
 8003ba2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003ba6:	461a      	mov	r2, r3
 8003ba8:	f64e 2360 	movw	r3, #60000	; 0xea60
 8003bac:	6053      	str	r3, [r2, #4]
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 8003bae:	6878      	ldr	r0, [r7, #4]
 8003bb0:	f024 f904 	bl	8027dbc <HAL_HCD_PortEnabled_Callback>
 8003bb4:	e002      	b.n	8003bbc <HCD_Port_IRQHandler+0xc0>
    else
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortDisabledCallback(hhcd);
#else
      HAL_HCD_PortDisabled_Callback(hhcd);
 8003bb6:	6878      	ldr	r0, [r7, #4]
 8003bb8:	f024 f90e 	bl	8027dd8 <HAL_HCD_PortDisabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 8003bbc:	68fb      	ldr	r3, [r7, #12]
 8003bbe:	f003 0320 	and.w	r3, r3, #32
 8003bc2:	2b20      	cmp	r3, #32
 8003bc4:	d103      	bne.n	8003bce <HCD_Port_IRQHandler+0xd2>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 8003bc6:	68bb      	ldr	r3, [r7, #8]
 8003bc8:	f043 0320 	orr.w	r3, r3, #32
 8003bcc:	60bb      	str	r3, [r7, #8]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 8003bce:	693b      	ldr	r3, [r7, #16]
 8003bd0:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 8003bd4:	461a      	mov	r2, r3
 8003bd6:	68bb      	ldr	r3, [r7, #8]
 8003bd8:	6013      	str	r3, [r2, #0]
}
 8003bda:	bf00      	nop
 8003bdc:	3718      	adds	r7, #24
 8003bde:	46bd      	mov	sp, r7
 8003be0:	bd80      	pop	{r7, pc}
	...

08003be4 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003be4:	b580      	push	{r7, lr}
 8003be6:	b086      	sub	sp, #24
 8003be8:	af00      	add	r7, sp, #0
 8003bea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8003bec:	687b      	ldr	r3, [r7, #4]
 8003bee:	2b00      	cmp	r3, #0
 8003bf0:	d101      	bne.n	8003bf6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8003bf2:	2301      	movs	r3, #1
 8003bf4:	e264      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003bf6:	687b      	ldr	r3, [r7, #4]
 8003bf8:	681b      	ldr	r3, [r3, #0]
 8003bfa:	f003 0301 	and.w	r3, r3, #1
 8003bfe:	2b00      	cmp	r3, #0
 8003c00:	d075      	beq.n	8003cee <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003c02:	4ba3      	ldr	r3, [pc, #652]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c04:	689b      	ldr	r3, [r3, #8]
 8003c06:	f003 030c 	and.w	r3, r3, #12
 8003c0a:	2b04      	cmp	r3, #4
 8003c0c:	d00c      	beq.n	8003c28 <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003c0e:	4ba0      	ldr	r3, [pc, #640]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c10:	689b      	ldr	r3, [r3, #8]
 8003c12:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003c16:	2b08      	cmp	r3, #8
 8003c18:	d112      	bne.n	8003c40 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003c1a:	4b9d      	ldr	r3, [pc, #628]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c1c:	685b      	ldr	r3, [r3, #4]
 8003c1e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003c22:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8003c26:	d10b      	bne.n	8003c40 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003c28:	4b99      	ldr	r3, [pc, #612]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c2a:	681b      	ldr	r3, [r3, #0]
 8003c2c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003c30:	2b00      	cmp	r3, #0
 8003c32:	d05b      	beq.n	8003cec <HAL_RCC_OscConfig+0x108>
 8003c34:	687b      	ldr	r3, [r7, #4]
 8003c36:	685b      	ldr	r3, [r3, #4]
 8003c38:	2b00      	cmp	r3, #0
 8003c3a:	d157      	bne.n	8003cec <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 8003c3c:	2301      	movs	r3, #1
 8003c3e:	e23f      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003c40:	687b      	ldr	r3, [r7, #4]
 8003c42:	685b      	ldr	r3, [r3, #4]
 8003c44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003c48:	d106      	bne.n	8003c58 <HAL_RCC_OscConfig+0x74>
 8003c4a:	4b91      	ldr	r3, [pc, #580]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c4c:	681b      	ldr	r3, [r3, #0]
 8003c4e:	4a90      	ldr	r2, [pc, #576]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003c54:	6013      	str	r3, [r2, #0]
 8003c56:	e01d      	b.n	8003c94 <HAL_RCC_OscConfig+0xb0>
 8003c58:	687b      	ldr	r3, [r7, #4]
 8003c5a:	685b      	ldr	r3, [r3, #4]
 8003c5c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8003c60:	d10c      	bne.n	8003c7c <HAL_RCC_OscConfig+0x98>
 8003c62:	4b8b      	ldr	r3, [pc, #556]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c64:	681b      	ldr	r3, [r3, #0]
 8003c66:	4a8a      	ldr	r2, [pc, #552]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c68:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003c6c:	6013      	str	r3, [r2, #0]
 8003c6e:	4b88      	ldr	r3, [pc, #544]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c70:	681b      	ldr	r3, [r3, #0]
 8003c72:	4a87      	ldr	r2, [pc, #540]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c74:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003c78:	6013      	str	r3, [r2, #0]
 8003c7a:	e00b      	b.n	8003c94 <HAL_RCC_OscConfig+0xb0>
 8003c7c:	4b84      	ldr	r3, [pc, #528]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c7e:	681b      	ldr	r3, [r3, #0]
 8003c80:	4a83      	ldr	r2, [pc, #524]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c82:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003c86:	6013      	str	r3, [r2, #0]
 8003c88:	4b81      	ldr	r3, [pc, #516]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c8a:	681b      	ldr	r3, [r3, #0]
 8003c8c:	4a80      	ldr	r2, [pc, #512]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003c8e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003c92:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003c94:	687b      	ldr	r3, [r7, #4]
 8003c96:	685b      	ldr	r3, [r3, #4]
 8003c98:	2b00      	cmp	r3, #0
 8003c9a:	d013      	beq.n	8003cc4 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003c9c:	f7fd ff52 	bl	8001b44 <HAL_GetTick>
 8003ca0:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003ca2:	e008      	b.n	8003cb6 <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003ca4:	f7fd ff4e 	bl	8001b44 <HAL_GetTick>
 8003ca8:	4602      	mov	r2, r0
 8003caa:	693b      	ldr	r3, [r7, #16]
 8003cac:	1ad3      	subs	r3, r2, r3
 8003cae:	2b64      	cmp	r3, #100	; 0x64
 8003cb0:	d901      	bls.n	8003cb6 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8003cb2:	2303      	movs	r3, #3
 8003cb4:	e204      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003cb6:	4b76      	ldr	r3, [pc, #472]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003cb8:	681b      	ldr	r3, [r3, #0]
 8003cba:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003cbe:	2b00      	cmp	r3, #0
 8003cc0:	d0f0      	beq.n	8003ca4 <HAL_RCC_OscConfig+0xc0>
 8003cc2:	e014      	b.n	8003cee <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003cc4:	f7fd ff3e 	bl	8001b44 <HAL_GetTick>
 8003cc8:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003cca:	e008      	b.n	8003cde <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003ccc:	f7fd ff3a 	bl	8001b44 <HAL_GetTick>
 8003cd0:	4602      	mov	r2, r0
 8003cd2:	693b      	ldr	r3, [r7, #16]
 8003cd4:	1ad3      	subs	r3, r2, r3
 8003cd6:	2b64      	cmp	r3, #100	; 0x64
 8003cd8:	d901      	bls.n	8003cde <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 8003cda:	2303      	movs	r3, #3
 8003cdc:	e1f0      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003cde:	4b6c      	ldr	r3, [pc, #432]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003ce0:	681b      	ldr	r3, [r3, #0]
 8003ce2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	d1f0      	bne.n	8003ccc <HAL_RCC_OscConfig+0xe8>
 8003cea:	e000      	b.n	8003cee <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003cec:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003cee:	687b      	ldr	r3, [r7, #4]
 8003cf0:	681b      	ldr	r3, [r3, #0]
 8003cf2:	f003 0302 	and.w	r3, r3, #2
 8003cf6:	2b00      	cmp	r3, #0
 8003cf8:	d063      	beq.n	8003dc2 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8003cfa:	4b65      	ldr	r3, [pc, #404]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003cfc:	689b      	ldr	r3, [r3, #8]
 8003cfe:	f003 030c 	and.w	r3, r3, #12
 8003d02:	2b00      	cmp	r3, #0
 8003d04:	d00b      	beq.n	8003d1e <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003d06:	4b62      	ldr	r3, [pc, #392]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d08:	689b      	ldr	r3, [r3, #8]
 8003d0a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8003d0e:	2b08      	cmp	r3, #8
 8003d10:	d11c      	bne.n	8003d4c <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003d12:	4b5f      	ldr	r3, [pc, #380]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d14:	685b      	ldr	r3, [r3, #4]
 8003d16:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003d1a:	2b00      	cmp	r3, #0
 8003d1c:	d116      	bne.n	8003d4c <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8003d1e:	4b5c      	ldr	r3, [pc, #368]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d20:	681b      	ldr	r3, [r3, #0]
 8003d22:	f003 0302 	and.w	r3, r3, #2
 8003d26:	2b00      	cmp	r3, #0
 8003d28:	d005      	beq.n	8003d36 <HAL_RCC_OscConfig+0x152>
 8003d2a:	687b      	ldr	r3, [r7, #4]
 8003d2c:	68db      	ldr	r3, [r3, #12]
 8003d2e:	2b01      	cmp	r3, #1
 8003d30:	d001      	beq.n	8003d36 <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 8003d32:	2301      	movs	r3, #1
 8003d34:	e1c4      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003d36:	4b56      	ldr	r3, [pc, #344]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d38:	681b      	ldr	r3, [r3, #0]
 8003d3a:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8003d3e:	687b      	ldr	r3, [r7, #4]
 8003d40:	691b      	ldr	r3, [r3, #16]
 8003d42:	00db      	lsls	r3, r3, #3
 8003d44:	4952      	ldr	r1, [pc, #328]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d46:	4313      	orrs	r3, r2
 8003d48:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8003d4a:	e03a      	b.n	8003dc2 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8003d4c:	687b      	ldr	r3, [r7, #4]
 8003d4e:	68db      	ldr	r3, [r3, #12]
 8003d50:	2b00      	cmp	r3, #0
 8003d52:	d020      	beq.n	8003d96 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8003d54:	4b4f      	ldr	r3, [pc, #316]	; (8003e94 <HAL_RCC_OscConfig+0x2b0>)
 8003d56:	2201      	movs	r2, #1
 8003d58:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003d5a:	f7fd fef3 	bl	8001b44 <HAL_GetTick>
 8003d5e:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003d60:	e008      	b.n	8003d74 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003d62:	f7fd feef 	bl	8001b44 <HAL_GetTick>
 8003d66:	4602      	mov	r2, r0
 8003d68:	693b      	ldr	r3, [r7, #16]
 8003d6a:	1ad3      	subs	r3, r2, r3
 8003d6c:	2b02      	cmp	r3, #2
 8003d6e:	d901      	bls.n	8003d74 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 8003d70:	2303      	movs	r3, #3
 8003d72:	e1a5      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003d74:	4b46      	ldr	r3, [pc, #280]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d76:	681b      	ldr	r3, [r3, #0]
 8003d78:	f003 0302 	and.w	r3, r3, #2
 8003d7c:	2b00      	cmp	r3, #0
 8003d7e:	d0f0      	beq.n	8003d62 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003d80:	4b43      	ldr	r3, [pc, #268]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d82:	681b      	ldr	r3, [r3, #0]
 8003d84:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8003d88:	687b      	ldr	r3, [r7, #4]
 8003d8a:	691b      	ldr	r3, [r3, #16]
 8003d8c:	00db      	lsls	r3, r3, #3
 8003d8e:	4940      	ldr	r1, [pc, #256]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003d90:	4313      	orrs	r3, r2
 8003d92:	600b      	str	r3, [r1, #0]
 8003d94:	e015      	b.n	8003dc2 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8003d96:	4b3f      	ldr	r3, [pc, #252]	; (8003e94 <HAL_RCC_OscConfig+0x2b0>)
 8003d98:	2200      	movs	r2, #0
 8003d9a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003d9c:	f7fd fed2 	bl	8001b44 <HAL_GetTick>
 8003da0:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003da2:	e008      	b.n	8003db6 <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003da4:	f7fd fece 	bl	8001b44 <HAL_GetTick>
 8003da8:	4602      	mov	r2, r0
 8003daa:	693b      	ldr	r3, [r7, #16]
 8003dac:	1ad3      	subs	r3, r2, r3
 8003dae:	2b02      	cmp	r3, #2
 8003db0:	d901      	bls.n	8003db6 <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8003db2:	2303      	movs	r3, #3
 8003db4:	e184      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003db6:	4b36      	ldr	r3, [pc, #216]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003db8:	681b      	ldr	r3, [r3, #0]
 8003dba:	f003 0302 	and.w	r3, r3, #2
 8003dbe:	2b00      	cmp	r3, #0
 8003dc0:	d1f0      	bne.n	8003da4 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	681b      	ldr	r3, [r3, #0]
 8003dc6:	f003 0308 	and.w	r3, r3, #8
 8003dca:	2b00      	cmp	r3, #0
 8003dcc:	d030      	beq.n	8003e30 <HAL_RCC_OscConfig+0x24c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8003dce:	687b      	ldr	r3, [r7, #4]
 8003dd0:	695b      	ldr	r3, [r3, #20]
 8003dd2:	2b00      	cmp	r3, #0
 8003dd4:	d016      	beq.n	8003e04 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8003dd6:	4b30      	ldr	r3, [pc, #192]	; (8003e98 <HAL_RCC_OscConfig+0x2b4>)
 8003dd8:	2201      	movs	r2, #1
 8003dda:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003ddc:	f7fd feb2 	bl	8001b44 <HAL_GetTick>
 8003de0:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003de2:	e008      	b.n	8003df6 <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003de4:	f7fd feae 	bl	8001b44 <HAL_GetTick>
 8003de8:	4602      	mov	r2, r0
 8003dea:	693b      	ldr	r3, [r7, #16]
 8003dec:	1ad3      	subs	r3, r2, r3
 8003dee:	2b02      	cmp	r3, #2
 8003df0:	d901      	bls.n	8003df6 <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 8003df2:	2303      	movs	r3, #3
 8003df4:	e164      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003df6:	4b26      	ldr	r3, [pc, #152]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003df8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8003dfa:	f003 0302 	and.w	r3, r3, #2
 8003dfe:	2b00      	cmp	r3, #0
 8003e00:	d0f0      	beq.n	8003de4 <HAL_RCC_OscConfig+0x200>
 8003e02:	e015      	b.n	8003e30 <HAL_RCC_OscConfig+0x24c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8003e04:	4b24      	ldr	r3, [pc, #144]	; (8003e98 <HAL_RCC_OscConfig+0x2b4>)
 8003e06:	2200      	movs	r2, #0
 8003e08:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003e0a:	f7fd fe9b 	bl	8001b44 <HAL_GetTick>
 8003e0e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003e10:	e008      	b.n	8003e24 <HAL_RCC_OscConfig+0x240>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003e12:	f7fd fe97 	bl	8001b44 <HAL_GetTick>
 8003e16:	4602      	mov	r2, r0
 8003e18:	693b      	ldr	r3, [r7, #16]
 8003e1a:	1ad3      	subs	r3, r2, r3
 8003e1c:	2b02      	cmp	r3, #2
 8003e1e:	d901      	bls.n	8003e24 <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
 8003e20:	2303      	movs	r3, #3
 8003e22:	e14d      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003e24:	4b1a      	ldr	r3, [pc, #104]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003e26:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8003e28:	f003 0302 	and.w	r3, r3, #2
 8003e2c:	2b00      	cmp	r3, #0
 8003e2e:	d1f0      	bne.n	8003e12 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003e30:	687b      	ldr	r3, [r7, #4]
 8003e32:	681b      	ldr	r3, [r3, #0]
 8003e34:	f003 0304 	and.w	r3, r3, #4
 8003e38:	2b00      	cmp	r3, #0
 8003e3a:	f000 80a0 	beq.w	8003f7e <HAL_RCC_OscConfig+0x39a>
  {
    FlagStatus       pwrclkchanged = RESET;
 8003e3e:	2300      	movs	r3, #0
 8003e40:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003e42:	4b13      	ldr	r3, [pc, #76]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003e44:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003e46:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d10f      	bne.n	8003e6e <HAL_RCC_OscConfig+0x28a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003e4e:	2300      	movs	r3, #0
 8003e50:	60bb      	str	r3, [r7, #8]
 8003e52:	4b0f      	ldr	r3, [pc, #60]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003e54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003e56:	4a0e      	ldr	r2, [pc, #56]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003e58:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003e5c:	6413      	str	r3, [r2, #64]	; 0x40
 8003e5e:	4b0c      	ldr	r3, [pc, #48]	; (8003e90 <HAL_RCC_OscConfig+0x2ac>)
 8003e60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003e62:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003e66:	60bb      	str	r3, [r7, #8]
 8003e68:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 8003e6a:	2301      	movs	r3, #1
 8003e6c:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003e6e:	4b0b      	ldr	r3, [pc, #44]	; (8003e9c <HAL_RCC_OscConfig+0x2b8>)
 8003e70:	681b      	ldr	r3, [r3, #0]
 8003e72:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003e76:	2b00      	cmp	r3, #0
 8003e78:	d121      	bne.n	8003ebe <HAL_RCC_OscConfig+0x2da>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8003e7a:	4b08      	ldr	r3, [pc, #32]	; (8003e9c <HAL_RCC_OscConfig+0x2b8>)
 8003e7c:	681b      	ldr	r3, [r3, #0]
 8003e7e:	4a07      	ldr	r2, [pc, #28]	; (8003e9c <HAL_RCC_OscConfig+0x2b8>)
 8003e80:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003e84:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003e86:	f7fd fe5d 	bl	8001b44 <HAL_GetTick>
 8003e8a:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003e8c:	e011      	b.n	8003eb2 <HAL_RCC_OscConfig+0x2ce>
 8003e8e:	bf00      	nop
 8003e90:	40023800 	.word	0x40023800
 8003e94:	42470000 	.word	0x42470000
 8003e98:	42470e80 	.word	0x42470e80
 8003e9c:	40007000 	.word	0x40007000
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003ea0:	f7fd fe50 	bl	8001b44 <HAL_GetTick>
 8003ea4:	4602      	mov	r2, r0
 8003ea6:	693b      	ldr	r3, [r7, #16]
 8003ea8:	1ad3      	subs	r3, r2, r3
 8003eaa:	2b02      	cmp	r3, #2
 8003eac:	d901      	bls.n	8003eb2 <HAL_RCC_OscConfig+0x2ce>
        {
          return HAL_TIMEOUT;
 8003eae:	2303      	movs	r3, #3
 8003eb0:	e106      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003eb2:	4b85      	ldr	r3, [pc, #532]	; (80040c8 <HAL_RCC_OscConfig+0x4e4>)
 8003eb4:	681b      	ldr	r3, [r3, #0]
 8003eb6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003eba:	2b00      	cmp	r3, #0
 8003ebc:	d0f0      	beq.n	8003ea0 <HAL_RCC_OscConfig+0x2bc>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003ebe:	687b      	ldr	r3, [r7, #4]
 8003ec0:	689b      	ldr	r3, [r3, #8]
 8003ec2:	2b01      	cmp	r3, #1
 8003ec4:	d106      	bne.n	8003ed4 <HAL_RCC_OscConfig+0x2f0>
 8003ec6:	4b81      	ldr	r3, [pc, #516]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003ec8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003eca:	4a80      	ldr	r2, [pc, #512]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003ecc:	f043 0301 	orr.w	r3, r3, #1
 8003ed0:	6713      	str	r3, [r2, #112]	; 0x70
 8003ed2:	e01c      	b.n	8003f0e <HAL_RCC_OscConfig+0x32a>
 8003ed4:	687b      	ldr	r3, [r7, #4]
 8003ed6:	689b      	ldr	r3, [r3, #8]
 8003ed8:	2b05      	cmp	r3, #5
 8003eda:	d10c      	bne.n	8003ef6 <HAL_RCC_OscConfig+0x312>
 8003edc:	4b7b      	ldr	r3, [pc, #492]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003ede:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003ee0:	4a7a      	ldr	r2, [pc, #488]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003ee2:	f043 0304 	orr.w	r3, r3, #4
 8003ee6:	6713      	str	r3, [r2, #112]	; 0x70
 8003ee8:	4b78      	ldr	r3, [pc, #480]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003eea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003eec:	4a77      	ldr	r2, [pc, #476]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003eee:	f043 0301 	orr.w	r3, r3, #1
 8003ef2:	6713      	str	r3, [r2, #112]	; 0x70
 8003ef4:	e00b      	b.n	8003f0e <HAL_RCC_OscConfig+0x32a>
 8003ef6:	4b75      	ldr	r3, [pc, #468]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003ef8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003efa:	4a74      	ldr	r2, [pc, #464]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003efc:	f023 0301 	bic.w	r3, r3, #1
 8003f00:	6713      	str	r3, [r2, #112]	; 0x70
 8003f02:	4b72      	ldr	r3, [pc, #456]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f04:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f06:	4a71      	ldr	r2, [pc, #452]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f08:	f023 0304 	bic.w	r3, r3, #4
 8003f0c:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8003f0e:	687b      	ldr	r3, [r7, #4]
 8003f10:	689b      	ldr	r3, [r3, #8]
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	d015      	beq.n	8003f42 <HAL_RCC_OscConfig+0x35e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003f16:	f7fd fe15 	bl	8001b44 <HAL_GetTick>
 8003f1a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003f1c:	e00a      	b.n	8003f34 <HAL_RCC_OscConfig+0x350>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003f1e:	f7fd fe11 	bl	8001b44 <HAL_GetTick>
 8003f22:	4602      	mov	r2, r0
 8003f24:	693b      	ldr	r3, [r7, #16]
 8003f26:	1ad3      	subs	r3, r2, r3
 8003f28:	f241 3288 	movw	r2, #5000	; 0x1388
 8003f2c:	4293      	cmp	r3, r2
 8003f2e:	d901      	bls.n	8003f34 <HAL_RCC_OscConfig+0x350>
        {
          return HAL_TIMEOUT;
 8003f30:	2303      	movs	r3, #3
 8003f32:	e0c5      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003f34:	4b65      	ldr	r3, [pc, #404]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f36:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f38:	f003 0302 	and.w	r3, r3, #2
 8003f3c:	2b00      	cmp	r3, #0
 8003f3e:	d0ee      	beq.n	8003f1e <HAL_RCC_OscConfig+0x33a>
 8003f40:	e014      	b.n	8003f6c <HAL_RCC_OscConfig+0x388>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003f42:	f7fd fdff 	bl	8001b44 <HAL_GetTick>
 8003f46:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003f48:	e00a      	b.n	8003f60 <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003f4a:	f7fd fdfb 	bl	8001b44 <HAL_GetTick>
 8003f4e:	4602      	mov	r2, r0
 8003f50:	693b      	ldr	r3, [r7, #16]
 8003f52:	1ad3      	subs	r3, r2, r3
 8003f54:	f241 3288 	movw	r2, #5000	; 0x1388
 8003f58:	4293      	cmp	r3, r2
 8003f5a:	d901      	bls.n	8003f60 <HAL_RCC_OscConfig+0x37c>
        {
          return HAL_TIMEOUT;
 8003f5c:	2303      	movs	r3, #3
 8003f5e:	e0af      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003f60:	4b5a      	ldr	r3, [pc, #360]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f62:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f64:	f003 0302 	and.w	r3, r3, #2
 8003f68:	2b00      	cmp	r3, #0
 8003f6a:	d1ee      	bne.n	8003f4a <HAL_RCC_OscConfig+0x366>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8003f6c:	7dfb      	ldrb	r3, [r7, #23]
 8003f6e:	2b01      	cmp	r3, #1
 8003f70:	d105      	bne.n	8003f7e <HAL_RCC_OscConfig+0x39a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003f72:	4b56      	ldr	r3, [pc, #344]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003f76:	4a55      	ldr	r2, [pc, #340]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f78:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003f7c:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8003f7e:	687b      	ldr	r3, [r7, #4]
 8003f80:	699b      	ldr	r3, [r3, #24]
 8003f82:	2b00      	cmp	r3, #0
 8003f84:	f000 809b 	beq.w	80040be <HAL_RCC_OscConfig+0x4da>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8003f88:	4b50      	ldr	r3, [pc, #320]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003f8a:	689b      	ldr	r3, [r3, #8]
 8003f8c:	f003 030c 	and.w	r3, r3, #12
 8003f90:	2b08      	cmp	r3, #8
 8003f92:	d05c      	beq.n	800404e <HAL_RCC_OscConfig+0x46a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003f94:	687b      	ldr	r3, [r7, #4]
 8003f96:	699b      	ldr	r3, [r3, #24]
 8003f98:	2b02      	cmp	r3, #2
 8003f9a:	d141      	bne.n	8004020 <HAL_RCC_OscConfig+0x43c>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003f9c:	4b4c      	ldr	r3, [pc, #304]	; (80040d0 <HAL_RCC_OscConfig+0x4ec>)
 8003f9e:	2200      	movs	r2, #0
 8003fa0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003fa2:	f7fd fdcf 	bl	8001b44 <HAL_GetTick>
 8003fa6:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003fa8:	e008      	b.n	8003fbc <HAL_RCC_OscConfig+0x3d8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003faa:	f7fd fdcb 	bl	8001b44 <HAL_GetTick>
 8003fae:	4602      	mov	r2, r0
 8003fb0:	693b      	ldr	r3, [r7, #16]
 8003fb2:	1ad3      	subs	r3, r2, r3
 8003fb4:	2b02      	cmp	r3, #2
 8003fb6:	d901      	bls.n	8003fbc <HAL_RCC_OscConfig+0x3d8>
          {
            return HAL_TIMEOUT;
 8003fb8:	2303      	movs	r3, #3
 8003fba:	e081      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003fbc:	4b43      	ldr	r3, [pc, #268]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003fbe:	681b      	ldr	r3, [r3, #0]
 8003fc0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003fc4:	2b00      	cmp	r3, #0
 8003fc6:	d1f0      	bne.n	8003faa <HAL_RCC_OscConfig+0x3c6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	69da      	ldr	r2, [r3, #28]
 8003fcc:	687b      	ldr	r3, [r7, #4]
 8003fce:	6a1b      	ldr	r3, [r3, #32]
 8003fd0:	431a      	orrs	r2, r3
 8003fd2:	687b      	ldr	r3, [r7, #4]
 8003fd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003fd6:	019b      	lsls	r3, r3, #6
 8003fd8:	431a      	orrs	r2, r3
 8003fda:	687b      	ldr	r3, [r7, #4]
 8003fdc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003fde:	085b      	lsrs	r3, r3, #1
 8003fe0:	3b01      	subs	r3, #1
 8003fe2:	041b      	lsls	r3, r3, #16
 8003fe4:	431a      	orrs	r2, r3
 8003fe6:	687b      	ldr	r3, [r7, #4]
 8003fe8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003fea:	061b      	lsls	r3, r3, #24
 8003fec:	4937      	ldr	r1, [pc, #220]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8003fee:	4313      	orrs	r3, r2
 8003ff0:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8003ff2:	4b37      	ldr	r3, [pc, #220]	; (80040d0 <HAL_RCC_OscConfig+0x4ec>)
 8003ff4:	2201      	movs	r2, #1
 8003ff6:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003ff8:	f7fd fda4 	bl	8001b44 <HAL_GetTick>
 8003ffc:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003ffe:	e008      	b.n	8004012 <HAL_RCC_OscConfig+0x42e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004000:	f7fd fda0 	bl	8001b44 <HAL_GetTick>
 8004004:	4602      	mov	r2, r0
 8004006:	693b      	ldr	r3, [r7, #16]
 8004008:	1ad3      	subs	r3, r2, r3
 800400a:	2b02      	cmp	r3, #2
 800400c:	d901      	bls.n	8004012 <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_TIMEOUT;
 800400e:	2303      	movs	r3, #3
 8004010:	e056      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004012:	4b2e      	ldr	r3, [pc, #184]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8004014:	681b      	ldr	r3, [r3, #0]
 8004016:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800401a:	2b00      	cmp	r3, #0
 800401c:	d0f0      	beq.n	8004000 <HAL_RCC_OscConfig+0x41c>
 800401e:	e04e      	b.n	80040be <HAL_RCC_OscConfig+0x4da>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004020:	4b2b      	ldr	r3, [pc, #172]	; (80040d0 <HAL_RCC_OscConfig+0x4ec>)
 8004022:	2200      	movs	r2, #0
 8004024:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8004026:	f7fd fd8d 	bl	8001b44 <HAL_GetTick>
 800402a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800402c:	e008      	b.n	8004040 <HAL_RCC_OscConfig+0x45c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800402e:	f7fd fd89 	bl	8001b44 <HAL_GetTick>
 8004032:	4602      	mov	r2, r0
 8004034:	693b      	ldr	r3, [r7, #16]
 8004036:	1ad3      	subs	r3, r2, r3
 8004038:	2b02      	cmp	r3, #2
 800403a:	d901      	bls.n	8004040 <HAL_RCC_OscConfig+0x45c>
          {
            return HAL_TIMEOUT;
 800403c:	2303      	movs	r3, #3
 800403e:	e03f      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004040:	4b22      	ldr	r3, [pc, #136]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 8004042:	681b      	ldr	r3, [r3, #0]
 8004044:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004048:	2b00      	cmp	r3, #0
 800404a:	d1f0      	bne.n	800402e <HAL_RCC_OscConfig+0x44a>
 800404c:	e037      	b.n	80040be <HAL_RCC_OscConfig+0x4da>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800404e:	687b      	ldr	r3, [r7, #4]
 8004050:	699b      	ldr	r3, [r3, #24]
 8004052:	2b01      	cmp	r3, #1
 8004054:	d101      	bne.n	800405a <HAL_RCC_OscConfig+0x476>
      {
        return HAL_ERROR;
 8004056:	2301      	movs	r3, #1
 8004058:	e032      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 800405a:	4b1c      	ldr	r3, [pc, #112]	; (80040cc <HAL_RCC_OscConfig+0x4e8>)
 800405c:	685b      	ldr	r3, [r3, #4]
 800405e:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004060:	687b      	ldr	r3, [r7, #4]
 8004062:	699b      	ldr	r3, [r3, #24]
 8004064:	2b01      	cmp	r3, #1
 8004066:	d028      	beq.n	80040ba <HAL_RCC_OscConfig+0x4d6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004068:	68fb      	ldr	r3, [r7, #12]
 800406a:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 800406e:	687b      	ldr	r3, [r7, #4]
 8004070:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004072:	429a      	cmp	r2, r3
 8004074:	d121      	bne.n	80040ba <HAL_RCC_OscConfig+0x4d6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004076:	68fb      	ldr	r3, [r7, #12]
 8004078:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800407c:	687b      	ldr	r3, [r7, #4]
 800407e:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004080:	429a      	cmp	r2, r3
 8004082:	d11a      	bne.n	80040ba <HAL_RCC_OscConfig+0x4d6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8004084:	68fa      	ldr	r2, [r7, #12]
 8004086:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800408a:	4013      	ands	r3, r2
 800408c:	687a      	ldr	r2, [r7, #4]
 800408e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8004090:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8004092:	4293      	cmp	r3, r2
 8004094:	d111      	bne.n	80040ba <HAL_RCC_OscConfig+0x4d6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8004096:	68fb      	ldr	r3, [r7, #12]
 8004098:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800409c:	687b      	ldr	r3, [r7, #4]
 800409e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80040a0:	085b      	lsrs	r3, r3, #1
 80040a2:	3b01      	subs	r3, #1
 80040a4:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80040a6:	429a      	cmp	r2, r3
 80040a8:	d107      	bne.n	80040ba <HAL_RCC_OscConfig+0x4d6>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80040aa:	68fb      	ldr	r3, [r7, #12]
 80040ac:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 80040b0:	687b      	ldr	r3, [r7, #4]
 80040b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80040b4:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80040b6:	429a      	cmp	r2, r3
 80040b8:	d001      	beq.n	80040be <HAL_RCC_OscConfig+0x4da>
#endif
        {
          return HAL_ERROR;
 80040ba:	2301      	movs	r3, #1
 80040bc:	e000      	b.n	80040c0 <HAL_RCC_OscConfig+0x4dc>
        }
      }
    }
  }
  return HAL_OK;
 80040be:	2300      	movs	r3, #0
}
 80040c0:	4618      	mov	r0, r3
 80040c2:	3718      	adds	r7, #24
 80040c4:	46bd      	mov	sp, r7
 80040c6:	bd80      	pop	{r7, pc}
 80040c8:	40007000 	.word	0x40007000
 80040cc:	40023800 	.word	0x40023800
 80040d0:	42470060 	.word	0x42470060

080040d4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80040d4:	b580      	push	{r7, lr}
 80040d6:	b084      	sub	sp, #16
 80040d8:	af00      	add	r7, sp, #0
 80040da:	6078      	str	r0, [r7, #4]
 80040dc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 80040de:	687b      	ldr	r3, [r7, #4]
 80040e0:	2b00      	cmp	r3, #0
 80040e2:	d101      	bne.n	80040e8 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 80040e4:	2301      	movs	r3, #1
 80040e6:	e0cc      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80040e8:	4b68      	ldr	r3, [pc, #416]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 80040ea:	681b      	ldr	r3, [r3, #0]
 80040ec:	f003 0307 	and.w	r3, r3, #7
 80040f0:	683a      	ldr	r2, [r7, #0]
 80040f2:	429a      	cmp	r2, r3
 80040f4:	d90c      	bls.n	8004110 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80040f6:	4b65      	ldr	r3, [pc, #404]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 80040f8:	683a      	ldr	r2, [r7, #0]
 80040fa:	b2d2      	uxtb	r2, r2
 80040fc:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80040fe:	4b63      	ldr	r3, [pc, #396]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 8004100:	681b      	ldr	r3, [r3, #0]
 8004102:	f003 0307 	and.w	r3, r3, #7
 8004106:	683a      	ldr	r2, [r7, #0]
 8004108:	429a      	cmp	r2, r3
 800410a:	d001      	beq.n	8004110 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 800410c:	2301      	movs	r3, #1
 800410e:	e0b8      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004110:	687b      	ldr	r3, [r7, #4]
 8004112:	681b      	ldr	r3, [r3, #0]
 8004114:	f003 0302 	and.w	r3, r3, #2
 8004118:	2b00      	cmp	r3, #0
 800411a:	d020      	beq.n	800415e <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800411c:	687b      	ldr	r3, [r7, #4]
 800411e:	681b      	ldr	r3, [r3, #0]
 8004120:	f003 0304 	and.w	r3, r3, #4
 8004124:	2b00      	cmp	r3, #0
 8004126:	d005      	beq.n	8004134 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8004128:	4b59      	ldr	r3, [pc, #356]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 800412a:	689b      	ldr	r3, [r3, #8]
 800412c:	4a58      	ldr	r2, [pc, #352]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 800412e:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 8004132:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004134:	687b      	ldr	r3, [r7, #4]
 8004136:	681b      	ldr	r3, [r3, #0]
 8004138:	f003 0308 	and.w	r3, r3, #8
 800413c:	2b00      	cmp	r3, #0
 800413e:	d005      	beq.n	800414c <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8004140:	4b53      	ldr	r3, [pc, #332]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004142:	689b      	ldr	r3, [r3, #8]
 8004144:	4a52      	ldr	r2, [pc, #328]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004146:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800414a:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800414c:	4b50      	ldr	r3, [pc, #320]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 800414e:	689b      	ldr	r3, [r3, #8]
 8004150:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8004154:	687b      	ldr	r3, [r7, #4]
 8004156:	689b      	ldr	r3, [r3, #8]
 8004158:	494d      	ldr	r1, [pc, #308]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 800415a:	4313      	orrs	r3, r2
 800415c:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800415e:	687b      	ldr	r3, [r7, #4]
 8004160:	681b      	ldr	r3, [r3, #0]
 8004162:	f003 0301 	and.w	r3, r3, #1
 8004166:	2b00      	cmp	r3, #0
 8004168:	d044      	beq.n	80041f4 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800416a:	687b      	ldr	r3, [r7, #4]
 800416c:	685b      	ldr	r3, [r3, #4]
 800416e:	2b01      	cmp	r3, #1
 8004170:	d107      	bne.n	8004182 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004172:	4b47      	ldr	r3, [pc, #284]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004174:	681b      	ldr	r3, [r3, #0]
 8004176:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800417a:	2b00      	cmp	r3, #0
 800417c:	d119      	bne.n	80041b2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800417e:	2301      	movs	r3, #1
 8004180:	e07f      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004182:	687b      	ldr	r3, [r7, #4]
 8004184:	685b      	ldr	r3, [r3, #4]
 8004186:	2b02      	cmp	r3, #2
 8004188:	d003      	beq.n	8004192 <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 800418a:	687b      	ldr	r3, [r7, #4]
 800418c:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800418e:	2b03      	cmp	r3, #3
 8004190:	d107      	bne.n	80041a2 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004192:	4b3f      	ldr	r3, [pc, #252]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004194:	681b      	ldr	r3, [r3, #0]
 8004196:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800419a:	2b00      	cmp	r3, #0
 800419c:	d109      	bne.n	80041b2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800419e:	2301      	movs	r3, #1
 80041a0:	e06f      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80041a2:	4b3b      	ldr	r3, [pc, #236]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 80041a4:	681b      	ldr	r3, [r3, #0]
 80041a6:	f003 0302 	and.w	r3, r3, #2
 80041aa:	2b00      	cmp	r3, #0
 80041ac:	d101      	bne.n	80041b2 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80041ae:	2301      	movs	r3, #1
 80041b0:	e067      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80041b2:	4b37      	ldr	r3, [pc, #220]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 80041b4:	689b      	ldr	r3, [r3, #8]
 80041b6:	f023 0203 	bic.w	r2, r3, #3
 80041ba:	687b      	ldr	r3, [r7, #4]
 80041bc:	685b      	ldr	r3, [r3, #4]
 80041be:	4934      	ldr	r1, [pc, #208]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 80041c0:	4313      	orrs	r3, r2
 80041c2:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 80041c4:	f7fd fcbe 	bl	8001b44 <HAL_GetTick>
 80041c8:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80041ca:	e00a      	b.n	80041e2 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80041cc:	f7fd fcba 	bl	8001b44 <HAL_GetTick>
 80041d0:	4602      	mov	r2, r0
 80041d2:	68fb      	ldr	r3, [r7, #12]
 80041d4:	1ad3      	subs	r3, r2, r3
 80041d6:	f241 3288 	movw	r2, #5000	; 0x1388
 80041da:	4293      	cmp	r3, r2
 80041dc:	d901      	bls.n	80041e2 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 80041de:	2303      	movs	r3, #3
 80041e0:	e04f      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80041e2:	4b2b      	ldr	r3, [pc, #172]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 80041e4:	689b      	ldr	r3, [r3, #8]
 80041e6:	f003 020c 	and.w	r2, r3, #12
 80041ea:	687b      	ldr	r3, [r7, #4]
 80041ec:	685b      	ldr	r3, [r3, #4]
 80041ee:	009b      	lsls	r3, r3, #2
 80041f0:	429a      	cmp	r2, r3
 80041f2:	d1eb      	bne.n	80041cc <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80041f4:	4b25      	ldr	r3, [pc, #148]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 80041f6:	681b      	ldr	r3, [r3, #0]
 80041f8:	f003 0307 	and.w	r3, r3, #7
 80041fc:	683a      	ldr	r2, [r7, #0]
 80041fe:	429a      	cmp	r2, r3
 8004200:	d20c      	bcs.n	800421c <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004202:	4b22      	ldr	r3, [pc, #136]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 8004204:	683a      	ldr	r2, [r7, #0]
 8004206:	b2d2      	uxtb	r2, r2
 8004208:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800420a:	4b20      	ldr	r3, [pc, #128]	; (800428c <HAL_RCC_ClockConfig+0x1b8>)
 800420c:	681b      	ldr	r3, [r3, #0]
 800420e:	f003 0307 	and.w	r3, r3, #7
 8004212:	683a      	ldr	r2, [r7, #0]
 8004214:	429a      	cmp	r2, r3
 8004216:	d001      	beq.n	800421c <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8004218:	2301      	movs	r3, #1
 800421a:	e032      	b.n	8004282 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800421c:	687b      	ldr	r3, [r7, #4]
 800421e:	681b      	ldr	r3, [r3, #0]
 8004220:	f003 0304 	and.w	r3, r3, #4
 8004224:	2b00      	cmp	r3, #0
 8004226:	d008      	beq.n	800423a <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004228:	4b19      	ldr	r3, [pc, #100]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 800422a:	689b      	ldr	r3, [r3, #8]
 800422c:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8004230:	687b      	ldr	r3, [r7, #4]
 8004232:	68db      	ldr	r3, [r3, #12]
 8004234:	4916      	ldr	r1, [pc, #88]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004236:	4313      	orrs	r3, r2
 8004238:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800423a:	687b      	ldr	r3, [r7, #4]
 800423c:	681b      	ldr	r3, [r3, #0]
 800423e:	f003 0308 	and.w	r3, r3, #8
 8004242:	2b00      	cmp	r3, #0
 8004244:	d009      	beq.n	800425a <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8004246:	4b12      	ldr	r3, [pc, #72]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004248:	689b      	ldr	r3, [r3, #8]
 800424a:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800424e:	687b      	ldr	r3, [r7, #4]
 8004250:	691b      	ldr	r3, [r3, #16]
 8004252:	00db      	lsls	r3, r3, #3
 8004254:	490e      	ldr	r1, [pc, #56]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004256:	4313      	orrs	r3, r2
 8004258:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800425a:	f000 f821 	bl	80042a0 <HAL_RCC_GetSysClockFreq>
 800425e:	4602      	mov	r2, r0
 8004260:	4b0b      	ldr	r3, [pc, #44]	; (8004290 <HAL_RCC_ClockConfig+0x1bc>)
 8004262:	689b      	ldr	r3, [r3, #8]
 8004264:	091b      	lsrs	r3, r3, #4
 8004266:	f003 030f 	and.w	r3, r3, #15
 800426a:	490a      	ldr	r1, [pc, #40]	; (8004294 <HAL_RCC_ClockConfig+0x1c0>)
 800426c:	5ccb      	ldrb	r3, [r1, r3]
 800426e:	fa22 f303 	lsr.w	r3, r2, r3
 8004272:	4a09      	ldr	r2, [pc, #36]	; (8004298 <HAL_RCC_ClockConfig+0x1c4>)
 8004274:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 8004276:	4b09      	ldr	r3, [pc, #36]	; (800429c <HAL_RCC_ClockConfig+0x1c8>)
 8004278:	681b      	ldr	r3, [r3, #0]
 800427a:	4618      	mov	r0, r3
 800427c:	f7fd fc1e 	bl	8001abc <HAL_InitTick>

  return HAL_OK;
 8004280:	2300      	movs	r3, #0
}
 8004282:	4618      	mov	r0, r3
 8004284:	3710      	adds	r7, #16
 8004286:	46bd      	mov	sp, r7
 8004288:	bd80      	pop	{r7, pc}
 800428a:	bf00      	nop
 800428c:	40023c00 	.word	0x40023c00
 8004290:	40023800 	.word	0x40023800
 8004294:	08029eec 	.word	0x08029eec
 8004298:	20000000 	.word	0x20000000
 800429c:	20000004 	.word	0x20000004

080042a0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80042a0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80042a4:	b084      	sub	sp, #16
 80042a6:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 80042a8:	2300      	movs	r3, #0
 80042aa:	607b      	str	r3, [r7, #4]
 80042ac:	2300      	movs	r3, #0
 80042ae:	60fb      	str	r3, [r7, #12]
 80042b0:	2300      	movs	r3, #0
 80042b2:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0U;
 80042b4:	2300      	movs	r3, #0
 80042b6:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80042b8:	4b67      	ldr	r3, [pc, #412]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 80042ba:	689b      	ldr	r3, [r3, #8]
 80042bc:	f003 030c 	and.w	r3, r3, #12
 80042c0:	2b08      	cmp	r3, #8
 80042c2:	d00d      	beq.n	80042e0 <HAL_RCC_GetSysClockFreq+0x40>
 80042c4:	2b08      	cmp	r3, #8
 80042c6:	f200 80bd 	bhi.w	8004444 <HAL_RCC_GetSysClockFreq+0x1a4>
 80042ca:	2b00      	cmp	r3, #0
 80042cc:	d002      	beq.n	80042d4 <HAL_RCC_GetSysClockFreq+0x34>
 80042ce:	2b04      	cmp	r3, #4
 80042d0:	d003      	beq.n	80042da <HAL_RCC_GetSysClockFreq+0x3a>
 80042d2:	e0b7      	b.n	8004444 <HAL_RCC_GetSysClockFreq+0x1a4>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80042d4:	4b61      	ldr	r3, [pc, #388]	; (800445c <HAL_RCC_GetSysClockFreq+0x1bc>)
 80042d6:	60bb      	str	r3, [r7, #8]
       break;
 80042d8:	e0b7      	b.n	800444a <HAL_RCC_GetSysClockFreq+0x1aa>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 80042da:	4b61      	ldr	r3, [pc, #388]	; (8004460 <HAL_RCC_GetSysClockFreq+0x1c0>)
 80042dc:	60bb      	str	r3, [r7, #8]
      break;
 80042de:	e0b4      	b.n	800444a <HAL_RCC_GetSysClockFreq+0x1aa>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80042e0:	4b5d      	ldr	r3, [pc, #372]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 80042e2:	685b      	ldr	r3, [r3, #4]
 80042e4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80042e8:	607b      	str	r3, [r7, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80042ea:	4b5b      	ldr	r3, [pc, #364]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 80042ec:	685b      	ldr	r3, [r3, #4]
 80042ee:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80042f2:	2b00      	cmp	r3, #0
 80042f4:	d04d      	beq.n	8004392 <HAL_RCC_GetSysClockFreq+0xf2>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80042f6:	4b58      	ldr	r3, [pc, #352]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 80042f8:	685b      	ldr	r3, [r3, #4]
 80042fa:	099b      	lsrs	r3, r3, #6
 80042fc:	461a      	mov	r2, r3
 80042fe:	f04f 0300 	mov.w	r3, #0
 8004302:	f240 10ff 	movw	r0, #511	; 0x1ff
 8004306:	f04f 0100 	mov.w	r1, #0
 800430a:	ea02 0800 	and.w	r8, r2, r0
 800430e:	ea03 0901 	and.w	r9, r3, r1
 8004312:	4640      	mov	r0, r8
 8004314:	4649      	mov	r1, r9
 8004316:	f04f 0200 	mov.w	r2, #0
 800431a:	f04f 0300 	mov.w	r3, #0
 800431e:	014b      	lsls	r3, r1, #5
 8004320:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 8004324:	0142      	lsls	r2, r0, #5
 8004326:	4610      	mov	r0, r2
 8004328:	4619      	mov	r1, r3
 800432a:	ebb0 0008 	subs.w	r0, r0, r8
 800432e:	eb61 0109 	sbc.w	r1, r1, r9
 8004332:	f04f 0200 	mov.w	r2, #0
 8004336:	f04f 0300 	mov.w	r3, #0
 800433a:	018b      	lsls	r3, r1, #6
 800433c:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
 8004340:	0182      	lsls	r2, r0, #6
 8004342:	1a12      	subs	r2, r2, r0
 8004344:	eb63 0301 	sbc.w	r3, r3, r1
 8004348:	f04f 0000 	mov.w	r0, #0
 800434c:	f04f 0100 	mov.w	r1, #0
 8004350:	00d9      	lsls	r1, r3, #3
 8004352:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8004356:	00d0      	lsls	r0, r2, #3
 8004358:	4602      	mov	r2, r0
 800435a:	460b      	mov	r3, r1
 800435c:	eb12 0208 	adds.w	r2, r2, r8
 8004360:	eb43 0309 	adc.w	r3, r3, r9
 8004364:	f04f 0000 	mov.w	r0, #0
 8004368:	f04f 0100 	mov.w	r1, #0
 800436c:	0259      	lsls	r1, r3, #9
 800436e:	ea41 51d2 	orr.w	r1, r1, r2, lsr #23
 8004372:	0250      	lsls	r0, r2, #9
 8004374:	4602      	mov	r2, r0
 8004376:	460b      	mov	r3, r1
 8004378:	4610      	mov	r0, r2
 800437a:	4619      	mov	r1, r3
 800437c:	687b      	ldr	r3, [r7, #4]
 800437e:	461a      	mov	r2, r3
 8004380:	f04f 0300 	mov.w	r3, #0
 8004384:	f7fc fb9a 	bl	8000abc <__aeabi_uldivmod>
 8004388:	4602      	mov	r2, r0
 800438a:	460b      	mov	r3, r1
 800438c:	4613      	mov	r3, r2
 800438e:	60fb      	str	r3, [r7, #12]
 8004390:	e04a      	b.n	8004428 <HAL_RCC_GetSysClockFreq+0x188>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004392:	4b31      	ldr	r3, [pc, #196]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 8004394:	685b      	ldr	r3, [r3, #4]
 8004396:	099b      	lsrs	r3, r3, #6
 8004398:	461a      	mov	r2, r3
 800439a:	f04f 0300 	mov.w	r3, #0
 800439e:	f240 10ff 	movw	r0, #511	; 0x1ff
 80043a2:	f04f 0100 	mov.w	r1, #0
 80043a6:	ea02 0400 	and.w	r4, r2, r0
 80043aa:	ea03 0501 	and.w	r5, r3, r1
 80043ae:	4620      	mov	r0, r4
 80043b0:	4629      	mov	r1, r5
 80043b2:	f04f 0200 	mov.w	r2, #0
 80043b6:	f04f 0300 	mov.w	r3, #0
 80043ba:	014b      	lsls	r3, r1, #5
 80043bc:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 80043c0:	0142      	lsls	r2, r0, #5
 80043c2:	4610      	mov	r0, r2
 80043c4:	4619      	mov	r1, r3
 80043c6:	1b00      	subs	r0, r0, r4
 80043c8:	eb61 0105 	sbc.w	r1, r1, r5
 80043cc:	f04f 0200 	mov.w	r2, #0
 80043d0:	f04f 0300 	mov.w	r3, #0
 80043d4:	018b      	lsls	r3, r1, #6
 80043d6:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
 80043da:	0182      	lsls	r2, r0, #6
 80043dc:	1a12      	subs	r2, r2, r0
 80043de:	eb63 0301 	sbc.w	r3, r3, r1
 80043e2:	f04f 0000 	mov.w	r0, #0
 80043e6:	f04f 0100 	mov.w	r1, #0
 80043ea:	00d9      	lsls	r1, r3, #3
 80043ec:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 80043f0:	00d0      	lsls	r0, r2, #3
 80043f2:	4602      	mov	r2, r0
 80043f4:	460b      	mov	r3, r1
 80043f6:	1912      	adds	r2, r2, r4
 80043f8:	eb45 0303 	adc.w	r3, r5, r3
 80043fc:	f04f 0000 	mov.w	r0, #0
 8004400:	f04f 0100 	mov.w	r1, #0
 8004404:	0299      	lsls	r1, r3, #10
 8004406:	ea41 5192 	orr.w	r1, r1, r2, lsr #22
 800440a:	0290      	lsls	r0, r2, #10
 800440c:	4602      	mov	r2, r0
 800440e:	460b      	mov	r3, r1
 8004410:	4610      	mov	r0, r2
 8004412:	4619      	mov	r1, r3
 8004414:	687b      	ldr	r3, [r7, #4]
 8004416:	461a      	mov	r2, r3
 8004418:	f04f 0300 	mov.w	r3, #0
 800441c:	f7fc fb4e 	bl	8000abc <__aeabi_uldivmod>
 8004420:	4602      	mov	r2, r0
 8004422:	460b      	mov	r3, r1
 8004424:	4613      	mov	r3, r2
 8004426:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8004428:	4b0b      	ldr	r3, [pc, #44]	; (8004458 <HAL_RCC_GetSysClockFreq+0x1b8>)
 800442a:	685b      	ldr	r3, [r3, #4]
 800442c:	0c1b      	lsrs	r3, r3, #16
 800442e:	f003 0303 	and.w	r3, r3, #3
 8004432:	3301      	adds	r3, #1
 8004434:	005b      	lsls	r3, r3, #1
 8004436:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
 8004438:	68fa      	ldr	r2, [r7, #12]
 800443a:	683b      	ldr	r3, [r7, #0]
 800443c:	fbb2 f3f3 	udiv	r3, r2, r3
 8004440:	60bb      	str	r3, [r7, #8]
      break;
 8004442:	e002      	b.n	800444a <HAL_RCC_GetSysClockFreq+0x1aa>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8004444:	4b05      	ldr	r3, [pc, #20]	; (800445c <HAL_RCC_GetSysClockFreq+0x1bc>)
 8004446:	60bb      	str	r3, [r7, #8]
      break;
 8004448:	bf00      	nop
    }
  }
  return sysclockfreq;
 800444a:	68bb      	ldr	r3, [r7, #8]
}
 800444c:	4618      	mov	r0, r3
 800444e:	3710      	adds	r7, #16
 8004450:	46bd      	mov	sp, r7
 8004452:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8004456:	bf00      	nop
 8004458:	40023800 	.word	0x40023800
 800445c:	00f42400 	.word	0x00f42400
 8004460:	007a1200 	.word	0x007a1200

08004464 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004464:	b480      	push	{r7}
 8004466:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8004468:	4b03      	ldr	r3, [pc, #12]	; (8004478 <HAL_RCC_GetHCLKFreq+0x14>)
 800446a:	681b      	ldr	r3, [r3, #0]
}
 800446c:	4618      	mov	r0, r3
 800446e:	46bd      	mov	sp, r7
 8004470:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004474:	4770      	bx	lr
 8004476:	bf00      	nop
 8004478:	20000000 	.word	0x20000000

0800447c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800447c:	b580      	push	{r7, lr}
 800447e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8004480:	f7ff fff0 	bl	8004464 <HAL_RCC_GetHCLKFreq>
 8004484:	4602      	mov	r2, r0
 8004486:	4b05      	ldr	r3, [pc, #20]	; (800449c <HAL_RCC_GetPCLK1Freq+0x20>)
 8004488:	689b      	ldr	r3, [r3, #8]
 800448a:	0a9b      	lsrs	r3, r3, #10
 800448c:	f003 0307 	and.w	r3, r3, #7
 8004490:	4903      	ldr	r1, [pc, #12]	; (80044a0 <HAL_RCC_GetPCLK1Freq+0x24>)
 8004492:	5ccb      	ldrb	r3, [r1, r3]
 8004494:	fa22 f303 	lsr.w	r3, r2, r3
}
 8004498:	4618      	mov	r0, r3
 800449a:	bd80      	pop	{r7, pc}
 800449c:	40023800 	.word	0x40023800
 80044a0:	08029efc 	.word	0x08029efc

080044a4 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 80044a4:	b580      	push	{r7, lr}
 80044a6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80044a8:	f7ff ffdc 	bl	8004464 <HAL_RCC_GetHCLKFreq>
 80044ac:	4602      	mov	r2, r0
 80044ae:	4b05      	ldr	r3, [pc, #20]	; (80044c4 <HAL_RCC_GetPCLK2Freq+0x20>)
 80044b0:	689b      	ldr	r3, [r3, #8]
 80044b2:	0b5b      	lsrs	r3, r3, #13
 80044b4:	f003 0307 	and.w	r3, r3, #7
 80044b8:	4903      	ldr	r1, [pc, #12]	; (80044c8 <HAL_RCC_GetPCLK2Freq+0x24>)
 80044ba:	5ccb      	ldrb	r3, [r1, r3]
 80044bc:	fa22 f303 	lsr.w	r3, r2, r3
}
 80044c0:	4618      	mov	r0, r3
 80044c2:	bd80      	pop	{r7, pc}
 80044c4:	40023800 	.word	0x40023800
 80044c8:	08029efc 	.word	0x08029efc

080044cc <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80044cc:	b580      	push	{r7, lr}
 80044ce:	b082      	sub	sp, #8
 80044d0:	af00      	add	r7, sp, #0
 80044d2:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80044d4:	687b      	ldr	r3, [r7, #4]
 80044d6:	2b00      	cmp	r3, #0
 80044d8:	d101      	bne.n	80044de <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80044da:	2301      	movs	r3, #1
 80044dc:	e07b      	b.n	80045d6 <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044e2:	2b00      	cmp	r3, #0
 80044e4:	d108      	bne.n	80044f8 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	685b      	ldr	r3, [r3, #4]
 80044ea:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80044ee:	d009      	beq.n	8004504 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80044f0:	687b      	ldr	r3, [r7, #4]
 80044f2:	2200      	movs	r2, #0
 80044f4:	61da      	str	r2, [r3, #28]
 80044f6:	e005      	b.n	8004504 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80044f8:	687b      	ldr	r3, [r7, #4]
 80044fa:	2200      	movs	r2, #0
 80044fc:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 80044fe:	687b      	ldr	r3, [r7, #4]
 8004500:	2200      	movs	r2, #0
 8004502:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8004504:	687b      	ldr	r3, [r7, #4]
 8004506:	2200      	movs	r2, #0
 8004508:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800450a:	687b      	ldr	r3, [r7, #4]
 800450c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8004510:	b2db      	uxtb	r3, r3
 8004512:	2b00      	cmp	r3, #0
 8004514:	d106      	bne.n	8004524 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8004516:	687b      	ldr	r3, [r7, #4]
 8004518:	2200      	movs	r2, #0
 800451a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800451e:	6878      	ldr	r0, [r7, #4]
 8004520:	f7fd f922 	bl	8001768 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8004524:	687b      	ldr	r3, [r7, #4]
 8004526:	2202      	movs	r2, #2
 8004528:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800452c:	687b      	ldr	r3, [r7, #4]
 800452e:	681b      	ldr	r3, [r3, #0]
 8004530:	681a      	ldr	r2, [r3, #0]
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	681b      	ldr	r3, [r3, #0]
 8004536:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800453a:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800453c:	687b      	ldr	r3, [r7, #4]
 800453e:	685b      	ldr	r3, [r3, #4]
 8004540:	f403 7282 	and.w	r2, r3, #260	; 0x104
 8004544:	687b      	ldr	r3, [r7, #4]
 8004546:	689b      	ldr	r3, [r3, #8]
 8004548:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 800454c:	431a      	orrs	r2, r3
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	68db      	ldr	r3, [r3, #12]
 8004552:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004556:	431a      	orrs	r2, r3
 8004558:	687b      	ldr	r3, [r7, #4]
 800455a:	691b      	ldr	r3, [r3, #16]
 800455c:	f003 0302 	and.w	r3, r3, #2
 8004560:	431a      	orrs	r2, r3
 8004562:	687b      	ldr	r3, [r7, #4]
 8004564:	695b      	ldr	r3, [r3, #20]
 8004566:	f003 0301 	and.w	r3, r3, #1
 800456a:	431a      	orrs	r2, r3
 800456c:	687b      	ldr	r3, [r7, #4]
 800456e:	699b      	ldr	r3, [r3, #24]
 8004570:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004574:	431a      	orrs	r2, r3
 8004576:	687b      	ldr	r3, [r7, #4]
 8004578:	69db      	ldr	r3, [r3, #28]
 800457a:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800457e:	431a      	orrs	r2, r3
 8004580:	687b      	ldr	r3, [r7, #4]
 8004582:	6a1b      	ldr	r3, [r3, #32]
 8004584:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004588:	ea42 0103 	orr.w	r1, r2, r3
 800458c:	687b      	ldr	r3, [r7, #4]
 800458e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004590:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 8004594:	687b      	ldr	r3, [r7, #4]
 8004596:	681b      	ldr	r3, [r3, #0]
 8004598:	430a      	orrs	r2, r1
 800459a:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 800459c:	687b      	ldr	r3, [r7, #4]
 800459e:	699b      	ldr	r3, [r3, #24]
 80045a0:	0c1b      	lsrs	r3, r3, #16
 80045a2:	f003 0104 	and.w	r1, r3, #4
 80045a6:	687b      	ldr	r3, [r7, #4]
 80045a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045aa:	f003 0210 	and.w	r2, r3, #16
 80045ae:	687b      	ldr	r3, [r7, #4]
 80045b0:	681b      	ldr	r3, [r3, #0]
 80045b2:	430a      	orrs	r2, r1
 80045b4:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80045b6:	687b      	ldr	r3, [r7, #4]
 80045b8:	681b      	ldr	r3, [r3, #0]
 80045ba:	69da      	ldr	r2, [r3, #28]
 80045bc:	687b      	ldr	r3, [r7, #4]
 80045be:	681b      	ldr	r3, [r3, #0]
 80045c0:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80045c4:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80045c6:	687b      	ldr	r3, [r7, #4]
 80045c8:	2200      	movs	r2, #0
 80045ca:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80045cc:	687b      	ldr	r3, [r7, #4]
 80045ce:	2201      	movs	r2, #1
 80045d0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 80045d4:	2300      	movs	r3, #0
}
 80045d6:	4618      	mov	r0, r3
 80045d8:	3708      	adds	r7, #8
 80045da:	46bd      	mov	sp, r7
 80045dc:	bd80      	pop	{r7, pc}

080045de <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80045de:	b580      	push	{r7, lr}
 80045e0:	b082      	sub	sp, #8
 80045e2:	af00      	add	r7, sp, #0
 80045e4:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80045e6:	687b      	ldr	r3, [r7, #4]
 80045e8:	2b00      	cmp	r3, #0
 80045ea:	d101      	bne.n	80045f0 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80045ec:	2301      	movs	r3, #1
 80045ee:	e03f      	b.n	8004670 <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 80045f0:	687b      	ldr	r3, [r7, #4]
 80045f2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80045f6:	b2db      	uxtb	r3, r3
 80045f8:	2b00      	cmp	r3, #0
 80045fa:	d106      	bne.n	800460a <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80045fc:	687b      	ldr	r3, [r7, #4]
 80045fe:	2200      	movs	r2, #0
 8004600:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8004604:	6878      	ldr	r0, [r7, #4]
 8004606:	f7fd f9c5 	bl	8001994 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800460a:	687b      	ldr	r3, [r7, #4]
 800460c:	2224      	movs	r2, #36	; 0x24
 800460e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8004612:	687b      	ldr	r3, [r7, #4]
 8004614:	681b      	ldr	r3, [r3, #0]
 8004616:	68da      	ldr	r2, [r3, #12]
 8004618:	687b      	ldr	r3, [r7, #4]
 800461a:	681b      	ldr	r3, [r3, #0]
 800461c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8004620:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8004622:	6878      	ldr	r0, [r7, #4]
 8004624:	f000 f928 	bl	8004878 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004628:	687b      	ldr	r3, [r7, #4]
 800462a:	681b      	ldr	r3, [r3, #0]
 800462c:	691a      	ldr	r2, [r3, #16]
 800462e:	687b      	ldr	r3, [r7, #4]
 8004630:	681b      	ldr	r3, [r3, #0]
 8004632:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8004636:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8004638:	687b      	ldr	r3, [r7, #4]
 800463a:	681b      	ldr	r3, [r3, #0]
 800463c:	695a      	ldr	r2, [r3, #20]
 800463e:	687b      	ldr	r3, [r7, #4]
 8004640:	681b      	ldr	r3, [r3, #0]
 8004642:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8004646:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8004648:	687b      	ldr	r3, [r7, #4]
 800464a:	681b      	ldr	r3, [r3, #0]
 800464c:	68da      	ldr	r2, [r3, #12]
 800464e:	687b      	ldr	r3, [r7, #4]
 8004650:	681b      	ldr	r3, [r3, #0]
 8004652:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8004656:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	2200      	movs	r2, #0
 800465c:	641a      	str	r2, [r3, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	2220      	movs	r2, #32
 8004662:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 8004666:	687b      	ldr	r3, [r7, #4]
 8004668:	2220      	movs	r2, #32
 800466a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

  return HAL_OK;
 800466e:	2300      	movs	r3, #0
}
 8004670:	4618      	mov	r0, r3
 8004672:	3708      	adds	r7, #8
 8004674:	46bd      	mov	sp, r7
 8004676:	bd80      	pop	{r7, pc}

08004678 <HAL_UART_Transmit>:
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8004678:	b580      	push	{r7, lr}
 800467a:	b08a      	sub	sp, #40	; 0x28
 800467c:	af02      	add	r7, sp, #8
 800467e:	60f8      	str	r0, [r7, #12]
 8004680:	60b9      	str	r1, [r7, #8]
 8004682:	603b      	str	r3, [r7, #0]
 8004684:	4613      	mov	r3, r2
 8004686:	80fb      	strh	r3, [r7, #6]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart = 0U;
 8004688:	2300      	movs	r3, #0
 800468a:	617b      	str	r3, [r7, #20]

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800468c:	68fb      	ldr	r3, [r7, #12]
 800468e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8004692:	b2db      	uxtb	r3, r3
 8004694:	2b20      	cmp	r3, #32
 8004696:	d17c      	bne.n	8004792 <HAL_UART_Transmit+0x11a>
  {
    if ((pData == NULL) || (Size == 0U))
 8004698:	68bb      	ldr	r3, [r7, #8]
 800469a:	2b00      	cmp	r3, #0
 800469c:	d002      	beq.n	80046a4 <HAL_UART_Transmit+0x2c>
 800469e:	88fb      	ldrh	r3, [r7, #6]
 80046a0:	2b00      	cmp	r3, #0
 80046a2:	d101      	bne.n	80046a8 <HAL_UART_Transmit+0x30>
    {
      return  HAL_ERROR;
 80046a4:	2301      	movs	r3, #1
 80046a6:	e075      	b.n	8004794 <HAL_UART_Transmit+0x11c>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80046a8:	68fb      	ldr	r3, [r7, #12]
 80046aa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80046ae:	2b01      	cmp	r3, #1
 80046b0:	d101      	bne.n	80046b6 <HAL_UART_Transmit+0x3e>
 80046b2:	2302      	movs	r3, #2
 80046b4:	e06e      	b.n	8004794 <HAL_UART_Transmit+0x11c>
 80046b6:	68fb      	ldr	r3, [r7, #12]
 80046b8:	2201      	movs	r2, #1
 80046ba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80046be:	68fb      	ldr	r3, [r7, #12]
 80046c0:	2200      	movs	r2, #0
 80046c2:	641a      	str	r2, [r3, #64]	; 0x40
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80046c4:	68fb      	ldr	r3, [r7, #12]
 80046c6:	2221      	movs	r2, #33	; 0x21
 80046c8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 80046cc:	f7fd fa3a 	bl	8001b44 <HAL_GetTick>
 80046d0:	6178      	str	r0, [r7, #20]

    huart->TxXferSize = Size;
 80046d2:	68fb      	ldr	r3, [r7, #12]
 80046d4:	88fa      	ldrh	r2, [r7, #6]
 80046d6:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 80046d8:	68fb      	ldr	r3, [r7, #12]
 80046da:	88fa      	ldrh	r2, [r7, #6]
 80046dc:	84da      	strh	r2, [r3, #38]	; 0x26

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80046de:	68fb      	ldr	r3, [r7, #12]
 80046e0:	689b      	ldr	r3, [r3, #8]
 80046e2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80046e6:	d108      	bne.n	80046fa <HAL_UART_Transmit+0x82>
 80046e8:	68fb      	ldr	r3, [r7, #12]
 80046ea:	691b      	ldr	r3, [r3, #16]
 80046ec:	2b00      	cmp	r3, #0
 80046ee:	d104      	bne.n	80046fa <HAL_UART_Transmit+0x82>
    {
      pdata8bits  = NULL;
 80046f0:	2300      	movs	r3, #0
 80046f2:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 80046f4:	68bb      	ldr	r3, [r7, #8]
 80046f6:	61bb      	str	r3, [r7, #24]
 80046f8:	e003      	b.n	8004702 <HAL_UART_Transmit+0x8a>
    }
    else
    {
      pdata8bits  = pData;
 80046fa:	68bb      	ldr	r3, [r7, #8]
 80046fc:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80046fe:	2300      	movs	r3, #0
 8004700:	61bb      	str	r3, [r7, #24]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8004702:	68fb      	ldr	r3, [r7, #12]
 8004704:	2200      	movs	r2, #0
 8004706:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    while (huart->TxXferCount > 0U)
 800470a:	e02a      	b.n	8004762 <HAL_UART_Transmit+0xea>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800470c:	683b      	ldr	r3, [r7, #0]
 800470e:	9300      	str	r3, [sp, #0]
 8004710:	697b      	ldr	r3, [r7, #20]
 8004712:	2200      	movs	r2, #0
 8004714:	2180      	movs	r1, #128	; 0x80
 8004716:	68f8      	ldr	r0, [r7, #12]
 8004718:	f000 f840 	bl	800479c <UART_WaitOnFlagUntilTimeout>
 800471c:	4603      	mov	r3, r0
 800471e:	2b00      	cmp	r3, #0
 8004720:	d001      	beq.n	8004726 <HAL_UART_Transmit+0xae>
      {
        return HAL_TIMEOUT;
 8004722:	2303      	movs	r3, #3
 8004724:	e036      	b.n	8004794 <HAL_UART_Transmit+0x11c>
      }
      if (pdata8bits == NULL)
 8004726:	69fb      	ldr	r3, [r7, #28]
 8004728:	2b00      	cmp	r3, #0
 800472a:	d10b      	bne.n	8004744 <HAL_UART_Transmit+0xcc>
      {
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 800472c:	69bb      	ldr	r3, [r7, #24]
 800472e:	881b      	ldrh	r3, [r3, #0]
 8004730:	461a      	mov	r2, r3
 8004732:	68fb      	ldr	r3, [r7, #12]
 8004734:	681b      	ldr	r3, [r3, #0]
 8004736:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800473a:	605a      	str	r2, [r3, #4]
        pdata16bits++;
 800473c:	69bb      	ldr	r3, [r7, #24]
 800473e:	3302      	adds	r3, #2
 8004740:	61bb      	str	r3, [r7, #24]
 8004742:	e007      	b.n	8004754 <HAL_UART_Transmit+0xdc>
      }
      else
      {
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8004744:	69fb      	ldr	r3, [r7, #28]
 8004746:	781a      	ldrb	r2, [r3, #0]
 8004748:	68fb      	ldr	r3, [r7, #12]
 800474a:	681b      	ldr	r3, [r3, #0]
 800474c:	605a      	str	r2, [r3, #4]
        pdata8bits++;
 800474e:	69fb      	ldr	r3, [r7, #28]
 8004750:	3301      	adds	r3, #1
 8004752:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8004754:	68fb      	ldr	r3, [r7, #12]
 8004756:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8004758:	b29b      	uxth	r3, r3
 800475a:	3b01      	subs	r3, #1
 800475c:	b29a      	uxth	r2, r3
 800475e:	68fb      	ldr	r3, [r7, #12]
 8004760:	84da      	strh	r2, [r3, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 8004762:	68fb      	ldr	r3, [r7, #12]
 8004764:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8004766:	b29b      	uxth	r3, r3
 8004768:	2b00      	cmp	r3, #0
 800476a:	d1cf      	bne.n	800470c <HAL_UART_Transmit+0x94>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800476c:	683b      	ldr	r3, [r7, #0]
 800476e:	9300      	str	r3, [sp, #0]
 8004770:	697b      	ldr	r3, [r7, #20]
 8004772:	2200      	movs	r2, #0
 8004774:	2140      	movs	r1, #64	; 0x40
 8004776:	68f8      	ldr	r0, [r7, #12]
 8004778:	f000 f810 	bl	800479c <UART_WaitOnFlagUntilTimeout>
 800477c:	4603      	mov	r3, r0
 800477e:	2b00      	cmp	r3, #0
 8004780:	d001      	beq.n	8004786 <HAL_UART_Transmit+0x10e>
    {
      return HAL_TIMEOUT;
 8004782:	2303      	movs	r3, #3
 8004784:	e006      	b.n	8004794 <HAL_UART_Transmit+0x11c>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8004786:	68fb      	ldr	r3, [r7, #12]
 8004788:	2220      	movs	r2, #32
 800478a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return HAL_OK;
 800478e:	2300      	movs	r3, #0
 8004790:	e000      	b.n	8004794 <HAL_UART_Transmit+0x11c>
  }
  else
  {
    return HAL_BUSY;
 8004792:	2302      	movs	r3, #2
  }
}
 8004794:	4618      	mov	r0, r3
 8004796:	3720      	adds	r7, #32
 8004798:	46bd      	mov	sp, r7
 800479a:	bd80      	pop	{r7, pc}

0800479c <UART_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Tickstart, uint32_t Timeout)
{
 800479c:	b580      	push	{r7, lr}
 800479e:	b090      	sub	sp, #64	; 0x40
 80047a0:	af00      	add	r7, sp, #0
 80047a2:	60f8      	str	r0, [r7, #12]
 80047a4:	60b9      	str	r1, [r7, #8]
 80047a6:	603b      	str	r3, [r7, #0]
 80047a8:	4613      	mov	r3, r2
 80047aa:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80047ac:	e050      	b.n	8004850 <UART_WaitOnFlagUntilTimeout+0xb4>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80047ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80047b0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80047b4:	d04c      	beq.n	8004850 <UART_WaitOnFlagUntilTimeout+0xb4>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 80047b6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80047b8:	2b00      	cmp	r3, #0
 80047ba:	d007      	beq.n	80047cc <UART_WaitOnFlagUntilTimeout+0x30>
 80047bc:	f7fd f9c2 	bl	8001b44 <HAL_GetTick>
 80047c0:	4602      	mov	r2, r0
 80047c2:	683b      	ldr	r3, [r7, #0]
 80047c4:	1ad3      	subs	r3, r2, r3
 80047c6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80047c8:	429a      	cmp	r2, r3
 80047ca:	d241      	bcs.n	8004850 <UART_WaitOnFlagUntilTimeout+0xb4>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80047cc:	68fb      	ldr	r3, [r7, #12]
 80047ce:	681b      	ldr	r3, [r3, #0]
 80047d0:	330c      	adds	r3, #12
 80047d2:	62bb      	str	r3, [r7, #40]	; 0x28
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80047d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047d6:	e853 3f00 	ldrex	r3, [r3]
 80047da:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 80047dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80047de:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 80047e2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80047e4:	68fb      	ldr	r3, [r7, #12]
 80047e6:	681b      	ldr	r3, [r3, #0]
 80047e8:	330c      	adds	r3, #12
 80047ea:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80047ec:	637a      	str	r2, [r7, #52]	; 0x34
 80047ee:	633b      	str	r3, [r7, #48]	; 0x30
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80047f0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80047f2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80047f4:	e841 2300 	strex	r3, r2, [r1]
 80047f8:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 80047fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80047fc:	2b00      	cmp	r3, #0
 80047fe:	d1e5      	bne.n	80047cc <UART_WaitOnFlagUntilTimeout+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004800:	68fb      	ldr	r3, [r7, #12]
 8004802:	681b      	ldr	r3, [r3, #0]
 8004804:	3314      	adds	r3, #20
 8004806:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004808:	697b      	ldr	r3, [r7, #20]
 800480a:	e853 3f00 	ldrex	r3, [r3]
 800480e:	613b      	str	r3, [r7, #16]
   return(result);
 8004810:	693b      	ldr	r3, [r7, #16]
 8004812:	f023 0301 	bic.w	r3, r3, #1
 8004816:	63bb      	str	r3, [r7, #56]	; 0x38
 8004818:	68fb      	ldr	r3, [r7, #12]
 800481a:	681b      	ldr	r3, [r3, #0]
 800481c:	3314      	adds	r3, #20
 800481e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8004820:	623a      	str	r2, [r7, #32]
 8004822:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004824:	69f9      	ldr	r1, [r7, #28]
 8004826:	6a3a      	ldr	r2, [r7, #32]
 8004828:	e841 2300 	strex	r3, r2, [r1]
 800482c:	61bb      	str	r3, [r7, #24]
   return(result);
 800482e:	69bb      	ldr	r3, [r7, #24]
 8004830:	2b00      	cmp	r3, #0
 8004832:	d1e5      	bne.n	8004800 <UART_WaitOnFlagUntilTimeout+0x64>

        huart->gState  = HAL_UART_STATE_READY;
 8004834:	68fb      	ldr	r3, [r7, #12]
 8004836:	2220      	movs	r2, #32
 8004838:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        huart->RxState = HAL_UART_STATE_READY;
 800483c:	68fb      	ldr	r3, [r7, #12]
 800483e:	2220      	movs	r2, #32
 8004840:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8004844:	68fb      	ldr	r3, [r7, #12]
 8004846:	2200      	movs	r2, #0
 8004848:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        return HAL_TIMEOUT;
 800484c:	2303      	movs	r3, #3
 800484e:	e00f      	b.n	8004870 <UART_WaitOnFlagUntilTimeout+0xd4>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004850:	68fb      	ldr	r3, [r7, #12]
 8004852:	681b      	ldr	r3, [r3, #0]
 8004854:	681a      	ldr	r2, [r3, #0]
 8004856:	68bb      	ldr	r3, [r7, #8]
 8004858:	4013      	ands	r3, r2
 800485a:	68ba      	ldr	r2, [r7, #8]
 800485c:	429a      	cmp	r2, r3
 800485e:	bf0c      	ite	eq
 8004860:	2301      	moveq	r3, #1
 8004862:	2300      	movne	r3, #0
 8004864:	b2db      	uxtb	r3, r3
 8004866:	461a      	mov	r2, r3
 8004868:	79fb      	ldrb	r3, [r7, #7]
 800486a:	429a      	cmp	r2, r3
 800486c:	d09f      	beq.n	80047ae <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800486e:	2300      	movs	r3, #0
}
 8004870:	4618      	mov	r0, r3
 8004872:	3740      	adds	r7, #64	; 0x40
 8004874:	46bd      	mov	sp, r7
 8004876:	bd80      	pop	{r7, pc}

08004878 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8004878:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800487c:	b09f      	sub	sp, #124	; 0x7c
 800487e:	af00      	add	r7, sp, #0
 8004880:	66f8      	str	r0, [r7, #108]	; 0x6c
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8004882:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004884:	681b      	ldr	r3, [r3, #0]
 8004886:	691b      	ldr	r3, [r3, #16]
 8004888:	f423 5040 	bic.w	r0, r3, #12288	; 0x3000
 800488c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800488e:	68d9      	ldr	r1, [r3, #12]
 8004890:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004892:	681a      	ldr	r2, [r3, #0]
 8004894:	ea40 0301 	orr.w	r3, r0, r1
 8004898:	6113      	str	r3, [r2, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 800489a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800489c:	689a      	ldr	r2, [r3, #8]
 800489e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048a0:	691b      	ldr	r3, [r3, #16]
 80048a2:	431a      	orrs	r2, r3
 80048a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048a6:	695b      	ldr	r3, [r3, #20]
 80048a8:	431a      	orrs	r2, r3
 80048aa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048ac:	69db      	ldr	r3, [r3, #28]
 80048ae:	4313      	orrs	r3, r2
 80048b0:	673b      	str	r3, [r7, #112]	; 0x70
  MODIFY_REG(huart->Instance->CR1,
 80048b2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048b4:	681b      	ldr	r3, [r3, #0]
 80048b6:	68db      	ldr	r3, [r3, #12]
 80048b8:	f423 4116 	bic.w	r1, r3, #38400	; 0x9600
 80048bc:	f021 010c 	bic.w	r1, r1, #12
 80048c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048c2:	681a      	ldr	r2, [r3, #0]
 80048c4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80048c6:	430b      	orrs	r3, r1
 80048c8:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80048ca:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048cc:	681b      	ldr	r3, [r3, #0]
 80048ce:	695b      	ldr	r3, [r3, #20]
 80048d0:	f423 7040 	bic.w	r0, r3, #768	; 0x300
 80048d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048d6:	6999      	ldr	r1, [r3, #24]
 80048d8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048da:	681a      	ldr	r2, [r3, #0]
 80048dc:	ea40 0301 	orr.w	r3, r0, r1
 80048e0:	6153      	str	r3, [r2, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
    {
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80048e2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048e4:	681a      	ldr	r2, [r3, #0]
 80048e6:	4bc5      	ldr	r3, [pc, #788]	; (8004bfc <UART_SetConfig+0x384>)
 80048e8:	429a      	cmp	r2, r3
 80048ea:	d004      	beq.n	80048f6 <UART_SetConfig+0x7e>
 80048ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80048ee:	681a      	ldr	r2, [r3, #0]
 80048f0:	4bc3      	ldr	r3, [pc, #780]	; (8004c00 <UART_SetConfig+0x388>)
 80048f2:	429a      	cmp	r2, r3
 80048f4:	d103      	bne.n	80048fe <UART_SetConfig+0x86>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 80048f6:	f7ff fdd5 	bl	80044a4 <HAL_RCC_GetPCLK2Freq>
 80048fa:	6778      	str	r0, [r7, #116]	; 0x74
 80048fc:	e002      	b.n	8004904 <UART_SetConfig+0x8c>
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 80048fe:	f7ff fdbd 	bl	800447c <HAL_RCC_GetPCLK1Freq>
 8004902:	6778      	str	r0, [r7, #116]	; 0x74
    }
  /*-------------------------- USART BRR Configuration ---------------------*/
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004904:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004906:	69db      	ldr	r3, [r3, #28]
 8004908:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800490c:	f040 80b6 	bne.w	8004a7c <UART_SetConfig+0x204>
  {
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8004910:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004912:	461c      	mov	r4, r3
 8004914:	f04f 0500 	mov.w	r5, #0
 8004918:	4622      	mov	r2, r4
 800491a:	462b      	mov	r3, r5
 800491c:	1891      	adds	r1, r2, r2
 800491e:	6439      	str	r1, [r7, #64]	; 0x40
 8004920:	415b      	adcs	r3, r3
 8004922:	647b      	str	r3, [r7, #68]	; 0x44
 8004924:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8004928:	1912      	adds	r2, r2, r4
 800492a:	eb45 0303 	adc.w	r3, r5, r3
 800492e:	f04f 0000 	mov.w	r0, #0
 8004932:	f04f 0100 	mov.w	r1, #0
 8004936:	00d9      	lsls	r1, r3, #3
 8004938:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 800493c:	00d0      	lsls	r0, r2, #3
 800493e:	4602      	mov	r2, r0
 8004940:	460b      	mov	r3, r1
 8004942:	1911      	adds	r1, r2, r4
 8004944:	6639      	str	r1, [r7, #96]	; 0x60
 8004946:	416b      	adcs	r3, r5
 8004948:	667b      	str	r3, [r7, #100]	; 0x64
 800494a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800494c:	685b      	ldr	r3, [r3, #4]
 800494e:	461a      	mov	r2, r3
 8004950:	f04f 0300 	mov.w	r3, #0
 8004954:	1891      	adds	r1, r2, r2
 8004956:	63b9      	str	r1, [r7, #56]	; 0x38
 8004958:	415b      	adcs	r3, r3
 800495a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800495c:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 8004960:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 8004964:	f7fc f8aa 	bl	8000abc <__aeabi_uldivmod>
 8004968:	4602      	mov	r2, r0
 800496a:	460b      	mov	r3, r1
 800496c:	4ba5      	ldr	r3, [pc, #660]	; (8004c04 <UART_SetConfig+0x38c>)
 800496e:	fba3 2302 	umull	r2, r3, r3, r2
 8004972:	095b      	lsrs	r3, r3, #5
 8004974:	011e      	lsls	r6, r3, #4
 8004976:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004978:	461c      	mov	r4, r3
 800497a:	f04f 0500 	mov.w	r5, #0
 800497e:	4622      	mov	r2, r4
 8004980:	462b      	mov	r3, r5
 8004982:	1891      	adds	r1, r2, r2
 8004984:	6339      	str	r1, [r7, #48]	; 0x30
 8004986:	415b      	adcs	r3, r3
 8004988:	637b      	str	r3, [r7, #52]	; 0x34
 800498a:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800498e:	1912      	adds	r2, r2, r4
 8004990:	eb45 0303 	adc.w	r3, r5, r3
 8004994:	f04f 0000 	mov.w	r0, #0
 8004998:	f04f 0100 	mov.w	r1, #0
 800499c:	00d9      	lsls	r1, r3, #3
 800499e:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 80049a2:	00d0      	lsls	r0, r2, #3
 80049a4:	4602      	mov	r2, r0
 80049a6:	460b      	mov	r3, r1
 80049a8:	1911      	adds	r1, r2, r4
 80049aa:	65b9      	str	r1, [r7, #88]	; 0x58
 80049ac:	416b      	adcs	r3, r5
 80049ae:	65fb      	str	r3, [r7, #92]	; 0x5c
 80049b0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80049b2:	685b      	ldr	r3, [r3, #4]
 80049b4:	461a      	mov	r2, r3
 80049b6:	f04f 0300 	mov.w	r3, #0
 80049ba:	1891      	adds	r1, r2, r2
 80049bc:	62b9      	str	r1, [r7, #40]	; 0x28
 80049be:	415b      	adcs	r3, r3
 80049c0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80049c2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 80049c6:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 80049ca:	f7fc f877 	bl	8000abc <__aeabi_uldivmod>
 80049ce:	4602      	mov	r2, r0
 80049d0:	460b      	mov	r3, r1
 80049d2:	4b8c      	ldr	r3, [pc, #560]	; (8004c04 <UART_SetConfig+0x38c>)
 80049d4:	fba3 1302 	umull	r1, r3, r3, r2
 80049d8:	095b      	lsrs	r3, r3, #5
 80049da:	2164      	movs	r1, #100	; 0x64
 80049dc:	fb01 f303 	mul.w	r3, r1, r3
 80049e0:	1ad3      	subs	r3, r2, r3
 80049e2:	00db      	lsls	r3, r3, #3
 80049e4:	3332      	adds	r3, #50	; 0x32
 80049e6:	4a87      	ldr	r2, [pc, #540]	; (8004c04 <UART_SetConfig+0x38c>)
 80049e8:	fba2 2303 	umull	r2, r3, r2, r3
 80049ec:	095b      	lsrs	r3, r3, #5
 80049ee:	005b      	lsls	r3, r3, #1
 80049f0:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 80049f4:	441e      	add	r6, r3
 80049f6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80049f8:	4618      	mov	r0, r3
 80049fa:	f04f 0100 	mov.w	r1, #0
 80049fe:	4602      	mov	r2, r0
 8004a00:	460b      	mov	r3, r1
 8004a02:	1894      	adds	r4, r2, r2
 8004a04:	623c      	str	r4, [r7, #32]
 8004a06:	415b      	adcs	r3, r3
 8004a08:	627b      	str	r3, [r7, #36]	; 0x24
 8004a0a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8004a0e:	1812      	adds	r2, r2, r0
 8004a10:	eb41 0303 	adc.w	r3, r1, r3
 8004a14:	f04f 0400 	mov.w	r4, #0
 8004a18:	f04f 0500 	mov.w	r5, #0
 8004a1c:	00dd      	lsls	r5, r3, #3
 8004a1e:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 8004a22:	00d4      	lsls	r4, r2, #3
 8004a24:	4622      	mov	r2, r4
 8004a26:	462b      	mov	r3, r5
 8004a28:	1814      	adds	r4, r2, r0
 8004a2a:	653c      	str	r4, [r7, #80]	; 0x50
 8004a2c:	414b      	adcs	r3, r1
 8004a2e:	657b      	str	r3, [r7, #84]	; 0x54
 8004a30:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004a32:	685b      	ldr	r3, [r3, #4]
 8004a34:	461a      	mov	r2, r3
 8004a36:	f04f 0300 	mov.w	r3, #0
 8004a3a:	1891      	adds	r1, r2, r2
 8004a3c:	61b9      	str	r1, [r7, #24]
 8004a3e:	415b      	adcs	r3, r3
 8004a40:	61fb      	str	r3, [r7, #28]
 8004a42:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8004a46:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 8004a4a:	f7fc f837 	bl	8000abc <__aeabi_uldivmod>
 8004a4e:	4602      	mov	r2, r0
 8004a50:	460b      	mov	r3, r1
 8004a52:	4b6c      	ldr	r3, [pc, #432]	; (8004c04 <UART_SetConfig+0x38c>)
 8004a54:	fba3 1302 	umull	r1, r3, r3, r2
 8004a58:	095b      	lsrs	r3, r3, #5
 8004a5a:	2164      	movs	r1, #100	; 0x64
 8004a5c:	fb01 f303 	mul.w	r3, r1, r3
 8004a60:	1ad3      	subs	r3, r2, r3
 8004a62:	00db      	lsls	r3, r3, #3
 8004a64:	3332      	adds	r3, #50	; 0x32
 8004a66:	4a67      	ldr	r2, [pc, #412]	; (8004c04 <UART_SetConfig+0x38c>)
 8004a68:	fba2 2303 	umull	r2, r3, r2, r3
 8004a6c:	095b      	lsrs	r3, r3, #5
 8004a6e:	f003 0207 	and.w	r2, r3, #7
 8004a72:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004a74:	681b      	ldr	r3, [r3, #0]
 8004a76:	4432      	add	r2, r6
 8004a78:	609a      	str	r2, [r3, #8]
  }
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
}
 8004a7a:	e0b9      	b.n	8004bf0 <UART_SetConfig+0x378>
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8004a7c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004a7e:	461c      	mov	r4, r3
 8004a80:	f04f 0500 	mov.w	r5, #0
 8004a84:	4622      	mov	r2, r4
 8004a86:	462b      	mov	r3, r5
 8004a88:	1891      	adds	r1, r2, r2
 8004a8a:	6139      	str	r1, [r7, #16]
 8004a8c:	415b      	adcs	r3, r3
 8004a8e:	617b      	str	r3, [r7, #20]
 8004a90:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8004a94:	1912      	adds	r2, r2, r4
 8004a96:	eb45 0303 	adc.w	r3, r5, r3
 8004a9a:	f04f 0000 	mov.w	r0, #0
 8004a9e:	f04f 0100 	mov.w	r1, #0
 8004aa2:	00d9      	lsls	r1, r3, #3
 8004aa4:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8004aa8:	00d0      	lsls	r0, r2, #3
 8004aaa:	4602      	mov	r2, r0
 8004aac:	460b      	mov	r3, r1
 8004aae:	eb12 0804 	adds.w	r8, r2, r4
 8004ab2:	eb43 0905 	adc.w	r9, r3, r5
 8004ab6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004ab8:	685b      	ldr	r3, [r3, #4]
 8004aba:	4618      	mov	r0, r3
 8004abc:	f04f 0100 	mov.w	r1, #0
 8004ac0:	f04f 0200 	mov.w	r2, #0
 8004ac4:	f04f 0300 	mov.w	r3, #0
 8004ac8:	008b      	lsls	r3, r1, #2
 8004aca:	ea43 7390 	orr.w	r3, r3, r0, lsr #30
 8004ace:	0082      	lsls	r2, r0, #2
 8004ad0:	4640      	mov	r0, r8
 8004ad2:	4649      	mov	r1, r9
 8004ad4:	f7fb fff2 	bl	8000abc <__aeabi_uldivmod>
 8004ad8:	4602      	mov	r2, r0
 8004ada:	460b      	mov	r3, r1
 8004adc:	4b49      	ldr	r3, [pc, #292]	; (8004c04 <UART_SetConfig+0x38c>)
 8004ade:	fba3 2302 	umull	r2, r3, r3, r2
 8004ae2:	095b      	lsrs	r3, r3, #5
 8004ae4:	011e      	lsls	r6, r3, #4
 8004ae6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004ae8:	4618      	mov	r0, r3
 8004aea:	f04f 0100 	mov.w	r1, #0
 8004aee:	4602      	mov	r2, r0
 8004af0:	460b      	mov	r3, r1
 8004af2:	1894      	adds	r4, r2, r2
 8004af4:	60bc      	str	r4, [r7, #8]
 8004af6:	415b      	adcs	r3, r3
 8004af8:	60fb      	str	r3, [r7, #12]
 8004afa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8004afe:	1812      	adds	r2, r2, r0
 8004b00:	eb41 0303 	adc.w	r3, r1, r3
 8004b04:	f04f 0400 	mov.w	r4, #0
 8004b08:	f04f 0500 	mov.w	r5, #0
 8004b0c:	00dd      	lsls	r5, r3, #3
 8004b0e:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 8004b12:	00d4      	lsls	r4, r2, #3
 8004b14:	4622      	mov	r2, r4
 8004b16:	462b      	mov	r3, r5
 8004b18:	1814      	adds	r4, r2, r0
 8004b1a:	64bc      	str	r4, [r7, #72]	; 0x48
 8004b1c:	414b      	adcs	r3, r1
 8004b1e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8004b20:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004b22:	685b      	ldr	r3, [r3, #4]
 8004b24:	4618      	mov	r0, r3
 8004b26:	f04f 0100 	mov.w	r1, #0
 8004b2a:	f04f 0200 	mov.w	r2, #0
 8004b2e:	f04f 0300 	mov.w	r3, #0
 8004b32:	008b      	lsls	r3, r1, #2
 8004b34:	ea43 7390 	orr.w	r3, r3, r0, lsr #30
 8004b38:	0082      	lsls	r2, r0, #2
 8004b3a:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 8004b3e:	f7fb ffbd 	bl	8000abc <__aeabi_uldivmod>
 8004b42:	4602      	mov	r2, r0
 8004b44:	460b      	mov	r3, r1
 8004b46:	4b2f      	ldr	r3, [pc, #188]	; (8004c04 <UART_SetConfig+0x38c>)
 8004b48:	fba3 1302 	umull	r1, r3, r3, r2
 8004b4c:	095b      	lsrs	r3, r3, #5
 8004b4e:	2164      	movs	r1, #100	; 0x64
 8004b50:	fb01 f303 	mul.w	r3, r1, r3
 8004b54:	1ad3      	subs	r3, r2, r3
 8004b56:	011b      	lsls	r3, r3, #4
 8004b58:	3332      	adds	r3, #50	; 0x32
 8004b5a:	4a2a      	ldr	r2, [pc, #168]	; (8004c04 <UART_SetConfig+0x38c>)
 8004b5c:	fba2 2303 	umull	r2, r3, r2, r3
 8004b60:	095b      	lsrs	r3, r3, #5
 8004b62:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004b66:	441e      	add	r6, r3
 8004b68:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8004b6a:	4618      	mov	r0, r3
 8004b6c:	f04f 0100 	mov.w	r1, #0
 8004b70:	4602      	mov	r2, r0
 8004b72:	460b      	mov	r3, r1
 8004b74:	1894      	adds	r4, r2, r2
 8004b76:	603c      	str	r4, [r7, #0]
 8004b78:	415b      	adcs	r3, r3
 8004b7a:	607b      	str	r3, [r7, #4]
 8004b7c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8004b80:	1812      	adds	r2, r2, r0
 8004b82:	eb41 0303 	adc.w	r3, r1, r3
 8004b86:	f04f 0400 	mov.w	r4, #0
 8004b8a:	f04f 0500 	mov.w	r5, #0
 8004b8e:	00dd      	lsls	r5, r3, #3
 8004b90:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 8004b94:	00d4      	lsls	r4, r2, #3
 8004b96:	4622      	mov	r2, r4
 8004b98:	462b      	mov	r3, r5
 8004b9a:	eb12 0a00 	adds.w	sl, r2, r0
 8004b9e:	eb43 0b01 	adc.w	fp, r3, r1
 8004ba2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004ba4:	685b      	ldr	r3, [r3, #4]
 8004ba6:	4618      	mov	r0, r3
 8004ba8:	f04f 0100 	mov.w	r1, #0
 8004bac:	f04f 0200 	mov.w	r2, #0
 8004bb0:	f04f 0300 	mov.w	r3, #0
 8004bb4:	008b      	lsls	r3, r1, #2
 8004bb6:	ea43 7390 	orr.w	r3, r3, r0, lsr #30
 8004bba:	0082      	lsls	r2, r0, #2
 8004bbc:	4650      	mov	r0, sl
 8004bbe:	4659      	mov	r1, fp
 8004bc0:	f7fb ff7c 	bl	8000abc <__aeabi_uldivmod>
 8004bc4:	4602      	mov	r2, r0
 8004bc6:	460b      	mov	r3, r1
 8004bc8:	4b0e      	ldr	r3, [pc, #56]	; (8004c04 <UART_SetConfig+0x38c>)
 8004bca:	fba3 1302 	umull	r1, r3, r3, r2
 8004bce:	095b      	lsrs	r3, r3, #5
 8004bd0:	2164      	movs	r1, #100	; 0x64
 8004bd2:	fb01 f303 	mul.w	r3, r1, r3
 8004bd6:	1ad3      	subs	r3, r2, r3
 8004bd8:	011b      	lsls	r3, r3, #4
 8004bda:	3332      	adds	r3, #50	; 0x32
 8004bdc:	4a09      	ldr	r2, [pc, #36]	; (8004c04 <UART_SetConfig+0x38c>)
 8004bde:	fba2 2303 	umull	r2, r3, r2, r3
 8004be2:	095b      	lsrs	r3, r3, #5
 8004be4:	f003 020f 	and.w	r2, r3, #15
 8004be8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8004bea:	681b      	ldr	r3, [r3, #0]
 8004bec:	4432      	add	r2, r6
 8004bee:	609a      	str	r2, [r3, #8]
}
 8004bf0:	bf00      	nop
 8004bf2:	377c      	adds	r7, #124	; 0x7c
 8004bf4:	46bd      	mov	sp, r7
 8004bf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004bfa:	bf00      	nop
 8004bfc:	40011000 	.word	0x40011000
 8004c00:	40011400 	.word	0x40011400
 8004c04:	51eb851f 	.word	0x51eb851f

08004c08 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8004c08:	b084      	sub	sp, #16
 8004c0a:	b580      	push	{r7, lr}
 8004c0c:	b084      	sub	sp, #16
 8004c0e:	af00      	add	r7, sp, #0
 8004c10:	6078      	str	r0, [r7, #4]
 8004c12:	f107 001c 	add.w	r0, r7, #28
 8004c16:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8004c1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c1c:	2b01      	cmp	r3, #1
 8004c1e:	d122      	bne.n	8004c66 <USB_CoreInit+0x5e>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8004c20:	687b      	ldr	r3, [r7, #4]
 8004c22:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004c24:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8004c28:	687b      	ldr	r3, [r7, #4]
 8004c2a:	639a      	str	r2, [r3, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8004c2c:	687b      	ldr	r3, [r7, #4]
 8004c2e:	68db      	ldr	r3, [r3, #12]
 8004c30:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8004c34:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004c38:	687a      	ldr	r2, [r7, #4]
 8004c3a:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8004c3c:	687b      	ldr	r3, [r7, #4]
 8004c3e:	68db      	ldr	r3, [r3, #12]
 8004c40:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004c44:	687b      	ldr	r3, [r7, #4]
 8004c46:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8004c48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004c4a:	2b01      	cmp	r3, #1
 8004c4c:	d105      	bne.n	8004c5a <USB_CoreInit+0x52>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8004c4e:	687b      	ldr	r3, [r7, #4]
 8004c50:	68db      	ldr	r3, [r3, #12]
 8004c52:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 8004c56:	687b      	ldr	r3, [r7, #4]
 8004c58:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8004c5a:	6878      	ldr	r0, [r7, #4]
 8004c5c:	f000 f9a0 	bl	8004fa0 <USB_CoreReset>
 8004c60:	4603      	mov	r3, r0
 8004c62:	73fb      	strb	r3, [r7, #15]
 8004c64:	e01a      	b.n	8004c9c <USB_CoreInit+0x94>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8004c66:	687b      	ldr	r3, [r7, #4]
 8004c68:	68db      	ldr	r3, [r3, #12]
 8004c6a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8004c6e:	687b      	ldr	r3, [r7, #4]
 8004c70:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8004c72:	6878      	ldr	r0, [r7, #4]
 8004c74:	f000 f994 	bl	8004fa0 <USB_CoreReset>
 8004c78:	4603      	mov	r3, r0
 8004c7a:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8004c7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004c7e:	2b00      	cmp	r3, #0
 8004c80:	d106      	bne.n	8004c90 <USB_CoreInit+0x88>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8004c82:	687b      	ldr	r3, [r7, #4]
 8004c84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004c86:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8004c8a:	687b      	ldr	r3, [r7, #4]
 8004c8c:	639a      	str	r2, [r3, #56]	; 0x38
 8004c8e:	e005      	b.n	8004c9c <USB_CoreInit+0x94>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8004c90:	687b      	ldr	r3, [r7, #4]
 8004c92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004c94:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8004c98:	687b      	ldr	r3, [r7, #4]
 8004c9a:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8004c9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004c9e:	2b01      	cmp	r3, #1
 8004ca0:	d10b      	bne.n	8004cba <USB_CoreInit+0xb2>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8004ca2:	687b      	ldr	r3, [r7, #4]
 8004ca4:	689b      	ldr	r3, [r3, #8]
 8004ca6:	f043 0206 	orr.w	r2, r3, #6
 8004caa:	687b      	ldr	r3, [r7, #4]
 8004cac:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8004cae:	687b      	ldr	r3, [r7, #4]
 8004cb0:	689b      	ldr	r3, [r3, #8]
 8004cb2:	f043 0220 	orr.w	r2, r3, #32
 8004cb6:	687b      	ldr	r3, [r7, #4]
 8004cb8:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8004cba:	7bfb      	ldrb	r3, [r7, #15]
}
 8004cbc:	4618      	mov	r0, r3
 8004cbe:	3710      	adds	r7, #16
 8004cc0:	46bd      	mov	sp, r7
 8004cc2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004cc6:	b004      	add	sp, #16
 8004cc8:	4770      	bx	lr

08004cca <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8004cca:	b480      	push	{r7}
 8004ccc:	b083      	sub	sp, #12
 8004cce:	af00      	add	r7, sp, #0
 8004cd0:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8004cd2:	687b      	ldr	r3, [r7, #4]
 8004cd4:	689b      	ldr	r3, [r3, #8]
 8004cd6:	f043 0201 	orr.w	r2, r3, #1
 8004cda:	687b      	ldr	r3, [r7, #4]
 8004cdc:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8004cde:	2300      	movs	r3, #0
}
 8004ce0:	4618      	mov	r0, r3
 8004ce2:	370c      	adds	r7, #12
 8004ce4:	46bd      	mov	sp, r7
 8004ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004cea:	4770      	bx	lr

08004cec <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8004cec:	b480      	push	{r7}
 8004cee:	b083      	sub	sp, #12
 8004cf0:	af00      	add	r7, sp, #0
 8004cf2:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8004cf4:	687b      	ldr	r3, [r7, #4]
 8004cf6:	689b      	ldr	r3, [r3, #8]
 8004cf8:	f023 0201 	bic.w	r2, r3, #1
 8004cfc:	687b      	ldr	r3, [r7, #4]
 8004cfe:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8004d00:	2300      	movs	r3, #0
}
 8004d02:	4618      	mov	r0, r3
 8004d04:	370c      	adds	r7, #12
 8004d06:	46bd      	mov	sp, r7
 8004d08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d0c:	4770      	bx	lr

08004d0e <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8004d0e:	b580      	push	{r7, lr}
 8004d10:	b084      	sub	sp, #16
 8004d12:	af00      	add	r7, sp, #0
 8004d14:	6078      	str	r0, [r7, #4]
 8004d16:	460b      	mov	r3, r1
 8004d18:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8004d1a:	2300      	movs	r3, #0
 8004d1c:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8004d1e:	687b      	ldr	r3, [r7, #4]
 8004d20:	68db      	ldr	r3, [r3, #12]
 8004d22:	f023 42c0 	bic.w	r2, r3, #1610612736	; 0x60000000
 8004d26:	687b      	ldr	r3, [r7, #4]
 8004d28:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8004d2a:	78fb      	ldrb	r3, [r7, #3]
 8004d2c:	2b01      	cmp	r3, #1
 8004d2e:	d115      	bne.n	8004d5c <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8004d30:	687b      	ldr	r3, [r7, #4]
 8004d32:	68db      	ldr	r3, [r3, #12]
 8004d34:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 8004d38:	687b      	ldr	r3, [r7, #4]
 8004d3a:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(1U);
 8004d3c:	2001      	movs	r0, #1
 8004d3e:	f7fc ff0d 	bl	8001b5c <HAL_Delay>
      ms++;
 8004d42:	68fb      	ldr	r3, [r7, #12]
 8004d44:	3301      	adds	r3, #1
 8004d46:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8004d48:	6878      	ldr	r0, [r7, #4]
 8004d4a:	f000 f91a 	bl	8004f82 <USB_GetMode>
 8004d4e:	4603      	mov	r3, r0
 8004d50:	2b01      	cmp	r3, #1
 8004d52:	d01e      	beq.n	8004d92 <USB_SetCurrentMode+0x84>
 8004d54:	68fb      	ldr	r3, [r7, #12]
 8004d56:	2b31      	cmp	r3, #49	; 0x31
 8004d58:	d9f0      	bls.n	8004d3c <USB_SetCurrentMode+0x2e>
 8004d5a:	e01a      	b.n	8004d92 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8004d5c:	78fb      	ldrb	r3, [r7, #3]
 8004d5e:	2b00      	cmp	r3, #0
 8004d60:	d115      	bne.n	8004d8e <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8004d62:	687b      	ldr	r3, [r7, #4]
 8004d64:	68db      	ldr	r3, [r3, #12]
 8004d66:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8004d6a:	687b      	ldr	r3, [r7, #4]
 8004d6c:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(1U);
 8004d6e:	2001      	movs	r0, #1
 8004d70:	f7fc fef4 	bl	8001b5c <HAL_Delay>
      ms++;
 8004d74:	68fb      	ldr	r3, [r7, #12]
 8004d76:	3301      	adds	r3, #1
 8004d78:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8004d7a:	6878      	ldr	r0, [r7, #4]
 8004d7c:	f000 f901 	bl	8004f82 <USB_GetMode>
 8004d80:	4603      	mov	r3, r0
 8004d82:	2b00      	cmp	r3, #0
 8004d84:	d005      	beq.n	8004d92 <USB_SetCurrentMode+0x84>
 8004d86:	68fb      	ldr	r3, [r7, #12]
 8004d88:	2b31      	cmp	r3, #49	; 0x31
 8004d8a:	d9f0      	bls.n	8004d6e <USB_SetCurrentMode+0x60>
 8004d8c:	e001      	b.n	8004d92 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8004d8e:	2301      	movs	r3, #1
 8004d90:	e005      	b.n	8004d9e <USB_SetCurrentMode+0x90>
  }

  if (ms == 50U)
 8004d92:	68fb      	ldr	r3, [r7, #12]
 8004d94:	2b32      	cmp	r3, #50	; 0x32
 8004d96:	d101      	bne.n	8004d9c <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8004d98:	2301      	movs	r3, #1
 8004d9a:	e000      	b.n	8004d9e <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8004d9c:	2300      	movs	r3, #0
}
 8004d9e:	4618      	mov	r0, r3
 8004da0:	3710      	adds	r7, #16
 8004da2:	46bd      	mov	sp, r7
 8004da4:	bd80      	pop	{r7, pc}
	...

08004da8 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8004da8:	b480      	push	{r7}
 8004daa:	b085      	sub	sp, #20
 8004dac:	af00      	add	r7, sp, #0
 8004dae:	6078      	str	r0, [r7, #4]
 8004db0:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8004db2:	2300      	movs	r3, #0
 8004db4:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004db6:	683b      	ldr	r3, [r7, #0]
 8004db8:	019b      	lsls	r3, r3, #6
 8004dba:	f043 0220 	orr.w	r2, r3, #32
 8004dbe:	687b      	ldr	r3, [r7, #4]
 8004dc0:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8004dc2:	68fb      	ldr	r3, [r7, #12]
 8004dc4:	3301      	adds	r3, #1
 8004dc6:	60fb      	str	r3, [r7, #12]
 8004dc8:	4a08      	ldr	r2, [pc, #32]	; (8004dec <USB_FlushTxFifo+0x44>)
 8004dca:	4293      	cmp	r3, r2
 8004dcc:	d901      	bls.n	8004dd2 <USB_FlushTxFifo+0x2a>
    {
      return HAL_TIMEOUT;
 8004dce:	2303      	movs	r3, #3
 8004dd0:	e006      	b.n	8004de0 <USB_FlushTxFifo+0x38>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8004dd2:	687b      	ldr	r3, [r7, #4]
 8004dd4:	691b      	ldr	r3, [r3, #16]
 8004dd6:	f003 0320 	and.w	r3, r3, #32
 8004dda:	2b20      	cmp	r3, #32
 8004ddc:	d0f1      	beq.n	8004dc2 <USB_FlushTxFifo+0x1a>

  return HAL_OK;
 8004dde:	2300      	movs	r3, #0
}
 8004de0:	4618      	mov	r0, r3
 8004de2:	3714      	adds	r7, #20
 8004de4:	46bd      	mov	sp, r7
 8004de6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004dea:	4770      	bx	lr
 8004dec:	00030d40 	.word	0x00030d40

08004df0 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo : Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8004df0:	b480      	push	{r7}
 8004df2:	b085      	sub	sp, #20
 8004df4:	af00      	add	r7, sp, #0
 8004df6:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8004df8:	2300      	movs	r3, #0
 8004dfa:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004dfc:	687b      	ldr	r3, [r7, #4]
 8004dfe:	2210      	movs	r2, #16
 8004e00:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8004e02:	68fb      	ldr	r3, [r7, #12]
 8004e04:	3301      	adds	r3, #1
 8004e06:	60fb      	str	r3, [r7, #12]
 8004e08:	4a08      	ldr	r2, [pc, #32]	; (8004e2c <USB_FlushRxFifo+0x3c>)
 8004e0a:	4293      	cmp	r3, r2
 8004e0c:	d901      	bls.n	8004e12 <USB_FlushRxFifo+0x22>
    {
      return HAL_TIMEOUT;
 8004e0e:	2303      	movs	r3, #3
 8004e10:	e006      	b.n	8004e20 <USB_FlushRxFifo+0x30>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8004e12:	687b      	ldr	r3, [r7, #4]
 8004e14:	691b      	ldr	r3, [r3, #16]
 8004e16:	f003 0310 	and.w	r3, r3, #16
 8004e1a:	2b10      	cmp	r3, #16
 8004e1c:	d0f1      	beq.n	8004e02 <USB_FlushRxFifo+0x12>

  return HAL_OK;
 8004e1e:	2300      	movs	r3, #0
}
 8004e20:	4618      	mov	r0, r3
 8004e22:	3714      	adds	r7, #20
 8004e24:	46bd      	mov	sp, r7
 8004e26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e2a:	4770      	bx	lr
 8004e2c:	00030d40 	.word	0x00030d40

08004e30 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8004e30:	b480      	push	{r7}
 8004e32:	b089      	sub	sp, #36	; 0x24
 8004e34:	af00      	add	r7, sp, #0
 8004e36:	60f8      	str	r0, [r7, #12]
 8004e38:	60b9      	str	r1, [r7, #8]
 8004e3a:	4611      	mov	r1, r2
 8004e3c:	461a      	mov	r2, r3
 8004e3e:	460b      	mov	r3, r1
 8004e40:	71fb      	strb	r3, [r7, #7]
 8004e42:	4613      	mov	r3, r2
 8004e44:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004e46:	68fb      	ldr	r3, [r7, #12]
 8004e48:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 8004e4a:	68bb      	ldr	r3, [r7, #8]
 8004e4c:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8004e4e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8004e52:	2b00      	cmp	r3, #0
 8004e54:	d123      	bne.n	8004e9e <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8004e56:	88bb      	ldrh	r3, [r7, #4]
 8004e58:	3303      	adds	r3, #3
 8004e5a:	089b      	lsrs	r3, r3, #2
 8004e5c:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8004e5e:	2300      	movs	r3, #0
 8004e60:	61bb      	str	r3, [r7, #24]
 8004e62:	e018      	b.n	8004e96 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8004e64:	79fb      	ldrb	r3, [r7, #7]
 8004e66:	031a      	lsls	r2, r3, #12
 8004e68:	697b      	ldr	r3, [r7, #20]
 8004e6a:	4413      	add	r3, r2
 8004e6c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8004e70:	461a      	mov	r2, r3
 8004e72:	69fb      	ldr	r3, [r7, #28]
 8004e74:	681b      	ldr	r3, [r3, #0]
 8004e76:	6013      	str	r3, [r2, #0]
      pSrc++;
 8004e78:	69fb      	ldr	r3, [r7, #28]
 8004e7a:	3301      	adds	r3, #1
 8004e7c:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8004e7e:	69fb      	ldr	r3, [r7, #28]
 8004e80:	3301      	adds	r3, #1
 8004e82:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8004e84:	69fb      	ldr	r3, [r7, #28]
 8004e86:	3301      	adds	r3, #1
 8004e88:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8004e8a:	69fb      	ldr	r3, [r7, #28]
 8004e8c:	3301      	adds	r3, #1
 8004e8e:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8004e90:	69bb      	ldr	r3, [r7, #24]
 8004e92:	3301      	adds	r3, #1
 8004e94:	61bb      	str	r3, [r7, #24]
 8004e96:	69ba      	ldr	r2, [r7, #24]
 8004e98:	693b      	ldr	r3, [r7, #16]
 8004e9a:	429a      	cmp	r2, r3
 8004e9c:	d3e2      	bcc.n	8004e64 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 8004e9e:	2300      	movs	r3, #0
}
 8004ea0:	4618      	mov	r0, r3
 8004ea2:	3724      	adds	r7, #36	; 0x24
 8004ea4:	46bd      	mov	sp, r7
 8004ea6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004eaa:	4770      	bx	lr

08004eac <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8004eac:	b480      	push	{r7}
 8004eae:	b08b      	sub	sp, #44	; 0x2c
 8004eb0:	af00      	add	r7, sp, #0
 8004eb2:	60f8      	str	r0, [r7, #12]
 8004eb4:	60b9      	str	r1, [r7, #8]
 8004eb6:	4613      	mov	r3, r2
 8004eb8:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004eba:	68fb      	ldr	r3, [r7, #12]
 8004ebc:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 8004ebe:	68bb      	ldr	r3, [r7, #8]
 8004ec0:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 8004ec2:	88fb      	ldrh	r3, [r7, #6]
 8004ec4:	089b      	lsrs	r3, r3, #2
 8004ec6:	b29b      	uxth	r3, r3
 8004ec8:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 8004eca:	88fb      	ldrh	r3, [r7, #6]
 8004ecc:	f003 0303 	and.w	r3, r3, #3
 8004ed0:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 8004ed2:	2300      	movs	r3, #0
 8004ed4:	623b      	str	r3, [r7, #32]
 8004ed6:	e014      	b.n	8004f02 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8004ed8:	69bb      	ldr	r3, [r7, #24]
 8004eda:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8004ede:	681a      	ldr	r2, [r3, #0]
 8004ee0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004ee2:	601a      	str	r2, [r3, #0]
    pDest++;
 8004ee4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004ee6:	3301      	adds	r3, #1
 8004ee8:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 8004eea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004eec:	3301      	adds	r3, #1
 8004eee:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 8004ef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004ef2:	3301      	adds	r3, #1
 8004ef4:	627b      	str	r3, [r7, #36]	; 0x24
    pDest++;
 8004ef6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004ef8:	3301      	adds	r3, #1
 8004efa:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0U; i < count32b; i++)
 8004efc:	6a3b      	ldr	r3, [r7, #32]
 8004efe:	3301      	adds	r3, #1
 8004f00:	623b      	str	r3, [r7, #32]
 8004f02:	6a3a      	ldr	r2, [r7, #32]
 8004f04:	697b      	ldr	r3, [r7, #20]
 8004f06:	429a      	cmp	r2, r3
 8004f08:	d3e6      	bcc.n	8004ed8 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8004f0a:	8bfb      	ldrh	r3, [r7, #30]
 8004f0c:	2b00      	cmp	r3, #0
 8004f0e:	d01e      	beq.n	8004f4e <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8004f10:	2300      	movs	r3, #0
 8004f12:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8004f14:	69bb      	ldr	r3, [r7, #24]
 8004f16:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8004f1a:	461a      	mov	r2, r3
 8004f1c:	f107 0310 	add.w	r3, r7, #16
 8004f20:	6812      	ldr	r2, [r2, #0]
 8004f22:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8004f24:	693a      	ldr	r2, [r7, #16]
 8004f26:	6a3b      	ldr	r3, [r7, #32]
 8004f28:	b2db      	uxtb	r3, r3
 8004f2a:	00db      	lsls	r3, r3, #3
 8004f2c:	fa22 f303 	lsr.w	r3, r2, r3
 8004f30:	b2da      	uxtb	r2, r3
 8004f32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004f34:	701a      	strb	r2, [r3, #0]
      i++;
 8004f36:	6a3b      	ldr	r3, [r7, #32]
 8004f38:	3301      	adds	r3, #1
 8004f3a:	623b      	str	r3, [r7, #32]
      pDest++;
 8004f3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004f3e:	3301      	adds	r3, #1
 8004f40:	627b      	str	r3, [r7, #36]	; 0x24
      remaining_bytes--;
 8004f42:	8bfb      	ldrh	r3, [r7, #30]
 8004f44:	3b01      	subs	r3, #1
 8004f46:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8004f48:	8bfb      	ldrh	r3, [r7, #30]
 8004f4a:	2b00      	cmp	r3, #0
 8004f4c:	d1ea      	bne.n	8004f24 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 8004f4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8004f50:	4618      	mov	r0, r3
 8004f52:	372c      	adds	r7, #44	; 0x2c
 8004f54:	46bd      	mov	sp, r7
 8004f56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f5a:	4770      	bx	lr

08004f5c <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
{
 8004f5c:	b480      	push	{r7}
 8004f5e:	b085      	sub	sp, #20
 8004f60:	af00      	add	r7, sp, #0
 8004f62:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8004f64:	687b      	ldr	r3, [r7, #4]
 8004f66:	695b      	ldr	r3, [r3, #20]
 8004f68:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8004f6a:	687b      	ldr	r3, [r7, #4]
 8004f6c:	699b      	ldr	r3, [r3, #24]
 8004f6e:	68fa      	ldr	r2, [r7, #12]
 8004f70:	4013      	ands	r3, r2
 8004f72:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8004f74:	68fb      	ldr	r3, [r7, #12]
}
 8004f76:	4618      	mov	r0, r3
 8004f78:	3714      	adds	r7, #20
 8004f7a:	46bd      	mov	sp, r7
 8004f7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f80:	4770      	bx	lr

08004f82 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
 8004f82:	b480      	push	{r7}
 8004f84:	b083      	sub	sp, #12
 8004f86:	af00      	add	r7, sp, #0
 8004f88:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8004f8a:	687b      	ldr	r3, [r7, #4]
 8004f8c:	695b      	ldr	r3, [r3, #20]
 8004f8e:	f003 0301 	and.w	r3, r3, #1
}
 8004f92:	4618      	mov	r0, r3
 8004f94:	370c      	adds	r7, #12
 8004f96:	46bd      	mov	sp, r7
 8004f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f9c:	4770      	bx	lr
	...

08004fa0 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8004fa0:	b480      	push	{r7}
 8004fa2:	b085      	sub	sp, #20
 8004fa4:	af00      	add	r7, sp, #0
 8004fa6:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8004fa8:	2300      	movs	r3, #0
 8004faa:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8004fac:	68fb      	ldr	r3, [r7, #12]
 8004fae:	3301      	adds	r3, #1
 8004fb0:	60fb      	str	r3, [r7, #12]
 8004fb2:	4a13      	ldr	r2, [pc, #76]	; (8005000 <USB_CoreReset+0x60>)
 8004fb4:	4293      	cmp	r3, r2
 8004fb6:	d901      	bls.n	8004fbc <USB_CoreReset+0x1c>
    {
      return HAL_TIMEOUT;
 8004fb8:	2303      	movs	r3, #3
 8004fba:	e01a      	b.n	8004ff2 <USB_CoreReset+0x52>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8004fbc:	687b      	ldr	r3, [r7, #4]
 8004fbe:	691b      	ldr	r3, [r3, #16]
 8004fc0:	2b00      	cmp	r3, #0
 8004fc2:	daf3      	bge.n	8004fac <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 8004fc4:	2300      	movs	r3, #0
 8004fc6:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8004fc8:	687b      	ldr	r3, [r7, #4]
 8004fca:	691b      	ldr	r3, [r3, #16]
 8004fcc:	f043 0201 	orr.w	r2, r3, #1
 8004fd0:	687b      	ldr	r3, [r7, #4]
 8004fd2:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8004fd4:	68fb      	ldr	r3, [r7, #12]
 8004fd6:	3301      	adds	r3, #1
 8004fd8:	60fb      	str	r3, [r7, #12]
 8004fda:	4a09      	ldr	r2, [pc, #36]	; (8005000 <USB_CoreReset+0x60>)
 8004fdc:	4293      	cmp	r3, r2
 8004fde:	d901      	bls.n	8004fe4 <USB_CoreReset+0x44>
    {
      return HAL_TIMEOUT;
 8004fe0:	2303      	movs	r3, #3
 8004fe2:	e006      	b.n	8004ff2 <USB_CoreReset+0x52>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8004fe4:	687b      	ldr	r3, [r7, #4]
 8004fe6:	691b      	ldr	r3, [r3, #16]
 8004fe8:	f003 0301 	and.w	r3, r3, #1
 8004fec:	2b01      	cmp	r3, #1
 8004fee:	d0f1      	beq.n	8004fd4 <USB_CoreReset+0x34>

  return HAL_OK;
 8004ff0:	2300      	movs	r3, #0
}
 8004ff2:	4618      	mov	r0, r3
 8004ff4:	3714      	adds	r7, #20
 8004ff6:	46bd      	mov	sp, r7
 8004ff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ffc:	4770      	bx	lr
 8004ffe:	bf00      	nop
 8005000:	00030d40 	.word	0x00030d40

08005004 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8005004:	b084      	sub	sp, #16
 8005006:	b580      	push	{r7, lr}
 8005008:	b084      	sub	sp, #16
 800500a:	af00      	add	r7, sp, #0
 800500c:	6078      	str	r0, [r7, #4]
 800500e:	f107 001c 	add.w	r0, r7, #28
 8005012:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005016:	687b      	ldr	r3, [r7, #4]
 8005018:	60bb      	str	r3, [r7, #8]
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800501a:	68bb      	ldr	r3, [r7, #8]
 800501c:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8005020:	461a      	mov	r2, r3
 8005022:	2300      	movs	r3, #0
 8005024:	6013      	str	r3, [r2, #0]
#else
  /*
  * Disable HW VBUS sensing. VBUS is internally considered to be always
  * at VBUS-Valid level (5V).
  */
  USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8005026:	687b      	ldr	r3, [r7, #4]
 8005028:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800502a:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 800502e:	687b      	ldr	r3, [r7, #4]
 8005030:	639a      	str	r2, [r3, #56]	; 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8005032:	687b      	ldr	r3, [r7, #4]
 8005034:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005036:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 800503a:	687b      	ldr	r3, [r7, #4]
 800503c:	639a      	str	r2, [r3, #56]	; 0x38
  USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 800503e:	687b      	ldr	r3, [r7, #4]
 8005040:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005042:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 8005046:	687b      	ldr	r3, [r7, #4]
 8005048:	639a      	str	r2, [r3, #56]	; 0x38
#if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
#endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */

  if ((USBx->CID & (0x1U << 8)) != 0U)
 800504a:	687b      	ldr	r3, [r7, #4]
 800504c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800504e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005052:	2b00      	cmp	r3, #0
 8005054:	d018      	beq.n	8005088 <USB_HostInit+0x84>
  {
    if (cfg.speed == USBH_FSLS_SPEED)
 8005056:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005058:	2b01      	cmp	r3, #1
 800505a:	d10a      	bne.n	8005072 <USB_HostInit+0x6e>
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 800505c:	68bb      	ldr	r3, [r7, #8]
 800505e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005062:	681b      	ldr	r3, [r3, #0]
 8005064:	68ba      	ldr	r2, [r7, #8]
 8005066:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800506a:	f043 0304 	orr.w	r3, r3, #4
 800506e:	6013      	str	r3, [r2, #0]
 8005070:	e014      	b.n	800509c <USB_HostInit+0x98>
    }
    else
    {
      /* Set default Max speed support */
      USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8005072:	68bb      	ldr	r3, [r7, #8]
 8005074:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	68ba      	ldr	r2, [r7, #8]
 800507c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005080:	f023 0304 	bic.w	r3, r3, #4
 8005084:	6013      	str	r3, [r2, #0]
 8005086:	e009      	b.n	800509c <USB_HostInit+0x98>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8005088:	68bb      	ldr	r3, [r7, #8]
 800508a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800508e:	681b      	ldr	r3, [r3, #0]
 8005090:	68ba      	ldr	r2, [r7, #8]
 8005092:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005096:	f023 0304 	bic.w	r3, r3, #4
 800509a:	6013      	str	r3, [r2, #0]
  }

  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
 800509c:	2110      	movs	r1, #16
 800509e:	6878      	ldr	r0, [r7, #4]
 80050a0:	f7ff fe82 	bl	8004da8 <USB_FlushTxFifo>
  (void)USB_FlushRxFifo(USBx);
 80050a4:	6878      	ldr	r0, [r7, #4]
 80050a6:	f7ff fea3 	bl	8004df0 <USB_FlushRxFifo>

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 80050aa:	2300      	movs	r3, #0
 80050ac:	60fb      	str	r3, [r7, #12]
 80050ae:	e015      	b.n	80050dc <USB_HostInit+0xd8>
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 80050b0:	68fb      	ldr	r3, [r7, #12]
 80050b2:	015a      	lsls	r2, r3, #5
 80050b4:	68bb      	ldr	r3, [r7, #8]
 80050b6:	4413      	add	r3, r2
 80050b8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80050bc:	461a      	mov	r2, r3
 80050be:	f04f 33ff 	mov.w	r3, #4294967295
 80050c2:	6093      	str	r3, [r2, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 80050c4:	68fb      	ldr	r3, [r7, #12]
 80050c6:	015a      	lsls	r2, r3, #5
 80050c8:	68bb      	ldr	r3, [r7, #8]
 80050ca:	4413      	add	r3, r2
 80050cc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80050d0:	461a      	mov	r2, r3
 80050d2:	2300      	movs	r3, #0
 80050d4:	60d3      	str	r3, [r2, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 80050d6:	68fb      	ldr	r3, [r7, #12]
 80050d8:	3301      	adds	r3, #1
 80050da:	60fb      	str	r3, [r7, #12]
 80050dc:	6a3b      	ldr	r3, [r7, #32]
 80050de:	68fa      	ldr	r2, [r7, #12]
 80050e0:	429a      	cmp	r2, r3
 80050e2:	d3e5      	bcc.n	80050b0 <USB_HostInit+0xac>
  }

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 80050e4:	687b      	ldr	r3, [r7, #4]
 80050e6:	2200      	movs	r2, #0
 80050e8:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFFU;
 80050ea:	687b      	ldr	r3, [r7, #4]
 80050ec:	f04f 32ff 	mov.w	r2, #4294967295
 80050f0:	615a      	str	r2, [r3, #20]

  if ((USBx->CID & (0x1U << 8)) != 0U)
 80050f2:	687b      	ldr	r3, [r7, #4]
 80050f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80050f6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80050fa:	2b00      	cmp	r3, #0
 80050fc:	d00b      	beq.n	8005116 <USB_HostInit+0x112>
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x200U;
 80050fe:	687b      	ldr	r3, [r7, #4]
 8005100:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005104:	625a      	str	r2, [r3, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 8005106:	687b      	ldr	r3, [r7, #4]
 8005108:	4a13      	ldr	r2, [pc, #76]	; (8005158 <USB_HostInit+0x154>)
 800510a:	629a      	str	r2, [r3, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 800510c:	687b      	ldr	r3, [r7, #4]
 800510e:	4a13      	ldr	r2, [pc, #76]	; (800515c <USB_HostInit+0x158>)
 8005110:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 8005114:	e009      	b.n	800512a <USB_HostInit+0x126>
  }
  else
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x80U;
 8005116:	687b      	ldr	r3, [r7, #4]
 8005118:	2280      	movs	r2, #128	; 0x80
 800511a:	625a      	str	r2, [r3, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 800511c:	687b      	ldr	r3, [r7, #4]
 800511e:	4a10      	ldr	r2, [pc, #64]	; (8005160 <USB_HostInit+0x15c>)
 8005120:	629a      	str	r2, [r3, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 8005122:	687b      	ldr	r3, [r7, #4]
 8005124:	4a0f      	ldr	r2, [pc, #60]	; (8005164 <USB_HostInit+0x160>)
 8005126:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 800512a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800512c:	2b00      	cmp	r3, #0
 800512e:	d105      	bne.n	800513c <USB_HostInit+0x138>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8005130:	687b      	ldr	r3, [r7, #4]
 8005132:	699b      	ldr	r3, [r3, #24]
 8005134:	f043 0210 	orr.w	r2, r3, #16
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 800513c:	687b      	ldr	r3, [r7, #4]
 800513e:	699a      	ldr	r2, [r3, #24]
 8005140:	4b09      	ldr	r3, [pc, #36]	; (8005168 <USB_HostInit+0x164>)
 8005142:	4313      	orrs	r3, r2
 8005144:	687a      	ldr	r2, [r7, #4]
 8005146:	6193      	str	r3, [r2, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return HAL_OK;
 8005148:	2300      	movs	r3, #0
}
 800514a:	4618      	mov	r0, r3
 800514c:	3710      	adds	r7, #16
 800514e:	46bd      	mov	sp, r7
 8005150:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8005154:	b004      	add	sp, #16
 8005156:	4770      	bx	lr
 8005158:	01000200 	.word	0x01000200
 800515c:	00e00300 	.word	0x00e00300
 8005160:	00600080 	.word	0x00600080
 8005164:	004000e0 	.word	0x004000e0
 8005168:	a3200008 	.word	0xa3200008

0800516c <USB_InitFSLSPClkSel>:
  *           HCFG_48_MHZ : Full Speed 48 MHz Clock
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
 800516c:	b480      	push	{r7}
 800516e:	b085      	sub	sp, #20
 8005170:	af00      	add	r7, sp, #0
 8005172:	6078      	str	r0, [r7, #4]
 8005174:	460b      	mov	r3, r1
 8005176:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005178:	687b      	ldr	r3, [r7, #4]
 800517a:	60fb      	str	r3, [r7, #12]

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 800517c:	68fb      	ldr	r3, [r7, #12]
 800517e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005182:	681b      	ldr	r3, [r3, #0]
 8005184:	68fa      	ldr	r2, [r7, #12]
 8005186:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800518a:	f023 0303 	bic.w	r3, r3, #3
 800518e:	6013      	str	r3, [r2, #0]
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 8005190:	68fb      	ldr	r3, [r7, #12]
 8005192:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005196:	681a      	ldr	r2, [r3, #0]
 8005198:	78fb      	ldrb	r3, [r7, #3]
 800519a:	f003 0303 	and.w	r3, r3, #3
 800519e:	68f9      	ldr	r1, [r7, #12]
 80051a0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80051a4:	4313      	orrs	r3, r2
 80051a6:	600b      	str	r3, [r1, #0]

  if (freq == HCFG_48_MHZ)
 80051a8:	78fb      	ldrb	r3, [r7, #3]
 80051aa:	2b01      	cmp	r3, #1
 80051ac:	d107      	bne.n	80051be <USB_InitFSLSPClkSel+0x52>
  {
    USBx_HOST->HFIR = 48000U;
 80051ae:	68fb      	ldr	r3, [r7, #12]
 80051b0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051b4:	461a      	mov	r2, r3
 80051b6:	f64b 3380 	movw	r3, #48000	; 0xbb80
 80051ba:	6053      	str	r3, [r2, #4]
 80051bc:	e009      	b.n	80051d2 <USB_InitFSLSPClkSel+0x66>
  }
  else if (freq == HCFG_6_MHZ)
 80051be:	78fb      	ldrb	r3, [r7, #3]
 80051c0:	2b02      	cmp	r3, #2
 80051c2:	d106      	bne.n	80051d2 <USB_InitFSLSPClkSel+0x66>
  {
    USBx_HOST->HFIR = 6000U;
 80051c4:	68fb      	ldr	r3, [r7, #12]
 80051c6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80051ca:	461a      	mov	r2, r3
 80051cc:	f241 7370 	movw	r3, #6000	; 0x1770
 80051d0:	6053      	str	r3, [r2, #4]
  else
  {
    /* ... */
  }

  return HAL_OK;
 80051d2:	2300      	movs	r3, #0
}
 80051d4:	4618      	mov	r0, r3
 80051d6:	3714      	adds	r7, #20
 80051d8:	46bd      	mov	sp, r7
 80051da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051de:	4770      	bx	lr

080051e0 <USB_ResetPort>:
  * @retval HAL status
  * @note (1)The application must wait at least 10 ms
  *   before clearing the reset bit.
  */
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
{
 80051e0:	b580      	push	{r7, lr}
 80051e2:	b084      	sub	sp, #16
 80051e4:	af00      	add	r7, sp, #0
 80051e6:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80051e8:	687b      	ldr	r3, [r7, #4]
 80051ea:	60fb      	str	r3, [r7, #12]

  __IO uint32_t hprt0 = 0U;
 80051ec:	2300      	movs	r3, #0
 80051ee:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 80051f0:	68fb      	ldr	r3, [r7, #12]
 80051f2:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80051f6:	681b      	ldr	r3, [r3, #0]
 80051f8:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80051fa:	68bb      	ldr	r3, [r7, #8]
 80051fc:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8005200:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 8005202:	68bb      	ldr	r3, [r7, #8]
 8005204:	68fa      	ldr	r2, [r7, #12]
 8005206:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 800520a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800520e:	6013      	str	r3, [r2, #0]
  HAL_Delay(100U);                                 /* See Note #1 */
 8005210:	2064      	movs	r0, #100	; 0x64
 8005212:	f7fc fca3 	bl	8001b5c <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 8005216:	68bb      	ldr	r3, [r7, #8]
 8005218:	68fa      	ldr	r2, [r7, #12]
 800521a:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 800521e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005222:	6013      	str	r3, [r2, #0]
  HAL_Delay(10U);
 8005224:	200a      	movs	r0, #10
 8005226:	f7fc fc99 	bl	8001b5c <HAL_Delay>

  return HAL_OK;
 800522a:	2300      	movs	r3, #0
}
 800522c:	4618      	mov	r0, r3
 800522e:	3710      	adds	r7, #16
 8005230:	46bd      	mov	sp, r7
 8005232:	bd80      	pop	{r7, pc}

08005234 <USB_DriveVbus>:
  *           0 : Deactivate VBUS
  *           1 : Activate VBUS
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 8005234:	b480      	push	{r7}
 8005236:	b085      	sub	sp, #20
 8005238:	af00      	add	r7, sp, #0
 800523a:	6078      	str	r0, [r7, #4]
 800523c:	460b      	mov	r3, r1
 800523e:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005240:	687b      	ldr	r3, [r7, #4]
 8005242:	60fb      	str	r3, [r7, #12]
  __IO uint32_t hprt0 = 0U;
 8005244:	2300      	movs	r3, #0
 8005246:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 8005248:	68fb      	ldr	r3, [r7, #12]
 800524a:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 800524e:	681b      	ldr	r3, [r3, #0]
 8005250:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 8005252:	68bb      	ldr	r3, [r7, #8]
 8005254:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8005258:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 800525a:	68bb      	ldr	r3, [r7, #8]
 800525c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8005260:	2b00      	cmp	r3, #0
 8005262:	d109      	bne.n	8005278 <USB_DriveVbus+0x44>
 8005264:	78fb      	ldrb	r3, [r7, #3]
 8005266:	2b01      	cmp	r3, #1
 8005268:	d106      	bne.n	8005278 <USB_DriveVbus+0x44>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 800526a:	68bb      	ldr	r3, [r7, #8]
 800526c:	68fa      	ldr	r2, [r7, #12]
 800526e:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 8005272:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005276:	6013      	str	r3, [r2, #0]
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8005278:	68bb      	ldr	r3, [r7, #8]
 800527a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800527e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005282:	d109      	bne.n	8005298 <USB_DriveVbus+0x64>
 8005284:	78fb      	ldrb	r3, [r7, #3]
 8005286:	2b00      	cmp	r3, #0
 8005288:	d106      	bne.n	8005298 <USB_DriveVbus+0x64>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 800528a:	68bb      	ldr	r3, [r7, #8]
 800528c:	68fa      	ldr	r2, [r7, #12]
 800528e:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 8005292:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005296:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 8005298:	2300      	movs	r3, #0
}
 800529a:	4618      	mov	r0, r3
 800529c:	3714      	adds	r7, #20
 800529e:	46bd      	mov	sp, r7
 80052a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052a4:	4770      	bx	lr

080052a6 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 80052a6:	b480      	push	{r7}
 80052a8:	b085      	sub	sp, #20
 80052aa:	af00      	add	r7, sp, #0
 80052ac:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80052ae:	687b      	ldr	r3, [r7, #4]
 80052b0:	60fb      	str	r3, [r7, #12]
  __IO uint32_t hprt0 = 0U;
 80052b2:	2300      	movs	r3, #0
 80052b4:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 80052b6:	68fb      	ldr	r3, [r7, #12]
 80052b8:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80052bc:	681b      	ldr	r3, [r3, #0]
 80052be:	60bb      	str	r3, [r7, #8]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 80052c0:	68bb      	ldr	r3, [r7, #8]
 80052c2:	0c5b      	lsrs	r3, r3, #17
 80052c4:	f003 0303 	and.w	r3, r3, #3
}
 80052c8:	4618      	mov	r0, r3
 80052ca:	3714      	adds	r7, #20
 80052cc:	46bd      	mov	sp, r7
 80052ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052d2:	4770      	bx	lr

080052d4 <USB_GetCurrentFrame>:
  * @brief  Return Host Current Frame number
  * @param  USBx  Selected device
  * @retval current frame number
  */
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
 80052d4:	b480      	push	{r7}
 80052d6:	b085      	sub	sp, #20
 80052d8:	af00      	add	r7, sp, #0
 80052da:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80052dc:	687b      	ldr	r3, [r7, #4]
 80052de:	60fb      	str	r3, [r7, #12]

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 80052e0:	68fb      	ldr	r3, [r7, #12]
 80052e2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80052e6:	689b      	ldr	r3, [r3, #8]
 80052e8:	b29b      	uxth	r3, r3
}
 80052ea:	4618      	mov	r0, r3
 80052ec:	3714      	adds	r7, #20
 80052ee:	46bd      	mov	sp, r7
 80052f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052f4:	4770      	bx	lr
	...

080052f8 <USB_HC_Init>:
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
                              uint8_t epnum, uint8_t dev_address, uint8_t speed,
                              uint8_t ep_type, uint16_t mps)
{
 80052f8:	b580      	push	{r7, lr}
 80052fa:	b088      	sub	sp, #32
 80052fc:	af00      	add	r7, sp, #0
 80052fe:	6078      	str	r0, [r7, #4]
 8005300:	4608      	mov	r0, r1
 8005302:	4611      	mov	r1, r2
 8005304:	461a      	mov	r2, r3
 8005306:	4603      	mov	r3, r0
 8005308:	70fb      	strb	r3, [r7, #3]
 800530a:	460b      	mov	r3, r1
 800530c:	70bb      	strb	r3, [r7, #2]
 800530e:	4613      	mov	r3, r2
 8005310:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef ret = HAL_OK;
 8005312:	2300      	movs	r3, #0
 8005314:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005316:	687b      	ldr	r3, [r7, #4]
 8005318:	613b      	str	r3, [r7, #16]
  uint32_t HCcharEpDir;
  uint32_t HCcharLowSpeed;
  uint32_t HostCoreSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 800531a:	78fb      	ldrb	r3, [r7, #3]
 800531c:	015a      	lsls	r2, r3, #5
 800531e:	693b      	ldr	r3, [r7, #16]
 8005320:	4413      	add	r3, r2
 8005322:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005326:	461a      	mov	r2, r3
 8005328:	f04f 33ff 	mov.w	r3, #4294967295
 800532c:	6093      	str	r3, [r2, #8]

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 800532e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8005332:	2b03      	cmp	r3, #3
 8005334:	d87e      	bhi.n	8005434 <USB_HC_Init+0x13c>
 8005336:	a201      	add	r2, pc, #4	; (adr r2, 800533c <USB_HC_Init+0x44>)
 8005338:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800533c:	0800534d 	.word	0x0800534d
 8005340:	080053f7 	.word	0x080053f7
 8005344:	0800534d 	.word	0x0800534d
 8005348:	080053b9 	.word	0x080053b9
  {
    case EP_TYPE_CTRL:
    case EP_TYPE_BULK:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 800534c:	78fb      	ldrb	r3, [r7, #3]
 800534e:	015a      	lsls	r2, r3, #5
 8005350:	693b      	ldr	r3, [r7, #16]
 8005352:	4413      	add	r3, r2
 8005354:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005358:	461a      	mov	r2, r3
 800535a:	f240 439d 	movw	r3, #1181	; 0x49d
 800535e:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_TXERRM |
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_NAKM;

      if ((epnum & 0x80U) == 0x80U)
 8005360:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8005364:	2b00      	cmp	r3, #0
 8005366:	da10      	bge.n	800538a <USB_HC_Init+0x92>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8005368:	78fb      	ldrb	r3, [r7, #3]
 800536a:	015a      	lsls	r2, r3, #5
 800536c:	693b      	ldr	r3, [r7, #16]
 800536e:	4413      	add	r3, r2
 8005370:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005374:	68db      	ldr	r3, [r3, #12]
 8005376:	78fa      	ldrb	r2, [r7, #3]
 8005378:	0151      	lsls	r1, r2, #5
 800537a:	693a      	ldr	r2, [r7, #16]
 800537c:	440a      	add	r2, r1
 800537e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005382:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005386:	60d3      	str	r3, [r2, #12]
        {
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
                                                 USB_OTG_HCINTMSK_ACKM;
        }
      }
      break;
 8005388:	e057      	b.n	800543a <USB_HC_Init+0x142>
        if ((USBx->CID & (0x1U << 8)) != 0U)
 800538a:	687b      	ldr	r3, [r7, #4]
 800538c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800538e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005392:	2b00      	cmp	r3, #0
 8005394:	d051      	beq.n	800543a <USB_HC_Init+0x142>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_NYET |
 8005396:	78fb      	ldrb	r3, [r7, #3]
 8005398:	015a      	lsls	r2, r3, #5
 800539a:	693b      	ldr	r3, [r7, #16]
 800539c:	4413      	add	r3, r2
 800539e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80053a2:	68db      	ldr	r3, [r3, #12]
 80053a4:	78fa      	ldrb	r2, [r7, #3]
 80053a6:	0151      	lsls	r1, r2, #5
 80053a8:	693a      	ldr	r2, [r7, #16]
 80053aa:	440a      	add	r2, r1
 80053ac:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80053b0:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 80053b4:	60d3      	str	r3, [r2, #12]
      break;
 80053b6:	e040      	b.n	800543a <USB_HC_Init+0x142>

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80053b8:	78fb      	ldrb	r3, [r7, #3]
 80053ba:	015a      	lsls	r2, r3, #5
 80053bc:	693b      	ldr	r3, [r7, #16]
 80053be:	4413      	add	r3, r2
 80053c0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80053c4:	461a      	mov	r2, r3
 80053c6:	f240 639d 	movw	r3, #1693	; 0x69d
 80053ca:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 80053cc:	f997 3002 	ldrsb.w	r3, [r7, #2]
 80053d0:	2b00      	cmp	r3, #0
 80053d2:	da34      	bge.n	800543e <USB_HC_Init+0x146>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 80053d4:	78fb      	ldrb	r3, [r7, #3]
 80053d6:	015a      	lsls	r2, r3, #5
 80053d8:	693b      	ldr	r3, [r7, #16]
 80053da:	4413      	add	r3, r2
 80053dc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80053e0:	68db      	ldr	r3, [r3, #12]
 80053e2:	78fa      	ldrb	r2, [r7, #3]
 80053e4:	0151      	lsls	r1, r2, #5
 80053e6:	693a      	ldr	r2, [r7, #16]
 80053e8:	440a      	add	r2, r1
 80053ea:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80053ee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80053f2:	60d3      	str	r3, [r2, #12]
      }

      break;
 80053f4:	e023      	b.n	800543e <USB_HC_Init+0x146>

    case EP_TYPE_ISOC:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80053f6:	78fb      	ldrb	r3, [r7, #3]
 80053f8:	015a      	lsls	r2, r3, #5
 80053fa:	693b      	ldr	r3, [r7, #16]
 80053fc:	4413      	add	r3, r2
 80053fe:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005402:	461a      	mov	r2, r3
 8005404:	f240 2325 	movw	r3, #549	; 0x225
 8005408:	60d3      	str	r3, [r2, #12]
                                            USB_OTG_HCINTMSK_ACKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 800540a:	f997 3002 	ldrsb.w	r3, [r7, #2]
 800540e:	2b00      	cmp	r3, #0
 8005410:	da17      	bge.n	8005442 <USB_HC_Init+0x14a>
      {
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 8005412:	78fb      	ldrb	r3, [r7, #3]
 8005414:	015a      	lsls	r2, r3, #5
 8005416:	693b      	ldr	r3, [r7, #16]
 8005418:	4413      	add	r3, r2
 800541a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800541e:	68db      	ldr	r3, [r3, #12]
 8005420:	78fa      	ldrb	r2, [r7, #3]
 8005422:	0151      	lsls	r1, r2, #5
 8005424:	693a      	ldr	r2, [r7, #16]
 8005426:	440a      	add	r2, r1
 8005428:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800542c:	f443 73c0 	orr.w	r3, r3, #384	; 0x180
 8005430:	60d3      	str	r3, [r2, #12]
      }
      break;
 8005432:	e006      	b.n	8005442 <USB_HC_Init+0x14a>

    default:
      ret = HAL_ERROR;
 8005434:	2301      	movs	r3, #1
 8005436:	77fb      	strb	r3, [r7, #31]
      break;
 8005438:	e004      	b.n	8005444 <USB_HC_Init+0x14c>
      break;
 800543a:	bf00      	nop
 800543c:	e002      	b.n	8005444 <USB_HC_Init+0x14c>
      break;
 800543e:	bf00      	nop
 8005440:	e000      	b.n	8005444 <USB_HC_Init+0x14c>
      break;
 8005442:	bf00      	nop
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8005444:	693b      	ldr	r3, [r7, #16]
 8005446:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800544a:	699a      	ldr	r2, [r3, #24]
 800544c:	78fb      	ldrb	r3, [r7, #3]
 800544e:	f003 030f 	and.w	r3, r3, #15
 8005452:	2101      	movs	r1, #1
 8005454:	fa01 f303 	lsl.w	r3, r1, r3
 8005458:	6939      	ldr	r1, [r7, #16]
 800545a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800545e:	4313      	orrs	r3, r2
 8005460:	618b      	str	r3, [r1, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8005462:	687b      	ldr	r3, [r7, #4]
 8005464:	699b      	ldr	r3, [r3, #24]
 8005466:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	619a      	str	r2, [r3, #24]

  /* Program the HCCHAR register */
  if ((epnum & 0x80U) == 0x80U)
 800546e:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8005472:	2b00      	cmp	r3, #0
 8005474:	da03      	bge.n	800547e <USB_HC_Init+0x186>
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 8005476:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800547a:	61bb      	str	r3, [r7, #24]
 800547c:	e001      	b.n	8005482 <USB_HC_Init+0x18a>
  }
  else
  {
    HCcharEpDir = 0U;
 800547e:	2300      	movs	r3, #0
 8005480:	61bb      	str	r3, [r7, #24]
  }

  HostCoreSpeed = USB_GetHostSpeed(USBx);
 8005482:	6878      	ldr	r0, [r7, #4]
 8005484:	f7ff ff0f 	bl	80052a6 <USB_GetHostSpeed>
 8005488:	60f8      	str	r0, [r7, #12]

  /* LS device plugged to HUB */
  if ((speed == HPRT0_PRTSPD_LOW_SPEED) && (HostCoreSpeed != HPRT0_PRTSPD_LOW_SPEED))
 800548a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800548e:	2b02      	cmp	r3, #2
 8005490:	d106      	bne.n	80054a0 <USB_HC_Init+0x1a8>
 8005492:	68fb      	ldr	r3, [r7, #12]
 8005494:	2b02      	cmp	r3, #2
 8005496:	d003      	beq.n	80054a0 <USB_HC_Init+0x1a8>
  {
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 8005498:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800549c:	617b      	str	r3, [r7, #20]
 800549e:	e001      	b.n	80054a4 <USB_HC_Init+0x1ac>
  }
  else
  {
    HCcharLowSpeed = 0U;
 80054a0:	2300      	movs	r3, #0
 80054a2:	617b      	str	r3, [r7, #20]
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80054a4:	787b      	ldrb	r3, [r7, #1]
 80054a6:	059b      	lsls	r3, r3, #22
 80054a8:	f003 52fe 	and.w	r2, r3, #532676608	; 0x1fc00000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 80054ac:	78bb      	ldrb	r3, [r7, #2]
 80054ae:	02db      	lsls	r3, r3, #11
 80054b0:	f403 43f0 	and.w	r3, r3, #30720	; 0x7800
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80054b4:	431a      	orrs	r2, r3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 80054b6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 80054ba:	049b      	lsls	r3, r3, #18
 80054bc:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 80054c0:	431a      	orrs	r2, r3
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 80054c2:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 80054c4:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 80054c8:	431a      	orrs	r2, r3
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 80054ca:	69bb      	ldr	r3, [r7, #24]
 80054cc:	431a      	orrs	r2, r3
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80054ce:	78fb      	ldrb	r3, [r7, #3]
 80054d0:	0159      	lsls	r1, r3, #5
 80054d2:	693b      	ldr	r3, [r7, #16]
 80054d4:	440b      	add	r3, r1
 80054d6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80054da:	4619      	mov	r1, r3
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 80054dc:	697b      	ldr	r3, [r7, #20]
 80054de:	4313      	orrs	r3, r2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80054e0:	600b      	str	r3, [r1, #0]

  if (ep_type == EP_TYPE_INTR)
 80054e2:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 80054e6:	2b03      	cmp	r3, #3
 80054e8:	d10f      	bne.n	800550a <USB_HC_Init+0x212>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
 80054ea:	78fb      	ldrb	r3, [r7, #3]
 80054ec:	015a      	lsls	r2, r3, #5
 80054ee:	693b      	ldr	r3, [r7, #16]
 80054f0:	4413      	add	r3, r2
 80054f2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80054f6:	681b      	ldr	r3, [r3, #0]
 80054f8:	78fa      	ldrb	r2, [r7, #3]
 80054fa:	0151      	lsls	r1, r2, #5
 80054fc:	693a      	ldr	r2, [r7, #16]
 80054fe:	440a      	add	r2, r1
 8005500:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005504:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8005508:	6013      	str	r3, [r2, #0]
  }

  return ret;
 800550a:	7ffb      	ldrb	r3, [r7, #31]
}
 800550c:	4618      	mov	r0, r3
 800550e:	3720      	adds	r7, #32
 8005510:	46bd      	mov	sp, r7
 8005512:	bd80      	pop	{r7, pc}

08005514 <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 8005514:	b580      	push	{r7, lr}
 8005516:	b08c      	sub	sp, #48	; 0x30
 8005518:	af02      	add	r7, sp, #8
 800551a:	60f8      	str	r0, [r7, #12]
 800551c:	60b9      	str	r1, [r7, #8]
 800551e:	4613      	mov	r3, r2
 8005520:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005522:	68fb      	ldr	r3, [r7, #12]
 8005524:	623b      	str	r3, [r7, #32]
  uint32_t ch_num = (uint32_t)hc->ch_num;
 8005526:	68bb      	ldr	r3, [r7, #8]
 8005528:	785b      	ldrb	r3, [r3, #1]
 800552a:	61fb      	str	r3, [r7, #28]
  __IO uint32_t tmpreg;
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;
 800552c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8005530:	837b      	strh	r3, [r7, #26]

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
 8005532:	68fb      	ldr	r3, [r7, #12]
 8005534:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005536:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800553a:	2b00      	cmp	r3, #0
 800553c:	d02d      	beq.n	800559a <USB_HC_StartXfer+0x86>
 800553e:	68bb      	ldr	r3, [r7, #8]
 8005540:	791b      	ldrb	r3, [r3, #4]
 8005542:	2b00      	cmp	r3, #0
 8005544:	d129      	bne.n	800559a <USB_HC_StartXfer+0x86>
  {
    /* in DMA mode host Core automatically issues ping  in case of NYET/NAK */
    if ((dma == 1U) && ((hc->ep_type == EP_TYPE_CTRL) || (hc->ep_type == EP_TYPE_BULK)))
 8005546:	79fb      	ldrb	r3, [r7, #7]
 8005548:	2b01      	cmp	r3, #1
 800554a:	d117      	bne.n	800557c <USB_HC_StartXfer+0x68>
 800554c:	68bb      	ldr	r3, [r7, #8]
 800554e:	79db      	ldrb	r3, [r3, #7]
 8005550:	2b00      	cmp	r3, #0
 8005552:	d003      	beq.n	800555c <USB_HC_StartXfer+0x48>
 8005554:	68bb      	ldr	r3, [r7, #8]
 8005556:	79db      	ldrb	r3, [r3, #7]
 8005558:	2b02      	cmp	r3, #2
 800555a:	d10f      	bne.n	800557c <USB_HC_StartXfer+0x68>
    {
      USBx_HC((uint32_t)ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET |
 800555c:	69fb      	ldr	r3, [r7, #28]
 800555e:	015a      	lsls	r2, r3, #5
 8005560:	6a3b      	ldr	r3, [r7, #32]
 8005562:	4413      	add	r3, r2
 8005564:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005568:	68db      	ldr	r3, [r3, #12]
 800556a:	69fa      	ldr	r2, [r7, #28]
 800556c:	0151      	lsls	r1, r2, #5
 800556e:	6a3a      	ldr	r2, [r7, #32]
 8005570:	440a      	add	r2, r1
 8005572:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005576:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800557a:	60d3      	str	r3, [r2, #12]
                                               USB_OTG_HCINTMSK_ACKM |
                                               USB_OTG_HCINTMSK_NAKM);
    }

    if ((dma == 0U) && (hc->do_ping == 1U))
 800557c:	79fb      	ldrb	r3, [r7, #7]
 800557e:	2b00      	cmp	r3, #0
 8005580:	d10b      	bne.n	800559a <USB_HC_StartXfer+0x86>
 8005582:	68bb      	ldr	r3, [r7, #8]
 8005584:	795b      	ldrb	r3, [r3, #5]
 8005586:	2b01      	cmp	r3, #1
 8005588:	d107      	bne.n	800559a <USB_HC_StartXfer+0x86>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
 800558a:	68bb      	ldr	r3, [r7, #8]
 800558c:	785b      	ldrb	r3, [r3, #1]
 800558e:	4619      	mov	r1, r3
 8005590:	68f8      	ldr	r0, [r7, #12]
 8005592:	f000 fa2f 	bl	80059f4 <USB_DoPing>
      return HAL_OK;
 8005596:	2300      	movs	r3, #0
 8005598:	e0f8      	b.n	800578c <USB_HC_StartXfer+0x278>
    }

  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
 800559a:	68bb      	ldr	r3, [r7, #8]
 800559c:	695b      	ldr	r3, [r3, #20]
 800559e:	2b00      	cmp	r3, #0
 80055a0:	d018      	beq.n	80055d4 <USB_HC_StartXfer+0xc0>
  {
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 80055a2:	68bb      	ldr	r3, [r7, #8]
 80055a4:	695b      	ldr	r3, [r3, #20]
 80055a6:	68ba      	ldr	r2, [r7, #8]
 80055a8:	8912      	ldrh	r2, [r2, #8]
 80055aa:	4413      	add	r3, r2
 80055ac:	3b01      	subs	r3, #1
 80055ae:	68ba      	ldr	r2, [r7, #8]
 80055b0:	8912      	ldrh	r2, [r2, #8]
 80055b2:	fbb3 f3f2 	udiv	r3, r3, r2
 80055b6:	84fb      	strh	r3, [r7, #38]	; 0x26

    if (num_packets > max_hc_pkt_count)
 80055b8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80055ba:	8b7b      	ldrh	r3, [r7, #26]
 80055bc:	429a      	cmp	r2, r3
 80055be:	d90b      	bls.n	80055d8 <USB_HC_StartXfer+0xc4>
    {
      num_packets = max_hc_pkt_count;
 80055c0:	8b7b      	ldrh	r3, [r7, #26]
 80055c2:	84fb      	strh	r3, [r7, #38]	; 0x26
      hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80055c4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80055c6:	68ba      	ldr	r2, [r7, #8]
 80055c8:	8912      	ldrh	r2, [r2, #8]
 80055ca:	fb02 f203 	mul.w	r2, r2, r3
 80055ce:	68bb      	ldr	r3, [r7, #8]
 80055d0:	611a      	str	r2, [r3, #16]
 80055d2:	e001      	b.n	80055d8 <USB_HC_StartXfer+0xc4>
    }
  }
  else
  {
    num_packets = 1U;
 80055d4:	2301      	movs	r3, #1
 80055d6:	84fb      	strh	r3, [r7, #38]	; 0x26

  /*
   * For IN channel HCTSIZ.XferSize is expected to be an integer multiple of
   * max_packet size.
   */
  if (hc->ep_is_in != 0U)
 80055d8:	68bb      	ldr	r3, [r7, #8]
 80055da:	78db      	ldrb	r3, [r3, #3]
 80055dc:	2b00      	cmp	r3, #0
 80055de:	d007      	beq.n	80055f0 <USB_HC_StartXfer+0xdc>
  {
    hc->XferSize = (uint32_t)num_packets * hc->max_packet;
 80055e0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80055e2:	68ba      	ldr	r2, [r7, #8]
 80055e4:	8912      	ldrh	r2, [r2, #8]
 80055e6:	fb02 f203 	mul.w	r2, r2, r3
 80055ea:	68bb      	ldr	r3, [r7, #8]
 80055ec:	611a      	str	r2, [r3, #16]
 80055ee:	e003      	b.n	80055f8 <USB_HC_StartXfer+0xe4>
  }
  else
  {
    hc->XferSize = hc->xfer_len;
 80055f0:	68bb      	ldr	r3, [r7, #8]
 80055f2:	695a      	ldr	r2, [r3, #20]
 80055f4:	68bb      	ldr	r3, [r7, #8]
 80055f6:	611a      	str	r2, [r3, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 80055f8:	68bb      	ldr	r3, [r7, #8]
 80055fa:	691b      	ldr	r3, [r3, #16]
 80055fc:	f3c3 0212 	ubfx	r2, r3, #0, #19
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005600:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8005602:	04d9      	lsls	r1, r3, #19
 8005604:	4b63      	ldr	r3, [pc, #396]	; (8005794 <USB_HC_StartXfer+0x280>)
 8005606:	400b      	ands	r3, r1
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8005608:	431a      	orrs	r2, r3
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 800560a:	68bb      	ldr	r3, [r7, #8]
 800560c:	7a9b      	ldrb	r3, [r3, #10]
 800560e:	075b      	lsls	r3, r3, #29
 8005610:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8005614:	69f9      	ldr	r1, [r7, #28]
 8005616:	0148      	lsls	r0, r1, #5
 8005618:	6a39      	ldr	r1, [r7, #32]
 800561a:	4401      	add	r1, r0
 800561c:	f501 61a0 	add.w	r1, r1, #1280	; 0x500
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005620:	4313      	orrs	r3, r2
  USBx_HC(ch_num)->HCTSIZ = (hc->XferSize & USB_OTG_HCTSIZ_XFRSIZ) |
 8005622:	610b      	str	r3, [r1, #16]

  if (dma != 0U)
 8005624:	79fb      	ldrb	r3, [r7, #7]
 8005626:	2b00      	cmp	r3, #0
 8005628:	d009      	beq.n	800563e <USB_HC_StartXfer+0x12a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 800562a:	68bb      	ldr	r3, [r7, #8]
 800562c:	68d9      	ldr	r1, [r3, #12]
 800562e:	69fb      	ldr	r3, [r7, #28]
 8005630:	015a      	lsls	r2, r3, #5
 8005632:	6a3b      	ldr	r3, [r7, #32]
 8005634:	4413      	add	r3, r2
 8005636:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800563a:	460a      	mov	r2, r1
 800563c:	615a      	str	r2, [r3, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 800563e:	6a3b      	ldr	r3, [r7, #32]
 8005640:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005644:	689b      	ldr	r3, [r3, #8]
 8005646:	f003 0301 	and.w	r3, r3, #1
 800564a:	2b00      	cmp	r3, #0
 800564c:	bf0c      	ite	eq
 800564e:	2301      	moveq	r3, #1
 8005650:	2300      	movne	r3, #0
 8005652:	b2db      	uxtb	r3, r3
 8005654:	767b      	strb	r3, [r7, #25]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 8005656:	69fb      	ldr	r3, [r7, #28]
 8005658:	015a      	lsls	r2, r3, #5
 800565a:	6a3b      	ldr	r3, [r7, #32]
 800565c:	4413      	add	r3, r2
 800565e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005662:	681b      	ldr	r3, [r3, #0]
 8005664:	69fa      	ldr	r2, [r7, #28]
 8005666:	0151      	lsls	r1, r2, #5
 8005668:	6a3a      	ldr	r2, [r7, #32]
 800566a:	440a      	add	r2, r1
 800566c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005670:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8005674:	6013      	str	r3, [r2, #0]
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 8005676:	69fb      	ldr	r3, [r7, #28]
 8005678:	015a      	lsls	r2, r3, #5
 800567a:	6a3b      	ldr	r3, [r7, #32]
 800567c:	4413      	add	r3, r2
 800567e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005682:	681a      	ldr	r2, [r3, #0]
 8005684:	7e7b      	ldrb	r3, [r7, #25]
 8005686:	075b      	lsls	r3, r3, #29
 8005688:	69f9      	ldr	r1, [r7, #28]
 800568a:	0148      	lsls	r0, r1, #5
 800568c:	6a39      	ldr	r1, [r7, #32]
 800568e:	4401      	add	r1, r0
 8005690:	f501 61a0 	add.w	r1, r1, #1280	; 0x500
 8005694:	4313      	orrs	r3, r2
 8005696:	600b      	str	r3, [r1, #0]

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 8005698:	69fb      	ldr	r3, [r7, #28]
 800569a:	015a      	lsls	r2, r3, #5
 800569c:	6a3b      	ldr	r3, [r7, #32]
 800569e:	4413      	add	r3, r2
 80056a0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80056a4:	681b      	ldr	r3, [r3, #0]
 80056a6:	613b      	str	r3, [r7, #16]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80056a8:	693b      	ldr	r3, [r7, #16]
 80056aa:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80056ae:	613b      	str	r3, [r7, #16]

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 80056b0:	68bb      	ldr	r3, [r7, #8]
 80056b2:	78db      	ldrb	r3, [r3, #3]
 80056b4:	2b00      	cmp	r3, #0
 80056b6:	d004      	beq.n	80056c2 <USB_HC_StartXfer+0x1ae>
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 80056b8:	693b      	ldr	r3, [r7, #16]
 80056ba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80056be:	613b      	str	r3, [r7, #16]
 80056c0:	e003      	b.n	80056ca <USB_HC_StartXfer+0x1b6>
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 80056c2:	693b      	ldr	r3, [r7, #16]
 80056c4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80056c8:	613b      	str	r3, [r7, #16]
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 80056ca:	693b      	ldr	r3, [r7, #16]
 80056cc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80056d0:	613b      	str	r3, [r7, #16]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 80056d2:	69fb      	ldr	r3, [r7, #28]
 80056d4:	015a      	lsls	r2, r3, #5
 80056d6:	6a3b      	ldr	r3, [r7, #32]
 80056d8:	4413      	add	r3, r2
 80056da:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80056de:	461a      	mov	r2, r3
 80056e0:	693b      	ldr	r3, [r7, #16]
 80056e2:	6013      	str	r3, [r2, #0]

  if (dma != 0U) /* dma mode */
 80056e4:	79fb      	ldrb	r3, [r7, #7]
 80056e6:	2b00      	cmp	r3, #0
 80056e8:	d001      	beq.n	80056ee <USB_HC_StartXfer+0x1da>
  {
    return HAL_OK;
 80056ea:	2300      	movs	r3, #0
 80056ec:	e04e      	b.n	800578c <USB_HC_StartXfer+0x278>
  }

  if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
 80056ee:	68bb      	ldr	r3, [r7, #8]
 80056f0:	78db      	ldrb	r3, [r3, #3]
 80056f2:	2b00      	cmp	r3, #0
 80056f4:	d149      	bne.n	800578a <USB_HC_StartXfer+0x276>
 80056f6:	68bb      	ldr	r3, [r7, #8]
 80056f8:	695b      	ldr	r3, [r3, #20]
 80056fa:	2b00      	cmp	r3, #0
 80056fc:	d045      	beq.n	800578a <USB_HC_StartXfer+0x276>
  {
    switch (hc->ep_type)
 80056fe:	68bb      	ldr	r3, [r7, #8]
 8005700:	79db      	ldrb	r3, [r3, #7]
 8005702:	2b03      	cmp	r3, #3
 8005704:	d830      	bhi.n	8005768 <USB_HC_StartXfer+0x254>
 8005706:	a201      	add	r2, pc, #4	; (adr r2, 800570c <USB_HC_StartXfer+0x1f8>)
 8005708:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800570c:	0800571d 	.word	0x0800571d
 8005710:	08005741 	.word	0x08005741
 8005714:	0800571d 	.word	0x0800571d
 8005718:	08005741 	.word	0x08005741
    {
      /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:

        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 800571c:	68bb      	ldr	r3, [r7, #8]
 800571e:	695b      	ldr	r3, [r3, #20]
 8005720:	3303      	adds	r3, #3
 8005722:	089b      	lsrs	r3, r3, #2
 8005724:	82fb      	strh	r3, [r7, #22]

        /* check if there is enough space in FIFO space */
        if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8005726:	8afa      	ldrh	r2, [r7, #22]
 8005728:	68fb      	ldr	r3, [r7, #12]
 800572a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800572c:	b29b      	uxth	r3, r3
 800572e:	429a      	cmp	r2, r3
 8005730:	d91c      	bls.n	800576c <USB_HC_StartXfer+0x258>
        {
          /* need to process data in nptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8005732:	68fb      	ldr	r3, [r7, #12]
 8005734:	699b      	ldr	r3, [r3, #24]
 8005736:	f043 0220 	orr.w	r2, r3, #32
 800573a:	68fb      	ldr	r3, [r7, #12]
 800573c:	619a      	str	r2, [r3, #24]
        }
        break;
 800573e:	e015      	b.n	800576c <USB_HC_StartXfer+0x258>

      /* Periodic transfer */
      case EP_TYPE_INTR:
      case EP_TYPE_ISOC:
        len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8005740:	68bb      	ldr	r3, [r7, #8]
 8005742:	695b      	ldr	r3, [r3, #20]
 8005744:	3303      	adds	r3, #3
 8005746:	089b      	lsrs	r3, r3, #2
 8005748:	82fb      	strh	r3, [r7, #22]
        /* check if there is enough space in FIFO space */
        if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 800574a:	8afa      	ldrh	r2, [r7, #22]
 800574c:	6a3b      	ldr	r3, [r7, #32]
 800574e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005752:	691b      	ldr	r3, [r3, #16]
 8005754:	b29b      	uxth	r3, r3
 8005756:	429a      	cmp	r2, r3
 8005758:	d90a      	bls.n	8005770 <USB_HC_StartXfer+0x25c>
        {
          /* need to process data in ptxfempty interrupt */
          USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 800575a:	68fb      	ldr	r3, [r7, #12]
 800575c:	699b      	ldr	r3, [r3, #24]
 800575e:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 8005762:	68fb      	ldr	r3, [r7, #12]
 8005764:	619a      	str	r2, [r3, #24]
        }
        break;
 8005766:	e003      	b.n	8005770 <USB_HC_StartXfer+0x25c>

      default:
        break;
 8005768:	bf00      	nop
 800576a:	e002      	b.n	8005772 <USB_HC_StartXfer+0x25e>
        break;
 800576c:	bf00      	nop
 800576e:	e000      	b.n	8005772 <USB_HC_StartXfer+0x25e>
        break;
 8005770:	bf00      	nop
    }

    /* Write packet into the Tx FIFO. */
    (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 8005772:	68bb      	ldr	r3, [r7, #8]
 8005774:	68d9      	ldr	r1, [r3, #12]
 8005776:	68bb      	ldr	r3, [r7, #8]
 8005778:	785a      	ldrb	r2, [r3, #1]
 800577a:	68bb      	ldr	r3, [r7, #8]
 800577c:	695b      	ldr	r3, [r3, #20]
 800577e:	b29b      	uxth	r3, r3
 8005780:	2000      	movs	r0, #0
 8005782:	9000      	str	r0, [sp, #0]
 8005784:	68f8      	ldr	r0, [r7, #12]
 8005786:	f7ff fb53 	bl	8004e30 <USB_WritePacket>
  }

  return HAL_OK;
 800578a:	2300      	movs	r3, #0
}
 800578c:	4618      	mov	r0, r3
 800578e:	3728      	adds	r7, #40	; 0x28
 8005790:	46bd      	mov	sp, r7
 8005792:	bd80      	pop	{r7, pc}
 8005794:	1ff80000 	.word	0x1ff80000

08005798 <USB_HC_ReadInterrupt>:
  * @brief Read all host channel interrupts status
  * @param  USBx  Selected device
  * @retval HAL state
  */
uint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
 8005798:	b480      	push	{r7}
 800579a:	b085      	sub	sp, #20
 800579c:	af00      	add	r7, sp, #0
 800579e:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80057a0:	687b      	ldr	r3, [r7, #4]
 80057a2:	60fb      	str	r3, [r7, #12]

  return ((USBx_HOST->HAINT) & 0xFFFFU);
 80057a4:	68fb      	ldr	r3, [r7, #12]
 80057a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80057aa:	695b      	ldr	r3, [r3, #20]
 80057ac:	b29b      	uxth	r3, r3
}
 80057ae:	4618      	mov	r0, r3
 80057b0:	3714      	adds	r7, #20
 80057b2:	46bd      	mov	sp, r7
 80057b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057b8:	4770      	bx	lr

080057ba <USB_HC_Halt>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
{
 80057ba:	b480      	push	{r7}
 80057bc:	b089      	sub	sp, #36	; 0x24
 80057be:	af00      	add	r7, sp, #0
 80057c0:	6078      	str	r0, [r7, #4]
 80057c2:	460b      	mov	r3, r1
 80057c4:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80057c6:	687b      	ldr	r3, [r7, #4]
 80057c8:	61bb      	str	r3, [r7, #24]
  uint32_t hcnum = (uint32_t)hc_num;
 80057ca:	78fb      	ldrb	r3, [r7, #3]
 80057cc:	617b      	str	r3, [r7, #20]
  uint32_t count = 0U;
 80057ce:	2300      	movs	r3, #0
 80057d0:	61fb      	str	r3, [r7, #28]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 80057d2:	697b      	ldr	r3, [r7, #20]
 80057d4:	015a      	lsls	r2, r3, #5
 80057d6:	69bb      	ldr	r3, [r7, #24]
 80057d8:	4413      	add	r3, r2
 80057da:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80057de:	681b      	ldr	r3, [r3, #0]
 80057e0:	0c9b      	lsrs	r3, r3, #18
 80057e2:	f003 0303 	and.w	r3, r3, #3
 80057e6:	613b      	str	r3, [r7, #16]
  uint32_t ChannelEna = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) >> 31;
 80057e8:	697b      	ldr	r3, [r7, #20]
 80057ea:	015a      	lsls	r2, r3, #5
 80057ec:	69bb      	ldr	r3, [r7, #24]
 80057ee:	4413      	add	r3, r2
 80057f0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80057f4:	681b      	ldr	r3, [r3, #0]
 80057f6:	0fdb      	lsrs	r3, r3, #31
 80057f8:	f003 0301 	and.w	r3, r3, #1
 80057fc:	60fb      	str	r3, [r7, #12]

  if (((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == USB_OTG_GAHBCFG_DMAEN) &&
 80057fe:	687b      	ldr	r3, [r7, #4]
 8005800:	689b      	ldr	r3, [r3, #8]
 8005802:	f003 0320 	and.w	r3, r3, #32
 8005806:	2b20      	cmp	r3, #32
 8005808:	d104      	bne.n	8005814 <USB_HC_Halt+0x5a>
 800580a:	68fb      	ldr	r3, [r7, #12]
 800580c:	2b00      	cmp	r3, #0
 800580e:	d101      	bne.n	8005814 <USB_HC_Halt+0x5a>
      (ChannelEna == 0U))
  {
    return HAL_OK;
 8005810:	2300      	movs	r3, #0
 8005812:	e0e8      	b.n	80059e6 <USB_HC_Halt+0x22c>
  }

  /* Check for space in the request queue to issue the halt. */
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8005814:	693b      	ldr	r3, [r7, #16]
 8005816:	2b00      	cmp	r3, #0
 8005818:	d002      	beq.n	8005820 <USB_HC_Halt+0x66>
 800581a:	693b      	ldr	r3, [r7, #16]
 800581c:	2b02      	cmp	r3, #2
 800581e:	d173      	bne.n	8005908 <USB_HC_Halt+0x14e>
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8005820:	697b      	ldr	r3, [r7, #20]
 8005822:	015a      	lsls	r2, r3, #5
 8005824:	69bb      	ldr	r3, [r7, #24]
 8005826:	4413      	add	r3, r2
 8005828:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800582c:	681b      	ldr	r3, [r3, #0]
 800582e:	697a      	ldr	r2, [r7, #20]
 8005830:	0151      	lsls	r1, r2, #5
 8005832:	69ba      	ldr	r2, [r7, #24]
 8005834:	440a      	add	r2, r1
 8005836:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800583a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800583e:	6013      	str	r3, [r2, #0]

    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8005840:	687b      	ldr	r3, [r7, #4]
 8005842:	689b      	ldr	r3, [r3, #8]
 8005844:	f003 0320 	and.w	r3, r3, #32
 8005848:	2b00      	cmp	r3, #0
 800584a:	f040 80cb 	bne.w	80059e4 <USB_HC_Halt+0x22a>
    {
      if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800584e:	687b      	ldr	r3, [r7, #4]
 8005850:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005852:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8005856:	2b00      	cmp	r3, #0
 8005858:	d143      	bne.n	80058e2 <USB_HC_Halt+0x128>
      {
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 800585a:	697b      	ldr	r3, [r7, #20]
 800585c:	015a      	lsls	r2, r3, #5
 800585e:	69bb      	ldr	r3, [r7, #24]
 8005860:	4413      	add	r3, r2
 8005862:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005866:	681b      	ldr	r3, [r3, #0]
 8005868:	697a      	ldr	r2, [r7, #20]
 800586a:	0151      	lsls	r1, r2, #5
 800586c:	69ba      	ldr	r2, [r7, #24]
 800586e:	440a      	add	r2, r1
 8005870:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005874:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8005878:	6013      	str	r3, [r2, #0]
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800587a:	697b      	ldr	r3, [r7, #20]
 800587c:	015a      	lsls	r2, r3, #5
 800587e:	69bb      	ldr	r3, [r7, #24]
 8005880:	4413      	add	r3, r2
 8005882:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005886:	681b      	ldr	r3, [r3, #0]
 8005888:	697a      	ldr	r2, [r7, #20]
 800588a:	0151      	lsls	r1, r2, #5
 800588c:	69ba      	ldr	r2, [r7, #24]
 800588e:	440a      	add	r2, r1
 8005890:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005894:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005898:	6013      	str	r3, [r2, #0]
        USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 800589a:	697b      	ldr	r3, [r7, #20]
 800589c:	015a      	lsls	r2, r3, #5
 800589e:	69bb      	ldr	r3, [r7, #24]
 80058a0:	4413      	add	r3, r2
 80058a2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80058a6:	681b      	ldr	r3, [r3, #0]
 80058a8:	697a      	ldr	r2, [r7, #20]
 80058aa:	0151      	lsls	r1, r2, #5
 80058ac:	69ba      	ldr	r2, [r7, #24]
 80058ae:	440a      	add	r2, r1
 80058b0:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80058b4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80058b8:	6013      	str	r3, [r2, #0]
        do
        {
          if (++count > 1000U)
 80058ba:	69fb      	ldr	r3, [r7, #28]
 80058bc:	3301      	adds	r3, #1
 80058be:	61fb      	str	r3, [r7, #28]
 80058c0:	69fb      	ldr	r3, [r7, #28]
 80058c2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80058c6:	d81d      	bhi.n	8005904 <USB_HC_Halt+0x14a>
          {
            break;
          }
        } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 80058c8:	697b      	ldr	r3, [r7, #20]
 80058ca:	015a      	lsls	r2, r3, #5
 80058cc:	69bb      	ldr	r3, [r7, #24]
 80058ce:	4413      	add	r3, r2
 80058d0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80058d4:	681b      	ldr	r3, [r3, #0]
 80058d6:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80058da:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80058de:	d0ec      	beq.n	80058ba <USB_HC_Halt+0x100>
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 80058e0:	e080      	b.n	80059e4 <USB_HC_Halt+0x22a>
      }
      else
      {
        USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80058e2:	697b      	ldr	r3, [r7, #20]
 80058e4:	015a      	lsls	r2, r3, #5
 80058e6:	69bb      	ldr	r3, [r7, #24]
 80058e8:	4413      	add	r3, r2
 80058ea:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80058ee:	681b      	ldr	r3, [r3, #0]
 80058f0:	697a      	ldr	r2, [r7, #20]
 80058f2:	0151      	lsls	r1, r2, #5
 80058f4:	69ba      	ldr	r2, [r7, #24]
 80058f6:	440a      	add	r2, r1
 80058f8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80058fc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005900:	6013      	str	r3, [r2, #0]
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8005902:	e06f      	b.n	80059e4 <USB_HC_Halt+0x22a>
            break;
 8005904:	bf00      	nop
    if ((USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) == 0U)
 8005906:	e06d      	b.n	80059e4 <USB_HC_Halt+0x22a>
      }
    }
  }
  else
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8005908:	697b      	ldr	r3, [r7, #20]
 800590a:	015a      	lsls	r2, r3, #5
 800590c:	69bb      	ldr	r3, [r7, #24]
 800590e:	4413      	add	r3, r2
 8005910:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005914:	681b      	ldr	r3, [r3, #0]
 8005916:	697a      	ldr	r2, [r7, #20]
 8005918:	0151      	lsls	r1, r2, #5
 800591a:	69ba      	ldr	r2, [r7, #24]
 800591c:	440a      	add	r2, r1
 800591e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005922:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8005926:	6013      	str	r3, [r2, #0]

    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8005928:	69bb      	ldr	r3, [r7, #24]
 800592a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800592e:	691b      	ldr	r3, [r3, #16]
 8005930:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8005934:	2b00      	cmp	r3, #0
 8005936:	d143      	bne.n	80059c0 <USB_HC_Halt+0x206>
    {
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8005938:	697b      	ldr	r3, [r7, #20]
 800593a:	015a      	lsls	r2, r3, #5
 800593c:	69bb      	ldr	r3, [r7, #24]
 800593e:	4413      	add	r3, r2
 8005940:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005944:	681b      	ldr	r3, [r3, #0]
 8005946:	697a      	ldr	r2, [r7, #20]
 8005948:	0151      	lsls	r1, r2, #5
 800594a:	69ba      	ldr	r2, [r7, #24]
 800594c:	440a      	add	r2, r1
 800594e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005952:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8005956:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8005958:	697b      	ldr	r3, [r7, #20]
 800595a:	015a      	lsls	r2, r3, #5
 800595c:	69bb      	ldr	r3, [r7, #24]
 800595e:	4413      	add	r3, r2
 8005960:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005964:	681b      	ldr	r3, [r3, #0]
 8005966:	697a      	ldr	r2, [r7, #20]
 8005968:	0151      	lsls	r1, r2, #5
 800596a:	69ba      	ldr	r2, [r7, #24]
 800596c:	440a      	add	r2, r1
 800596e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005972:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005976:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 8005978:	697b      	ldr	r3, [r7, #20]
 800597a:	015a      	lsls	r2, r3, #5
 800597c:	69bb      	ldr	r3, [r7, #24]
 800597e:	4413      	add	r3, r2
 8005980:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005984:	681b      	ldr	r3, [r3, #0]
 8005986:	697a      	ldr	r2, [r7, #20]
 8005988:	0151      	lsls	r1, r2, #5
 800598a:	69ba      	ldr	r2, [r7, #24]
 800598c:	440a      	add	r2, r1
 800598e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005992:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005996:	6013      	str	r3, [r2, #0]
      do
      {
        if (++count > 1000U)
 8005998:	69fb      	ldr	r3, [r7, #28]
 800599a:	3301      	adds	r3, #1
 800599c:	61fb      	str	r3, [r7, #28]
 800599e:	69fb      	ldr	r3, [r7, #28]
 80059a0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80059a4:	d81d      	bhi.n	80059e2 <USB_HC_Halt+0x228>
        {
          break;
        }
      } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 80059a6:	697b      	ldr	r3, [r7, #20]
 80059a8:	015a      	lsls	r2, r3, #5
 80059aa:	69bb      	ldr	r3, [r7, #24]
 80059ac:	4413      	add	r3, r2
 80059ae:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80059b2:	681b      	ldr	r3, [r3, #0]
 80059b4:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80059b8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80059bc:	d0ec      	beq.n	8005998 <USB_HC_Halt+0x1de>
 80059be:	e011      	b.n	80059e4 <USB_HC_Halt+0x22a>
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80059c0:	697b      	ldr	r3, [r7, #20]
 80059c2:	015a      	lsls	r2, r3, #5
 80059c4:	69bb      	ldr	r3, [r7, #24]
 80059c6:	4413      	add	r3, r2
 80059c8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80059cc:	681b      	ldr	r3, [r3, #0]
 80059ce:	697a      	ldr	r2, [r7, #20]
 80059d0:	0151      	lsls	r1, r2, #5
 80059d2:	69ba      	ldr	r2, [r7, #24]
 80059d4:	440a      	add	r2, r1
 80059d6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80059da:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80059de:	6013      	str	r3, [r2, #0]
 80059e0:	e000      	b.n	80059e4 <USB_HC_Halt+0x22a>
          break;
 80059e2:	bf00      	nop
    }
  }

  return HAL_OK;
 80059e4:	2300      	movs	r3, #0
}
 80059e6:	4618      	mov	r0, r3
 80059e8:	3724      	adds	r7, #36	; 0x24
 80059ea:	46bd      	mov	sp, r7
 80059ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059f0:	4770      	bx	lr
	...

080059f4 <USB_DoPing>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
{
 80059f4:	b480      	push	{r7}
 80059f6:	b087      	sub	sp, #28
 80059f8:	af00      	add	r7, sp, #0
 80059fa:	6078      	str	r0, [r7, #4]
 80059fc:	460b      	mov	r3, r1
 80059fe:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a00:	687b      	ldr	r3, [r7, #4]
 8005a02:	617b      	str	r3, [r7, #20]
  uint32_t chnum = (uint32_t)ch_num;
 8005a04:	78fb      	ldrb	r3, [r7, #3]
 8005a06:	613b      	str	r3, [r7, #16]
  uint32_t num_packets = 1U;
 8005a08:	2301      	movs	r3, #1
 8005a0a:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8005a0c:	68fb      	ldr	r3, [r7, #12]
 8005a0e:	04da      	lsls	r2, r3, #19
 8005a10:	4b15      	ldr	r3, [pc, #84]	; (8005a68 <USB_DoPing+0x74>)
 8005a12:	4013      	ands	r3, r2
 8005a14:	693a      	ldr	r2, [r7, #16]
 8005a16:	0151      	lsls	r1, r2, #5
 8005a18:	697a      	ldr	r2, [r7, #20]
 8005a1a:	440a      	add	r2, r1
 8005a1c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8005a20:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005a24:	6113      	str	r3, [r2, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 8005a26:	693b      	ldr	r3, [r7, #16]
 8005a28:	015a      	lsls	r2, r3, #5
 8005a2a:	697b      	ldr	r3, [r7, #20]
 8005a2c:	4413      	add	r3, r2
 8005a2e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005a32:	681b      	ldr	r3, [r3, #0]
 8005a34:	60bb      	str	r3, [r7, #8]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8005a36:	68bb      	ldr	r3, [r7, #8]
 8005a38:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8005a3c:	60bb      	str	r3, [r7, #8]
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8005a3e:	68bb      	ldr	r3, [r7, #8]
 8005a40:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005a44:	60bb      	str	r3, [r7, #8]
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8005a46:	693b      	ldr	r3, [r7, #16]
 8005a48:	015a      	lsls	r2, r3, #5
 8005a4a:	697b      	ldr	r3, [r7, #20]
 8005a4c:	4413      	add	r3, r2
 8005a4e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005a52:	461a      	mov	r2, r3
 8005a54:	68bb      	ldr	r3, [r7, #8]
 8005a56:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 8005a58:	2300      	movs	r3, #0
}
 8005a5a:	4618      	mov	r0, r3
 8005a5c:	371c      	adds	r7, #28
 8005a5e:	46bd      	mov	sp, r7
 8005a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a64:	4770      	bx	lr
 8005a66:	bf00      	nop
 8005a68:	1ff80000 	.word	0x1ff80000

08005a6c <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 8005a6c:	b580      	push	{r7, lr}
 8005a6e:	b086      	sub	sp, #24
 8005a70:	af00      	add	r7, sp, #0
 8005a72:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a74:	687b      	ldr	r3, [r7, #4]
 8005a76:	60fb      	str	r3, [r7, #12]
  uint32_t count = 0U;
 8005a78:	2300      	movs	r3, #0
 8005a7a:	617b      	str	r3, [r7, #20]
  uint32_t value;
  uint32_t i;

  (void)USB_DisableGlobalInt(USBx);
 8005a7c:	6878      	ldr	r0, [r7, #4]
 8005a7e:	f7ff f935 	bl	8004cec <USB_DisableGlobalInt>

  /* Flush FIFO */
  (void)USB_FlushTxFifo(USBx, 0x10U);
 8005a82:	2110      	movs	r1, #16
 8005a84:	6878      	ldr	r0, [r7, #4]
 8005a86:	f7ff f98f 	bl	8004da8 <USB_FlushTxFifo>
  (void)USB_FlushRxFifo(USBx);
 8005a8a:	6878      	ldr	r0, [r7, #4]
 8005a8c:	f7ff f9b0 	bl	8004df0 <USB_FlushRxFifo>

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
 8005a90:	2300      	movs	r3, #0
 8005a92:	613b      	str	r3, [r7, #16]
 8005a94:	e01f      	b.n	8005ad6 <USB_StopHost+0x6a>
  {
    value = USBx_HC(i)->HCCHAR;
 8005a96:	693b      	ldr	r3, [r7, #16]
 8005a98:	015a      	lsls	r2, r3, #5
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	4413      	add	r3, r2
 8005a9e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005aa2:	681b      	ldr	r3, [r3, #0]
 8005aa4:	60bb      	str	r3, [r7, #8]
    value |=  USB_OTG_HCCHAR_CHDIS;
 8005aa6:	68bb      	ldr	r3, [r7, #8]
 8005aa8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8005aac:	60bb      	str	r3, [r7, #8]
    value &= ~USB_OTG_HCCHAR_CHENA;
 8005aae:	68bb      	ldr	r3, [r7, #8]
 8005ab0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8005ab4:	60bb      	str	r3, [r7, #8]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8005ab6:	68bb      	ldr	r3, [r7, #8]
 8005ab8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005abc:	60bb      	str	r3, [r7, #8]
    USBx_HC(i)->HCCHAR = value;
 8005abe:	693b      	ldr	r3, [r7, #16]
 8005ac0:	015a      	lsls	r2, r3, #5
 8005ac2:	68fb      	ldr	r3, [r7, #12]
 8005ac4:	4413      	add	r3, r2
 8005ac6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005aca:	461a      	mov	r2, r3
 8005acc:	68bb      	ldr	r3, [r7, #8]
 8005ace:	6013      	str	r3, [r2, #0]
  for (i = 0U; i <= 15U; i++)
 8005ad0:	693b      	ldr	r3, [r7, #16]
 8005ad2:	3301      	adds	r3, #1
 8005ad4:	613b      	str	r3, [r7, #16]
 8005ad6:	693b      	ldr	r3, [r7, #16]
 8005ad8:	2b0f      	cmp	r3, #15
 8005ada:	d9dc      	bls.n	8005a96 <USB_StopHost+0x2a>
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
 8005adc:	2300      	movs	r3, #0
 8005ade:	613b      	str	r3, [r7, #16]
 8005ae0:	e034      	b.n	8005b4c <USB_StopHost+0xe0>
  {
    value = USBx_HC(i)->HCCHAR;
 8005ae2:	693b      	ldr	r3, [r7, #16]
 8005ae4:	015a      	lsls	r2, r3, #5
 8005ae6:	68fb      	ldr	r3, [r7, #12]
 8005ae8:	4413      	add	r3, r2
 8005aea:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005aee:	681b      	ldr	r3, [r3, #0]
 8005af0:	60bb      	str	r3, [r7, #8]
    value |= USB_OTG_HCCHAR_CHDIS;
 8005af2:	68bb      	ldr	r3, [r7, #8]
 8005af4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8005af8:	60bb      	str	r3, [r7, #8]
    value |= USB_OTG_HCCHAR_CHENA;
 8005afa:	68bb      	ldr	r3, [r7, #8]
 8005afc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005b00:	60bb      	str	r3, [r7, #8]
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8005b02:	68bb      	ldr	r3, [r7, #8]
 8005b04:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005b08:	60bb      	str	r3, [r7, #8]
    USBx_HC(i)->HCCHAR = value;
 8005b0a:	693b      	ldr	r3, [r7, #16]
 8005b0c:	015a      	lsls	r2, r3, #5
 8005b0e:	68fb      	ldr	r3, [r7, #12]
 8005b10:	4413      	add	r3, r2
 8005b12:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005b16:	461a      	mov	r2, r3
 8005b18:	68bb      	ldr	r3, [r7, #8]
 8005b1a:	6013      	str	r3, [r2, #0]

    do
    {
      if (++count > 1000U)
 8005b1c:	697b      	ldr	r3, [r7, #20]
 8005b1e:	3301      	adds	r3, #1
 8005b20:	617b      	str	r3, [r7, #20]
 8005b22:	697b      	ldr	r3, [r7, #20]
 8005b24:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005b28:	d80c      	bhi.n	8005b44 <USB_StopHost+0xd8>
      {
        break;
      }
    } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8005b2a:	693b      	ldr	r3, [r7, #16]
 8005b2c:	015a      	lsls	r2, r3, #5
 8005b2e:	68fb      	ldr	r3, [r7, #12]
 8005b30:	4413      	add	r3, r2
 8005b32:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8005b36:	681b      	ldr	r3, [r3, #0]
 8005b38:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8005b3c:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8005b40:	d0ec      	beq.n	8005b1c <USB_StopHost+0xb0>
 8005b42:	e000      	b.n	8005b46 <USB_StopHost+0xda>
        break;
 8005b44:	bf00      	nop
  for (i = 0U; i <= 15U; i++)
 8005b46:	693b      	ldr	r3, [r7, #16]
 8005b48:	3301      	adds	r3, #1
 8005b4a:	613b      	str	r3, [r7, #16]
 8005b4c:	693b      	ldr	r3, [r7, #16]
 8005b4e:	2b0f      	cmp	r3, #15
 8005b50:	d9c7      	bls.n	8005ae2 <USB_StopHost+0x76>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 8005b52:	68fb      	ldr	r3, [r7, #12]
 8005b54:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005b58:	461a      	mov	r2, r3
 8005b5a:	f04f 33ff 	mov.w	r3, #4294967295
 8005b5e:	6153      	str	r3, [r2, #20]
  USBx->GINTSTS = 0xFFFFFFFFU;
 8005b60:	687b      	ldr	r3, [r7, #4]
 8005b62:	f04f 32ff 	mov.w	r2, #4294967295
 8005b66:	615a      	str	r2, [r3, #20]

  (void)USB_EnableGlobalInt(USBx);
 8005b68:	6878      	ldr	r0, [r7, #4]
 8005b6a:	f7ff f8ae 	bl	8004cca <USB_EnableGlobalInt>

  return HAL_OK;
 8005b6e:	2300      	movs	r3, #0
}
 8005b70:	4618      	mov	r0, r3
 8005b72:	3718      	adds	r7, #24
 8005b74:	46bd      	mov	sp, r7
 8005b76:	bd80      	pop	{r7, pc}

08005b78 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 8005b78:	b580      	push	{r7, lr}
 8005b7a:	af00      	add	r7, sp, #0
  /*## FatFS: Link the USBH driver ###########################*/
  retUSBH = FATFS_LinkDriver(&USBH_Driver, USBHPath);
 8005b7c:	4904      	ldr	r1, [pc, #16]	; (8005b90 <MX_FATFS_Init+0x18>)
 8005b7e:	4805      	ldr	r0, [pc, #20]	; (8005b94 <MX_FATFS_Init+0x1c>)
 8005b80:	f006 f924 	bl	800bdcc <FATFS_LinkDriver>
 8005b84:	4603      	mov	r3, r0
 8005b86:	461a      	mov	r2, r3
 8005b88:	4b03      	ldr	r3, [pc, #12]	; (8005b98 <MX_FATFS_Init+0x20>)
 8005b8a:	701a      	strb	r2, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
 8005b8c:	bf00      	nop
 8005b8e:	bd80      	pop	{r7, pc}
 8005b90:	20000964 	.word	0x20000964
 8005b94:	08029f04 	.word	0x08029f04
 8005b98:	20000dcc 	.word	0x20000dcc

08005b9c <get_fattime>:
  * @brief  Gets Time from RTC
  * @param  None
  * @retval Time in DWORD
  */
DWORD get_fattime(void)
{
 8005b9c:	b480      	push	{r7}
 8005b9e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN get_fattime */
  return 0;
 8005ba0:	2300      	movs	r3, #0
  /* USER CODE END get_fattime */
}
 8005ba2:	4618      	mov	r0, r3
 8005ba4:	46bd      	mov	sp, r7
 8005ba6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005baa:	4770      	bx	lr

08005bac <USBH_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_initialize(BYTE lun)
{
 8005bac:	b480      	push	{r7}
 8005bae:	b083      	sub	sp, #12
 8005bb0:	af00      	add	r7, sp, #0
 8005bb2:	4603      	mov	r3, r0
 8005bb4:	71fb      	strb	r3, [r7, #7]
  /* CAUTION : USB Host library has to be initialized in the application */

  return RES_OK;
 8005bb6:	2300      	movs	r3, #0
}
 8005bb8:	4618      	mov	r0, r3
 8005bba:	370c      	adds	r7, #12
 8005bbc:	46bd      	mov	sp, r7
 8005bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005bc2:	4770      	bx	lr

08005bc4 <USBH_status>:
  * @brief  Gets Disk Status
  * @param  lun : lun id
  * @retval DSTATUS: Operation status
  */
DSTATUS USBH_status(BYTE lun)
{
 8005bc4:	b580      	push	{r7, lr}
 8005bc6:	b084      	sub	sp, #16
 8005bc8:	af00      	add	r7, sp, #0
 8005bca:	4603      	mov	r3, r0
 8005bcc:	71fb      	strb	r3, [r7, #7]
  DRESULT res = RES_ERROR;
 8005bce:	2301      	movs	r3, #1
 8005bd0:	73fb      	strb	r3, [r7, #15]

  if(USBH_MSC_UnitIsReady(&hUSB_Host, lun))
 8005bd2:	79fb      	ldrb	r3, [r7, #7]
 8005bd4:	4619      	mov	r1, r3
 8005bd6:	4808      	ldr	r0, [pc, #32]	; (8005bf8 <USBH_status+0x34>)
 8005bd8:	f000 fe36 	bl	8006848 <USBH_MSC_UnitIsReady>
 8005bdc:	4603      	mov	r3, r0
 8005bde:	2b00      	cmp	r3, #0
 8005be0:	d002      	beq.n	8005be8 <USBH_status+0x24>
  {
    res = RES_OK;
 8005be2:	2300      	movs	r3, #0
 8005be4:	73fb      	strb	r3, [r7, #15]
 8005be6:	e001      	b.n	8005bec <USBH_status+0x28>
  }
  else
  {
    res = RES_ERROR;
 8005be8:	2301      	movs	r3, #1
 8005bea:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 8005bec:	7bfb      	ldrb	r3, [r7, #15]
}
 8005bee:	4618      	mov	r0, r3
 8005bf0:	3710      	adds	r7, #16
 8005bf2:	46bd      	mov	sp, r7
 8005bf4:	bd80      	pop	{r7, pc}
 8005bf6:	bf00      	nop
 8005bf8:	20000dd0 	.word	0x20000dd0

08005bfc <USBH_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT USBH_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8005bfc:	b580      	push	{r7, lr}
 8005bfe:	b094      	sub	sp, #80	; 0x50
 8005c00:	af02      	add	r7, sp, #8
 8005c02:	60b9      	str	r1, [r7, #8]
 8005c04:	607a      	str	r2, [r7, #4]
 8005c06:	603b      	str	r3, [r7, #0]
 8005c08:	4603      	mov	r3, r0
 8005c0a:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 8005c0c:	2301      	movs	r3, #1
 8005c0e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Read(&hUSB_Host, lun, sector, buff, count) == USBH_OK)
 8005c12:	7bf9      	ldrb	r1, [r7, #15]
 8005c14:	683b      	ldr	r3, [r7, #0]
 8005c16:	9300      	str	r3, [sp, #0]
 8005c18:	68bb      	ldr	r3, [r7, #8]
 8005c1a:	687a      	ldr	r2, [r7, #4]
 8005c1c:	4813      	ldr	r0, [pc, #76]	; (8005c6c <USBH_read+0x70>)
 8005c1e:	f000 fe5d 	bl	80068dc <USBH_MSC_Read>
 8005c22:	4603      	mov	r3, r0
 8005c24:	2b00      	cmp	r3, #0
 8005c26:	d103      	bne.n	8005c30 <USBH_read+0x34>
  {
    res = RES_OK;
 8005c28:	2300      	movs	r3, #0
 8005c2a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 8005c2e:	e017      	b.n	8005c60 <USBH_read+0x64>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 8005c30:	f107 0210 	add.w	r2, r7, #16
 8005c34:	7bfb      	ldrb	r3, [r7, #15]
 8005c36:	4619      	mov	r1, r3
 8005c38:	480c      	ldr	r0, [pc, #48]	; (8005c6c <USBH_read+0x70>)
 8005c3a:	f000 fe2b 	bl	8006894 <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 8005c3e:	7f7b      	ldrb	r3, [r7, #29]
 8005c40:	2b3a      	cmp	r3, #58	; 0x3a
 8005c42:	d005      	beq.n	8005c50 <USBH_read+0x54>
 8005c44:	2b3a      	cmp	r3, #58	; 0x3a
 8005c46:	dc07      	bgt.n	8005c58 <USBH_read+0x5c>
 8005c48:	2b04      	cmp	r3, #4
 8005c4a:	d001      	beq.n	8005c50 <USBH_read+0x54>
 8005c4c:	2b28      	cmp	r3, #40	; 0x28
 8005c4e:	d103      	bne.n	8005c58 <USBH_read+0x5c>
    {
    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog ("USB Disk is not ready!");
      res = RES_NOTRDY;
 8005c50:	2303      	movs	r3, #3
 8005c52:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      break;
 8005c56:	e003      	b.n	8005c60 <USBH_read+0x64>

    default:
      res = RES_ERROR;
 8005c58:	2301      	movs	r3, #1
 8005c5a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      break;
 8005c5e:	bf00      	nop
    }
  }

  return res;
 8005c60:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 8005c64:	4618      	mov	r0, r3
 8005c66:	3748      	adds	r7, #72	; 0x48
 8005c68:	46bd      	mov	sp, r7
 8005c6a:	bd80      	pop	{r7, pc}
 8005c6c:	20000dd0 	.word	0x20000dd0

08005c70 <USBH_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT USBH_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8005c70:	b580      	push	{r7, lr}
 8005c72:	b094      	sub	sp, #80	; 0x50
 8005c74:	af02      	add	r7, sp, #8
 8005c76:	60b9      	str	r1, [r7, #8]
 8005c78:	607a      	str	r2, [r7, #4]
 8005c7a:	603b      	str	r3, [r7, #0]
 8005c7c:	4603      	mov	r3, r0
 8005c7e:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 8005c80:	2301      	movs	r3, #1
 8005c82:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
  MSC_LUNTypeDef info;

  if(USBH_MSC_Write(&hUSB_Host, lun, sector, (BYTE *)buff, count) == USBH_OK)
 8005c86:	7bf9      	ldrb	r1, [r7, #15]
 8005c88:	683b      	ldr	r3, [r7, #0]
 8005c8a:	9300      	str	r3, [sp, #0]
 8005c8c:	68bb      	ldr	r3, [r7, #8]
 8005c8e:	687a      	ldr	r2, [r7, #4]
 8005c90:	4817      	ldr	r0, [pc, #92]	; (8005cf0 <USBH_write+0x80>)
 8005c92:	f000 fe8c 	bl	80069ae <USBH_MSC_Write>
 8005c96:	4603      	mov	r3, r0
 8005c98:	2b00      	cmp	r3, #0
 8005c9a:	d103      	bne.n	8005ca4 <USBH_write+0x34>
  {
    res = RES_OK;
 8005c9c:	2300      	movs	r3, #0
 8005c9e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 8005ca2:	e01f      	b.n	8005ce4 <USBH_write+0x74>
  }
  else
  {
    USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info);
 8005ca4:	f107 0210 	add.w	r2, r7, #16
 8005ca8:	7bfb      	ldrb	r3, [r7, #15]
 8005caa:	4619      	mov	r1, r3
 8005cac:	4810      	ldr	r0, [pc, #64]	; (8005cf0 <USBH_write+0x80>)
 8005cae:	f000 fdf1 	bl	8006894 <USBH_MSC_GetLUNInfo>

    switch (info.sense.asc)
 8005cb2:	7f7b      	ldrb	r3, [r7, #29]
 8005cb4:	2b3a      	cmp	r3, #58	; 0x3a
 8005cb6:	d00d      	beq.n	8005cd4 <USBH_write+0x64>
 8005cb8:	2b3a      	cmp	r3, #58	; 0x3a
 8005cba:	dc0f      	bgt.n	8005cdc <USBH_write+0x6c>
 8005cbc:	2b28      	cmp	r3, #40	; 0x28
 8005cbe:	d009      	beq.n	8005cd4 <USBH_write+0x64>
 8005cc0:	2b28      	cmp	r3, #40	; 0x28
 8005cc2:	dc0b      	bgt.n	8005cdc <USBH_write+0x6c>
 8005cc4:	2b04      	cmp	r3, #4
 8005cc6:	d005      	beq.n	8005cd4 <USBH_write+0x64>
 8005cc8:	2b27      	cmp	r3, #39	; 0x27
 8005cca:	d107      	bne.n	8005cdc <USBH_write+0x6c>
    {
    case SCSI_ASC_WRITE_PROTECTED:
      USBH_ErrLog("USB Disk is Write protected!");
      res = RES_WRPRT;
 8005ccc:	2302      	movs	r3, #2
 8005cce:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      break;
 8005cd2:	e007      	b.n	8005ce4 <USBH_write+0x74>

    case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    case SCSI_ASC_MEDIUM_NOT_PRESENT:
    case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
      USBH_ErrLog("USB Disk is not ready!");
      res = RES_NOTRDY;
 8005cd4:	2303      	movs	r3, #3
 8005cd6:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      break;
 8005cda:	e003      	b.n	8005ce4 <USBH_write+0x74>

    default:
      res = RES_ERROR;
 8005cdc:	2301      	movs	r3, #1
 8005cde:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
      break;
 8005ce2:	bf00      	nop
    }
  }

  return res;
 8005ce4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 8005ce8:	4618      	mov	r0, r3
 8005cea:	3748      	adds	r7, #72	; 0x48
 8005cec:	46bd      	mov	sp, r7
 8005cee:	bd80      	pop	{r7, pc}
 8005cf0:	20000dd0 	.word	0x20000dd0

08005cf4 <USBH_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USBH_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8005cf4:	b580      	push	{r7, lr}
 8005cf6:	b090      	sub	sp, #64	; 0x40
 8005cf8:	af00      	add	r7, sp, #0
 8005cfa:	4603      	mov	r3, r0
 8005cfc:	603a      	str	r2, [r7, #0]
 8005cfe:	71fb      	strb	r3, [r7, #7]
 8005d00:	460b      	mov	r3, r1
 8005d02:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_ERROR;
 8005d04:	2301      	movs	r3, #1
 8005d06:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  MSC_LUNTypeDef info;

  switch (cmd)
 8005d0a:	79bb      	ldrb	r3, [r7, #6]
 8005d0c:	2b03      	cmp	r3, #3
 8005d0e:	d852      	bhi.n	8005db6 <USBH_ioctl+0xc2>
 8005d10:	a201      	add	r2, pc, #4	; (adr r2, 8005d18 <USBH_ioctl+0x24>)
 8005d12:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005d16:	bf00      	nop
 8005d18:	08005d29 	.word	0x08005d29
 8005d1c:	08005d31 	.word	0x08005d31
 8005d20:	08005d5b 	.word	0x08005d5b
 8005d24:	08005d87 	.word	0x08005d87
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC:
    res = RES_OK;
 8005d28:	2300      	movs	r3, #0
 8005d2a:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    break;
 8005d2e:	e045      	b.n	8005dbc <USBH_ioctl+0xc8>

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 8005d30:	f107 0208 	add.w	r2, r7, #8
 8005d34:	79fb      	ldrb	r3, [r7, #7]
 8005d36:	4619      	mov	r1, r3
 8005d38:	4823      	ldr	r0, [pc, #140]	; (8005dc8 <USBH_ioctl+0xd4>)
 8005d3a:	f000 fdab 	bl	8006894 <USBH_MSC_GetLUNInfo>
 8005d3e:	4603      	mov	r3, r0
 8005d40:	2b00      	cmp	r3, #0
 8005d42:	d106      	bne.n	8005d52 <USBH_ioctl+0x5e>
    {
      *(DWORD*)buff = info.capacity.block_nbr;
 8005d44:	68fa      	ldr	r2, [r7, #12]
 8005d46:	683b      	ldr	r3, [r7, #0]
 8005d48:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 8005d4a:	2300      	movs	r3, #0
 8005d4c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 8005d50:	e034      	b.n	8005dbc <USBH_ioctl+0xc8>
      res = RES_ERROR;
 8005d52:	2301      	movs	r3, #1
 8005d54:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    break;
 8005d58:	e030      	b.n	8005dbc <USBH_ioctl+0xc8>

  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 8005d5a:	f107 0208 	add.w	r2, r7, #8
 8005d5e:	79fb      	ldrb	r3, [r7, #7]
 8005d60:	4619      	mov	r1, r3
 8005d62:	4819      	ldr	r0, [pc, #100]	; (8005dc8 <USBH_ioctl+0xd4>)
 8005d64:	f000 fd96 	bl	8006894 <USBH_MSC_GetLUNInfo>
 8005d68:	4603      	mov	r3, r0
 8005d6a:	2b00      	cmp	r3, #0
 8005d6c:	d107      	bne.n	8005d7e <USBH_ioctl+0x8a>
    {
      *(DWORD*)buff = info.capacity.block_size;
 8005d6e:	8a3b      	ldrh	r3, [r7, #16]
 8005d70:	461a      	mov	r2, r3
 8005d72:	683b      	ldr	r3, [r7, #0]
 8005d74:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 8005d76:	2300      	movs	r3, #0
 8005d78:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 8005d7c:	e01e      	b.n	8005dbc <USBH_ioctl+0xc8>
      res = RES_ERROR;
 8005d7e:	2301      	movs	r3, #1
 8005d80:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    break;
 8005d84:	e01a      	b.n	8005dbc <USBH_ioctl+0xc8>

    /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :

    if(USBH_MSC_GetLUNInfo(&hUSB_Host, lun, &info) == USBH_OK)
 8005d86:	f107 0208 	add.w	r2, r7, #8
 8005d8a:	79fb      	ldrb	r3, [r7, #7]
 8005d8c:	4619      	mov	r1, r3
 8005d8e:	480e      	ldr	r0, [pc, #56]	; (8005dc8 <USBH_ioctl+0xd4>)
 8005d90:	f000 fd80 	bl	8006894 <USBH_MSC_GetLUNInfo>
 8005d94:	4603      	mov	r3, r0
 8005d96:	2b00      	cmp	r3, #0
 8005d98:	d109      	bne.n	8005dae <USBH_ioctl+0xba>
    {
      *(DWORD*)buff = info.capacity.block_size / USB_DEFAULT_BLOCK_SIZE;
 8005d9a:	8a3b      	ldrh	r3, [r7, #16]
 8005d9c:	0a5b      	lsrs	r3, r3, #9
 8005d9e:	b29b      	uxth	r3, r3
 8005da0:	461a      	mov	r2, r3
 8005da2:	683b      	ldr	r3, [r7, #0]
 8005da4:	601a      	str	r2, [r3, #0]
      res = RES_OK;
 8005da6:	2300      	movs	r3, #0
 8005da8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }
    else
    {
      res = RES_ERROR;
    }
    break;
 8005dac:	e006      	b.n	8005dbc <USBH_ioctl+0xc8>
      res = RES_ERROR;
 8005dae:	2301      	movs	r3, #1
 8005db0:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    break;
 8005db4:	e002      	b.n	8005dbc <USBH_ioctl+0xc8>

  default:
    res = RES_PARERR;
 8005db6:	2304      	movs	r3, #4
 8005db8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  }

  return res;
 8005dbc:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
 8005dc0:	4618      	mov	r0, r3
 8005dc2:	3740      	adds	r7, #64	; 0x40
 8005dc4:	46bd      	mov	sp, r7
 8005dc6:	bd80      	pop	{r7, pc}
 8005dc8:	20000dd0 	.word	0x20000dd0

08005dcc <MX_LIBJPEG_Init>:
/* USER CODE BEGIN 2 */
/* USER CODE END 2 */

/* LIBJPEG init function */
void MX_LIBJPEG_Init(void)
{
 8005dcc:	b480      	push	{r7}
 8005dce:	af00      	add	r7, sp, #0
  */

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

}
 8005dd0:	bf00      	nop
 8005dd2:	46bd      	mov	sp, r7
 8005dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dd8:	4770      	bx	lr
	...

08005ddc <read_file>:
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

size_t read_file (FIL  *file, uint8_t *buf, uint32_t sizeofbuf)
{
 8005ddc:	b580      	push	{r7, lr}
 8005dde:	b084      	sub	sp, #16
 8005de0:	af00      	add	r7, sp, #0
 8005de2:	60f8      	str	r0, [r7, #12]
 8005de4:	60b9      	str	r1, [r7, #8]
 8005de6:	607a      	str	r2, [r7, #4]
static size_t BytesReadfile ;
f_read (file, buf , sizeofbuf, &BytesReadfile);
 8005de8:	4b05      	ldr	r3, [pc, #20]	; (8005e00 <read_file+0x24>)
 8005dea:	687a      	ldr	r2, [r7, #4]
 8005dec:	68b9      	ldr	r1, [r7, #8]
 8005dee:	68f8      	ldr	r0, [r7, #12]
 8005df0:	f005 fc9c 	bl	800b72c <f_read>
return BytesReadfile;
 8005df4:	4b02      	ldr	r3, [pc, #8]	; (8005e00 <read_file+0x24>)
 8005df6:	681b      	ldr	r3, [r3, #0]
}
 8005df8:	4618      	mov	r0, r3
 8005dfa:	3710      	adds	r7, #16
 8005dfc:	46bd      	mov	sp, r7
 8005dfe:	bd80      	pop	{r7, pc}
 8005e00:	200000b0 	.word	0x200000b0

08005e04 <USBH_MSC_InterfaceInit>:
  *         The function init the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceInit(USBH_HandleTypeDef *phost)
{
 8005e04:	b590      	push	{r4, r7, lr}
 8005e06:	b089      	sub	sp, #36	; 0x24
 8005e08:	af04      	add	r7, sp, #16
 8005e0a:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef status;
  uint8_t interface;
  MSC_HandleTypeDef *MSC_Handle;

  interface = USBH_FindInterface(phost, phost->pActiveClass->ClassCode, MSC_TRANSPARENT, MSC_BOT);
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8005e12:	7919      	ldrb	r1, [r3, #4]
 8005e14:	2350      	movs	r3, #80	; 0x50
 8005e16:	2206      	movs	r2, #6
 8005e18:	6878      	ldr	r0, [r7, #4]
 8005e1a:	f001 fc53 	bl	80076c4 <USBH_FindInterface>
 8005e1e:	4603      	mov	r3, r0
 8005e20:	73fb      	strb	r3, [r7, #15]

  if ((interface == 0xFFU) || (interface >= USBH_MAX_NUM_INTERFACES)) /* Not Valid Interface */
 8005e22:	7bfb      	ldrb	r3, [r7, #15]
 8005e24:	2bff      	cmp	r3, #255	; 0xff
 8005e26:	d002      	beq.n	8005e2e <USBH_MSC_InterfaceInit+0x2a>
 8005e28:	7bfb      	ldrb	r3, [r7, #15]
 8005e2a:	2b01      	cmp	r3, #1
 8005e2c:	d901      	bls.n	8005e32 <USBH_MSC_InterfaceInit+0x2e>
  {
    USBH_DbgLog("Cannot Find the interface for %s class.", phost->pActiveClass->Name);
    return USBH_FAIL;
 8005e2e:	2302      	movs	r3, #2
 8005e30:	e0ef      	b.n	8006012 <USBH_MSC_InterfaceInit+0x20e>
  }

  status = USBH_SelectInterface(phost, interface);
 8005e32:	7bfb      	ldrb	r3, [r7, #15]
 8005e34:	4619      	mov	r1, r3
 8005e36:	6878      	ldr	r0, [r7, #4]
 8005e38:	f001 fc28 	bl	800768c <USBH_SelectInterface>
 8005e3c:	4603      	mov	r3, r0
 8005e3e:	73bb      	strb	r3, [r7, #14]

  if (status != USBH_OK)
 8005e40:	7bbb      	ldrb	r3, [r7, #14]
 8005e42:	2b00      	cmp	r3, #0
 8005e44:	d001      	beq.n	8005e4a <USBH_MSC_InterfaceInit+0x46>
  {
    return USBH_FAIL;
 8005e46:	2302      	movs	r3, #2
 8005e48:	e0e3      	b.n	8006012 <USBH_MSC_InterfaceInit+0x20e>
  }

  phost->pActiveClass->pData = (MSC_HandleTypeDef *)USBH_malloc(sizeof(MSC_HandleTypeDef));
 8005e4a:	687b      	ldr	r3, [r7, #4]
 8005e4c:	f8d3 437c 	ldr.w	r4, [r3, #892]	; 0x37c
 8005e50:	f44f 7080 	mov.w	r0, #256	; 0x100
 8005e54:	f022 f9f6 	bl	8028244 <malloc>
 8005e58:	4603      	mov	r3, r0
 8005e5a:	61e3      	str	r3, [r4, #28]
  MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8005e5c:	687b      	ldr	r3, [r7, #4]
 8005e5e:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8005e62:	69db      	ldr	r3, [r3, #28]
 8005e64:	60bb      	str	r3, [r7, #8]

  if (MSC_Handle == NULL)
 8005e66:	68bb      	ldr	r3, [r7, #8]
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d101      	bne.n	8005e70 <USBH_MSC_InterfaceInit+0x6c>
  {
    USBH_DbgLog("Cannot allocate memory for MSC Handle");
    return USBH_FAIL;
 8005e6c:	2302      	movs	r3, #2
 8005e6e:	e0d0      	b.n	8006012 <USBH_MSC_InterfaceInit+0x20e>
  }

  /* Initialize msc handler */
  USBH_memset(MSC_Handle, 0, sizeof(MSC_HandleTypeDef));
 8005e70:	f44f 7280 	mov.w	r2, #256	; 0x100
 8005e74:	2100      	movs	r1, #0
 8005e76:	68b8      	ldr	r0, [r7, #8]
 8005e78:	f022 fa02 	bl	8028280 <memset>

  if (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress & 0x80U)
 8005e7c:	7bfb      	ldrb	r3, [r7, #15]
 8005e7e:	687a      	ldr	r2, [r7, #4]
 8005e80:	211a      	movs	r1, #26
 8005e82:	fb01 f303 	mul.w	r3, r1, r3
 8005e86:	4413      	add	r3, r2
 8005e88:	f203 334e 	addw	r3, r3, #846	; 0x34e
 8005e8c:	781b      	ldrb	r3, [r3, #0]
 8005e8e:	b25b      	sxtb	r3, r3
 8005e90:	2b00      	cmp	r3, #0
 8005e92:	da16      	bge.n	8005ec2 <USBH_MSC_InterfaceInit+0xbe>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 8005e94:	7bfb      	ldrb	r3, [r7, #15]
 8005e96:	687a      	ldr	r2, [r7, #4]
 8005e98:	211a      	movs	r1, #26
 8005e9a:	fb01 f303 	mul.w	r3, r1, r3
 8005e9e:	4413      	add	r3, r2
 8005ea0:	f203 334e 	addw	r3, r3, #846	; 0x34e
 8005ea4:	781a      	ldrb	r2, [r3, #0]
 8005ea6:	68bb      	ldr	r3, [r7, #8]
 8005ea8:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 8005eaa:	7bfb      	ldrb	r3, [r7, #15]
 8005eac:	687a      	ldr	r2, [r7, #4]
 8005eae:	211a      	movs	r1, #26
 8005eb0:	fb01 f303 	mul.w	r3, r1, r3
 8005eb4:	4413      	add	r3, r2
 8005eb6:	f503 7354 	add.w	r3, r3, #848	; 0x350
 8005eba:	881a      	ldrh	r2, [r3, #0]
 8005ebc:	68bb      	ldr	r3, [r7, #8]
 8005ebe:	815a      	strh	r2, [r3, #10]
 8005ec0:	e015      	b.n	8005eee <USBH_MSC_InterfaceInit+0xea>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress);
 8005ec2:	7bfb      	ldrb	r3, [r7, #15]
 8005ec4:	687a      	ldr	r2, [r7, #4]
 8005ec6:	211a      	movs	r1, #26
 8005ec8:	fb01 f303 	mul.w	r3, r1, r3
 8005ecc:	4413      	add	r3, r2
 8005ece:	f203 334e 	addw	r3, r3, #846	; 0x34e
 8005ed2:	781a      	ldrb	r2, [r3, #0]
 8005ed4:	68bb      	ldr	r3, [r7, #8]
 8005ed6:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
 8005ed8:	7bfb      	ldrb	r3, [r7, #15]
 8005eda:	687a      	ldr	r2, [r7, #4]
 8005edc:	211a      	movs	r1, #26
 8005ede:	fb01 f303 	mul.w	r3, r1, r3
 8005ee2:	4413      	add	r3, r2
 8005ee4:	f503 7354 	add.w	r3, r3, #848	; 0x350
 8005ee8:	881a      	ldrh	r2, [r3, #0]
 8005eea:	68bb      	ldr	r3, [r7, #8]
 8005eec:	811a      	strh	r2, [r3, #8]
  }

  if (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress & 0x80U)
 8005eee:	7bfb      	ldrb	r3, [r7, #15]
 8005ef0:	687a      	ldr	r2, [r7, #4]
 8005ef2:	211a      	movs	r1, #26
 8005ef4:	fb01 f303 	mul.w	r3, r1, r3
 8005ef8:	4413      	add	r3, r2
 8005efa:	f203 3356 	addw	r3, r3, #854	; 0x356
 8005efe:	781b      	ldrb	r3, [r3, #0]
 8005f00:	b25b      	sxtb	r3, r3
 8005f02:	2b00      	cmp	r3, #0
 8005f04:	da16      	bge.n	8005f34 <USBH_MSC_InterfaceInit+0x130>
  {
    MSC_Handle->InEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 8005f06:	7bfb      	ldrb	r3, [r7, #15]
 8005f08:	687a      	ldr	r2, [r7, #4]
 8005f0a:	211a      	movs	r1, #26
 8005f0c:	fb01 f303 	mul.w	r3, r1, r3
 8005f10:	4413      	add	r3, r2
 8005f12:	f203 3356 	addw	r3, r3, #854	; 0x356
 8005f16:	781a      	ldrb	r2, [r3, #0]
 8005f18:	68bb      	ldr	r3, [r7, #8]
 8005f1a:	71da      	strb	r2, [r3, #7]
    MSC_Handle->InEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 8005f1c:	7bfb      	ldrb	r3, [r7, #15]
 8005f1e:	687a      	ldr	r2, [r7, #4]
 8005f20:	211a      	movs	r1, #26
 8005f22:	fb01 f303 	mul.w	r3, r1, r3
 8005f26:	4413      	add	r3, r2
 8005f28:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8005f2c:	881a      	ldrh	r2, [r3, #0]
 8005f2e:	68bb      	ldr	r3, [r7, #8]
 8005f30:	815a      	strh	r2, [r3, #10]
 8005f32:	e015      	b.n	8005f60 <USBH_MSC_InterfaceInit+0x15c>
  }
  else
  {
    MSC_Handle->OutEp = (phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].bEndpointAddress);
 8005f34:	7bfb      	ldrb	r3, [r7, #15]
 8005f36:	687a      	ldr	r2, [r7, #4]
 8005f38:	211a      	movs	r1, #26
 8005f3a:	fb01 f303 	mul.w	r3, r1, r3
 8005f3e:	4413      	add	r3, r2
 8005f40:	f203 3356 	addw	r3, r3, #854	; 0x356
 8005f44:	781a      	ldrb	r2, [r3, #0]
 8005f46:	68bb      	ldr	r3, [r7, #8]
 8005f48:	719a      	strb	r2, [r3, #6]
    MSC_Handle->OutEpSize = phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[1].wMaxPacketSize;
 8005f4a:	7bfb      	ldrb	r3, [r7, #15]
 8005f4c:	687a      	ldr	r2, [r7, #4]
 8005f4e:	211a      	movs	r1, #26
 8005f50:	fb01 f303 	mul.w	r3, r1, r3
 8005f54:	4413      	add	r3, r2
 8005f56:	f503 7356 	add.w	r3, r3, #856	; 0x358
 8005f5a:	881a      	ldrh	r2, [r3, #0]
 8005f5c:	68bb      	ldr	r3, [r7, #8]
 8005f5e:	811a      	strh	r2, [r3, #8]
  }

  MSC_Handle->state = MSC_INIT;
 8005f60:	68bb      	ldr	r3, [r7, #8]
 8005f62:	2200      	movs	r2, #0
 8005f64:	731a      	strb	r2, [r3, #12]
  MSC_Handle->error = MSC_OK;
 8005f66:	68bb      	ldr	r3, [r7, #8]
 8005f68:	2200      	movs	r2, #0
 8005f6a:	735a      	strb	r2, [r3, #13]
  MSC_Handle->req_state = MSC_REQ_IDLE;
 8005f6c:	68bb      	ldr	r3, [r7, #8]
 8005f6e:	2200      	movs	r2, #0
 8005f70:	739a      	strb	r2, [r3, #14]
  MSC_Handle->OutPipe = USBH_AllocPipe(phost, MSC_Handle->OutEp);
 8005f72:	68bb      	ldr	r3, [r7, #8]
 8005f74:	799b      	ldrb	r3, [r3, #6]
 8005f76:	4619      	mov	r1, r3
 8005f78:	6878      	ldr	r0, [r7, #4]
 8005f7a:	f002 fdc4 	bl	8008b06 <USBH_AllocPipe>
 8005f7e:	4603      	mov	r3, r0
 8005f80:	461a      	mov	r2, r3
 8005f82:	68bb      	ldr	r3, [r7, #8]
 8005f84:	715a      	strb	r2, [r3, #5]
  MSC_Handle->InPipe = USBH_AllocPipe(phost, MSC_Handle->InEp);
 8005f86:	68bb      	ldr	r3, [r7, #8]
 8005f88:	79db      	ldrb	r3, [r3, #7]
 8005f8a:	4619      	mov	r1, r3
 8005f8c:	6878      	ldr	r0, [r7, #4]
 8005f8e:	f002 fdba 	bl	8008b06 <USBH_AllocPipe>
 8005f92:	4603      	mov	r3, r0
 8005f94:	461a      	mov	r2, r3
 8005f96:	68bb      	ldr	r3, [r7, #8]
 8005f98:	711a      	strb	r2, [r3, #4]

  USBH_MSC_BOT_Init(phost);
 8005f9a:	6878      	ldr	r0, [r7, #4]
 8005f9c:	f000 fdac 	bl	8006af8 <USBH_MSC_BOT_Init>

  /* Open the new channels */
  USBH_OpenPipe(phost, MSC_Handle->OutPipe, MSC_Handle->OutEp,
 8005fa0:	68bb      	ldr	r3, [r7, #8]
 8005fa2:	7959      	ldrb	r1, [r3, #5]
 8005fa4:	68bb      	ldr	r3, [r7, #8]
 8005fa6:	7998      	ldrb	r0, [r3, #6]
 8005fa8:	687b      	ldr	r3, [r7, #4]
 8005faa:	f893 431c 	ldrb.w	r4, [r3, #796]	; 0x31c
 8005fae:	687b      	ldr	r3, [r7, #4]
 8005fb0:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
 8005fb4:	68ba      	ldr	r2, [r7, #8]
 8005fb6:	8912      	ldrh	r2, [r2, #8]
 8005fb8:	9202      	str	r2, [sp, #8]
 8005fba:	2202      	movs	r2, #2
 8005fbc:	9201      	str	r2, [sp, #4]
 8005fbe:	9300      	str	r3, [sp, #0]
 8005fc0:	4623      	mov	r3, r4
 8005fc2:	4602      	mov	r2, r0
 8005fc4:	6878      	ldr	r0, [r7, #4]
 8005fc6:	f002 fd6f 	bl	8008aa8 <USBH_OpenPipe>
                phost->device.address, phost->device.speed,
                USB_EP_TYPE_BULK, MSC_Handle->OutEpSize);

  USBH_OpenPipe(phost, MSC_Handle->InPipe, MSC_Handle->InEp,
 8005fca:	68bb      	ldr	r3, [r7, #8]
 8005fcc:	7919      	ldrb	r1, [r3, #4]
 8005fce:	68bb      	ldr	r3, [r7, #8]
 8005fd0:	79d8      	ldrb	r0, [r3, #7]
 8005fd2:	687b      	ldr	r3, [r7, #4]
 8005fd4:	f893 431c 	ldrb.w	r4, [r3, #796]	; 0x31c
 8005fd8:	687b      	ldr	r3, [r7, #4]
 8005fda:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
 8005fde:	68ba      	ldr	r2, [r7, #8]
 8005fe0:	8952      	ldrh	r2, [r2, #10]
 8005fe2:	9202      	str	r2, [sp, #8]
 8005fe4:	2202      	movs	r2, #2
 8005fe6:	9201      	str	r2, [sp, #4]
 8005fe8:	9300      	str	r3, [sp, #0]
 8005fea:	4623      	mov	r3, r4
 8005fec:	4602      	mov	r2, r0
 8005fee:	6878      	ldr	r0, [r7, #4]
 8005ff0:	f002 fd5a 	bl	8008aa8 <USBH_OpenPipe>
                phost->device.address, phost->device.speed, USB_EP_TYPE_BULK,
                MSC_Handle->InEpSize);

  USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 8005ff4:	68bb      	ldr	r3, [r7, #8]
 8005ff6:	791b      	ldrb	r3, [r3, #4]
 8005ff8:	2200      	movs	r2, #0
 8005ffa:	4619      	mov	r1, r3
 8005ffc:	6878      	ldr	r0, [r7, #4]
 8005ffe:	f022 f860 	bl	80280c2 <USBH_LL_SetToggle>
  USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 0U);
 8006002:	68bb      	ldr	r3, [r7, #8]
 8006004:	795b      	ldrb	r3, [r3, #5]
 8006006:	2200      	movs	r2, #0
 8006008:	4619      	mov	r1, r3
 800600a:	6878      	ldr	r0, [r7, #4]
 800600c:	f022 f859 	bl	80280c2 <USBH_LL_SetToggle>

  return USBH_OK;
 8006010:	2300      	movs	r3, #0
}
 8006012:	4618      	mov	r0, r3
 8006014:	3714      	adds	r7, #20
 8006016:	46bd      	mov	sp, r7
 8006018:	bd90      	pop	{r4, r7, pc}

0800601a <USBH_MSC_InterfaceDeInit>:
  *         The function DeInit the Pipes used for the MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_InterfaceDeInit(USBH_HandleTypeDef *phost)
{
 800601a:	b580      	push	{r7, lr}
 800601c:	b084      	sub	sp, #16
 800601e:	af00      	add	r7, sp, #0
 8006020:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006022:	687b      	ldr	r3, [r7, #4]
 8006024:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006028:	69db      	ldr	r3, [r3, #28]
 800602a:	60fb      	str	r3, [r7, #12]

  if (MSC_Handle->OutPipe)
 800602c:	68fb      	ldr	r3, [r7, #12]
 800602e:	795b      	ldrb	r3, [r3, #5]
 8006030:	2b00      	cmp	r3, #0
 8006032:	d00e      	beq.n	8006052 <USBH_MSC_InterfaceDeInit+0x38>
  {
    USBH_ClosePipe(phost, MSC_Handle->OutPipe);
 8006034:	68fb      	ldr	r3, [r7, #12]
 8006036:	795b      	ldrb	r3, [r3, #5]
 8006038:	4619      	mov	r1, r3
 800603a:	6878      	ldr	r0, [r7, #4]
 800603c:	f002 fd53 	bl	8008ae6 <USBH_ClosePipe>
    USBH_FreePipe(phost, MSC_Handle->OutPipe);
 8006040:	68fb      	ldr	r3, [r7, #12]
 8006042:	795b      	ldrb	r3, [r3, #5]
 8006044:	4619      	mov	r1, r3
 8006046:	6878      	ldr	r0, [r7, #4]
 8006048:	f002 fd7e 	bl	8008b48 <USBH_FreePipe>
    MSC_Handle->OutPipe = 0U;     /* Reset the Channel as Free */
 800604c:	68fb      	ldr	r3, [r7, #12]
 800604e:	2200      	movs	r2, #0
 8006050:	715a      	strb	r2, [r3, #5]
  }

  if (MSC_Handle->InPipe)
 8006052:	68fb      	ldr	r3, [r7, #12]
 8006054:	791b      	ldrb	r3, [r3, #4]
 8006056:	2b00      	cmp	r3, #0
 8006058:	d00e      	beq.n	8006078 <USBH_MSC_InterfaceDeInit+0x5e>
  {
    USBH_ClosePipe(phost, MSC_Handle->InPipe);
 800605a:	68fb      	ldr	r3, [r7, #12]
 800605c:	791b      	ldrb	r3, [r3, #4]
 800605e:	4619      	mov	r1, r3
 8006060:	6878      	ldr	r0, [r7, #4]
 8006062:	f002 fd40 	bl	8008ae6 <USBH_ClosePipe>
    USBH_FreePipe(phost, MSC_Handle->InPipe);
 8006066:	68fb      	ldr	r3, [r7, #12]
 8006068:	791b      	ldrb	r3, [r3, #4]
 800606a:	4619      	mov	r1, r3
 800606c:	6878      	ldr	r0, [r7, #4]
 800606e:	f002 fd6b 	bl	8008b48 <USBH_FreePipe>
    MSC_Handle->InPipe = 0U;     /* Reset the Channel as Free */
 8006072:	68fb      	ldr	r3, [r7, #12]
 8006074:	2200      	movs	r2, #0
 8006076:	711a      	strb	r2, [r3, #4]
  }

  if (phost->pActiveClass->pData)
 8006078:	687b      	ldr	r3, [r7, #4]
 800607a:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800607e:	69db      	ldr	r3, [r3, #28]
 8006080:	2b00      	cmp	r3, #0
 8006082:	d00b      	beq.n	800609c <USBH_MSC_InterfaceDeInit+0x82>
  {
    USBH_free(phost->pActiveClass->pData);
 8006084:	687b      	ldr	r3, [r7, #4]
 8006086:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800608a:	69db      	ldr	r3, [r3, #28]
 800608c:	4618      	mov	r0, r3
 800608e:	f022 f8e1 	bl	8028254 <free>
    phost->pActiveClass->pData = 0U;
 8006092:	687b      	ldr	r3, [r7, #4]
 8006094:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006098:	2200      	movs	r2, #0
 800609a:	61da      	str	r2, [r3, #28]
  }

  return USBH_OK;
 800609c:	2300      	movs	r3, #0
}
 800609e:	4618      	mov	r0, r3
 80060a0:	3710      	adds	r7, #16
 80060a2:	46bd      	mov	sp, r7
 80060a4:	bd80      	pop	{r7, pc}

080060a6 <USBH_MSC_ClassRequest>:
  *         for MSC class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_ClassRequest(USBH_HandleTypeDef *phost)
{
 80060a6:	b580      	push	{r7, lr}
 80060a8:	b084      	sub	sp, #16
 80060aa:	af00      	add	r7, sp, #0
 80060ac:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80060ae:	687b      	ldr	r3, [r7, #4]
 80060b0:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80060b4:	69db      	ldr	r3, [r3, #28]
 80060b6:	60bb      	str	r3, [r7, #8]
  USBH_StatusTypeDef status = USBH_BUSY;
 80060b8:	2301      	movs	r3, #1
 80060ba:	73fb      	strb	r3, [r7, #15]
  uint8_t i;

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->req_state)
 80060bc:	68bb      	ldr	r3, [r7, #8]
 80060be:	7b9b      	ldrb	r3, [r3, #14]
 80060c0:	2b03      	cmp	r3, #3
 80060c2:	d041      	beq.n	8006148 <USBH_MSC_ClassRequest+0xa2>
 80060c4:	2b03      	cmp	r3, #3
 80060c6:	dc4b      	bgt.n	8006160 <USBH_MSC_ClassRequest+0xba>
 80060c8:	2b00      	cmp	r3, #0
 80060ca:	d001      	beq.n	80060d0 <USBH_MSC_ClassRequest+0x2a>
 80060cc:	2b02      	cmp	r3, #2
 80060ce:	d147      	bne.n	8006160 <USBH_MSC_ClassRequest+0xba>
  {
    case MSC_REQ_IDLE:
    case MSC_REQ_GET_MAX_LUN:
      /* Issue GetMaxLUN request */
      status = USBH_MSC_BOT_REQ_GetMaxLUN(phost, &MSC_Handle->max_lun);
 80060d0:	68bb      	ldr	r3, [r7, #8]
 80060d2:	4619      	mov	r1, r3
 80060d4:	6878      	ldr	r0, [r7, #4]
 80060d6:	f000 fcf0 	bl	8006aba <USBH_MSC_BOT_REQ_GetMaxLUN>
 80060da:	4603      	mov	r3, r0
 80060dc:	73fb      	strb	r3, [r7, #15]

      /* When devices do not support the GetMaxLun request, this should
         be considred as only one logical unit is supported */
      if (status == USBH_NOT_SUPPORTED)
 80060de:	7bfb      	ldrb	r3, [r7, #15]
 80060e0:	2b03      	cmp	r3, #3
 80060e2:	d104      	bne.n	80060ee <USBH_MSC_ClassRequest+0x48>
      {
        MSC_Handle->max_lun = 0U;
 80060e4:	68bb      	ldr	r3, [r7, #8]
 80060e6:	2200      	movs	r2, #0
 80060e8:	701a      	strb	r2, [r3, #0]
        status = USBH_OK;
 80060ea:	2300      	movs	r3, #0
 80060ec:	73fb      	strb	r3, [r7, #15]
      }

      if (status == USBH_OK)
 80060ee:	7bfb      	ldrb	r3, [r7, #15]
 80060f0:	2b00      	cmp	r3, #0
 80060f2:	d137      	bne.n	8006164 <USBH_MSC_ClassRequest+0xbe>
      {
        MSC_Handle->max_lun = (MSC_Handle->max_lun > MAX_SUPPORTED_LUN) ? MAX_SUPPORTED_LUN : (MSC_Handle->max_lun + 1U);
 80060f4:	68bb      	ldr	r3, [r7, #8]
 80060f6:	781b      	ldrb	r3, [r3, #0]
 80060f8:	2b02      	cmp	r3, #2
 80060fa:	d804      	bhi.n	8006106 <USBH_MSC_ClassRequest+0x60>
 80060fc:	68bb      	ldr	r3, [r7, #8]
 80060fe:	781b      	ldrb	r3, [r3, #0]
 8006100:	3301      	adds	r3, #1
 8006102:	b2da      	uxtb	r2, r3
 8006104:	e000      	b.n	8006108 <USBH_MSC_ClassRequest+0x62>
 8006106:	2202      	movs	r2, #2
 8006108:	68bb      	ldr	r3, [r7, #8]
 800610a:	701a      	strb	r2, [r3, #0]
        USBH_UsrLog("Number of supported LUN: %d", MSC_Handle->max_lun);

        for (i = 0U; i < MSC_Handle->max_lun; i++)
 800610c:	2300      	movs	r3, #0
 800610e:	73bb      	strb	r3, [r7, #14]
 8006110:	e014      	b.n	800613c <USBH_MSC_ClassRequest+0x96>
        {
          MSC_Handle->unit[i].prev_ready_state = USBH_FAIL;
 8006112:	7bbb      	ldrb	r3, [r7, #14]
 8006114:	68ba      	ldr	r2, [r7, #8]
 8006116:	2134      	movs	r1, #52	; 0x34
 8006118:	fb01 f303 	mul.w	r3, r1, r3
 800611c:	4413      	add	r3, r2
 800611e:	3392      	adds	r3, #146	; 0x92
 8006120:	2202      	movs	r2, #2
 8006122:	701a      	strb	r2, [r3, #0]
          MSC_Handle->unit[i].state_changed = 0U;
 8006124:	7bbb      	ldrb	r3, [r7, #14]
 8006126:	68ba      	ldr	r2, [r7, #8]
 8006128:	2134      	movs	r1, #52	; 0x34
 800612a:	fb01 f303 	mul.w	r3, r1, r3
 800612e:	4413      	add	r3, r2
 8006130:	33c1      	adds	r3, #193	; 0xc1
 8006132:	2200      	movs	r2, #0
 8006134:	701a      	strb	r2, [r3, #0]
        for (i = 0U; i < MSC_Handle->max_lun; i++)
 8006136:	7bbb      	ldrb	r3, [r7, #14]
 8006138:	3301      	adds	r3, #1
 800613a:	73bb      	strb	r3, [r7, #14]
 800613c:	68bb      	ldr	r3, [r7, #8]
 800613e:	781b      	ldrb	r3, [r3, #0]
 8006140:	7bba      	ldrb	r2, [r7, #14]
 8006142:	429a      	cmp	r2, r3
 8006144:	d3e5      	bcc.n	8006112 <USBH_MSC_ClassRequest+0x6c>
        }
      }
      break;
 8006146:	e00d      	b.n	8006164 <USBH_MSC_ClassRequest+0xbe>

    case MSC_REQ_ERROR:
      /* a Clear Feature should be issued here */
      if (USBH_ClrFeature(phost, 0x00U) == USBH_OK)
 8006148:	2100      	movs	r1, #0
 800614a:	6878      	ldr	r0, [r7, #4]
 800614c:	f002 f87b 	bl	8008246 <USBH_ClrFeature>
 8006150:	4603      	mov	r3, r0
 8006152:	2b00      	cmp	r3, #0
 8006154:	d108      	bne.n	8006168 <USBH_MSC_ClassRequest+0xc2>
      {
        MSC_Handle->req_state = MSC_Handle->prev_req_state;
 8006156:	68bb      	ldr	r3, [r7, #8]
 8006158:	7bda      	ldrb	r2, [r3, #15]
 800615a:	68bb      	ldr	r3, [r7, #8]
 800615c:	739a      	strb	r2, [r3, #14]
      }
      break;
 800615e:	e003      	b.n	8006168 <USBH_MSC_ClassRequest+0xc2>

    default:
      break;
 8006160:	bf00      	nop
 8006162:	e002      	b.n	800616a <USBH_MSC_ClassRequest+0xc4>
      break;
 8006164:	bf00      	nop
 8006166:	e000      	b.n	800616a <USBH_MSC_ClassRequest+0xc4>
      break;
 8006168:	bf00      	nop
  }

  return status;
 800616a:	7bfb      	ldrb	r3, [r7, #15]
}
 800616c:	4618      	mov	r0, r3
 800616e:	3710      	adds	r7, #16
 8006170:	46bd      	mov	sp, r7
 8006172:	bd80      	pop	{r7, pc}

08006174 <USBH_MSC_Process>:
  *         The function is for managing state machine for MSC data transfers
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_Process(USBH_HandleTypeDef *phost)
{
 8006174:	b580      	push	{r7, lr}
 8006176:	b086      	sub	sp, #24
 8006178:	af00      	add	r7, sp, #0
 800617a:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800617c:	687b      	ldr	r3, [r7, #4]
 800617e:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006182:	69db      	ldr	r3, [r3, #28]
 8006184:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY;
 8006186:	2301      	movs	r3, #1
 8006188:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY;
 800618a:	2301      	movs	r3, #1
 800618c:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ready_status = USBH_BUSY;
 800618e:	2301      	movs	r3, #1
 8006190:	73bb      	strb	r3, [r7, #14]

  switch (MSC_Handle->state)
 8006192:	693b      	ldr	r3, [r7, #16]
 8006194:	7b1b      	ldrb	r3, [r3, #12]
 8006196:	2b00      	cmp	r3, #0
 8006198:	d003      	beq.n	80061a2 <USBH_MSC_Process+0x2e>
 800619a:	2b01      	cmp	r3, #1
 800619c:	f000 8271 	beq.w	8006682 <USBH_MSC_Process+0x50e>
    case MSC_IDLE:
      error = USBH_OK;
      break;

    default:
      break;
 80061a0:	e272      	b.n	8006688 <USBH_MSC_Process+0x514>
      if (MSC_Handle->current_lun < MSC_Handle->max_lun)
 80061a2:	693b      	ldr	r3, [r7, #16]
 80061a4:	f8b3 20f8 	ldrh.w	r2, [r3, #248]	; 0xf8
 80061a8:	693b      	ldr	r3, [r7, #16]
 80061aa:	781b      	ldrb	r3, [r3, #0]
 80061ac:	b29b      	uxth	r3, r3
 80061ae:	429a      	cmp	r2, r3
 80061b0:	f080 824f 	bcs.w	8006652 <USBH_MSC_Process+0x4de>
        MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 80061b4:	693b      	ldr	r3, [r7, #16]
 80061b6:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80061ba:	4619      	mov	r1, r3
 80061bc:	693a      	ldr	r2, [r7, #16]
 80061be:	2334      	movs	r3, #52	; 0x34
 80061c0:	fb03 f301 	mul.w	r3, r3, r1
 80061c4:	4413      	add	r3, r2
 80061c6:	3391      	adds	r3, #145	; 0x91
 80061c8:	2201      	movs	r2, #1
 80061ca:	701a      	strb	r2, [r3, #0]
        switch (MSC_Handle->unit[MSC_Handle->current_lun].state)
 80061cc:	693b      	ldr	r3, [r7, #16]
 80061ce:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80061d2:	4619      	mov	r1, r3
 80061d4:	693a      	ldr	r2, [r7, #16]
 80061d6:	2334      	movs	r3, #52	; 0x34
 80061d8:	fb03 f301 	mul.w	r3, r3, r1
 80061dc:	4413      	add	r3, r2
 80061de:	3390      	adds	r3, #144	; 0x90
 80061e0:	781b      	ldrb	r3, [r3, #0]
 80061e2:	2b08      	cmp	r3, #8
 80061e4:	f200 8243 	bhi.w	800666e <USBH_MSC_Process+0x4fa>
 80061e8:	a201      	add	r2, pc, #4	; (adr r2, 80061f0 <USBH_MSC_Process+0x7c>)
 80061ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80061ee:	bf00      	nop
 80061f0:	08006215 	.word	0x08006215
 80061f4:	0800666f 	.word	0x0800666f
 80061f8:	080062dd 	.word	0x080062dd
 80061fc:	08006461 	.word	0x08006461
 8006200:	0800623b 	.word	0x0800623b
 8006204:	0800652d 	.word	0x0800652d
 8006208:	0800666f 	.word	0x0800666f
 800620c:	0800666f 	.word	0x0800666f
 8006210:	08006641 	.word	0x08006641
            MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_INQUIRY;
 8006214:	693b      	ldr	r3, [r7, #16]
 8006216:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800621a:	4619      	mov	r1, r3
 800621c:	693a      	ldr	r2, [r7, #16]
 800621e:	2334      	movs	r3, #52	; 0x34
 8006220:	fb03 f301 	mul.w	r3, r3, r1
 8006224:	4413      	add	r3, r2
 8006226:	3390      	adds	r3, #144	; 0x90
 8006228:	2204      	movs	r2, #4
 800622a:	701a      	strb	r2, [r3, #0]
            MSC_Handle->timer = phost->Timer;
 800622c:	687b      	ldr	r3, [r7, #4]
 800622e:	f8d3 23c4 	ldr.w	r2, [r3, #964]	; 0x3c4
 8006232:	693b      	ldr	r3, [r7, #16]
 8006234:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
            break;
 8006238:	e222      	b.n	8006680 <USBH_MSC_Process+0x50c>
            scsi_status = USBH_MSC_SCSI_Inquiry(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].inquiry);
 800623a:	693b      	ldr	r3, [r7, #16]
 800623c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006240:	b2d9      	uxtb	r1, r3
 8006242:	693b      	ldr	r3, [r7, #16]
 8006244:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006248:	461a      	mov	r2, r3
 800624a:	2334      	movs	r3, #52	; 0x34
 800624c:	fb03 f302 	mul.w	r3, r3, r2
 8006250:	3398      	adds	r3, #152	; 0x98
 8006252:	693a      	ldr	r2, [r7, #16]
 8006254:	4413      	add	r3, r2
 8006256:	3307      	adds	r3, #7
 8006258:	461a      	mov	r2, r3
 800625a:	6878      	ldr	r0, [r7, #4]
 800625c:	f000 ff6a 	bl	8007134 <USBH_MSC_SCSI_Inquiry>
 8006260:	4603      	mov	r3, r0
 8006262:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 8006264:	7bfb      	ldrb	r3, [r7, #15]
 8006266:	2b00      	cmp	r3, #0
 8006268:	d10b      	bne.n	8006282 <USBH_MSC_Process+0x10e>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 800626a:	693b      	ldr	r3, [r7, #16]
 800626c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006270:	4619      	mov	r1, r3
 8006272:	693a      	ldr	r2, [r7, #16]
 8006274:	2334      	movs	r3, #52	; 0x34
 8006276:	fb03 f301 	mul.w	r3, r3, r1
 800627a:	4413      	add	r3, r2
 800627c:	3390      	adds	r3, #144	; 0x90
 800627e:	2202      	movs	r2, #2
 8006280:	701a      	strb	r2, [r3, #0]
            if (scsi_status == USBH_FAIL)
 8006282:	7bfb      	ldrb	r3, [r7, #15]
 8006284:	2b02      	cmp	r3, #2
 8006286:	d10c      	bne.n	80062a2 <USBH_MSC_Process+0x12e>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 8006288:	693b      	ldr	r3, [r7, #16]
 800628a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800628e:	4619      	mov	r1, r3
 8006290:	693a      	ldr	r2, [r7, #16]
 8006292:	2334      	movs	r3, #52	; 0x34
 8006294:	fb03 f301 	mul.w	r3, r3, r1
 8006298:	4413      	add	r3, r2
 800629a:	3390      	adds	r3, #144	; 0x90
 800629c:	2205      	movs	r2, #5
 800629e:	701a      	strb	r2, [r3, #0]
            break;
 80062a0:	e1e7      	b.n	8006672 <USBH_MSC_Process+0x4fe>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 80062a2:	7bfb      	ldrb	r3, [r7, #15]
 80062a4:	2b04      	cmp	r3, #4
 80062a6:	f040 81e4 	bne.w	8006672 <USBH_MSC_Process+0x4fe>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 80062aa:	693b      	ldr	r3, [r7, #16]
 80062ac:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80062b0:	4619      	mov	r1, r3
 80062b2:	693a      	ldr	r2, [r7, #16]
 80062b4:	2334      	movs	r3, #52	; 0x34
 80062b6:	fb03 f301 	mul.w	r3, r3, r1
 80062ba:	4413      	add	r3, r2
 80062bc:	3390      	adds	r3, #144	; 0x90
 80062be:	2201      	movs	r2, #1
 80062c0:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 80062c2:	693b      	ldr	r3, [r7, #16]
 80062c4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80062c8:	4619      	mov	r1, r3
 80062ca:	693a      	ldr	r2, [r7, #16]
 80062cc:	2334      	movs	r3, #52	; 0x34
 80062ce:	fb03 f301 	mul.w	r3, r3, r1
 80062d2:	4413      	add	r3, r2
 80062d4:	3391      	adds	r3, #145	; 0x91
 80062d6:	2202      	movs	r2, #2
 80062d8:	701a      	strb	r2, [r3, #0]
            break;
 80062da:	e1ca      	b.n	8006672 <USBH_MSC_Process+0x4fe>
            ready_status = USBH_MSC_SCSI_TestUnitReady(phost, (uint8_t)MSC_Handle->current_lun);
 80062dc:	693b      	ldr	r3, [r7, #16]
 80062de:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80062e2:	b2db      	uxtb	r3, r3
 80062e4:	4619      	mov	r1, r3
 80062e6:	6878      	ldr	r0, [r7, #4]
 80062e8:	f000 fe66 	bl	8006fb8 <USBH_MSC_SCSI_TestUnitReady>
 80062ec:	4603      	mov	r3, r0
 80062ee:	73bb      	strb	r3, [r7, #14]
            if (ready_status == USBH_OK)
 80062f0:	7bbb      	ldrb	r3, [r7, #14]
 80062f2:	2b00      	cmp	r3, #0
 80062f4:	d149      	bne.n	800638a <USBH_MSC_Process+0x216>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_OK)
 80062f6:	693b      	ldr	r3, [r7, #16]
 80062f8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80062fc:	4619      	mov	r1, r3
 80062fe:	693a      	ldr	r2, [r7, #16]
 8006300:	2334      	movs	r3, #52	; 0x34
 8006302:	fb03 f301 	mul.w	r3, r3, r1
 8006306:	4413      	add	r3, r2
 8006308:	3392      	adds	r3, #146	; 0x92
 800630a:	781b      	ldrb	r3, [r3, #0]
 800630c:	2b00      	cmp	r3, #0
 800630e:	d00c      	beq.n	800632a <USBH_MSC_Process+0x1b6>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 8006310:	693b      	ldr	r3, [r7, #16]
 8006312:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006316:	4619      	mov	r1, r3
 8006318:	693a      	ldr	r2, [r7, #16]
 800631a:	2334      	movs	r3, #52	; 0x34
 800631c:	fb03 f301 	mul.w	r3, r3, r1
 8006320:	4413      	add	r3, r2
 8006322:	33c1      	adds	r3, #193	; 0xc1
 8006324:	2201      	movs	r2, #1
 8006326:	701a      	strb	r2, [r3, #0]
 8006328:	e00b      	b.n	8006342 <USBH_MSC_Process+0x1ce>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 800632a:	693b      	ldr	r3, [r7, #16]
 800632c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006330:	4619      	mov	r1, r3
 8006332:	693a      	ldr	r2, [r7, #16]
 8006334:	2334      	movs	r3, #52	; 0x34
 8006336:	fb03 f301 	mul.w	r3, r3, r1
 800633a:	4413      	add	r3, r2
 800633c:	33c1      	adds	r3, #193	; 0xc1
 800633e:	2200      	movs	r2, #0
 8006340:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_READ_CAPACITY10;
 8006342:	693b      	ldr	r3, [r7, #16]
 8006344:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006348:	4619      	mov	r1, r3
 800634a:	693a      	ldr	r2, [r7, #16]
 800634c:	2334      	movs	r3, #52	; 0x34
 800634e:	fb03 f301 	mul.w	r3, r3, r1
 8006352:	4413      	add	r3, r2
 8006354:	3390      	adds	r3, #144	; 0x90
 8006356:	2203      	movs	r2, #3
 8006358:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 800635a:	693b      	ldr	r3, [r7, #16]
 800635c:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006360:	4619      	mov	r1, r3
 8006362:	693a      	ldr	r2, [r7, #16]
 8006364:	2334      	movs	r3, #52	; 0x34
 8006366:	fb03 f301 	mul.w	r3, r3, r1
 800636a:	4413      	add	r3, r2
 800636c:	3391      	adds	r3, #145	; 0x91
 800636e:	2200      	movs	r2, #0
 8006370:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_OK;
 8006372:	693b      	ldr	r3, [r7, #16]
 8006374:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006378:	4619      	mov	r1, r3
 800637a:	693a      	ldr	r2, [r7, #16]
 800637c:	2334      	movs	r3, #52	; 0x34
 800637e:	fb03 f301 	mul.w	r3, r3, r1
 8006382:	4413      	add	r3, r2
 8006384:	3392      	adds	r3, #146	; 0x92
 8006386:	2200      	movs	r2, #0
 8006388:	701a      	strb	r2, [r3, #0]
            if (ready_status == USBH_FAIL)
 800638a:	7bbb      	ldrb	r3, [r7, #14]
 800638c:	2b02      	cmp	r3, #2
 800638e:	d14a      	bne.n	8006426 <USBH_MSC_Process+0x2b2>
              if (MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state != USBH_FAIL)
 8006390:	693b      	ldr	r3, [r7, #16]
 8006392:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006396:	4619      	mov	r1, r3
 8006398:	693a      	ldr	r2, [r7, #16]
 800639a:	2334      	movs	r3, #52	; 0x34
 800639c:	fb03 f301 	mul.w	r3, r3, r1
 80063a0:	4413      	add	r3, r2
 80063a2:	3392      	adds	r3, #146	; 0x92
 80063a4:	781b      	ldrb	r3, [r3, #0]
 80063a6:	2b02      	cmp	r3, #2
 80063a8:	d00c      	beq.n	80063c4 <USBH_MSC_Process+0x250>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 1U;
 80063aa:	693b      	ldr	r3, [r7, #16]
 80063ac:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80063b0:	4619      	mov	r1, r3
 80063b2:	693a      	ldr	r2, [r7, #16]
 80063b4:	2334      	movs	r3, #52	; 0x34
 80063b6:	fb03 f301 	mul.w	r3, r3, r1
 80063ba:	4413      	add	r3, r2
 80063bc:	33c1      	adds	r3, #193	; 0xc1
 80063be:	2201      	movs	r2, #1
 80063c0:	701a      	strb	r2, [r3, #0]
 80063c2:	e00b      	b.n	80063dc <USBH_MSC_Process+0x268>
                MSC_Handle->unit[MSC_Handle->current_lun].state_changed = 0U;
 80063c4:	693b      	ldr	r3, [r7, #16]
 80063c6:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80063ca:	4619      	mov	r1, r3
 80063cc:	693a      	ldr	r2, [r7, #16]
 80063ce:	2334      	movs	r3, #52	; 0x34
 80063d0:	fb03 f301 	mul.w	r3, r3, r1
 80063d4:	4413      	add	r3, r2
 80063d6:	33c1      	adds	r3, #193	; 0xc1
 80063d8:	2200      	movs	r2, #0
 80063da:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80063dc:	693b      	ldr	r3, [r7, #16]
 80063de:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80063e2:	4619      	mov	r1, r3
 80063e4:	693a      	ldr	r2, [r7, #16]
 80063e6:	2334      	movs	r3, #52	; 0x34
 80063e8:	fb03 f301 	mul.w	r3, r3, r1
 80063ec:	4413      	add	r3, r2
 80063ee:	3390      	adds	r3, #144	; 0x90
 80063f0:	2205      	movs	r2, #5
 80063f2:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_NOT_READY;
 80063f4:	693b      	ldr	r3, [r7, #16]
 80063f6:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80063fa:	4619      	mov	r1, r3
 80063fc:	693a      	ldr	r2, [r7, #16]
 80063fe:	2334      	movs	r3, #52	; 0x34
 8006400:	fb03 f301 	mul.w	r3, r3, r1
 8006404:	4413      	add	r3, r2
 8006406:	3391      	adds	r3, #145	; 0x91
 8006408:	2201      	movs	r2, #1
 800640a:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].prev_ready_state = USBH_FAIL;
 800640c:	693b      	ldr	r3, [r7, #16]
 800640e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006412:	4619      	mov	r1, r3
 8006414:	693a      	ldr	r2, [r7, #16]
 8006416:	2334      	movs	r3, #52	; 0x34
 8006418:	fb03 f301 	mul.w	r3, r3, r1
 800641c:	4413      	add	r3, r2
 800641e:	3392      	adds	r3, #146	; 0x92
 8006420:	2202      	movs	r2, #2
 8006422:	701a      	strb	r2, [r3, #0]
            break;
 8006424:	e127      	b.n	8006676 <USBH_MSC_Process+0x502>
              if (ready_status == USBH_UNRECOVERED_ERROR)
 8006426:	7bbb      	ldrb	r3, [r7, #14]
 8006428:	2b04      	cmp	r3, #4
 800642a:	f040 8124 	bne.w	8006676 <USBH_MSC_Process+0x502>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800642e:	693b      	ldr	r3, [r7, #16]
 8006430:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006434:	4619      	mov	r1, r3
 8006436:	693a      	ldr	r2, [r7, #16]
 8006438:	2334      	movs	r3, #52	; 0x34
 800643a:	fb03 f301 	mul.w	r3, r3, r1
 800643e:	4413      	add	r3, r2
 8006440:	3390      	adds	r3, #144	; 0x90
 8006442:	2201      	movs	r2, #1
 8006444:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 8006446:	693b      	ldr	r3, [r7, #16]
 8006448:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800644c:	4619      	mov	r1, r3
 800644e:	693a      	ldr	r2, [r7, #16]
 8006450:	2334      	movs	r3, #52	; 0x34
 8006452:	fb03 f301 	mul.w	r3, r3, r1
 8006456:	4413      	add	r3, r2
 8006458:	3391      	adds	r3, #145	; 0x91
 800645a:	2202      	movs	r2, #2
 800645c:	701a      	strb	r2, [r3, #0]
            break;
 800645e:	e10a      	b.n	8006676 <USBH_MSC_Process+0x502>
            scsi_status = USBH_MSC_SCSI_ReadCapacity(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].capacity) ;
 8006460:	693b      	ldr	r3, [r7, #16]
 8006462:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006466:	b2d9      	uxtb	r1, r3
 8006468:	693b      	ldr	r3, [r7, #16]
 800646a:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800646e:	461a      	mov	r2, r3
 8006470:	2334      	movs	r3, #52	; 0x34
 8006472:	fb03 f302 	mul.w	r3, r3, r2
 8006476:	3390      	adds	r3, #144	; 0x90
 8006478:	693a      	ldr	r2, [r7, #16]
 800647a:	4413      	add	r3, r2
 800647c:	3304      	adds	r3, #4
 800647e:	461a      	mov	r2, r3
 8006480:	6878      	ldr	r0, [r7, #4]
 8006482:	f000 fddc 	bl	800703e <USBH_MSC_SCSI_ReadCapacity>
 8006486:	4603      	mov	r3, r0
 8006488:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 800648a:	7bfb      	ldrb	r3, [r7, #15]
 800648c:	2b00      	cmp	r3, #0
 800648e:	d120      	bne.n	80064d2 <USBH_MSC_Process+0x35e>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 8006490:	693b      	ldr	r3, [r7, #16]
 8006492:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006496:	4619      	mov	r1, r3
 8006498:	693a      	ldr	r2, [r7, #16]
 800649a:	2334      	movs	r3, #52	; 0x34
 800649c:	fb03 f301 	mul.w	r3, r3, r1
 80064a0:	4413      	add	r3, r2
 80064a2:	3390      	adds	r3, #144	; 0x90
 80064a4:	2201      	movs	r2, #1
 80064a6:	701a      	strb	r2, [r3, #0]
              MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_OK;
 80064a8:	693b      	ldr	r3, [r7, #16]
 80064aa:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80064ae:	4619      	mov	r1, r3
 80064b0:	693a      	ldr	r2, [r7, #16]
 80064b2:	2334      	movs	r3, #52	; 0x34
 80064b4:	fb03 f301 	mul.w	r3, r3, r1
 80064b8:	4413      	add	r3, r2
 80064ba:	3391      	adds	r3, #145	; 0x91
 80064bc:	2200      	movs	r2, #0
 80064be:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 80064c0:	693b      	ldr	r3, [r7, #16]
 80064c2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80064c6:	3301      	adds	r3, #1
 80064c8:	b29a      	uxth	r2, r3
 80064ca:	693b      	ldr	r3, [r7, #16]
 80064cc:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8
            break;
 80064d0:	e0d3      	b.n	800667a <USBH_MSC_Process+0x506>
            else if (scsi_status == USBH_FAIL)
 80064d2:	7bfb      	ldrb	r3, [r7, #15]
 80064d4:	2b02      	cmp	r3, #2
 80064d6:	d10c      	bne.n	80064f2 <USBH_MSC_Process+0x37e>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_REQUEST_SENSE;
 80064d8:	693b      	ldr	r3, [r7, #16]
 80064da:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80064de:	4619      	mov	r1, r3
 80064e0:	693a      	ldr	r2, [r7, #16]
 80064e2:	2334      	movs	r3, #52	; 0x34
 80064e4:	fb03 f301 	mul.w	r3, r3, r1
 80064e8:	4413      	add	r3, r2
 80064ea:	3390      	adds	r3, #144	; 0x90
 80064ec:	2205      	movs	r2, #5
 80064ee:	701a      	strb	r2, [r3, #0]
            break;
 80064f0:	e0c3      	b.n	800667a <USBH_MSC_Process+0x506>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 80064f2:	7bfb      	ldrb	r3, [r7, #15]
 80064f4:	2b04      	cmp	r3, #4
 80064f6:	f040 80c0 	bne.w	800667a <USBH_MSC_Process+0x506>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 80064fa:	693b      	ldr	r3, [r7, #16]
 80064fc:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006500:	4619      	mov	r1, r3
 8006502:	693a      	ldr	r2, [r7, #16]
 8006504:	2334      	movs	r3, #52	; 0x34
 8006506:	fb03 f301 	mul.w	r3, r3, r1
 800650a:	4413      	add	r3, r2
 800650c:	3390      	adds	r3, #144	; 0x90
 800650e:	2201      	movs	r2, #1
 8006510:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 8006512:	693b      	ldr	r3, [r7, #16]
 8006514:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006518:	4619      	mov	r1, r3
 800651a:	693a      	ldr	r2, [r7, #16]
 800651c:	2334      	movs	r3, #52	; 0x34
 800651e:	fb03 f301 	mul.w	r3, r3, r1
 8006522:	4413      	add	r3, r2
 8006524:	3391      	adds	r3, #145	; 0x91
 8006526:	2202      	movs	r2, #2
 8006528:	701a      	strb	r2, [r3, #0]
            break;
 800652a:	e0a6      	b.n	800667a <USBH_MSC_Process+0x506>
            scsi_status = USBH_MSC_SCSI_RequestSense(phost, (uint8_t)MSC_Handle->current_lun, &MSC_Handle->unit[MSC_Handle->current_lun].sense);
 800652c:	693b      	ldr	r3, [r7, #16]
 800652e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006532:	b2d9      	uxtb	r1, r3
 8006534:	693b      	ldr	r3, [r7, #16]
 8006536:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800653a:	461a      	mov	r2, r3
 800653c:	2334      	movs	r3, #52	; 0x34
 800653e:	fb03 f302 	mul.w	r3, r3, r2
 8006542:	3398      	adds	r3, #152	; 0x98
 8006544:	693a      	ldr	r2, [r7, #16]
 8006546:	4413      	add	r3, r2
 8006548:	3304      	adds	r3, #4
 800654a:	461a      	mov	r2, r3
 800654c:	6878      	ldr	r0, [r7, #4]
 800654e:	f000 fe96 	bl	800727e <USBH_MSC_SCSI_RequestSense>
 8006552:	4603      	mov	r3, r0
 8006554:	73fb      	strb	r3, [r7, #15]
            if (scsi_status == USBH_OK)
 8006556:	7bfb      	ldrb	r3, [r7, #15]
 8006558:	2b00      	cmp	r3, #0
 800655a:	d145      	bne.n	80065e8 <USBH_MSC_Process+0x474>
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800655c:	693b      	ldr	r3, [r7, #16]
 800655e:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006562:	4619      	mov	r1, r3
 8006564:	693a      	ldr	r2, [r7, #16]
 8006566:	2334      	movs	r3, #52	; 0x34
 8006568:	fb03 f301 	mul.w	r3, r3, r1
 800656c:	4413      	add	r3, r2
 800656e:	339c      	adds	r3, #156	; 0x9c
 8006570:	781b      	ldrb	r3, [r3, #0]
 8006572:	2b06      	cmp	r3, #6
 8006574:	d00c      	beq.n	8006590 <USBH_MSC_Process+0x41c>
                  (MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_NOT_READY))
 8006576:	693b      	ldr	r3, [r7, #16]
 8006578:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800657c:	4619      	mov	r1, r3
 800657e:	693a      	ldr	r2, [r7, #16]
 8006580:	2334      	movs	r3, #52	; 0x34
 8006582:	fb03 f301 	mul.w	r3, r3, r1
 8006586:	4413      	add	r3, r2
 8006588:	339c      	adds	r3, #156	; 0x9c
 800658a:	781b      	ldrb	r3, [r3, #0]
              if ((MSC_Handle->unit[MSC_Handle->current_lun].sense.key == SCSI_SENSE_KEY_UNIT_ATTENTION) ||
 800658c:	2b02      	cmp	r3, #2
 800658e:	d117      	bne.n	80065c0 <USBH_MSC_Process+0x44c>
                if ((phost->Timer - MSC_Handle->timer) < 10000U)
 8006590:	687b      	ldr	r3, [r7, #4]
 8006592:	f8d3 23c4 	ldr.w	r2, [r3, #964]	; 0x3c4
 8006596:	693b      	ldr	r3, [r7, #16]
 8006598:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800659c:	1ad3      	subs	r3, r2, r3
 800659e:	f242 720f 	movw	r2, #9999	; 0x270f
 80065a2:	4293      	cmp	r3, r2
 80065a4:	d80c      	bhi.n	80065c0 <USBH_MSC_Process+0x44c>
                  MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_TEST_UNIT_READY;
 80065a6:	693b      	ldr	r3, [r7, #16]
 80065a8:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80065ac:	4619      	mov	r1, r3
 80065ae:	693a      	ldr	r2, [r7, #16]
 80065b0:	2334      	movs	r3, #52	; 0x34
 80065b2:	fb03 f301 	mul.w	r3, r3, r1
 80065b6:	4413      	add	r3, r2
 80065b8:	3390      	adds	r3, #144	; 0x90
 80065ba:	2202      	movs	r2, #2
 80065bc:	701a      	strb	r2, [r3, #0]
                  break;
 80065be:	e05f      	b.n	8006680 <USBH_MSC_Process+0x50c>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 80065c0:	693b      	ldr	r3, [r7, #16]
 80065c2:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80065c6:	4619      	mov	r1, r3
 80065c8:	693a      	ldr	r2, [r7, #16]
 80065ca:	2334      	movs	r3, #52	; 0x34
 80065cc:	fb03 f301 	mul.w	r3, r3, r1
 80065d0:	4413      	add	r3, r2
 80065d2:	3390      	adds	r3, #144	; 0x90
 80065d4:	2201      	movs	r2, #1
 80065d6:	701a      	strb	r2, [r3, #0]
              MSC_Handle->current_lun++;
 80065d8:	693b      	ldr	r3, [r7, #16]
 80065da:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80065de:	3301      	adds	r3, #1
 80065e0:	b29a      	uxth	r2, r3
 80065e2:	693b      	ldr	r3, [r7, #16]
 80065e4:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8
            if (scsi_status == USBH_FAIL)
 80065e8:	7bfb      	ldrb	r3, [r7, #15]
 80065ea:	2b02      	cmp	r3, #2
 80065ec:	d10c      	bne.n	8006608 <USBH_MSC_Process+0x494>
              MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_UNRECOVERED_ERROR;
 80065ee:	693b      	ldr	r3, [r7, #16]
 80065f0:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 80065f4:	4619      	mov	r1, r3
 80065f6:	693a      	ldr	r2, [r7, #16]
 80065f8:	2334      	movs	r3, #52	; 0x34
 80065fa:	fb03 f301 	mul.w	r3, r3, r1
 80065fe:	4413      	add	r3, r2
 8006600:	3390      	adds	r3, #144	; 0x90
 8006602:	2208      	movs	r2, #8
 8006604:	701a      	strb	r2, [r3, #0]
            break;
 8006606:	e03a      	b.n	800667e <USBH_MSC_Process+0x50a>
              if (scsi_status == USBH_UNRECOVERED_ERROR)
 8006608:	7bfb      	ldrb	r3, [r7, #15]
 800660a:	2b04      	cmp	r3, #4
 800660c:	d137      	bne.n	800667e <USBH_MSC_Process+0x50a>
                MSC_Handle->unit[MSC_Handle->current_lun].state = MSC_IDLE;
 800660e:	693b      	ldr	r3, [r7, #16]
 8006610:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006614:	4619      	mov	r1, r3
 8006616:	693a      	ldr	r2, [r7, #16]
 8006618:	2334      	movs	r3, #52	; 0x34
 800661a:	fb03 f301 	mul.w	r3, r3, r1
 800661e:	4413      	add	r3, r2
 8006620:	3390      	adds	r3, #144	; 0x90
 8006622:	2201      	movs	r2, #1
 8006624:	701a      	strb	r2, [r3, #0]
                MSC_Handle->unit[MSC_Handle->current_lun].error = MSC_ERROR;
 8006626:	693b      	ldr	r3, [r7, #16]
 8006628:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 800662c:	4619      	mov	r1, r3
 800662e:	693a      	ldr	r2, [r7, #16]
 8006630:	2334      	movs	r3, #52	; 0x34
 8006632:	fb03 f301 	mul.w	r3, r3, r1
 8006636:	4413      	add	r3, r2
 8006638:	3391      	adds	r3, #145	; 0x91
 800663a:	2202      	movs	r2, #2
 800663c:	701a      	strb	r2, [r3, #0]
            break;
 800663e:	e01e      	b.n	800667e <USBH_MSC_Process+0x50a>
            MSC_Handle->current_lun++;
 8006640:	693b      	ldr	r3, [r7, #16]
 8006642:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 8006646:	3301      	adds	r3, #1
 8006648:	b29a      	uxth	r2, r3
 800664a:	693b      	ldr	r3, [r7, #16]
 800664c:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8
            break;
 8006650:	e016      	b.n	8006680 <USBH_MSC_Process+0x50c>
        MSC_Handle->current_lun = 0U;
 8006652:	693b      	ldr	r3, [r7, #16]
 8006654:	2200      	movs	r2, #0
 8006656:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8
        MSC_Handle->state = MSC_IDLE;
 800665a:	693b      	ldr	r3, [r7, #16]
 800665c:	2201      	movs	r2, #1
 800665e:	731a      	strb	r2, [r3, #12]
        phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 8006660:	687b      	ldr	r3, [r7, #4]
 8006662:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8006666:	2102      	movs	r1, #2
 8006668:	6878      	ldr	r0, [r7, #4]
 800666a:	4798      	blx	r3
      break;
 800666c:	e00c      	b.n	8006688 <USBH_MSC_Process+0x514>
            break;
 800666e:	bf00      	nop
 8006670:	e00a      	b.n	8006688 <USBH_MSC_Process+0x514>
            break;
 8006672:	bf00      	nop
 8006674:	e008      	b.n	8006688 <USBH_MSC_Process+0x514>
            break;
 8006676:	bf00      	nop
 8006678:	e006      	b.n	8006688 <USBH_MSC_Process+0x514>
            break;
 800667a:	bf00      	nop
 800667c:	e004      	b.n	8006688 <USBH_MSC_Process+0x514>
            break;
 800667e:	bf00      	nop
      break;
 8006680:	e002      	b.n	8006688 <USBH_MSC_Process+0x514>
      error = USBH_OK;
 8006682:	2300      	movs	r3, #0
 8006684:	75fb      	strb	r3, [r7, #23]
      break;
 8006686:	bf00      	nop
  }
  return error;
 8006688:	7dfb      	ldrb	r3, [r7, #23]
}
 800668a:	4618      	mov	r0, r3
 800668c:	3718      	adds	r7, #24
 800668e:	46bd      	mov	sp, r7
 8006690:	bd80      	pop	{r7, pc}
 8006692:	bf00      	nop

08006694 <USBH_MSC_SOFProcess>:
  *         The function is for SOF state
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_SOFProcess(USBH_HandleTypeDef *phost)
{
 8006694:	b480      	push	{r7}
 8006696:	b083      	sub	sp, #12
 8006698:	af00      	add	r7, sp, #0
 800669a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phost);

  return USBH_OK;
 800669c:	2300      	movs	r3, #0
}
 800669e:	4618      	mov	r0, r3
 80066a0:	370c      	adds	r7, #12
 80066a2:	46bd      	mov	sp, r7
 80066a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a8:	4770      	bx	lr

080066aa <USBH_MSC_RdWrProcess>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_RdWrProcess(USBH_HandleTypeDef *phost, uint8_t lun)
{
 80066aa:	b580      	push	{r7, lr}
 80066ac:	b088      	sub	sp, #32
 80066ae:	af02      	add	r7, sp, #8
 80066b0:	6078      	str	r0, [r7, #4]
 80066b2:	460b      	mov	r3, r1
 80066b4:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80066b6:	687b      	ldr	r3, [r7, #4]
 80066b8:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80066bc:	69db      	ldr	r3, [r3, #28]
 80066be:	613b      	str	r3, [r7, #16]
  USBH_StatusTypeDef error = USBH_BUSY ;
 80066c0:	2301      	movs	r3, #1
 80066c2:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef scsi_status = USBH_BUSY ;
 80066c4:	2301      	movs	r3, #1
 80066c6:	73fb      	strb	r3, [r7, #15]

  /* Switch MSC REQ state machine */
  switch (MSC_Handle->unit[lun].state)
 80066c8:	78fb      	ldrb	r3, [r7, #3]
 80066ca:	693a      	ldr	r2, [r7, #16]
 80066cc:	2134      	movs	r1, #52	; 0x34
 80066ce:	fb01 f303 	mul.w	r3, r1, r3
 80066d2:	4413      	add	r3, r2
 80066d4:	3390      	adds	r3, #144	; 0x90
 80066d6:	781b      	ldrb	r3, [r3, #0]
 80066d8:	2b07      	cmp	r3, #7
 80066da:	d03c      	beq.n	8006756 <USBH_MSC_RdWrProcess+0xac>
 80066dc:	2b07      	cmp	r3, #7
 80066de:	f300 80a7 	bgt.w	8006830 <USBH_MSC_RdWrProcess+0x186>
 80066e2:	2b05      	cmp	r3, #5
 80066e4:	d06c      	beq.n	80067c0 <USBH_MSC_RdWrProcess+0x116>
 80066e6:	2b06      	cmp	r3, #6
 80066e8:	f040 80a2 	bne.w	8006830 <USBH_MSC_RdWrProcess+0x186>
  {

    case MSC_READ:
      scsi_status = USBH_MSC_SCSI_Read(phost, lun, 0U, NULL, 0U);
 80066ec:	78f9      	ldrb	r1, [r7, #3]
 80066ee:	2300      	movs	r3, #0
 80066f0:	9300      	str	r3, [sp, #0]
 80066f2:	2300      	movs	r3, #0
 80066f4:	2200      	movs	r2, #0
 80066f6:	6878      	ldr	r0, [r7, #4]
 80066f8:	f000 fea5 	bl	8007446 <USBH_MSC_SCSI_Read>
 80066fc:	4603      	mov	r3, r0
 80066fe:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 8006700:	7bfb      	ldrb	r3, [r7, #15]
 8006702:	2b00      	cmp	r3, #0
 8006704:	d10b      	bne.n	800671e <USBH_MSC_RdWrProcess+0x74>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 8006706:	78fb      	ldrb	r3, [r7, #3]
 8006708:	693a      	ldr	r2, [r7, #16]
 800670a:	2134      	movs	r1, #52	; 0x34
 800670c:	fb01 f303 	mul.w	r3, r1, r3
 8006710:	4413      	add	r3, r2
 8006712:	3390      	adds	r3, #144	; 0x90
 8006714:	2201      	movs	r2, #1
 8006716:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 8006718:	2300      	movs	r3, #0
 800671a:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 800671c:	e08a      	b.n	8006834 <USBH_MSC_RdWrProcess+0x18a>
      else if (scsi_status == USBH_FAIL)
 800671e:	7bfb      	ldrb	r3, [r7, #15]
 8006720:	2b02      	cmp	r3, #2
 8006722:	d109      	bne.n	8006738 <USBH_MSC_RdWrProcess+0x8e>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 8006724:	78fb      	ldrb	r3, [r7, #3]
 8006726:	693a      	ldr	r2, [r7, #16]
 8006728:	2134      	movs	r1, #52	; 0x34
 800672a:	fb01 f303 	mul.w	r3, r1, r3
 800672e:	4413      	add	r3, r2
 8006730:	3390      	adds	r3, #144	; 0x90
 8006732:	2205      	movs	r2, #5
 8006734:	701a      	strb	r2, [r3, #0]
      break;
 8006736:	e07d      	b.n	8006834 <USBH_MSC_RdWrProcess+0x18a>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 8006738:	7bfb      	ldrb	r3, [r7, #15]
 800673a:	2b04      	cmp	r3, #4
 800673c:	d17a      	bne.n	8006834 <USBH_MSC_RdWrProcess+0x18a>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 800673e:	78fb      	ldrb	r3, [r7, #3]
 8006740:	693a      	ldr	r2, [r7, #16]
 8006742:	2134      	movs	r1, #52	; 0x34
 8006744:	fb01 f303 	mul.w	r3, r1, r3
 8006748:	4413      	add	r3, r2
 800674a:	3390      	adds	r3, #144	; 0x90
 800674c:	2208      	movs	r2, #8
 800674e:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 8006750:	2302      	movs	r3, #2
 8006752:	75fb      	strb	r3, [r7, #23]
      break;
 8006754:	e06e      	b.n	8006834 <USBH_MSC_RdWrProcess+0x18a>

    case MSC_WRITE:
      scsi_status = USBH_MSC_SCSI_Write(phost, lun, 0U, NULL, 0U);
 8006756:	78f9      	ldrb	r1, [r7, #3]
 8006758:	2300      	movs	r3, #0
 800675a:	9300      	str	r3, [sp, #0]
 800675c:	2300      	movs	r3, #0
 800675e:	2200      	movs	r2, #0
 8006760:	6878      	ldr	r0, [r7, #4]
 8006762:	f000 fe05 	bl	8007370 <USBH_MSC_SCSI_Write>
 8006766:	4603      	mov	r3, r0
 8006768:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 800676a:	7bfb      	ldrb	r3, [r7, #15]
 800676c:	2b00      	cmp	r3, #0
 800676e:	d10b      	bne.n	8006788 <USBH_MSC_RdWrProcess+0xde>
      {
        MSC_Handle->unit[lun].state = MSC_IDLE;
 8006770:	78fb      	ldrb	r3, [r7, #3]
 8006772:	693a      	ldr	r2, [r7, #16]
 8006774:	2134      	movs	r1, #52	; 0x34
 8006776:	fb01 f303 	mul.w	r3, r1, r3
 800677a:	4413      	add	r3, r2
 800677c:	3390      	adds	r3, #144	; 0x90
 800677e:	2201      	movs	r2, #1
 8006780:	701a      	strb	r2, [r3, #0]
        error = USBH_OK;
 8006782:	2300      	movs	r3, #0
 8006784:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8006786:	e057      	b.n	8006838 <USBH_MSC_RdWrProcess+0x18e>
      else if (scsi_status == USBH_FAIL)
 8006788:	7bfb      	ldrb	r3, [r7, #15]
 800678a:	2b02      	cmp	r3, #2
 800678c:	d109      	bne.n	80067a2 <USBH_MSC_RdWrProcess+0xf8>
        MSC_Handle->unit[lun].state = MSC_REQUEST_SENSE;
 800678e:	78fb      	ldrb	r3, [r7, #3]
 8006790:	693a      	ldr	r2, [r7, #16]
 8006792:	2134      	movs	r1, #52	; 0x34
 8006794:	fb01 f303 	mul.w	r3, r1, r3
 8006798:	4413      	add	r3, r2
 800679a:	3390      	adds	r3, #144	; 0x90
 800679c:	2205      	movs	r2, #5
 800679e:	701a      	strb	r2, [r3, #0]
      break;
 80067a0:	e04a      	b.n	8006838 <USBH_MSC_RdWrProcess+0x18e>
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 80067a2:	7bfb      	ldrb	r3, [r7, #15]
 80067a4:	2b04      	cmp	r3, #4
 80067a6:	d147      	bne.n	8006838 <USBH_MSC_RdWrProcess+0x18e>
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 80067a8:	78fb      	ldrb	r3, [r7, #3]
 80067aa:	693a      	ldr	r2, [r7, #16]
 80067ac:	2134      	movs	r1, #52	; 0x34
 80067ae:	fb01 f303 	mul.w	r3, r1, r3
 80067b2:	4413      	add	r3, r2
 80067b4:	3390      	adds	r3, #144	; 0x90
 80067b6:	2208      	movs	r2, #8
 80067b8:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 80067ba:	2302      	movs	r3, #2
 80067bc:	75fb      	strb	r3, [r7, #23]
      break;
 80067be:	e03b      	b.n	8006838 <USBH_MSC_RdWrProcess+0x18e>

    case MSC_REQUEST_SENSE:
      scsi_status = USBH_MSC_SCSI_RequestSense(phost, lun, &MSC_Handle->unit[lun].sense);
 80067c0:	78fb      	ldrb	r3, [r7, #3]
 80067c2:	2234      	movs	r2, #52	; 0x34
 80067c4:	fb02 f303 	mul.w	r3, r2, r3
 80067c8:	3398      	adds	r3, #152	; 0x98
 80067ca:	693a      	ldr	r2, [r7, #16]
 80067cc:	4413      	add	r3, r2
 80067ce:	1d1a      	adds	r2, r3, #4
 80067d0:	78fb      	ldrb	r3, [r7, #3]
 80067d2:	4619      	mov	r1, r3
 80067d4:	6878      	ldr	r0, [r7, #4]
 80067d6:	f000 fd52 	bl	800727e <USBH_MSC_SCSI_RequestSense>
 80067da:	4603      	mov	r3, r0
 80067dc:	73fb      	strb	r3, [r7, #15]

      if (scsi_status == USBH_OK)
 80067de:	7bfb      	ldrb	r3, [r7, #15]
 80067e0:	2b00      	cmp	r3, #0
 80067e2:	d113      	bne.n	800680c <USBH_MSC_RdWrProcess+0x162>
      {
        USBH_UsrLog("Sense Key  : %x", MSC_Handle->unit[lun].sense.key);
        USBH_UsrLog("Additional Sense Code : %x", MSC_Handle->unit[lun].sense.asc);
        USBH_UsrLog("Additional Sense Code Qualifier: %x", MSC_Handle->unit[lun].sense.ascq);
        MSC_Handle->unit[lun].state = MSC_IDLE;
 80067e4:	78fb      	ldrb	r3, [r7, #3]
 80067e6:	693a      	ldr	r2, [r7, #16]
 80067e8:	2134      	movs	r1, #52	; 0x34
 80067ea:	fb01 f303 	mul.w	r3, r1, r3
 80067ee:	4413      	add	r3, r2
 80067f0:	3390      	adds	r3, #144	; 0x90
 80067f2:	2201      	movs	r2, #1
 80067f4:	701a      	strb	r2, [r3, #0]
        MSC_Handle->unit[lun].error = MSC_ERROR;
 80067f6:	78fb      	ldrb	r3, [r7, #3]
 80067f8:	693a      	ldr	r2, [r7, #16]
 80067fa:	2134      	movs	r1, #52	; 0x34
 80067fc:	fb01 f303 	mul.w	r3, r1, r3
 8006800:	4413      	add	r3, r2
 8006802:	3391      	adds	r3, #145	; 0x91
 8006804:	2202      	movs	r2, #2
 8006806:	701a      	strb	r2, [r3, #0]

        error = USBH_FAIL;
 8006808:	2302      	movs	r3, #2
 800680a:	75fb      	strb	r3, [r7, #23]
      }
      if (scsi_status == USBH_FAIL)
 800680c:	7bfb      	ldrb	r3, [r7, #15]
 800680e:	2b02      	cmp	r3, #2
 8006810:	d014      	beq.n	800683c <USBH_MSC_RdWrProcess+0x192>
      {
        USBH_UsrLog("MSC Device NOT ready");
      }
      else
      {
        if (scsi_status == USBH_UNRECOVERED_ERROR)
 8006812:	7bfb      	ldrb	r3, [r7, #15]
 8006814:	2b04      	cmp	r3, #4
 8006816:	d111      	bne.n	800683c <USBH_MSC_RdWrProcess+0x192>
        {
          MSC_Handle->unit[lun].state = MSC_UNRECOVERED_ERROR;
 8006818:	78fb      	ldrb	r3, [r7, #3]
 800681a:	693a      	ldr	r2, [r7, #16]
 800681c:	2134      	movs	r1, #52	; 0x34
 800681e:	fb01 f303 	mul.w	r3, r1, r3
 8006822:	4413      	add	r3, r2
 8006824:	3390      	adds	r3, #144	; 0x90
 8006826:	2208      	movs	r2, #8
 8006828:	701a      	strb	r2, [r3, #0]
          error = USBH_FAIL;
 800682a:	2302      	movs	r3, #2
 800682c:	75fb      	strb	r3, [r7, #23]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 800682e:	e005      	b.n	800683c <USBH_MSC_RdWrProcess+0x192>

    default:
      break;
 8006830:	bf00      	nop
 8006832:	e004      	b.n	800683e <USBH_MSC_RdWrProcess+0x194>
      break;
 8006834:	bf00      	nop
 8006836:	e002      	b.n	800683e <USBH_MSC_RdWrProcess+0x194>
      break;
 8006838:	bf00      	nop
 800683a:	e000      	b.n	800683e <USBH_MSC_RdWrProcess+0x194>
      break;
 800683c:	bf00      	nop

  }
  return error;
 800683e:	7dfb      	ldrb	r3, [r7, #23]
}
 8006840:	4618      	mov	r0, r3
 8006842:	3718      	adds	r7, #24
 8006844:	46bd      	mov	sp, r7
 8006846:	bd80      	pop	{r7, pc}

08006848 <USBH_MSC_UnitIsReady>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval Lun status (0: not ready / 1: ready)
  */
uint8_t  USBH_MSC_UnitIsReady(USBH_HandleTypeDef *phost, uint8_t lun)
{
 8006848:	b480      	push	{r7}
 800684a:	b085      	sub	sp, #20
 800684c:	af00      	add	r7, sp, #0
 800684e:	6078      	str	r0, [r7, #4]
 8006850:	460b      	mov	r3, r1
 8006852:	70fb      	strb	r3, [r7, #3]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006854:	687b      	ldr	r3, [r7, #4]
 8006856:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800685a:	69db      	ldr	r3, [r3, #28]
 800685c:	60bb      	str	r3, [r7, #8]
  uint8_t res;

  if ((phost->gState == HOST_CLASS) && (MSC_Handle->unit[lun].error == MSC_OK))
 800685e:	687b      	ldr	r3, [r7, #4]
 8006860:	781b      	ldrb	r3, [r3, #0]
 8006862:	b2db      	uxtb	r3, r3
 8006864:	2b0b      	cmp	r3, #11
 8006866:	d10c      	bne.n	8006882 <USBH_MSC_UnitIsReady+0x3a>
 8006868:	78fb      	ldrb	r3, [r7, #3]
 800686a:	68ba      	ldr	r2, [r7, #8]
 800686c:	2134      	movs	r1, #52	; 0x34
 800686e:	fb01 f303 	mul.w	r3, r1, r3
 8006872:	4413      	add	r3, r2
 8006874:	3391      	adds	r3, #145	; 0x91
 8006876:	781b      	ldrb	r3, [r3, #0]
 8006878:	2b00      	cmp	r3, #0
 800687a:	d102      	bne.n	8006882 <USBH_MSC_UnitIsReady+0x3a>
  {
    res = 1U;
 800687c:	2301      	movs	r3, #1
 800687e:	73fb      	strb	r3, [r7, #15]
 8006880:	e001      	b.n	8006886 <USBH_MSC_UnitIsReady+0x3e>
  }
  else
  {
    res = 0U;
 8006882:	2300      	movs	r3, #0
 8006884:	73fb      	strb	r3, [r7, #15]
  }

  return res;
 8006886:	7bfb      	ldrb	r3, [r7, #15]
}
 8006888:	4618      	mov	r0, r3
 800688a:	3714      	adds	r7, #20
 800688c:	46bd      	mov	sp, r7
 800688e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006892:	4770      	bx	lr

08006894 <USBH_MSC_GetLUNInfo>:
  * @param  phost: Host handle
  * @param  lun: logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_GetLUNInfo(USBH_HandleTypeDef *phost, uint8_t lun, MSC_LUNTypeDef *info)
{
 8006894:	b580      	push	{r7, lr}
 8006896:	b086      	sub	sp, #24
 8006898:	af00      	add	r7, sp, #0
 800689a:	60f8      	str	r0, [r7, #12]
 800689c:	460b      	mov	r3, r1
 800689e:	607a      	str	r2, [r7, #4]
 80068a0:	72fb      	strb	r3, [r7, #11]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80068a2:	68fb      	ldr	r3, [r7, #12]
 80068a4:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80068a8:	69db      	ldr	r3, [r3, #28]
 80068aa:	617b      	str	r3, [r7, #20]
  if (phost->gState == HOST_CLASS)
 80068ac:	68fb      	ldr	r3, [r7, #12]
 80068ae:	781b      	ldrb	r3, [r3, #0]
 80068b0:	b2db      	uxtb	r3, r3
 80068b2:	2b0b      	cmp	r3, #11
 80068b4:	d10d      	bne.n	80068d2 <USBH_MSC_GetLUNInfo+0x3e>
  {
    USBH_memcpy(info, &MSC_Handle->unit[lun], sizeof(MSC_LUNTypeDef));
 80068b6:	7afb      	ldrb	r3, [r7, #11]
 80068b8:	2234      	movs	r2, #52	; 0x34
 80068ba:	fb02 f303 	mul.w	r3, r2, r3
 80068be:	3390      	adds	r3, #144	; 0x90
 80068c0:	697a      	ldr	r2, [r7, #20]
 80068c2:	4413      	add	r3, r2
 80068c4:	2234      	movs	r2, #52	; 0x34
 80068c6:	4619      	mov	r1, r3
 80068c8:	6878      	ldr	r0, [r7, #4]
 80068ca:	f021 fccb 	bl	8028264 <memcpy>
    return USBH_OK;
 80068ce:	2300      	movs	r3, #0
 80068d0:	e000      	b.n	80068d4 <USBH_MSC_GetLUNInfo+0x40>
  }
  else
  {
    return USBH_FAIL;
 80068d2:	2302      	movs	r3, #2
  }
}
 80068d4:	4618      	mov	r0, r3
 80068d6:	3718      	adds	r7, #24
 80068d8:	46bd      	mov	sp, r7
 80068da:	bd80      	pop	{r7, pc}

080068dc <USBH_MSC_Read>:
USBH_StatusTypeDef USBH_MSC_Read(USBH_HandleTypeDef *phost,
                                 uint8_t lun,
                                 uint32_t address,
                                 uint8_t *pbuf,
                                 uint32_t length)
{
 80068dc:	b580      	push	{r7, lr}
 80068de:	b088      	sub	sp, #32
 80068e0:	af02      	add	r7, sp, #8
 80068e2:	60f8      	str	r0, [r7, #12]
 80068e4:	607a      	str	r2, [r7, #4]
 80068e6:	603b      	str	r3, [r7, #0]
 80068e8:	460b      	mov	r3, r1
 80068ea:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80068ec:	68fb      	ldr	r3, [r7, #12]
 80068ee:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80068f2:	69db      	ldr	r3, [r3, #28]
 80068f4:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 80068f6:	68fb      	ldr	r3, [r7, #12]
 80068f8:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 80068fc:	b2db      	uxtb	r3, r3
 80068fe:	2b00      	cmp	r3, #0
 8006900:	d00e      	beq.n	8006920 <USBH_MSC_Read+0x44>
      (phost->gState != HOST_CLASS) ||
 8006902:	68fb      	ldr	r3, [r7, #12]
 8006904:	781b      	ldrb	r3, [r3, #0]
 8006906:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 8006908:	2b0b      	cmp	r3, #11
 800690a:	d109      	bne.n	8006920 <USBH_MSC_Read+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 800690c:	7afb      	ldrb	r3, [r7, #11]
 800690e:	697a      	ldr	r2, [r7, #20]
 8006910:	2134      	movs	r1, #52	; 0x34
 8006912:	fb01 f303 	mul.w	r3, r1, r3
 8006916:	4413      	add	r3, r2
 8006918:	3390      	adds	r3, #144	; 0x90
 800691a:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 800691c:	2b01      	cmp	r3, #1
 800691e:	d001      	beq.n	8006924 <USBH_MSC_Read+0x48>
  {
    return  USBH_FAIL;
 8006920:	2302      	movs	r3, #2
 8006922:	e040      	b.n	80069a6 <USBH_MSC_Read+0xca>
  }

  MSC_Handle->state = MSC_READ;
 8006924:	697b      	ldr	r3, [r7, #20]
 8006926:	2206      	movs	r2, #6
 8006928:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_READ;
 800692a:	7afb      	ldrb	r3, [r7, #11]
 800692c:	697a      	ldr	r2, [r7, #20]
 800692e:	2134      	movs	r1, #52	; 0x34
 8006930:	fb01 f303 	mul.w	r3, r1, r3
 8006934:	4413      	add	r3, r2
 8006936:	3390      	adds	r3, #144	; 0x90
 8006938:	2206      	movs	r2, #6
 800693a:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 800693c:	7afb      	ldrb	r3, [r7, #11]
 800693e:	b29a      	uxth	r2, r3
 8006940:	697b      	ldr	r3, [r7, #20]
 8006942:	f8a3 20fa 	strh.w	r2, [r3, #250]	; 0xfa

  USBH_MSC_SCSI_Read(phost, lun, address, pbuf, length);
 8006946:	7af9      	ldrb	r1, [r7, #11]
 8006948:	6a3b      	ldr	r3, [r7, #32]
 800694a:	9300      	str	r3, [sp, #0]
 800694c:	683b      	ldr	r3, [r7, #0]
 800694e:	687a      	ldr	r2, [r7, #4]
 8006950:	68f8      	ldr	r0, [r7, #12]
 8006952:	f000 fd78 	bl	8007446 <USBH_MSC_SCSI_Read>

  timeout = phost->Timer;
 8006956:	68fb      	ldr	r3, [r7, #12]
 8006958:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 800695c:	613b      	str	r3, [r7, #16]

  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800695e:	e016      	b.n	800698e <USBH_MSC_Read+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 8006960:	68fb      	ldr	r3, [r7, #12]
 8006962:	f8d3 23c4 	ldr.w	r2, [r3, #964]	; 0x3c4
 8006966:	693b      	ldr	r3, [r7, #16]
 8006968:	1ad2      	subs	r2, r2, r3
 800696a:	6a3b      	ldr	r3, [r7, #32]
 800696c:	f242 7110 	movw	r1, #10000	; 0x2710
 8006970:	fb01 f303 	mul.w	r3, r1, r3
 8006974:	429a      	cmp	r2, r3
 8006976:	d805      	bhi.n	8006984 <USBH_MSC_Read+0xa8>
 8006978:	68fb      	ldr	r3, [r7, #12]
 800697a:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 800697e:	b2db      	uxtb	r3, r3
 8006980:	2b00      	cmp	r3, #0
 8006982:	d104      	bne.n	800698e <USBH_MSC_Read+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 8006984:	697b      	ldr	r3, [r7, #20]
 8006986:	2201      	movs	r2, #1
 8006988:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 800698a:	2302      	movs	r3, #2
 800698c:	e00b      	b.n	80069a6 <USBH_MSC_Read+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 800698e:	7afb      	ldrb	r3, [r7, #11]
 8006990:	4619      	mov	r1, r3
 8006992:	68f8      	ldr	r0, [r7, #12]
 8006994:	f7ff fe89 	bl	80066aa <USBH_MSC_RdWrProcess>
 8006998:	4603      	mov	r3, r0
 800699a:	2b01      	cmp	r3, #1
 800699c:	d0e0      	beq.n	8006960 <USBH_MSC_Read+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 800699e:	697b      	ldr	r3, [r7, #20]
 80069a0:	2201      	movs	r2, #1
 80069a2:	731a      	strb	r2, [r3, #12]

  return USBH_OK;
 80069a4:	2300      	movs	r3, #0
}
 80069a6:	4618      	mov	r0, r3
 80069a8:	3718      	adds	r7, #24
 80069aa:	46bd      	mov	sp, r7
 80069ac:	bd80      	pop	{r7, pc}

080069ae <USBH_MSC_Write>:
USBH_StatusTypeDef USBH_MSC_Write(USBH_HandleTypeDef *phost,
                                  uint8_t lun,
                                  uint32_t address,
                                  uint8_t *pbuf,
                                  uint32_t length)
{
 80069ae:	b580      	push	{r7, lr}
 80069b0:	b088      	sub	sp, #32
 80069b2:	af02      	add	r7, sp, #8
 80069b4:	60f8      	str	r0, [r7, #12]
 80069b6:	607a      	str	r2, [r7, #4]
 80069b8:	603b      	str	r3, [r7, #0]
 80069ba:	460b      	mov	r3, r1
 80069bc:	72fb      	strb	r3, [r7, #11]
  uint32_t timeout;
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 80069be:	68fb      	ldr	r3, [r7, #12]
 80069c0:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80069c4:	69db      	ldr	r3, [r3, #28]
 80069c6:	617b      	str	r3, [r7, #20]

  if ((phost->device.is_connected == 0U) ||
 80069c8:	68fb      	ldr	r3, [r7, #12]
 80069ca:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 80069ce:	b2db      	uxtb	r3, r3
 80069d0:	2b00      	cmp	r3, #0
 80069d2:	d00e      	beq.n	80069f2 <USBH_MSC_Write+0x44>
      (phost->gState != HOST_CLASS) ||
 80069d4:	68fb      	ldr	r3, [r7, #12]
 80069d6:	781b      	ldrb	r3, [r3, #0]
 80069d8:	b2db      	uxtb	r3, r3
  if ((phost->device.is_connected == 0U) ||
 80069da:	2b0b      	cmp	r3, #11
 80069dc:	d109      	bne.n	80069f2 <USBH_MSC_Write+0x44>
      (MSC_Handle->unit[lun].state != MSC_IDLE))
 80069de:	7afb      	ldrb	r3, [r7, #11]
 80069e0:	697a      	ldr	r2, [r7, #20]
 80069e2:	2134      	movs	r1, #52	; 0x34
 80069e4:	fb01 f303 	mul.w	r3, r1, r3
 80069e8:	4413      	add	r3, r2
 80069ea:	3390      	adds	r3, #144	; 0x90
 80069ec:	781b      	ldrb	r3, [r3, #0]
      (phost->gState != HOST_CLASS) ||
 80069ee:	2b01      	cmp	r3, #1
 80069f0:	d001      	beq.n	80069f6 <USBH_MSC_Write+0x48>
  {
    return  USBH_FAIL;
 80069f2:	2302      	movs	r3, #2
 80069f4:	e040      	b.n	8006a78 <USBH_MSC_Write+0xca>
  }

  MSC_Handle->state = MSC_WRITE;
 80069f6:	697b      	ldr	r3, [r7, #20]
 80069f8:	2207      	movs	r2, #7
 80069fa:	731a      	strb	r2, [r3, #12]
  MSC_Handle->unit[lun].state = MSC_WRITE;
 80069fc:	7afb      	ldrb	r3, [r7, #11]
 80069fe:	697a      	ldr	r2, [r7, #20]
 8006a00:	2134      	movs	r1, #52	; 0x34
 8006a02:	fb01 f303 	mul.w	r3, r1, r3
 8006a06:	4413      	add	r3, r2
 8006a08:	3390      	adds	r3, #144	; 0x90
 8006a0a:	2207      	movs	r2, #7
 8006a0c:	701a      	strb	r2, [r3, #0]
  MSC_Handle->rw_lun = lun;
 8006a0e:	7afb      	ldrb	r3, [r7, #11]
 8006a10:	b29a      	uxth	r2, r3
 8006a12:	697b      	ldr	r3, [r7, #20]
 8006a14:	f8a3 20fa 	strh.w	r2, [r3, #250]	; 0xfa

  USBH_MSC_SCSI_Write(phost, lun, address, pbuf, length);
 8006a18:	7af9      	ldrb	r1, [r7, #11]
 8006a1a:	6a3b      	ldr	r3, [r7, #32]
 8006a1c:	9300      	str	r3, [sp, #0]
 8006a1e:	683b      	ldr	r3, [r7, #0]
 8006a20:	687a      	ldr	r2, [r7, #4]
 8006a22:	68f8      	ldr	r0, [r7, #12]
 8006a24:	f000 fca4 	bl	8007370 <USBH_MSC_SCSI_Write>

  timeout = phost->Timer;
 8006a28:	68fb      	ldr	r3, [r7, #12]
 8006a2a:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 8006a2e:	613b      	str	r3, [r7, #16]
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 8006a30:	e016      	b.n	8006a60 <USBH_MSC_Write+0xb2>
  {
    if (((phost->Timer - timeout) > (10000U * length)) || (phost->device.is_connected == 0U))
 8006a32:	68fb      	ldr	r3, [r7, #12]
 8006a34:	f8d3 23c4 	ldr.w	r2, [r3, #964]	; 0x3c4
 8006a38:	693b      	ldr	r3, [r7, #16]
 8006a3a:	1ad2      	subs	r2, r2, r3
 8006a3c:	6a3b      	ldr	r3, [r7, #32]
 8006a3e:	f242 7110 	movw	r1, #10000	; 0x2710
 8006a42:	fb01 f303 	mul.w	r3, r1, r3
 8006a46:	429a      	cmp	r2, r3
 8006a48:	d805      	bhi.n	8006a56 <USBH_MSC_Write+0xa8>
 8006a4a:	68fb      	ldr	r3, [r7, #12]
 8006a4c:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 8006a50:	b2db      	uxtb	r3, r3
 8006a52:	2b00      	cmp	r3, #0
 8006a54:	d104      	bne.n	8006a60 <USBH_MSC_Write+0xb2>
    {
      MSC_Handle->state = MSC_IDLE;
 8006a56:	697b      	ldr	r3, [r7, #20]
 8006a58:	2201      	movs	r2, #1
 8006a5a:	731a      	strb	r2, [r3, #12]
      return USBH_FAIL;
 8006a5c:	2302      	movs	r3, #2
 8006a5e:	e00b      	b.n	8006a78 <USBH_MSC_Write+0xca>
  while (USBH_MSC_RdWrProcess(phost, lun) == USBH_BUSY)
 8006a60:	7afb      	ldrb	r3, [r7, #11]
 8006a62:	4619      	mov	r1, r3
 8006a64:	68f8      	ldr	r0, [r7, #12]
 8006a66:	f7ff fe20 	bl	80066aa <USBH_MSC_RdWrProcess>
 8006a6a:	4603      	mov	r3, r0
 8006a6c:	2b01      	cmp	r3, #1
 8006a6e:	d0e0      	beq.n	8006a32 <USBH_MSC_Write+0x84>
    }
  }
  MSC_Handle->state = MSC_IDLE;
 8006a70:	697b      	ldr	r3, [r7, #20]
 8006a72:	2201      	movs	r2, #1
 8006a74:	731a      	strb	r2, [r3, #12]
  return USBH_OK;
 8006a76:	2300      	movs	r3, #0
}
 8006a78:	4618      	mov	r0, r3
 8006a7a:	3718      	adds	r7, #24
 8006a7c:	46bd      	mov	sp, r7
 8006a7e:	bd80      	pop	{r7, pc}

08006a80 <USBH_MSC_BOT_REQ_Reset>:
  *         The function the MSC BOT Reset request.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
{
 8006a80:	b580      	push	{r7, lr}
 8006a82:	b082      	sub	sp, #8
 8006a84:	af00      	add	r7, sp, #0
 8006a86:	6078      	str	r0, [r7, #4]

  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS
 8006a88:	687b      	ldr	r3, [r7, #4]
 8006a8a:	2221      	movs	r2, #33	; 0x21
 8006a8c:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
 8006a8e:	687b      	ldr	r3, [r7, #4]
 8006a90:	22ff      	movs	r2, #255	; 0xff
 8006a92:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	2200      	movs	r2, #0
 8006a98:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 8006a9a:	687b      	ldr	r3, [r7, #4]
 8006a9c:	2200      	movs	r2, #0
 8006a9e:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 0U;
 8006aa0:	687b      	ldr	r3, [r7, #4]
 8006aa2:	2200      	movs	r2, #0
 8006aa4:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, 0U, 0U);
 8006aa6:	2200      	movs	r2, #0
 8006aa8:	2100      	movs	r1, #0
 8006aaa:	6878      	ldr	r0, [r7, #4]
 8006aac:	f001 fdab 	bl	8008606 <USBH_CtlReq>
 8006ab0:	4603      	mov	r3, r0
}
 8006ab2:	4618      	mov	r0, r3
 8006ab4:	3708      	adds	r7, #8
 8006ab6:	46bd      	mov	sp, r7
 8006ab8:	bd80      	pop	{r7, pc}

08006aba <USBH_MSC_BOT_REQ_GetMaxLUN>:
  * @param  phost: Host handle
  * @param  Maxlun: pointer to Maxlun variable
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
{
 8006aba:	b580      	push	{r7, lr}
 8006abc:	b082      	sub	sp, #8
 8006abe:	af00      	add	r7, sp, #0
 8006ac0:	6078      	str	r0, [r7, #4]
 8006ac2:	6039      	str	r1, [r7, #0]
  phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS
 8006ac4:	687b      	ldr	r3, [r7, #4]
 8006ac6:	22a1      	movs	r2, #161	; 0xa1
 8006ac8:	741a      	strb	r2, [r3, #16]
                                         | USB_REQ_RECIPIENT_INTERFACE;

  phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
 8006aca:	687b      	ldr	r3, [r7, #4]
 8006acc:	22fe      	movs	r2, #254	; 0xfe
 8006ace:	745a      	strb	r2, [r3, #17]
  phost->Control.setup.b.wValue.w = 0U;
 8006ad0:	687b      	ldr	r3, [r7, #4]
 8006ad2:	2200      	movs	r2, #0
 8006ad4:	825a      	strh	r2, [r3, #18]
  phost->Control.setup.b.wIndex.w = 0U;
 8006ad6:	687b      	ldr	r3, [r7, #4]
 8006ad8:	2200      	movs	r2, #0
 8006ada:	829a      	strh	r2, [r3, #20]
  phost->Control.setup.b.wLength.w = 1U;
 8006adc:	687b      	ldr	r3, [r7, #4]
 8006ade:	2201      	movs	r2, #1
 8006ae0:	82da      	strh	r2, [r3, #22]

  return USBH_CtlReq(phost, Maxlun, 1U);
 8006ae2:	2201      	movs	r2, #1
 8006ae4:	6839      	ldr	r1, [r7, #0]
 8006ae6:	6878      	ldr	r0, [r7, #4]
 8006ae8:	f001 fd8d 	bl	8008606 <USBH_CtlReq>
 8006aec:	4603      	mov	r3, r0
}
 8006aee:	4618      	mov	r0, r3
 8006af0:	3708      	adds	r7, #8
 8006af2:	46bd      	mov	sp, r7
 8006af4:	bd80      	pop	{r7, pc}
	...

08006af8 <USBH_MSC_BOT_Init>:
  *         The function Initializes the BOT protocol.
  * @param  phost: Host handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
{
 8006af8:	b480      	push	{r7}
 8006afa:	b085      	sub	sp, #20
 8006afc:	af00      	add	r7, sp, #0
 8006afe:	6078      	str	r0, [r7, #4]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006b00:	687b      	ldr	r3, [r7, #4]
 8006b02:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006b06:	69db      	ldr	r3, [r3, #28]
 8006b08:	60fb      	str	r3, [r7, #12]

  MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
 8006b0a:	68fb      	ldr	r3, [r7, #12]
 8006b0c:	4a09      	ldr	r2, [pc, #36]	; (8006b34 <USBH_MSC_BOT_Init+0x3c>)
 8006b0e:	655a      	str	r2, [r3, #84]	; 0x54
  MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
 8006b10:	68fb      	ldr	r3, [r7, #12]
 8006b12:	4a09      	ldr	r2, [pc, #36]	; (8006b38 <USBH_MSC_BOT_Init+0x40>)
 8006b14:	659a      	str	r2, [r3, #88]	; 0x58
  MSC_Handle->hbot.state = BOT_SEND_CBW;
 8006b16:	68fb      	ldr	r3, [r7, #12]
 8006b18:	2201      	movs	r2, #1
 8006b1a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 8006b1e:	68fb      	ldr	r3, [r7, #12]
 8006b20:	2201      	movs	r2, #1
 8006b22:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

  return USBH_OK;
 8006b26:	2300      	movs	r3, #0
}
 8006b28:	4618      	mov	r0, r3
 8006b2a:	3714      	adds	r7, #20
 8006b2c:	46bd      	mov	sp, r7
 8006b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b32:	4770      	bx	lr
 8006b34:	43425355 	.word	0x43425355
 8006b38:	20304050 	.word	0x20304050

08006b3c <USBH_MSC_BOT_Process>:
  * @param  phost: Host handle
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_BOT_Process(USBH_HandleTypeDef *phost, uint8_t lun)
{
 8006b3c:	b580      	push	{r7, lr}
 8006b3e:	b088      	sub	sp, #32
 8006b40:	af02      	add	r7, sp, #8
 8006b42:	6078      	str	r0, [r7, #4]
 8006b44:	460b      	mov	r3, r1
 8006b46:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef   status = USBH_BUSY;
 8006b48:	2301      	movs	r3, #1
 8006b4a:	75fb      	strb	r3, [r7, #23]
  USBH_StatusTypeDef   error  = USBH_BUSY;
 8006b4c:	2301      	movs	r3, #1
 8006b4e:	75bb      	strb	r3, [r7, #22]
  BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
 8006b50:	2301      	movs	r3, #1
 8006b52:	757b      	strb	r3, [r7, #21]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 8006b54:	2300      	movs	r3, #0
 8006b56:	753b      	strb	r3, [r7, #20]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006b58:	687b      	ldr	r3, [r7, #4]
 8006b5a:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006b5e:	69db      	ldr	r3, [r3, #28]
 8006b60:	613b      	str	r3, [r7, #16]
  uint8_t toggle = 0U;
 8006b62:	2300      	movs	r3, #0
 8006b64:	73fb      	strb	r3, [r7, #15]

  switch (MSC_Handle->hbot.state)
 8006b66:	693b      	ldr	r3, [r7, #16]
 8006b68:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8006b6c:	3b01      	subs	r3, #1
 8006b6e:	2b0a      	cmp	r3, #10
 8006b70:	f200 819e 	bhi.w	8006eb0 <USBH_MSC_BOT_Process+0x374>
 8006b74:	a201      	add	r2, pc, #4	; (adr r2, 8006b7c <USBH_MSC_BOT_Process+0x40>)
 8006b76:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006b7a:	bf00      	nop
 8006b7c:	08006ba9 	.word	0x08006ba9
 8006b80:	08006bd1 	.word	0x08006bd1
 8006b84:	08006c3b 	.word	0x08006c3b
 8006b88:	08006c59 	.word	0x08006c59
 8006b8c:	08006cdd 	.word	0x08006cdd
 8006b90:	08006cff 	.word	0x08006cff
 8006b94:	08006d97 	.word	0x08006d97
 8006b98:	08006db3 	.word	0x08006db3
 8006b9c:	08006e05 	.word	0x08006e05
 8006ba0:	08006e35 	.word	0x08006e35
 8006ba4:	08006e97 	.word	0x08006e97
  {
    case BOT_SEND_CBW:
      MSC_Handle->hbot.cbw.field.LUN = lun;
 8006ba8:	693b      	ldr	r3, [r7, #16]
 8006baa:	78fa      	ldrb	r2, [r7, #3]
 8006bac:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
      MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;
 8006bb0:	693b      	ldr	r3, [r7, #16]
 8006bb2:	2202      	movs	r2, #2
 8006bb4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      USBH_BulkSendData(phost, MSC_Handle->hbot.cbw.data,
 8006bb8:	693b      	ldr	r3, [r7, #16]
 8006bba:	f103 0154 	add.w	r1, r3, #84	; 0x54
 8006bbe:	693b      	ldr	r3, [r7, #16]
 8006bc0:	795b      	ldrb	r3, [r3, #5]
 8006bc2:	2201      	movs	r2, #1
 8006bc4:	9200      	str	r2, [sp, #0]
 8006bc6:	221f      	movs	r2, #31
 8006bc8:	6878      	ldr	r0, [r7, #4]
 8006bca:	f001 ff2a 	bl	8008a22 <USBH_BulkSendData>
                        BOT_CBW_LENGTH, MSC_Handle->OutPipe, 1U);

      break;
 8006bce:	e17e      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>

    case BOT_SEND_CBW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 8006bd0:	693b      	ldr	r3, [r7, #16]
 8006bd2:	795b      	ldrb	r3, [r3, #5]
 8006bd4:	4619      	mov	r1, r3
 8006bd6:	6878      	ldr	r0, [r7, #4]
 8006bd8:	f021 fa52 	bl	8028080 <USBH_LL_GetURBState>
 8006bdc:	4603      	mov	r3, r0
 8006bde:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 8006be0:	7d3b      	ldrb	r3, [r7, #20]
 8006be2:	2b01      	cmp	r3, #1
 8006be4:	d118      	bne.n	8006c18 <USBH_MSC_BOT_Process+0xdc>
      {
        if (MSC_Handle->hbot.cbw.field.DataTransferLength != 0U)
 8006be6:	693b      	ldr	r3, [r7, #16]
 8006be8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006bea:	2b00      	cmp	r3, #0
 8006bec:	d00f      	beq.n	8006c0e <USBH_MSC_BOT_Process+0xd2>
        {
          /* If there is Data Transfer Stage */
          if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
 8006bee:	693b      	ldr	r3, [r7, #16]
 8006bf0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bf4:	b25b      	sxtb	r3, r3
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	da04      	bge.n	8006c04 <USBH_MSC_BOT_Process+0xc8>
          {
            /* Data Direction is IN */
            MSC_Handle->hbot.state = BOT_DATA_IN;
 8006bfa:	693b      	ldr	r3, [r7, #16]
 8006bfc:	2203      	movs	r2, #3
 8006bfe:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 8006c02:	e157      	b.n	8006eb4 <USBH_MSC_BOT_Process+0x378>
            MSC_Handle->hbot.state = BOT_DATA_OUT;
 8006c04:	693b      	ldr	r3, [r7, #16]
 8006c06:	2205      	movs	r2, #5
 8006c08:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006c0c:	e152      	b.n	8006eb4 <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 8006c0e:	693b      	ldr	r3, [r7, #16]
 8006c10:	2207      	movs	r2, #7
 8006c12:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006c16:	e14d      	b.n	8006eb4 <USBH_MSC_BOT_Process+0x378>
      else if (URB_Status == USBH_URB_NOTREADY)
 8006c18:	7d3b      	ldrb	r3, [r7, #20]
 8006c1a:	2b02      	cmp	r3, #2
 8006c1c:	d104      	bne.n	8006c28 <USBH_MSC_BOT_Process+0xec>
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8006c1e:	693b      	ldr	r3, [r7, #16]
 8006c20:	2201      	movs	r2, #1
 8006c22:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006c26:	e145      	b.n	8006eb4 <USBH_MSC_BOT_Process+0x378>
        if (URB_Status == USBH_URB_STALL)
 8006c28:	7d3b      	ldrb	r3, [r7, #20]
 8006c2a:	2b05      	cmp	r3, #5
 8006c2c:	f040 8142 	bne.w	8006eb4 <USBH_MSC_BOT_Process+0x378>
          MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 8006c30:	693b      	ldr	r3, [r7, #16]
 8006c32:	220a      	movs	r2, #10
 8006c34:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006c38:	e13c      	b.n	8006eb4 <USBH_MSC_BOT_Process+0x378>

    case BOT_DATA_IN:
      /* Send first packet */
      USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 8006c3a:	693b      	ldr	r3, [r7, #16]
 8006c3c:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8006c40:	693b      	ldr	r3, [r7, #16]
 8006c42:	895a      	ldrh	r2, [r3, #10]
 8006c44:	693b      	ldr	r3, [r7, #16]
 8006c46:	791b      	ldrb	r3, [r3, #4]
 8006c48:	6878      	ldr	r0, [r7, #4]
 8006c4a:	f001 ff0f 	bl	8008a6c <USBH_BulkReceiveData>
                           MSC_Handle->InEpSize, MSC_Handle->InPipe);

      MSC_Handle->hbot.state = BOT_DATA_IN_WAIT;
 8006c4e:	693b      	ldr	r3, [r7, #16]
 8006c50:	2204      	movs	r2, #4
 8006c52:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      break;
 8006c56:	e13a      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 8006c58:	693b      	ldr	r3, [r7, #16]
 8006c5a:	791b      	ldrb	r3, [r3, #4]
 8006c5c:	4619      	mov	r1, r3
 8006c5e:	6878      	ldr	r0, [r7, #4]
 8006c60:	f021 fa0e 	bl	8028080 <USBH_LL_GetURBState>
 8006c64:	4603      	mov	r3, r0
 8006c66:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 8006c68:	7d3b      	ldrb	r3, [r7, #20]
 8006c6a:	2b01      	cmp	r3, #1
 8006c6c:	d12d      	bne.n	8006cca <USBH_MSC_BOT_Process+0x18e>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
 8006c6e:	693b      	ldr	r3, [r7, #16]
 8006c70:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c72:	693a      	ldr	r2, [r7, #16]
 8006c74:	8952      	ldrh	r2, [r2, #10]
 8006c76:	4293      	cmp	r3, r2
 8006c78:	d910      	bls.n	8006c9c <USBH_MSC_BOT_Process+0x160>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
 8006c7a:	693b      	ldr	r3, [r7, #16]
 8006c7c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8006c80:	693a      	ldr	r2, [r7, #16]
 8006c82:	8952      	ldrh	r2, [r2, #10]
 8006c84:	441a      	add	r2, r3
 8006c86:	693b      	ldr	r3, [r7, #16]
 8006c88:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;
 8006c8c:	693b      	ldr	r3, [r7, #16]
 8006c8e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006c90:	693a      	ldr	r2, [r7, #16]
 8006c92:	8952      	ldrh	r2, [r2, #10]
 8006c94:	1a9a      	subs	r2, r3, r2
 8006c96:	693b      	ldr	r3, [r7, #16]
 8006c98:	65da      	str	r2, [r3, #92]	; 0x5c
 8006c9a:	e002      	b.n	8006ca2 <USBH_MSC_BOT_Process+0x166>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 8006c9c:	693b      	ldr	r3, [r7, #16]
 8006c9e:	2200      	movs	r2, #0
 8006ca0:	65da      	str	r2, [r3, #92]	; 0x5c
        }

        /* More Data To be Received */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 8006ca2:	693b      	ldr	r3, [r7, #16]
 8006ca4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006ca6:	2b00      	cmp	r3, #0
 8006ca8:	d00a      	beq.n	8006cc0 <USBH_MSC_BOT_Process+0x184>
        {
          /* Send next packet */
          USBH_BulkReceiveData(phost, MSC_Handle->hbot.pbuf,
 8006caa:	693b      	ldr	r3, [r7, #16]
 8006cac:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8006cb0:	693b      	ldr	r3, [r7, #16]
 8006cb2:	895a      	ldrh	r2, [r3, #10]
 8006cb4:	693b      	ldr	r3, [r7, #16]
 8006cb6:	791b      	ldrb	r3, [r3, #4]
 8006cb8:	6878      	ldr	r0, [r7, #4]
 8006cba:	f001 fed7 	bl	8008a6c <USBH_BulkReceiveData>
#endif
      }
      else
      {
      }
      break;
 8006cbe:	e0fb      	b.n	8006eb8 <USBH_MSC_BOT_Process+0x37c>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 8006cc0:	693b      	ldr	r3, [r7, #16]
 8006cc2:	2207      	movs	r2, #7
 8006cc4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006cc8:	e0f6      	b.n	8006eb8 <USBH_MSC_BOT_Process+0x37c>
      else if (URB_Status == USBH_URB_STALL)
 8006cca:	7d3b      	ldrb	r3, [r7, #20]
 8006ccc:	2b05      	cmp	r3, #5
 8006cce:	f040 80f3 	bne.w	8006eb8 <USBH_MSC_BOT_Process+0x37c>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 8006cd2:	693b      	ldr	r3, [r7, #16]
 8006cd4:	2209      	movs	r2, #9
 8006cd6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006cda:	e0ed      	b.n	8006eb8 <USBH_MSC_BOT_Process+0x37c>

    case BOT_DATA_OUT:

      USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 8006cdc:	693b      	ldr	r3, [r7, #16]
 8006cde:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8006ce2:	693b      	ldr	r3, [r7, #16]
 8006ce4:	891a      	ldrh	r2, [r3, #8]
 8006ce6:	693b      	ldr	r3, [r7, #16]
 8006ce8:	795b      	ldrb	r3, [r3, #5]
 8006cea:	2001      	movs	r0, #1
 8006cec:	9000      	str	r0, [sp, #0]
 8006cee:	6878      	ldr	r0, [r7, #4]
 8006cf0:	f001 fe97 	bl	8008a22 <USBH_BulkSendData>
                        MSC_Handle->OutEpSize, MSC_Handle->OutPipe, 1U);

      MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
 8006cf4:	693b      	ldr	r3, [r7, #16]
 8006cf6:	2206      	movs	r2, #6
 8006cf8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006cfc:	e0e7      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>

    case BOT_DATA_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);
 8006cfe:	693b      	ldr	r3, [r7, #16]
 8006d00:	795b      	ldrb	r3, [r3, #5]
 8006d02:	4619      	mov	r1, r3
 8006d04:	6878      	ldr	r0, [r7, #4]
 8006d06:	f021 f9bb 	bl	8028080 <USBH_LL_GetURBState>
 8006d0a:	4603      	mov	r3, r0
 8006d0c:	753b      	strb	r3, [r7, #20]

      if (URB_Status == USBH_URB_DONE)
 8006d0e:	7d3b      	ldrb	r3, [r7, #20]
 8006d10:	2b01      	cmp	r3, #1
 8006d12:	d12f      	bne.n	8006d74 <USBH_MSC_BOT_Process+0x238>
      {
        /* Adjust Data pointer and data length */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
 8006d14:	693b      	ldr	r3, [r7, #16]
 8006d16:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006d18:	693a      	ldr	r2, [r7, #16]
 8006d1a:	8912      	ldrh	r2, [r2, #8]
 8006d1c:	4293      	cmp	r3, r2
 8006d1e:	d910      	bls.n	8006d42 <USBH_MSC_BOT_Process+0x206>
        {
          MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
 8006d20:	693b      	ldr	r3, [r7, #16]
 8006d22:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8006d26:	693a      	ldr	r2, [r7, #16]
 8006d28:	8912      	ldrh	r2, [r2, #8]
 8006d2a:	441a      	add	r2, r3
 8006d2c:	693b      	ldr	r3, [r7, #16]
 8006d2e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
          MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize;
 8006d32:	693b      	ldr	r3, [r7, #16]
 8006d34:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006d36:	693a      	ldr	r2, [r7, #16]
 8006d38:	8912      	ldrh	r2, [r2, #8]
 8006d3a:	1a9a      	subs	r2, r3, r2
 8006d3c:	693b      	ldr	r3, [r7, #16]
 8006d3e:	65da      	str	r2, [r3, #92]	; 0x5c
 8006d40:	e002      	b.n	8006d48 <USBH_MSC_BOT_Process+0x20c>
        }
        else
        {
          MSC_Handle->hbot.cbw.field.DataTransferLength = 0U;
 8006d42:	693b      	ldr	r3, [r7, #16]
 8006d44:	2200      	movs	r2, #0
 8006d46:	65da      	str	r2, [r3, #92]	; 0x5c
        }

        /* More Data To be Sent */
        if (MSC_Handle->hbot.cbw.field.DataTransferLength > 0U)
 8006d48:	693b      	ldr	r3, [r7, #16]
 8006d4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8006d4c:	2b00      	cmp	r3, #0
 8006d4e:	d00c      	beq.n	8006d6a <USBH_MSC_BOT_Process+0x22e>
        {
          USBH_BulkSendData(phost, MSC_Handle->hbot.pbuf,
 8006d50:	693b      	ldr	r3, [r7, #16]
 8006d52:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8006d56:	693b      	ldr	r3, [r7, #16]
 8006d58:	891a      	ldrh	r2, [r3, #8]
 8006d5a:	693b      	ldr	r3, [r7, #16]
 8006d5c:	795b      	ldrb	r3, [r3, #5]
 8006d5e:	2001      	movs	r0, #1
 8006d60:	9000      	str	r0, [sp, #0]
 8006d62:	6878      	ldr	r0, [r7, #4]
 8006d64:	f001 fe5d 	bl	8008a22 <USBH_BulkSendData>
#endif
      }
      else
      {
      }
      break;
 8006d68:	e0a8      	b.n	8006ebc <USBH_MSC_BOT_Process+0x380>
          MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
 8006d6a:	693b      	ldr	r3, [r7, #16]
 8006d6c:	2207      	movs	r2, #7
 8006d6e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006d72:	e0a3      	b.n	8006ebc <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_NOTREADY)
 8006d74:	7d3b      	ldrb	r3, [r7, #20]
 8006d76:	2b02      	cmp	r3, #2
 8006d78:	d104      	bne.n	8006d84 <USBH_MSC_BOT_Process+0x248>
        MSC_Handle->hbot.state  = BOT_DATA_OUT;
 8006d7a:	693b      	ldr	r3, [r7, #16]
 8006d7c:	2205      	movs	r2, #5
 8006d7e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006d82:	e09b      	b.n	8006ebc <USBH_MSC_BOT_Process+0x380>
      else if (URB_Status == USBH_URB_STALL)
 8006d84:	7d3b      	ldrb	r3, [r7, #20]
 8006d86:	2b05      	cmp	r3, #5
 8006d88:	f040 8098 	bne.w	8006ebc <USBH_MSC_BOT_Process+0x380>
        MSC_Handle->hbot.state  = BOT_ERROR_OUT;
 8006d8c:	693b      	ldr	r3, [r7, #16]
 8006d8e:	220a      	movs	r2, #10
 8006d90:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006d94:	e092      	b.n	8006ebc <USBH_MSC_BOT_Process+0x380>

    case BOT_RECEIVE_CSW:

      USBH_BulkReceiveData(phost, MSC_Handle->hbot.csw.data,
 8006d96:	693b      	ldr	r3, [r7, #16]
 8006d98:	f103 0178 	add.w	r1, r3, #120	; 0x78
 8006d9c:	693b      	ldr	r3, [r7, #16]
 8006d9e:	791b      	ldrb	r3, [r3, #4]
 8006da0:	220d      	movs	r2, #13
 8006da2:	6878      	ldr	r0, [r7, #4]
 8006da4:	f001 fe62 	bl	8008a6c <USBH_BulkReceiveData>
                           BOT_CSW_LENGTH, MSC_Handle->InPipe);

      MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
 8006da8:	693b      	ldr	r3, [r7, #16]
 8006daa:	2208      	movs	r2, #8
 8006dac:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006db0:	e08d      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>

    case BOT_RECEIVE_CSW_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe);
 8006db2:	693b      	ldr	r3, [r7, #16]
 8006db4:	791b      	ldrb	r3, [r3, #4]
 8006db6:	4619      	mov	r1, r3
 8006db8:	6878      	ldr	r0, [r7, #4]
 8006dba:	f021 f961 	bl	8028080 <USBH_LL_GetURBState>
 8006dbe:	4603      	mov	r3, r0
 8006dc0:	753b      	strb	r3, [r7, #20]

      /* Decode CSW */
      if (URB_Status == USBH_URB_DONE)
 8006dc2:	7d3b      	ldrb	r3, [r7, #20]
 8006dc4:	2b01      	cmp	r3, #1
 8006dc6:	d115      	bne.n	8006df4 <USBH_MSC_BOT_Process+0x2b8>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8006dc8:	693b      	ldr	r3, [r7, #16]
 8006dca:	2201      	movs	r2, #1
 8006dcc:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
        MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;
 8006dd0:	693b      	ldr	r3, [r7, #16]
 8006dd2:	2201      	movs	r2, #1
 8006dd4:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
        CSW_Status = USBH_MSC_DecodeCSW(phost);
 8006dd8:	6878      	ldr	r0, [r7, #4]
 8006dda:	f000 f8a9 	bl	8006f30 <USBH_MSC_DecodeCSW>
 8006dde:	4603      	mov	r3, r0
 8006de0:	757b      	strb	r3, [r7, #21]

        if (CSW_Status == BOT_CSW_CMD_PASSED)
 8006de2:	7d7b      	ldrb	r3, [r7, #21]
 8006de4:	2b00      	cmp	r3, #0
 8006de6:	d102      	bne.n	8006dee <USBH_MSC_BOT_Process+0x2b2>
        {
          status = USBH_OK;
 8006de8:	2300      	movs	r3, #0
 8006dea:	75fb      	strb	r3, [r7, #23]
#endif
      }
      else
      {
      }
      break;
 8006dec:	e068      	b.n	8006ec0 <USBH_MSC_BOT_Process+0x384>
          status = USBH_FAIL;
 8006dee:	2302      	movs	r3, #2
 8006df0:	75fb      	strb	r3, [r7, #23]
      break;
 8006df2:	e065      	b.n	8006ec0 <USBH_MSC_BOT_Process+0x384>
      else if (URB_Status == USBH_URB_STALL)
 8006df4:	7d3b      	ldrb	r3, [r7, #20]
 8006df6:	2b05      	cmp	r3, #5
 8006df8:	d162      	bne.n	8006ec0 <USBH_MSC_BOT_Process+0x384>
        MSC_Handle->hbot.state  = BOT_ERROR_IN;
 8006dfa:	693b      	ldr	r3, [r7, #16]
 8006dfc:	2209      	movs	r2, #9
 8006dfe:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006e02:	e05d      	b.n	8006ec0 <USBH_MSC_BOT_Process+0x384>

    case BOT_ERROR_IN:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
 8006e04:	78fb      	ldrb	r3, [r7, #3]
 8006e06:	2200      	movs	r2, #0
 8006e08:	4619      	mov	r1, r3
 8006e0a:	6878      	ldr	r0, [r7, #4]
 8006e0c:	f000 f864 	bl	8006ed8 <USBH_MSC_BOT_Abort>
 8006e10:	4603      	mov	r3, r0
 8006e12:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 8006e14:	7dbb      	ldrb	r3, [r7, #22]
 8006e16:	2b00      	cmp	r3, #0
 8006e18:	d104      	bne.n	8006e24 <USBH_MSC_BOT_Process+0x2e8>
      {
        MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
 8006e1a:	693b      	ldr	r3, [r7, #16]
 8006e1c:	2207      	movs	r2, #7
 8006e1e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
      }
      else
      {
      }
      break;
 8006e22:	e04f      	b.n	8006ec4 <USBH_MSC_BOT_Process+0x388>
      else if (error == USBH_UNRECOVERED_ERROR)
 8006e24:	7dbb      	ldrb	r3, [r7, #22]
 8006e26:	2b04      	cmp	r3, #4
 8006e28:	d14c      	bne.n	8006ec4 <USBH_MSC_BOT_Process+0x388>
        MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 8006e2a:	693b      	ldr	r3, [r7, #16]
 8006e2c:	220b      	movs	r2, #11
 8006e2e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006e32:	e047      	b.n	8006ec4 <USBH_MSC_BOT_Process+0x388>

    case BOT_ERROR_OUT:
      error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
 8006e34:	78fb      	ldrb	r3, [r7, #3]
 8006e36:	2201      	movs	r2, #1
 8006e38:	4619      	mov	r1, r3
 8006e3a:	6878      	ldr	r0, [r7, #4]
 8006e3c:	f000 f84c 	bl	8006ed8 <USBH_MSC_BOT_Abort>
 8006e40:	4603      	mov	r3, r0
 8006e42:	75bb      	strb	r3, [r7, #22]

      if (error == USBH_OK)
 8006e44:	7dbb      	ldrb	r3, [r7, #22]
 8006e46:	2b00      	cmp	r3, #0
 8006e48:	d11d      	bne.n	8006e86 <USBH_MSC_BOT_Process+0x34a>
      {

        toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe);
 8006e4a:	693b      	ldr	r3, [r7, #16]
 8006e4c:	795b      	ldrb	r3, [r3, #5]
 8006e4e:	4619      	mov	r1, r3
 8006e50:	6878      	ldr	r0, [r7, #4]
 8006e52:	f021 f966 	bl	8028122 <USBH_LL_GetToggle>
 8006e56:	4603      	mov	r3, r0
 8006e58:	73fb      	strb	r3, [r7, #15]
        USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1U - toggle);
 8006e5a:	693b      	ldr	r3, [r7, #16]
 8006e5c:	7959      	ldrb	r1, [r3, #5]
 8006e5e:	7bfb      	ldrb	r3, [r7, #15]
 8006e60:	f1c3 0301 	rsb	r3, r3, #1
 8006e64:	b2db      	uxtb	r3, r3
 8006e66:	461a      	mov	r2, r3
 8006e68:	6878      	ldr	r0, [r7, #4]
 8006e6a:	f021 f92a 	bl	80280c2 <USBH_LL_SetToggle>
        USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0U);
 8006e6e:	693b      	ldr	r3, [r7, #16]
 8006e70:	791b      	ldrb	r3, [r3, #4]
 8006e72:	2200      	movs	r2, #0
 8006e74:	4619      	mov	r1, r3
 8006e76:	6878      	ldr	r0, [r7, #4]
 8006e78:	f021 f923 	bl	80280c2 <USBH_LL_SetToggle>
        MSC_Handle->hbot.state = BOT_ERROR_IN;
 8006e7c:	693b      	ldr	r3, [r7, #16]
 8006e7e:	2209      	movs	r2, #9
 8006e80:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
        if (error == USBH_UNRECOVERED_ERROR)
        {
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
        }
      }
      break;
 8006e84:	e020      	b.n	8006ec8 <USBH_MSC_BOT_Process+0x38c>
        if (error == USBH_UNRECOVERED_ERROR)
 8006e86:	7dbb      	ldrb	r3, [r7, #22]
 8006e88:	2b04      	cmp	r3, #4
 8006e8a:	d11d      	bne.n	8006ec8 <USBH_MSC_BOT_Process+0x38c>
          MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
 8006e8c:	693b      	ldr	r3, [r7, #16]
 8006e8e:	220b      	movs	r2, #11
 8006e90:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      break;
 8006e94:	e018      	b.n	8006ec8 <USBH_MSC_BOT_Process+0x38c>


    case BOT_UNRECOVERED_ERROR:
      status = USBH_MSC_BOT_REQ_Reset(phost);
 8006e96:	6878      	ldr	r0, [r7, #4]
 8006e98:	f7ff fdf2 	bl	8006a80 <USBH_MSC_BOT_REQ_Reset>
 8006e9c:	4603      	mov	r3, r0
 8006e9e:	75fb      	strb	r3, [r7, #23]
      if (status == USBH_OK)
 8006ea0:	7dfb      	ldrb	r3, [r7, #23]
 8006ea2:	2b00      	cmp	r3, #0
 8006ea4:	d112      	bne.n	8006ecc <USBH_MSC_BOT_Process+0x390>
      {
        MSC_Handle->hbot.state = BOT_SEND_CBW;
 8006ea6:	693b      	ldr	r3, [r7, #16]
 8006ea8:	2201      	movs	r2, #1
 8006eaa:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      }
      break;
 8006eae:	e00d      	b.n	8006ecc <USBH_MSC_BOT_Process+0x390>

    default:
      break;
 8006eb0:	bf00      	nop
 8006eb2:	e00c      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006eb4:	bf00      	nop
 8006eb6:	e00a      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006eb8:	bf00      	nop
 8006eba:	e008      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006ebc:	bf00      	nop
 8006ebe:	e006      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006ec0:	bf00      	nop
 8006ec2:	e004      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006ec4:	bf00      	nop
 8006ec6:	e002      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006ec8:	bf00      	nop
 8006eca:	e000      	b.n	8006ece <USBH_MSC_BOT_Process+0x392>
      break;
 8006ecc:	bf00      	nop
  }
  return status;
 8006ece:	7dfb      	ldrb	r3, [r7, #23]
}
 8006ed0:	4618      	mov	r0, r3
 8006ed2:	3718      	adds	r7, #24
 8006ed4:	46bd      	mov	sp, r7
 8006ed6:	bd80      	pop	{r7, pc}

08006ed8 <USBH_MSC_BOT_Abort>:
  * @param  lun: Logical Unit Number
  * @param  dir: direction (0: out / 1 : in)
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
{
 8006ed8:	b580      	push	{r7, lr}
 8006eda:	b084      	sub	sp, #16
 8006edc:	af00      	add	r7, sp, #0
 8006ede:	6078      	str	r0, [r7, #4]
 8006ee0:	460b      	mov	r3, r1
 8006ee2:	70fb      	strb	r3, [r7, #3]
 8006ee4:	4613      	mov	r3, r2
 8006ee6:	70bb      	strb	r3, [r7, #2]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(lun);

  USBH_StatusTypeDef status = USBH_FAIL;
 8006ee8:	2302      	movs	r3, #2
 8006eea:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006eec:	687b      	ldr	r3, [r7, #4]
 8006eee:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006ef2:	69db      	ldr	r3, [r3, #28]
 8006ef4:	60bb      	str	r3, [r7, #8]

  switch (dir)
 8006ef6:	78bb      	ldrb	r3, [r7, #2]
 8006ef8:	2b00      	cmp	r3, #0
 8006efa:	d002      	beq.n	8006f02 <USBH_MSC_BOT_Abort+0x2a>
 8006efc:	2b01      	cmp	r3, #1
 8006efe:	d009      	beq.n	8006f14 <USBH_MSC_BOT_Abort+0x3c>
      /*send ClrFeature on Bulk OUT endpoint */
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
      break;

    default:
      break;
 8006f00:	e011      	b.n	8006f26 <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->InEp);
 8006f02:	68bb      	ldr	r3, [r7, #8]
 8006f04:	79db      	ldrb	r3, [r3, #7]
 8006f06:	4619      	mov	r1, r3
 8006f08:	6878      	ldr	r0, [r7, #4]
 8006f0a:	f001 f99c 	bl	8008246 <USBH_ClrFeature>
 8006f0e:	4603      	mov	r3, r0
 8006f10:	73fb      	strb	r3, [r7, #15]
      break;
 8006f12:	e008      	b.n	8006f26 <USBH_MSC_BOT_Abort+0x4e>
      status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
 8006f14:	68bb      	ldr	r3, [r7, #8]
 8006f16:	799b      	ldrb	r3, [r3, #6]
 8006f18:	4619      	mov	r1, r3
 8006f1a:	6878      	ldr	r0, [r7, #4]
 8006f1c:	f001 f993 	bl	8008246 <USBH_ClrFeature>
 8006f20:	4603      	mov	r3, r0
 8006f22:	73fb      	strb	r3, [r7, #15]
      break;
 8006f24:	bf00      	nop
  }
  return status;
 8006f26:	7bfb      	ldrb	r3, [r7, #15]
}
 8006f28:	4618      	mov	r0, r3
 8006f2a:	3710      	adds	r7, #16
 8006f2c:	46bd      	mov	sp, r7
 8006f2e:	bd80      	pop	{r7, pc}

08006f30 <USBH_MSC_DecodeCSW>:
  *     2. the CSW is 13 (Dh) bytes in length,
  *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
  */

static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
{
 8006f30:	b580      	push	{r7, lr}
 8006f32:	b084      	sub	sp, #16
 8006f34:	af00      	add	r7, sp, #0
 8006f36:	6078      	str	r0, [r7, #4]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006f38:	687b      	ldr	r3, [r7, #4]
 8006f3a:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006f3e:	69db      	ldr	r3, [r3, #28]
 8006f40:	60bb      	str	r3, [r7, #8]
  BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
 8006f42:	2301      	movs	r3, #1
 8006f44:	73fb      	strb	r3, [r7, #15]

  /*Checking if the transfer length is different than 13*/
  if (USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
 8006f46:	68bb      	ldr	r3, [r7, #8]
 8006f48:	791b      	ldrb	r3, [r3, #4]
 8006f4a:	4619      	mov	r1, r3
 8006f4c:	6878      	ldr	r0, [r7, #4]
 8006f4e:	f021 f805 	bl	8027f5c <USBH_LL_GetLastXferSize>
 8006f52:	4603      	mov	r3, r0
 8006f54:	2b0d      	cmp	r3, #13
 8006f56:	d002      	beq.n	8006f5e <USBH_MSC_DecodeCSW+0x2e>
    Device intends to transfer no data)
    (11) Ho > Do  (Host expects to send data to the device,
    Device intends to receive data from the host)*/


    status = BOT_CSW_PHASE_ERROR;
 8006f58:	2302      	movs	r3, #2
 8006f5a:	73fb      	strb	r3, [r7, #15]
 8006f5c:	e024      	b.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
  else
  {
    /* CSW length is Correct */

    /* Check validity of the CSW Signature and CSWStatus */
    if (MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
 8006f5e:	68bb      	ldr	r3, [r7, #8]
 8006f60:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006f62:	4a14      	ldr	r2, [pc, #80]	; (8006fb4 <USBH_MSC_DecodeCSW+0x84>)
 8006f64:	4293      	cmp	r3, r2
 8006f66:	d11d      	bne.n	8006fa4 <USBH_MSC_DecodeCSW+0x74>
    {
      /* Check Condition 1. dCSWSignature is equal to 53425355h */

      if (MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
 8006f68:	68bb      	ldr	r3, [r7, #8]
 8006f6a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8006f6c:	68bb      	ldr	r3, [r7, #8]
 8006f6e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006f70:	429a      	cmp	r2, r3
 8006f72:	d119      	bne.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
      {
        /* Check Condition 3. dCSWTag matches the dCBWTag from the
        corresponding CBW */

        if (MSC_Handle->hbot.csw.field.Status == 0U)
 8006f74:	68bb      	ldr	r3, [r7, #8]
 8006f76:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006f7a:	2b00      	cmp	r3, #0
 8006f7c:	d102      	bne.n	8006f84 <USBH_MSC_DecodeCSW+0x54>
          (12) Ho = Do (Host expects to send data to the device,
          Device intends to receive data from the host)

          */

          status = BOT_CSW_CMD_PASSED;
 8006f7e:	2300      	movs	r3, #0
 8006f80:	73fb      	strb	r3, [r7, #15]
 8006f82:	e011      	b.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
        }
        else if (MSC_Handle->hbot.csw.field.Status == 1U)
 8006f84:	68bb      	ldr	r3, [r7, #8]
 8006f86:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006f8a:	2b01      	cmp	r3, #1
 8006f8c:	d102      	bne.n	8006f94 <USBH_MSC_DecodeCSW+0x64>
        {
          status = BOT_CSW_CMD_FAILED;
 8006f8e:	2301      	movs	r3, #1
 8006f90:	73fb      	strb	r3, [r7, #15]
 8006f92:	e009      	b.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
        }

        else if (MSC_Handle->hbot.csw.field.Status == 2U)
 8006f94:	68bb      	ldr	r3, [r7, #8]
 8006f96:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006f9a:	2b02      	cmp	r3, #2
 8006f9c:	d104      	bne.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
          Di Device intends to send data to the host)
          (13) Ho < Do (Host expects to send data to the device,
          Device intends to receive data from the host)
          */

          status = BOT_CSW_PHASE_ERROR;
 8006f9e:	2302      	movs	r3, #2
 8006fa0:	73fb      	strb	r3, [r7, #15]
 8006fa2:	e001      	b.n	8006fa8 <USBH_MSC_DecodeCSW+0x78>
    else
    {
      /* If the CSW Signature is not valid, We sall return the Phase Error to
      Upper Layers for Reset Recovery */

      status = BOT_CSW_PHASE_ERROR;
 8006fa4:	2302      	movs	r3, #2
 8006fa6:	73fb      	strb	r3, [r7, #15]
    }
  } /* CSW Length Check*/

  return status;
 8006fa8:	7bfb      	ldrb	r3, [r7, #15]
}
 8006faa:	4618      	mov	r0, r3
 8006fac:	3710      	adds	r7, #16
 8006fae:	46bd      	mov	sp, r7
 8006fb0:	bd80      	pop	{r7, pc}
 8006fb2:	bf00      	nop
 8006fb4:	53425355 	.word	0x53425355

08006fb8 <USBH_MSC_SCSI_TestUnitReady>:
  * @param  lun: Logical Unit Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady(USBH_HandleTypeDef *phost,
                                               uint8_t lun)
{
 8006fb8:	b580      	push	{r7, lr}
 8006fba:	b084      	sub	sp, #16
 8006fbc:	af00      	add	r7, sp, #0
 8006fbe:	6078      	str	r0, [r7, #4]
 8006fc0:	460b      	mov	r3, r1
 8006fc2:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef    error = USBH_FAIL ;
 8006fc4:	2302      	movs	r3, #2
 8006fc6:	73fb      	strb	r3, [r7, #15]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8006fc8:	687b      	ldr	r3, [r7, #4]
 8006fca:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8006fce:	69db      	ldr	r3, [r3, #28]
 8006fd0:	60bb      	str	r3, [r7, #8]

  switch (MSC_Handle->hbot.cmd_state)
 8006fd2:	68bb      	ldr	r3, [r7, #8]
 8006fd4:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 8006fd8:	2b01      	cmp	r3, #1
 8006fda:	d002      	beq.n	8006fe2 <USBH_MSC_SCSI_TestUnitReady+0x2a>
 8006fdc:	2b02      	cmp	r3, #2
 8006fde:	d021      	beq.n	8007024 <USBH_MSC_SCSI_TestUnitReady+0x6c>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 8006fe0:	e028      	b.n	8007034 <USBH_MSC_SCSI_TestUnitReady+0x7c>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;
 8006fe2:	68bb      	ldr	r3, [r7, #8]
 8006fe4:	2200      	movs	r2, #0
 8006fe6:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 8006fe8:	68bb      	ldr	r3, [r7, #8]
 8006fea:	2200      	movs	r2, #0
 8006fec:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8006ff0:	68bb      	ldr	r3, [r7, #8]
 8006ff2:	220a      	movs	r2, #10
 8006ff4:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8006ff8:	68bb      	ldr	r3, [r7, #8]
 8006ffa:	3363      	adds	r3, #99	; 0x63
 8006ffc:	2210      	movs	r2, #16
 8006ffe:	2100      	movs	r1, #0
 8007000:	4618      	mov	r0, r3
 8007002:	f021 f93d 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY;
 8007006:	68bb      	ldr	r3, [r7, #8]
 8007008:	2200      	movs	r2, #0
 800700a:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800700e:	68bb      	ldr	r3, [r7, #8]
 8007010:	2201      	movs	r2, #1
 8007012:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8007016:	68bb      	ldr	r3, [r7, #8]
 8007018:	2202      	movs	r2, #2
 800701a:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      error = USBH_BUSY;
 800701e:	2301      	movs	r3, #1
 8007020:	73fb      	strb	r3, [r7, #15]
      break;
 8007022:	e007      	b.n	8007034 <USBH_MSC_SCSI_TestUnitReady+0x7c>
      error = USBH_MSC_BOT_Process(phost, lun);
 8007024:	78fb      	ldrb	r3, [r7, #3]
 8007026:	4619      	mov	r1, r3
 8007028:	6878      	ldr	r0, [r7, #4]
 800702a:	f7ff fd87 	bl	8006b3c <USBH_MSC_BOT_Process>
 800702e:	4603      	mov	r3, r0
 8007030:	73fb      	strb	r3, [r7, #15]
      break;
 8007032:	bf00      	nop
  }

  return error;
 8007034:	7bfb      	ldrb	r3, [r7, #15]
}
 8007036:	4618      	mov	r0, r3
 8007038:	3710      	adds	r7, #16
 800703a:	46bd      	mov	sp, r7
 800703c:	bd80      	pop	{r7, pc}

0800703e <USBH_MSC_SCSI_ReadCapacity>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_CapacityTypeDef *capacity)
{
 800703e:	b580      	push	{r7, lr}
 8007040:	b086      	sub	sp, #24
 8007042:	af00      	add	r7, sp, #0
 8007044:	60f8      	str	r0, [r7, #12]
 8007046:	460b      	mov	r3, r1
 8007048:	607a      	str	r2, [r7, #4]
 800704a:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_BUSY ;
 800704c:	2301      	movs	r3, #1
 800704e:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8007050:	68fb      	ldr	r3, [r7, #12]
 8007052:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007056:	69db      	ldr	r3, [r3, #28]
 8007058:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800705a:	693b      	ldr	r3, [r7, #16]
 800705c:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 8007060:	2b01      	cmp	r3, #1
 8007062:	d002      	beq.n	800706a <USBH_MSC_SCSI_ReadCapacity+0x2c>
 8007064:	2b02      	cmp	r3, #2
 8007066:	d027      	beq.n	80070b8 <USBH_MSC_SCSI_ReadCapacity+0x7a>
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
      }
      break;

    default:
      break;
 8007068:	e05f      	b.n	800712a <USBH_MSC_SCSI_ReadCapacity+0xec>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
 800706a:	693b      	ldr	r3, [r7, #16]
 800706c:	2208      	movs	r2, #8
 800706e:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8007070:	693b      	ldr	r3, [r7, #16]
 8007072:	2280      	movs	r2, #128	; 0x80
 8007074:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 8007078:	693b      	ldr	r3, [r7, #16]
 800707a:	220a      	movs	r2, #10
 800707c:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8007080:	693b      	ldr	r3, [r7, #16]
 8007082:	3363      	adds	r3, #99	; 0x63
 8007084:	2210      	movs	r2, #16
 8007086:	2100      	movs	r1, #0
 8007088:	4618      	mov	r0, r3
 800708a:	f021 f8f9 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10;
 800708e:	693b      	ldr	r3, [r7, #16]
 8007090:	2225      	movs	r2, #37	; 0x25
 8007092:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8007096:	693b      	ldr	r3, [r7, #16]
 8007098:	2201      	movs	r2, #1
 800709a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800709e:	693b      	ldr	r3, [r7, #16]
 80070a0:	2202      	movs	r2, #2
 80070a2:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 80070a6:	693b      	ldr	r3, [r7, #16]
 80070a8:	f103 0210 	add.w	r2, r3, #16
 80070ac:	693b      	ldr	r3, [r7, #16]
 80070ae:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      error = USBH_BUSY;
 80070b2:	2301      	movs	r3, #1
 80070b4:	75fb      	strb	r3, [r7, #23]
      break;
 80070b6:	e038      	b.n	800712a <USBH_MSC_SCSI_ReadCapacity+0xec>
      error = USBH_MSC_BOT_Process(phost, lun);
 80070b8:	7afb      	ldrb	r3, [r7, #11]
 80070ba:	4619      	mov	r1, r3
 80070bc:	68f8      	ldr	r0, [r7, #12]
 80070be:	f7ff fd3d 	bl	8006b3c <USBH_MSC_BOT_Process>
 80070c2:	4603      	mov	r3, r0
 80070c4:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 80070c6:	7dfb      	ldrb	r3, [r7, #23]
 80070c8:	2b00      	cmp	r3, #0
 80070ca:	d12d      	bne.n	8007128 <USBH_MSC_SCSI_ReadCapacity+0xea>
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 80070cc:	693b      	ldr	r3, [r7, #16]
 80070ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80070d2:	3303      	adds	r3, #3
 80070d4:	781b      	ldrb	r3, [r3, #0]
 80070d6:	461a      	mov	r2, r3
 80070d8:	693b      	ldr	r3, [r7, #16]
 80070da:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80070de:	3302      	adds	r3, #2
 80070e0:	781b      	ldrb	r3, [r3, #0]
 80070e2:	021b      	lsls	r3, r3, #8
 80070e4:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 80070e6:	693b      	ldr	r3, [r7, #16]
 80070e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80070ec:	3301      	adds	r3, #1
 80070ee:	781b      	ldrb	r3, [r3, #0]
 80070f0:	041b      	lsls	r3, r3, #16
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 80070f2:	431a      	orrs	r2, r3
                              ((uint32_t)MSC_Handle->hbot.pbuf[1] << 16U) | ((uint32_t)MSC_Handle->hbot.pbuf[0] << 24U);
 80070f4:	693b      	ldr	r3, [r7, #16]
 80070f6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80070fa:	781b      	ldrb	r3, [r3, #0]
 80070fc:	061b      	lsls	r3, r3, #24
 80070fe:	431a      	orrs	r2, r3
        capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | ((uint32_t)MSC_Handle->hbot.pbuf[2] << 8U) | \
 8007100:	687b      	ldr	r3, [r7, #4]
 8007102:	601a      	str	r2, [r3, #0]
        capacity->block_size = (uint16_t)(MSC_Handle->hbot.pbuf[7] | ((uint32_t)MSC_Handle->hbot.pbuf[6] << 8U));
 8007104:	693b      	ldr	r3, [r7, #16]
 8007106:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800710a:	3307      	adds	r3, #7
 800710c:	781b      	ldrb	r3, [r3, #0]
 800710e:	b29a      	uxth	r2, r3
 8007110:	693b      	ldr	r3, [r7, #16]
 8007112:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007116:	3306      	adds	r3, #6
 8007118:	781b      	ldrb	r3, [r3, #0]
 800711a:	b29b      	uxth	r3, r3
 800711c:	021b      	lsls	r3, r3, #8
 800711e:	b29b      	uxth	r3, r3
 8007120:	4313      	orrs	r3, r2
 8007122:	b29a      	uxth	r2, r3
 8007124:	687b      	ldr	r3, [r7, #4]
 8007126:	809a      	strh	r2, [r3, #4]
      break;
 8007128:	bf00      	nop
  }

  return error;
 800712a:	7dfb      	ldrb	r3, [r7, #23]
}
 800712c:	4618      	mov	r0, r3
 800712e:	3718      	adds	r7, #24
 8007130:	46bd      	mov	sp, r7
 8007132:	bd80      	pop	{r7, pc}

08007134 <USBH_MSC_SCSI_Inquiry>:
  * @param  capacity: pointer to the inquiry structure
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry(USBH_HandleTypeDef *phost, uint8_t lun,
                                         SCSI_StdInquiryDataTypeDef *inquiry)
{
 8007134:	b580      	push	{r7, lr}
 8007136:	b086      	sub	sp, #24
 8007138:	af00      	add	r7, sp, #0
 800713a:	60f8      	str	r0, [r7, #12]
 800713c:	460b      	mov	r3, r1
 800713e:	607a      	str	r2, [r7, #4]
 8007140:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef error = USBH_FAIL;
 8007142:	2302      	movs	r3, #2
 8007144:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8007146:	68fb      	ldr	r3, [r7, #12]
 8007148:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800714c:	69db      	ldr	r3, [r3, #28]
 800714e:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 8007150:	693b      	ldr	r3, [r7, #16]
 8007152:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 8007156:	2b01      	cmp	r3, #1
 8007158:	d002      	beq.n	8007160 <USBH_MSC_SCSI_Inquiry+0x2c>
 800715a:	2b02      	cmp	r3, #2
 800715c:	d03d      	beq.n	80071da <USBH_MSC_SCSI_Inquiry+0xa6>
        USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
      }
      break;

    default:
      break;
 800715e:	e089      	b.n	8007274 <USBH_MSC_SCSI_Inquiry+0x140>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
 8007160:	693b      	ldr	r3, [r7, #16]
 8007162:	2224      	movs	r2, #36	; 0x24
 8007164:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8007166:	693b      	ldr	r3, [r7, #16]
 8007168:	2280      	movs	r2, #128	; 0x80
 800716a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800716e:	693b      	ldr	r3, [r7, #16]
 8007170:	220a      	movs	r2, #10
 8007172:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
 8007176:	693b      	ldr	r3, [r7, #16]
 8007178:	3363      	adds	r3, #99	; 0x63
 800717a:	220a      	movs	r2, #10
 800717c:	2100      	movs	r1, #0
 800717e:	4618      	mov	r0, r3
 8007180:	f021 f87e 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY;
 8007184:	693b      	ldr	r3, [r7, #16]
 8007186:	2212      	movs	r2, #18
 8007188:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 800718c:	7afb      	ldrb	r3, [r7, #11]
 800718e:	015b      	lsls	r3, r3, #5
 8007190:	b2da      	uxtb	r2, r3
 8007192:	693b      	ldr	r3, [r7, #16]
 8007194:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 8007198:	693b      	ldr	r3, [r7, #16]
 800719a:	2200      	movs	r2, #0
 800719c:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 80071a0:	693b      	ldr	r3, [r7, #16]
 80071a2:	2200      	movs	r2, #0
 80071a4:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = 0x24U;
 80071a8:	693b      	ldr	r3, [r7, #16]
 80071aa:	2224      	movs	r2, #36	; 0x24
 80071ac:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 80071b0:	693b      	ldr	r3, [r7, #16]
 80071b2:	2200      	movs	r2, #0
 80071b4:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 80071b8:	693b      	ldr	r3, [r7, #16]
 80071ba:	2201      	movs	r2, #1
 80071bc:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 80071c0:	693b      	ldr	r3, [r7, #16]
 80071c2:	2202      	movs	r2, #2
 80071c4:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 80071c8:	693b      	ldr	r3, [r7, #16]
 80071ca:	f103 0210 	add.w	r2, r3, #16
 80071ce:	693b      	ldr	r3, [r7, #16]
 80071d0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      error = USBH_BUSY;
 80071d4:	2301      	movs	r3, #1
 80071d6:	75fb      	strb	r3, [r7, #23]
      break;
 80071d8:	e04c      	b.n	8007274 <USBH_MSC_SCSI_Inquiry+0x140>
      error = USBH_MSC_BOT_Process(phost, lun);
 80071da:	7afb      	ldrb	r3, [r7, #11]
 80071dc:	4619      	mov	r1, r3
 80071de:	68f8      	ldr	r0, [r7, #12]
 80071e0:	f7ff fcac 	bl	8006b3c <USBH_MSC_BOT_Process>
 80071e4:	4603      	mov	r3, r0
 80071e6:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 80071e8:	7dfb      	ldrb	r3, [r7, #23]
 80071ea:	2b00      	cmp	r3, #0
 80071ec:	d141      	bne.n	8007272 <USBH_MSC_SCSI_Inquiry+0x13e>
        USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
 80071ee:	2222      	movs	r2, #34	; 0x22
 80071f0:	2100      	movs	r1, #0
 80071f2:	6878      	ldr	r0, [r7, #4]
 80071f4:	f021 f844 	bl	8028280 <memset>
        inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1FU;
 80071f8:	693b      	ldr	r3, [r7, #16]
 80071fa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80071fe:	781b      	ldrb	r3, [r3, #0]
 8007200:	f003 031f 	and.w	r3, r3, #31
 8007204:	b2da      	uxtb	r2, r3
 8007206:	687b      	ldr	r3, [r7, #4]
 8007208:	705a      	strb	r2, [r3, #1]
        inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5U;
 800720a:	693b      	ldr	r3, [r7, #16]
 800720c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007210:	781b      	ldrb	r3, [r3, #0]
 8007212:	095b      	lsrs	r3, r3, #5
 8007214:	b2da      	uxtb	r2, r3
 8007216:	687b      	ldr	r3, [r7, #4]
 8007218:	701a      	strb	r2, [r3, #0]
        if (((uint32_t)MSC_Handle->hbot.pbuf[1] & 0x80U) == 0x80U)
 800721a:	693b      	ldr	r3, [r7, #16]
 800721c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007220:	3301      	adds	r3, #1
 8007222:	781b      	ldrb	r3, [r3, #0]
 8007224:	b25b      	sxtb	r3, r3
 8007226:	2b00      	cmp	r3, #0
 8007228:	da03      	bge.n	8007232 <USBH_MSC_SCSI_Inquiry+0xfe>
          inquiry->RemovableMedia = 1U;
 800722a:	687b      	ldr	r3, [r7, #4]
 800722c:	2201      	movs	r2, #1
 800722e:	709a      	strb	r2, [r3, #2]
 8007230:	e002      	b.n	8007238 <USBH_MSC_SCSI_Inquiry+0x104>
          inquiry->RemovableMedia = 0U;
 8007232:	687b      	ldr	r3, [r7, #4]
 8007234:	2200      	movs	r2, #0
 8007236:	709a      	strb	r2, [r3, #2]
        USBH_memcpy(inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8U);
 8007238:	687b      	ldr	r3, [r7, #4]
 800723a:	1cd8      	adds	r0, r3, #3
 800723c:	693b      	ldr	r3, [r7, #16]
 800723e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007242:	3308      	adds	r3, #8
 8007244:	2208      	movs	r2, #8
 8007246:	4619      	mov	r1, r3
 8007248:	f021 f80c 	bl	8028264 <memcpy>
        USBH_memcpy(inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16U);
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	f103 000c 	add.w	r0, r3, #12
 8007252:	693b      	ldr	r3, [r7, #16]
 8007254:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007258:	3310      	adds	r3, #16
 800725a:	2210      	movs	r2, #16
 800725c:	4619      	mov	r1, r3
 800725e:	f021 f801 	bl	8028264 <memcpy>
        USBH_memcpy(inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4U);
 8007262:	687b      	ldr	r3, [r7, #4]
 8007264:	331d      	adds	r3, #29
 8007266:	693a      	ldr	r2, [r7, #16]
 8007268:	f8d2 208c 	ldr.w	r2, [r2, #140]	; 0x8c
 800726c:	3220      	adds	r2, #32
 800726e:	6812      	ldr	r2, [r2, #0]
 8007270:	601a      	str	r2, [r3, #0]
      break;
 8007272:	bf00      	nop
  }

  return error;
 8007274:	7dfb      	ldrb	r3, [r7, #23]
}
 8007276:	4618      	mov	r0, r3
 8007278:	3718      	adds	r7, #24
 800727a:	46bd      	mov	sp, r7
 800727c:	bd80      	pop	{r7, pc}

0800727e <USBH_MSC_SCSI_RequestSense>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense(USBH_HandleTypeDef *phost,
                                              uint8_t lun,
                                              SCSI_SenseTypeDef *sense_data)
{
 800727e:	b580      	push	{r7, lr}
 8007280:	b086      	sub	sp, #24
 8007282:	af00      	add	r7, sp, #0
 8007284:	60f8      	str	r0, [r7, #12]
 8007286:	460b      	mov	r3, r1
 8007288:	607a      	str	r2, [r7, #4]
 800728a:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL ;
 800728c:	2302      	movs	r3, #2
 800728e:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8007290:	68fb      	ldr	r3, [r7, #12]
 8007292:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007296:	69db      	ldr	r3, [r3, #28]
 8007298:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800729a:	693b      	ldr	r3, [r7, #16]
 800729c:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 80072a0:	2b01      	cmp	r3, #1
 80072a2:	d002      	beq.n	80072aa <USBH_MSC_SCSI_RequestSense+0x2c>
 80072a4:	2b02      	cmp	r3, #2
 80072a6:	d03d      	beq.n	8007324 <USBH_MSC_SCSI_RequestSense+0xa6>
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
      }
      break;

    default:
      break;
 80072a8:	e05d      	b.n	8007366 <USBH_MSC_SCSI_RequestSense+0xe8>
      MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
 80072aa:	693b      	ldr	r3, [r7, #16]
 80072ac:	220e      	movs	r2, #14
 80072ae:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 80072b0:	693b      	ldr	r3, [r7, #16]
 80072b2:	2280      	movs	r2, #128	; 0x80
 80072b4:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 80072b8:	693b      	ldr	r3, [r7, #16]
 80072ba:	220a      	movs	r2, #10
 80072bc:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 80072c0:	693b      	ldr	r3, [r7, #16]
 80072c2:	3363      	adds	r3, #99	; 0x63
 80072c4:	2210      	movs	r2, #16
 80072c6:	2100      	movs	r1, #0
 80072c8:	4618      	mov	r0, r3
 80072ca:	f020 ffd9 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE;
 80072ce:	693b      	ldr	r3, [r7, #16]
 80072d0:	2203      	movs	r2, #3
 80072d2:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);
 80072d6:	7afb      	ldrb	r3, [r7, #11]
 80072d8:	015b      	lsls	r3, r3, #5
 80072da:	b2da      	uxtb	r2, r3
 80072dc:	693b      	ldr	r3, [r7, #16]
 80072de:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      MSC_Handle->hbot.cbw.field.CB[2]  = 0U;
 80072e2:	693b      	ldr	r3, [r7, #16]
 80072e4:	2200      	movs	r2, #0
 80072e6:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = 0U;
 80072ea:	693b      	ldr	r3, [r7, #16]
 80072ec:	2200      	movs	r2, #0
 80072ee:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
 80072f2:	693b      	ldr	r3, [r7, #16]
 80072f4:	220e      	movs	r2, #14
 80072f6:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = 0U;
 80072fa:	693b      	ldr	r3, [r7, #16]
 80072fc:	2200      	movs	r2, #0
 80072fe:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 8007302:	693b      	ldr	r3, [r7, #16]
 8007304:	2201      	movs	r2, #1
 8007306:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 800730a:	693b      	ldr	r3, [r7, #16]
 800730c:	2202      	movs	r2, #2
 800730e:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      MSC_Handle->hbot.pbuf = (uint8_t *)(void *)MSC_Handle->hbot.data;
 8007312:	693b      	ldr	r3, [r7, #16]
 8007314:	f103 0210 	add.w	r2, r3, #16
 8007318:	693b      	ldr	r3, [r7, #16]
 800731a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      error = USBH_BUSY;
 800731e:	2301      	movs	r3, #1
 8007320:	75fb      	strb	r3, [r7, #23]
      break;
 8007322:	e020      	b.n	8007366 <USBH_MSC_SCSI_RequestSense+0xe8>
      error = USBH_MSC_BOT_Process(phost, lun);
 8007324:	7afb      	ldrb	r3, [r7, #11]
 8007326:	4619      	mov	r1, r3
 8007328:	68f8      	ldr	r0, [r7, #12]
 800732a:	f7ff fc07 	bl	8006b3c <USBH_MSC_BOT_Process>
 800732e:	4603      	mov	r3, r0
 8007330:	75fb      	strb	r3, [r7, #23]
      if (error == USBH_OK)
 8007332:	7dfb      	ldrb	r3, [r7, #23]
 8007334:	2b00      	cmp	r3, #0
 8007336:	d115      	bne.n	8007364 <USBH_MSC_SCSI_RequestSense+0xe6>
        sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0FU;
 8007338:	693b      	ldr	r3, [r7, #16]
 800733a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800733e:	3302      	adds	r3, #2
 8007340:	781b      	ldrb	r3, [r3, #0]
 8007342:	f003 030f 	and.w	r3, r3, #15
 8007346:	b2da      	uxtb	r2, r3
 8007348:	687b      	ldr	r3, [r7, #4]
 800734a:	701a      	strb	r2, [r3, #0]
        sense_data->asc  = MSC_Handle->hbot.pbuf[12];
 800734c:	693b      	ldr	r3, [r7, #16]
 800734e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007352:	7b1a      	ldrb	r2, [r3, #12]
 8007354:	687b      	ldr	r3, [r7, #4]
 8007356:	705a      	strb	r2, [r3, #1]
        sense_data->ascq = MSC_Handle->hbot.pbuf[13];
 8007358:	693b      	ldr	r3, [r7, #16]
 800735a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800735e:	7b5a      	ldrb	r2, [r3, #13]
 8007360:	687b      	ldr	r3, [r7, #4]
 8007362:	709a      	strb	r2, [r3, #2]
      break;
 8007364:	bf00      	nop
  }

  return error;
 8007366:	7dfb      	ldrb	r3, [r7, #23]
}
 8007368:	4618      	mov	r0, r3
 800736a:	3718      	adds	r7, #24
 800736c:	46bd      	mov	sp, r7
 800736e:	bd80      	pop	{r7, pc}

08007370 <USBH_MSC_SCSI_Write>:
USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
                                       uint8_t lun,
                                       uint32_t address,
                                       uint8_t *pbuf,
                                       uint32_t length)
{
 8007370:	b580      	push	{r7, lr}
 8007372:	b086      	sub	sp, #24
 8007374:	af00      	add	r7, sp, #0
 8007376:	60f8      	str	r0, [r7, #12]
 8007378:	607a      	str	r2, [r7, #4]
 800737a:	603b      	str	r3, [r7, #0]
 800737c:	460b      	mov	r3, r1
 800737e:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL ;
 8007380:	2302      	movs	r3, #2
 8007382:	75fb      	strb	r3, [r7, #23]

  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 8007384:	68fb      	ldr	r3, [r7, #12]
 8007386:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800738a:	69db      	ldr	r3, [r3, #28]
 800738c:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 800738e:	693b      	ldr	r3, [r7, #16]
 8007390:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 8007394:	2b01      	cmp	r3, #1
 8007396:	d002      	beq.n	800739e <USBH_MSC_SCSI_Write+0x2e>
 8007398:	2b02      	cmp	r3, #2
 800739a:	d047      	beq.n	800742c <USBH_MSC_SCSI_Write+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 800739c:	e04e      	b.n	800743c <USBH_MSC_SCSI_Write+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 800739e:	693b      	ldr	r3, [r7, #16]
 80073a0:	f8b3 3098 	ldrh.w	r3, [r3, #152]	; 0x98
 80073a4:	461a      	mov	r2, r3
 80073a6:	6a3b      	ldr	r3, [r7, #32]
 80073a8:	fb03 f202 	mul.w	r2, r3, r2
 80073ac:	693b      	ldr	r3, [r7, #16]
 80073ae:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
 80073b0:	693b      	ldr	r3, [r7, #16]
 80073b2:	2200      	movs	r2, #0
 80073b4:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 80073b8:	693b      	ldr	r3, [r7, #16]
 80073ba:	220a      	movs	r2, #10
 80073bc:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 80073c0:	693b      	ldr	r3, [r7, #16]
 80073c2:	3363      	adds	r3, #99	; 0x63
 80073c4:	2210      	movs	r2, #16
 80073c6:	2100      	movs	r1, #0
 80073c8:	4618      	mov	r0, r3
 80073ca:	f020 ff59 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10;
 80073ce:	693b      	ldr	r3, [r7, #16]
 80073d0:	222a      	movs	r2, #42	; 0x2a
 80073d2:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 80073d6:	79fa      	ldrb	r2, [r7, #7]
 80073d8:	693b      	ldr	r3, [r7, #16]
 80073da:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 80073de:	79ba      	ldrb	r2, [r7, #6]
 80073e0:	693b      	ldr	r3, [r7, #16]
 80073e2:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 80073e6:	797a      	ldrb	r2, [r7, #5]
 80073e8:	693b      	ldr	r3, [r7, #16]
 80073ea:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 80073ee:	1d3b      	adds	r3, r7, #4
 80073f0:	781a      	ldrb	r2, [r3, #0]
 80073f2:	693b      	ldr	r3, [r7, #16]
 80073f4:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]) ;
 80073f8:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 80073fc:	693b      	ldr	r3, [r7, #16]
 80073fe:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]) ;
 8007402:	f107 0320 	add.w	r3, r7, #32
 8007406:	781a      	ldrb	r2, [r3, #0]
 8007408:	693b      	ldr	r3, [r7, #16]
 800740a:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 800740e:	693b      	ldr	r3, [r7, #16]
 8007410:	2201      	movs	r2, #1
 8007412:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 8007416:	693b      	ldr	r3, [r7, #16]
 8007418:	2202      	movs	r2, #2
 800741a:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 800741e:	693b      	ldr	r3, [r7, #16]
 8007420:	683a      	ldr	r2, [r7, #0]
 8007422:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      error = USBH_BUSY;
 8007426:	2301      	movs	r3, #1
 8007428:	75fb      	strb	r3, [r7, #23]
      break;
 800742a:	e007      	b.n	800743c <USBH_MSC_SCSI_Write+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 800742c:	7afb      	ldrb	r3, [r7, #11]
 800742e:	4619      	mov	r1, r3
 8007430:	68f8      	ldr	r0, [r7, #12]
 8007432:	f7ff fb83 	bl	8006b3c <USBH_MSC_BOT_Process>
 8007436:	4603      	mov	r3, r0
 8007438:	75fb      	strb	r3, [r7, #23]
      break;
 800743a:	bf00      	nop
  }

  return error;
 800743c:	7dfb      	ldrb	r3, [r7, #23]
}
 800743e:	4618      	mov	r0, r3
 8007440:	3718      	adds	r7, #24
 8007442:	46bd      	mov	sp, r7
 8007444:	bd80      	pop	{r7, pc}

08007446 <USBH_MSC_SCSI_Read>:
USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
                                      uint8_t lun,
                                      uint32_t address,
                                      uint8_t *pbuf,
                                      uint32_t length)
{
 8007446:	b580      	push	{r7, lr}
 8007448:	b086      	sub	sp, #24
 800744a:	af00      	add	r7, sp, #0
 800744c:	60f8      	str	r0, [r7, #12]
 800744e:	607a      	str	r2, [r7, #4]
 8007450:	603b      	str	r3, [r7, #0]
 8007452:	460b      	mov	r3, r1
 8007454:	72fb      	strb	r3, [r7, #11]
  USBH_StatusTypeDef    error = USBH_FAIL ;
 8007456:	2302      	movs	r3, #2
 8007458:	75fb      	strb	r3, [r7, #23]
  MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
 800745a:	68fb      	ldr	r3, [r7, #12]
 800745c:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007460:	69db      	ldr	r3, [r3, #28]
 8007462:	613b      	str	r3, [r7, #16]

  switch (MSC_Handle->hbot.cmd_state)
 8007464:	693b      	ldr	r3, [r7, #16]
 8007466:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800746a:	2b01      	cmp	r3, #1
 800746c:	d002      	beq.n	8007474 <USBH_MSC_SCSI_Read+0x2e>
 800746e:	2b02      	cmp	r3, #2
 8007470:	d047      	beq.n	8007502 <USBH_MSC_SCSI_Read+0xbc>
    case BOT_CMD_WAIT:
      error = USBH_MSC_BOT_Process(phost, lun);
      break;

    default:
      break;
 8007472:	e04e      	b.n	8007512 <USBH_MSC_SCSI_Read+0xcc>
      MSC_Handle->hbot.cbw.field.DataTransferLength = length * MSC_Handle->unit[0].capacity.block_size;
 8007474:	693b      	ldr	r3, [r7, #16]
 8007476:	f8b3 3098 	ldrh.w	r3, [r3, #152]	; 0x98
 800747a:	461a      	mov	r2, r3
 800747c:	6a3b      	ldr	r3, [r7, #32]
 800747e:	fb03 f202 	mul.w	r2, r3, r2
 8007482:	693b      	ldr	r3, [r7, #16]
 8007484:	65da      	str	r2, [r3, #92]	; 0x5c
      MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
 8007486:	693b      	ldr	r3, [r7, #16]
 8007488:	2280      	movs	r2, #128	; 0x80
 800748a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
      MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
 800748e:	693b      	ldr	r3, [r7, #16]
 8007490:	220a      	movs	r2, #10
 8007492:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
      USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
 8007496:	693b      	ldr	r3, [r7, #16]
 8007498:	3363      	adds	r3, #99	; 0x63
 800749a:	2210      	movs	r2, #16
 800749c:	2100      	movs	r1, #0
 800749e:	4618      	mov	r0, r3
 80074a0:	f020 feee 	bl	8028280 <memset>
      MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10;
 80074a4:	693b      	ldr	r3, [r7, #16]
 80074a6:	2228      	movs	r2, #40	; 0x28
 80074a8:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
      MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t *)(void *)&address)[3]);
 80074ac:	79fa      	ldrb	r2, [r7, #7]
 80074ae:	693b      	ldr	r3, [r7, #16]
 80074b0:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
      MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t *)(void *)&address)[2]);
 80074b4:	79ba      	ldrb	r2, [r7, #6]
 80074b6:	693b      	ldr	r3, [r7, #16]
 80074b8:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
      MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t *)(void *)&address)[1]);
 80074bc:	797a      	ldrb	r2, [r7, #5]
 80074be:	693b      	ldr	r3, [r7, #16]
 80074c0:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
      MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t *)(void *)&address)[0]);
 80074c4:	1d3b      	adds	r3, r7, #4
 80074c6:	781a      	ldrb	r2, [r3, #0]
 80074c8:	693b      	ldr	r3, [r7, #16]
 80074ca:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
      MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)(void *)&length)[1]) ;
 80074ce:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 80074d2:	693b      	ldr	r3, [r7, #16]
 80074d4:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
      MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)(void *)&length)[0]) ;
 80074d8:	f107 0320 	add.w	r3, r7, #32
 80074dc:	781a      	ldrb	r2, [r3, #0]
 80074de:	693b      	ldr	r3, [r7, #16]
 80074e0:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
      MSC_Handle->hbot.state = BOT_SEND_CBW;
 80074e4:	693b      	ldr	r3, [r7, #16]
 80074e6:	2201      	movs	r2, #1
 80074e8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
 80074ec:	693b      	ldr	r3, [r7, #16]
 80074ee:	2202      	movs	r2, #2
 80074f0:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
      MSC_Handle->hbot.pbuf = pbuf;
 80074f4:	693b      	ldr	r3, [r7, #16]
 80074f6:	683a      	ldr	r2, [r7, #0]
 80074f8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      error = USBH_BUSY;
 80074fc:	2301      	movs	r3, #1
 80074fe:	75fb      	strb	r3, [r7, #23]
      break;
 8007500:	e007      	b.n	8007512 <USBH_MSC_SCSI_Read+0xcc>
      error = USBH_MSC_BOT_Process(phost, lun);
 8007502:	7afb      	ldrb	r3, [r7, #11]
 8007504:	4619      	mov	r1, r3
 8007506:	68f8      	ldr	r0, [r7, #12]
 8007508:	f7ff fb18 	bl	8006b3c <USBH_MSC_BOT_Process>
 800750c:	4603      	mov	r3, r0
 800750e:	75fb      	strb	r3, [r7, #23]
      break;
 8007510:	bf00      	nop
  }

  return error;
 8007512:	7dfb      	ldrb	r3, [r7, #23]
}
 8007514:	4618      	mov	r0, r3
 8007516:	3718      	adds	r7, #24
 8007518:	46bd      	mov	sp, r7
 800751a:	bd80      	pop	{r7, pc}

0800751c <USBH_Init>:
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
 800751c:	b580      	push	{r7, lr}
 800751e:	b084      	sub	sp, #16
 8007520:	af00      	add	r7, sp, #0
 8007522:	60f8      	str	r0, [r7, #12]
 8007524:	60b9      	str	r1, [r7, #8]
 8007526:	4613      	mov	r3, r2
 8007528:	71fb      	strb	r3, [r7, #7]
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 800752a:	68fb      	ldr	r3, [r7, #12]
 800752c:	2b00      	cmp	r3, #0
 800752e:	d101      	bne.n	8007534 <USBH_Init+0x18>
  {
    USBH_ErrLog("Invalid Host handle");
    return USBH_FAIL;
 8007530:	2302      	movs	r3, #2
 8007532:	e029      	b.n	8007588 <USBH_Init+0x6c>
  }

  /* Set DRiver ID */
  phost->id = id;
 8007534:	68fb      	ldr	r3, [r7, #12]
 8007536:	79fa      	ldrb	r2, [r7, #7]
 8007538:	f883 23cc 	strb.w	r2, [r3, #972]	; 0x3cc

  /* Unlink class*/
  phost->pActiveClass = NULL;
 800753c:	68fb      	ldr	r3, [r7, #12]
 800753e:	2200      	movs	r2, #0
 8007540:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
  phost->ClassNumber = 0U;
 8007544:	68fb      	ldr	r3, [r7, #12]
 8007546:	2200      	movs	r2, #0
 8007548:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380

  /* Restore default states and prepare EP0 */
  DeInitStateMachine(phost);
 800754c:	68f8      	ldr	r0, [r7, #12]
 800754e:	f000 f81f 	bl	8007590 <DeInitStateMachine>

  /* Restore default Device connection states */
  phost->device.PortEnabled = 0U;
 8007552:	68fb      	ldr	r3, [r7, #12]
 8007554:	2200      	movs	r2, #0
 8007556:	f883 2323 	strb.w	r2, [r3, #803]	; 0x323
  phost->device.is_connected = 0U;
 800755a:	68fb      	ldr	r3, [r7, #12]
 800755c:	2200      	movs	r2, #0
 800755e:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  phost->device.is_disconnected = 0U;
 8007562:	68fb      	ldr	r3, [r7, #12]
 8007564:	2200      	movs	r2, #0
 8007566:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
  phost->device.is_ReEnumerated = 0U;
 800756a:	68fb      	ldr	r3, [r7, #12]
 800756c:	2200      	movs	r2, #0
 800756e:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322

  /* Assign User process */
  if (pUsrFunc != NULL)
 8007572:	68bb      	ldr	r3, [r7, #8]
 8007574:	2b00      	cmp	r3, #0
 8007576:	d003      	beq.n	8007580 <USBH_Init+0x64>
  {
    phost->pUser = pUsrFunc;
 8007578:	68fb      	ldr	r3, [r7, #12]
 800757a:	68ba      	ldr	r2, [r7, #8]
 800757c:	f8c3 23d4 	str.w	r2, [r3, #980]	; 0x3d4

#endif /* (osCMSIS < 0x20000U) */
#endif /* (USBH_USE_OS == 1U) */

  /* Initialize low level driver */
  USBH_LL_Init(phost);
 8007580:	68f8      	ldr	r0, [r7, #12]
 8007582:	f020 fc37 	bl	8027df4 <USBH_LL_Init>

  return USBH_OK;
 8007586:	2300      	movs	r3, #0
}
 8007588:	4618      	mov	r0, r3
 800758a:	3710      	adds	r7, #16
 800758c:	46bd      	mov	sp, r7
 800758e:	bd80      	pop	{r7, pc}

08007590 <DeInitStateMachine>:
  *         De-Initialize the Host state machine.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef DeInitStateMachine(USBH_HandleTypeDef *phost)
{
 8007590:	b480      	push	{r7}
 8007592:	b085      	sub	sp, #20
 8007594:	af00      	add	r7, sp, #0
 8007596:	6078      	str	r0, [r7, #4]
  uint32_t i = 0U;
 8007598:	2300      	movs	r3, #0
 800759a:	60fb      	str	r3, [r7, #12]

  /* Clear Pipes flags*/
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 800759c:	2300      	movs	r3, #0
 800759e:	60fb      	str	r3, [r7, #12]
 80075a0:	e009      	b.n	80075b6 <DeInitStateMachine+0x26>
  {
    phost->Pipes[i] = 0U;
 80075a2:	687a      	ldr	r2, [r7, #4]
 80075a4:	68fb      	ldr	r3, [r7, #12]
 80075a6:	33e0      	adds	r3, #224	; 0xe0
 80075a8:	009b      	lsls	r3, r3, #2
 80075aa:	4413      	add	r3, r2
 80075ac:	2200      	movs	r2, #0
 80075ae:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < USBH_MAX_PIPES_NBR; i++)
 80075b0:	68fb      	ldr	r3, [r7, #12]
 80075b2:	3301      	adds	r3, #1
 80075b4:	60fb      	str	r3, [r7, #12]
 80075b6:	68fb      	ldr	r3, [r7, #12]
 80075b8:	2b0e      	cmp	r3, #14
 80075ba:	d9f2      	bls.n	80075a2 <DeInitStateMachine+0x12>
  }

  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 80075bc:	2300      	movs	r3, #0
 80075be:	60fb      	str	r3, [r7, #12]
 80075c0:	e009      	b.n	80075d6 <DeInitStateMachine+0x46>
  {
    phost->device.Data[i] = 0U;
 80075c2:	687a      	ldr	r2, [r7, #4]
 80075c4:	68fb      	ldr	r3, [r7, #12]
 80075c6:	4413      	add	r3, r2
 80075c8:	f503 738e 	add.w	r3, r3, #284	; 0x11c
 80075cc:	2200      	movs	r2, #0
 80075ce:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < USBH_MAX_DATA_BUFFER; i++)
 80075d0:	68fb      	ldr	r3, [r7, #12]
 80075d2:	3301      	adds	r3, #1
 80075d4:	60fb      	str	r3, [r7, #12]
 80075d6:	68fb      	ldr	r3, [r7, #12]
 80075d8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80075dc:	d3f1      	bcc.n	80075c2 <DeInitStateMachine+0x32>
  }

  phost->gState = HOST_IDLE;
 80075de:	687b      	ldr	r3, [r7, #4]
 80075e0:	2200      	movs	r2, #0
 80075e2:	701a      	strb	r2, [r3, #0]
  phost->EnumState = ENUM_IDLE;
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	2200      	movs	r2, #0
 80075e8:	705a      	strb	r2, [r3, #1]
  phost->RequestState = CMD_SEND;
 80075ea:	687b      	ldr	r3, [r7, #4]
 80075ec:	2201      	movs	r2, #1
 80075ee:	709a      	strb	r2, [r3, #2]
  phost->Timer = 0U;
 80075f0:	687b      	ldr	r3, [r7, #4]
 80075f2:	2200      	movs	r2, #0
 80075f4:	f8c3 23c4 	str.w	r2, [r3, #964]	; 0x3c4

  phost->Control.state = CTRL_SETUP;
 80075f8:	687b      	ldr	r3, [r7, #4]
 80075fa:	2201      	movs	r2, #1
 80075fc:	761a      	strb	r2, [r3, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 80075fe:	687b      	ldr	r3, [r7, #4]
 8007600:	2240      	movs	r2, #64	; 0x40
 8007602:	719a      	strb	r2, [r3, #6]
  phost->Control.errorcount = 0U;
 8007604:	687b      	ldr	r3, [r7, #4]
 8007606:	2200      	movs	r2, #0
 8007608:	765a      	strb	r2, [r3, #25]

  phost->device.address = USBH_ADDRESS_DEFAULT;
 800760a:	687b      	ldr	r3, [r7, #4]
 800760c:	2200      	movs	r2, #0
 800760e:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c
  phost->device.speed = USBH_SPEED_FULL;
 8007612:	687b      	ldr	r3, [r7, #4]
 8007614:	2201      	movs	r2, #1
 8007616:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
  phost->device.RstCnt = 0U;
 800761a:	687b      	ldr	r3, [r7, #4]
 800761c:	2200      	movs	r2, #0
 800761e:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
  phost->device.EnumCnt = 0U;
 8007622:	687b      	ldr	r3, [r7, #4]
 8007624:	2200      	movs	r2, #0
 8007626:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e

  return USBH_OK;
 800762a:	2300      	movs	r3, #0
}
 800762c:	4618      	mov	r0, r3
 800762e:	3714      	adds	r7, #20
 8007630:	46bd      	mov	sp, r7
 8007632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007636:	4770      	bx	lr

08007638 <USBH_RegisterClass>:
  * @param  phost : Host Handle
  * @param  pclass: Class handle
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
 8007638:	b480      	push	{r7}
 800763a:	b085      	sub	sp, #20
 800763c:	af00      	add	r7, sp, #0
 800763e:	6078      	str	r0, [r7, #4]
 8007640:	6039      	str	r1, [r7, #0]
  USBH_StatusTypeDef status = USBH_OK;
 8007642:	2300      	movs	r3, #0
 8007644:	73fb      	strb	r3, [r7, #15]

  if (pclass != NULL)
 8007646:	683b      	ldr	r3, [r7, #0]
 8007648:	2b00      	cmp	r3, #0
 800764a:	d016      	beq.n	800767a <USBH_RegisterClass+0x42>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 800764c:	687b      	ldr	r3, [r7, #4]
 800764e:	f8d3 3380 	ldr.w	r3, [r3, #896]	; 0x380
 8007652:	2b00      	cmp	r3, #0
 8007654:	d10e      	bne.n	8007674 <USBH_RegisterClass+0x3c>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 8007656:	687b      	ldr	r3, [r7, #4]
 8007658:	f8d3 3380 	ldr.w	r3, [r3, #896]	; 0x380
 800765c:	1c59      	adds	r1, r3, #1
 800765e:	687a      	ldr	r2, [r7, #4]
 8007660:	f8c2 1380 	str.w	r1, [r2, #896]	; 0x380
 8007664:	687a      	ldr	r2, [r7, #4]
 8007666:	33de      	adds	r3, #222	; 0xde
 8007668:	6839      	ldr	r1, [r7, #0]
 800766a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      status = USBH_OK;
 800766e:	2300      	movs	r3, #0
 8007670:	73fb      	strb	r3, [r7, #15]
 8007672:	e004      	b.n	800767e <USBH_RegisterClass+0x46>
    }
    else
    {
      USBH_ErrLog("Max Class Number reached");
      status = USBH_FAIL;
 8007674:	2302      	movs	r3, #2
 8007676:	73fb      	strb	r3, [r7, #15]
 8007678:	e001      	b.n	800767e <USBH_RegisterClass+0x46>
    }
  }
  else
  {
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
 800767a:	2302      	movs	r3, #2
 800767c:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800767e:	7bfb      	ldrb	r3, [r7, #15]
}
 8007680:	4618      	mov	r0, r3
 8007682:	3714      	adds	r7, #20
 8007684:	46bd      	mov	sp, r7
 8007686:	f85d 7b04 	ldr.w	r7, [sp], #4
 800768a:	4770      	bx	lr

0800768c <USBH_SelectInterface>:
  * @param  phost: Host Handle
  * @param  interface: Interface number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
 800768c:	b480      	push	{r7}
 800768e:	b085      	sub	sp, #20
 8007690:	af00      	add	r7, sp, #0
 8007692:	6078      	str	r0, [r7, #4]
 8007694:	460b      	mov	r3, r1
 8007696:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef status = USBH_OK;
 8007698:	2300      	movs	r3, #0
 800769a:	73fb      	strb	r3, [r7, #15]

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 800769c:	687b      	ldr	r3, [r7, #4]
 800769e:	f893 333c 	ldrb.w	r3, [r3, #828]	; 0x33c
 80076a2:	78fa      	ldrb	r2, [r7, #3]
 80076a4:	429a      	cmp	r2, r3
 80076a6:	d204      	bcs.n	80076b2 <USBH_SelectInterface+0x26>
  {
    phost->device.current_interface = interface;
 80076a8:	687b      	ldr	r3, [r7, #4]
 80076aa:	78fa      	ldrb	r2, [r7, #3]
 80076ac:	f883 2324 	strb.w	r2, [r3, #804]	; 0x324
 80076b0:	e001      	b.n	80076b6 <USBH_SelectInterface+0x2a>
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
 80076b2:	2302      	movs	r3, #2
 80076b4:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 80076b6:	7bfb      	ldrb	r3, [r7, #15]
}
 80076b8:	4618      	mov	r0, r3
 80076ba:	3714      	adds	r7, #20
 80076bc:	46bd      	mov	sp, r7
 80076be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076c2:	4770      	bx	lr

080076c4 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 80076c4:	b480      	push	{r7}
 80076c6:	b087      	sub	sp, #28
 80076c8:	af00      	add	r7, sp, #0
 80076ca:	6078      	str	r0, [r7, #4]
 80076cc:	4608      	mov	r0, r1
 80076ce:	4611      	mov	r1, r2
 80076d0:	461a      	mov	r2, r3
 80076d2:	4603      	mov	r3, r0
 80076d4:	70fb      	strb	r3, [r7, #3]
 80076d6:	460b      	mov	r3, r1
 80076d8:	70bb      	strb	r3, [r7, #2]
 80076da:	4613      	mov	r3, r2
 80076dc:	707b      	strb	r3, [r7, #1]
  USBH_InterfaceDescTypeDef *pif;
  USBH_CfgDescTypeDef *pcfg;
  uint8_t if_ix = 0U;
 80076de:	2300      	movs	r3, #0
 80076e0:	75fb      	strb	r3, [r7, #23]

  pif = (USBH_InterfaceDescTypeDef *)0;
 80076e2:	2300      	movs	r3, #0
 80076e4:	613b      	str	r3, [r7, #16]
  pcfg = &phost->device.CfgDesc;
 80076e6:	687b      	ldr	r3, [r7, #4]
 80076e8:	f503 734e 	add.w	r3, r3, #824	; 0x338
 80076ec:	60fb      	str	r3, [r7, #12]

  while (if_ix < USBH_MAX_NUM_INTERFACES)
 80076ee:	e025      	b.n	800773c <USBH_FindInterface+0x78>
  {
    pif = &pcfg->Itf_Desc[if_ix];
 80076f0:	7dfb      	ldrb	r3, [r7, #23]
 80076f2:	221a      	movs	r2, #26
 80076f4:	fb02 f303 	mul.w	r3, r2, r3
 80076f8:	3308      	adds	r3, #8
 80076fa:	68fa      	ldr	r2, [r7, #12]
 80076fc:	4413      	add	r3, r2
 80076fe:	3302      	adds	r3, #2
 8007700:	613b      	str	r3, [r7, #16]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8007702:	693b      	ldr	r3, [r7, #16]
 8007704:	795b      	ldrb	r3, [r3, #5]
 8007706:	78fa      	ldrb	r2, [r7, #3]
 8007708:	429a      	cmp	r2, r3
 800770a:	d002      	beq.n	8007712 <USBH_FindInterface+0x4e>
 800770c:	78fb      	ldrb	r3, [r7, #3]
 800770e:	2bff      	cmp	r3, #255	; 0xff
 8007710:	d111      	bne.n	8007736 <USBH_FindInterface+0x72>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8007712:	693b      	ldr	r3, [r7, #16]
 8007714:	799b      	ldrb	r3, [r3, #6]
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8007716:	78ba      	ldrb	r2, [r7, #2]
 8007718:	429a      	cmp	r2, r3
 800771a:	d002      	beq.n	8007722 <USBH_FindInterface+0x5e>
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 800771c:	78bb      	ldrb	r3, [r7, #2]
 800771e:	2bff      	cmp	r3, #255	; 0xff
 8007720:	d109      	bne.n	8007736 <USBH_FindInterface+0x72>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8007722:	693b      	ldr	r3, [r7, #16]
 8007724:	79db      	ldrb	r3, [r3, #7]
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8007726:	787a      	ldrb	r2, [r7, #1]
 8007728:	429a      	cmp	r2, r3
 800772a:	d002      	beq.n	8007732 <USBH_FindInterface+0x6e>
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 800772c:	787b      	ldrb	r3, [r7, #1]
 800772e:	2bff      	cmp	r3, #255	; 0xff
 8007730:	d101      	bne.n	8007736 <USBH_FindInterface+0x72>
    {
      return  if_ix;
 8007732:	7dfb      	ldrb	r3, [r7, #23]
 8007734:	e006      	b.n	8007744 <USBH_FindInterface+0x80>
    }
    if_ix++;
 8007736:	7dfb      	ldrb	r3, [r7, #23]
 8007738:	3301      	adds	r3, #1
 800773a:	75fb      	strb	r3, [r7, #23]
  while (if_ix < USBH_MAX_NUM_INTERFACES)
 800773c:	7dfb      	ldrb	r3, [r7, #23]
 800773e:	2b01      	cmp	r3, #1
 8007740:	d9d6      	bls.n	80076f0 <USBH_FindInterface+0x2c>
  }
  return 0xFFU;
 8007742:	23ff      	movs	r3, #255	; 0xff
}
 8007744:	4618      	mov	r0, r3
 8007746:	371c      	adds	r7, #28
 8007748:	46bd      	mov	sp, r7
 800774a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800774e:	4770      	bx	lr

08007750 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
 8007750:	b580      	push	{r7, lr}
 8007752:	b082      	sub	sp, #8
 8007754:	af00      	add	r7, sp, #0
 8007756:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  USBH_LL_Start(phost);
 8007758:	6878      	ldr	r0, [r7, #4]
 800775a:	f020 fb87 	bl	8027e6c <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, TRUE);
 800775e:	2101      	movs	r1, #1
 8007760:	6878      	ldr	r0, [r7, #4]
 8007762:	f020 fca0 	bl	80280a6 <USBH_LL_DriverVBUS>

  return USBH_OK;
 8007766:	2300      	movs	r3, #0
}
 8007768:	4618      	mov	r0, r3
 800776a:	3708      	adds	r7, #8
 800776c:	46bd      	mov	sp, r7
 800776e:	bd80      	pop	{r7, pc}

08007770 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
 8007770:	b580      	push	{r7, lr}
 8007772:	b088      	sub	sp, #32
 8007774:	af04      	add	r7, sp, #16
 8007776:	6078      	str	r0, [r7, #4]
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 8007778:	2302      	movs	r3, #2
 800777a:	73bb      	strb	r3, [r7, #14]
  uint8_t idx = 0U;
 800777c:	2300      	movs	r3, #0
 800777e:	73fb      	strb	r3, [r7, #15]

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 8007780:	687b      	ldr	r3, [r7, #4]
 8007782:	f893 3321 	ldrb.w	r3, [r3, #801]	; 0x321
 8007786:	b2db      	uxtb	r3, r3
 8007788:	2b01      	cmp	r3, #1
 800778a:	d102      	bne.n	8007792 <USBH_Process+0x22>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 800778c:	687b      	ldr	r3, [r7, #4]
 800778e:	2203      	movs	r2, #3
 8007790:	701a      	strb	r2, [r3, #0]
  }

  switch (phost->gState)
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	781b      	ldrb	r3, [r3, #0]
 8007796:	b2db      	uxtb	r3, r3
 8007798:	2b0b      	cmp	r3, #11
 800779a:	f200 81b3 	bhi.w	8007b04 <USBH_Process+0x394>
 800779e:	a201      	add	r2, pc, #4	; (adr r2, 80077a4 <USBH_Process+0x34>)
 80077a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80077a4:	080077d5 	.word	0x080077d5
 80077a8:	08007807 	.word	0x08007807
 80077ac:	0800786f 	.word	0x0800786f
 80077b0:	08007a9f 	.word	0x08007a9f
 80077b4:	08007b05 	.word	0x08007b05
 80077b8:	08007913 	.word	0x08007913
 80077bc:	08007a45 	.word	0x08007a45
 80077c0:	08007949 	.word	0x08007949
 80077c4:	08007969 	.word	0x08007969
 80077c8:	08007989 	.word	0x08007989
 80077cc:	080079b7 	.word	0x080079b7
 80077d0:	08007a87 	.word	0x08007a87
  {
    case HOST_IDLE :

      if (phost->device.is_connected)
 80077d4:	687b      	ldr	r3, [r7, #4]
 80077d6:	f893 3320 	ldrb.w	r3, [r3, #800]	; 0x320
 80077da:	b2db      	uxtb	r3, r3
 80077dc:	2b00      	cmp	r3, #0
 80077de:	f000 8193 	beq.w	8007b08 <USBH_Process+0x398>
      {
        USBH_UsrLog("USB Device Connected");

        /* Wait for 200 ms after connection */
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 80077e2:	687b      	ldr	r3, [r7, #4]
 80077e4:	2201      	movs	r2, #1
 80077e6:	701a      	strb	r2, [r3, #0]
        USBH_Delay(200U);
 80077e8:	20c8      	movs	r0, #200	; 0xc8
 80077ea:	f020 fcca 	bl	8028182 <USBH_Delay>
        USBH_LL_ResetPort(phost);
 80077ee:	6878      	ldr	r0, [r7, #4]
 80077f0:	f020 fb99 	bl	8027f26 <USBH_LL_ResetPort>

        /* Make sure to start with Default address */
        phost->device.address = USBH_ADDRESS_DEFAULT;
 80077f4:	687b      	ldr	r3, [r7, #4]
 80077f6:	2200      	movs	r2, #0
 80077f8:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c
        phost->Timeout = 0U;
 80077fc:	687b      	ldr	r3, [r7, #4]
 80077fe:	2200      	movs	r2, #0
 8007800:	f8c3 23c8 	str.w	r2, [r3, #968]	; 0x3c8
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      }
      break;
 8007804:	e180      	b.n	8007b08 <USBH_Process+0x398>

    case HOST_DEV_WAIT_FOR_ATTACHMENT: /* Wait for Port Enabled */

      if (phost->device.PortEnabled == 1U)
 8007806:	687b      	ldr	r3, [r7, #4]
 8007808:	f893 3323 	ldrb.w	r3, [r3, #803]	; 0x323
 800780c:	2b01      	cmp	r3, #1
 800780e:	d107      	bne.n	8007820 <USBH_Process+0xb0>
      {
        USBH_UsrLog("USB Device Reset Completed");
        phost->device.RstCnt = 0U;
 8007810:	687b      	ldr	r3, [r7, #4]
 8007812:	2200      	movs	r2, #0
 8007814:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 8007818:	687b      	ldr	r3, [r7, #4]
 800781a:	2202      	movs	r2, #2
 800781c:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 800781e:	e182      	b.n	8007b26 <USBH_Process+0x3b6>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 8007820:	687b      	ldr	r3, [r7, #4]
 8007822:	f8d3 33c8 	ldr.w	r3, [r3, #968]	; 0x3c8
 8007826:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800782a:	d914      	bls.n	8007856 <USBH_Process+0xe6>
          phost->device.RstCnt++;
 800782c:	687b      	ldr	r3, [r7, #4]
 800782e:	f893 331f 	ldrb.w	r3, [r3, #799]	; 0x31f
 8007832:	3301      	adds	r3, #1
 8007834:	b2da      	uxtb	r2, r3
 8007836:	687b      	ldr	r3, [r7, #4]
 8007838:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
 800783c:	687b      	ldr	r3, [r7, #4]
 800783e:	f893 331f 	ldrb.w	r3, [r3, #799]	; 0x31f
 8007842:	2b03      	cmp	r3, #3
 8007844:	d903      	bls.n	800784e <USBH_Process+0xde>
            phost->gState = HOST_ABORT_STATE;
 8007846:	687b      	ldr	r3, [r7, #4]
 8007848:	220d      	movs	r2, #13
 800784a:	701a      	strb	r2, [r3, #0]
      break;
 800784c:	e16b      	b.n	8007b26 <USBH_Process+0x3b6>
            phost->gState = HOST_IDLE;
 800784e:	687b      	ldr	r3, [r7, #4]
 8007850:	2200      	movs	r2, #0
 8007852:	701a      	strb	r2, [r3, #0]
      break;
 8007854:	e167      	b.n	8007b26 <USBH_Process+0x3b6>
          phost->Timeout += 10U;
 8007856:	687b      	ldr	r3, [r7, #4]
 8007858:	f8d3 33c8 	ldr.w	r3, [r3, #968]	; 0x3c8
 800785c:	f103 020a 	add.w	r2, r3, #10
 8007860:	687b      	ldr	r3, [r7, #4]
 8007862:	f8c3 23c8 	str.w	r2, [r3, #968]	; 0x3c8
          USBH_Delay(10U);
 8007866:	200a      	movs	r0, #10
 8007868:	f020 fc8b 	bl	8028182 <USBH_Delay>
      break;
 800786c:	e15b      	b.n	8007b26 <USBH_Process+0x3b6>

    case HOST_DEV_ATTACHED :

      if (phost->pUser != NULL)
 800786e:	687b      	ldr	r3, [r7, #4]
 8007870:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8007874:	2b00      	cmp	r3, #0
 8007876:	d005      	beq.n	8007884 <USBH_Process+0x114>
      {
        phost->pUser(phost, HOST_USER_CONNECTION);
 8007878:	687b      	ldr	r3, [r7, #4]
 800787a:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 800787e:	2104      	movs	r1, #4
 8007880:	6878      	ldr	r0, [r7, #4]
 8007882:	4798      	blx	r3
      }

      /* Wait for 100 ms after Reset */
      USBH_Delay(100U);
 8007884:	2064      	movs	r0, #100	; 0x64
 8007886:	f020 fc7c 	bl	8028182 <USBH_Delay>

      phost->device.speed = USBH_LL_GetSpeed(phost);
 800788a:	6878      	ldr	r0, [r7, #4]
 800788c:	f020 fb24 	bl	8027ed8 <USBH_LL_GetSpeed>
 8007890:	4603      	mov	r3, r0
 8007892:	461a      	mov	r2, r3
 8007894:	687b      	ldr	r3, [r7, #4]
 8007896:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d

      phost->gState = HOST_ENUMERATION;
 800789a:	687b      	ldr	r3, [r7, #4]
 800789c:	2205      	movs	r2, #5
 800789e:	701a      	strb	r2, [r3, #0]

      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 80078a0:	2100      	movs	r1, #0
 80078a2:	6878      	ldr	r0, [r7, #4]
 80078a4:	f001 f92f 	bl	8008b06 <USBH_AllocPipe>
 80078a8:	4603      	mov	r3, r0
 80078aa:	461a      	mov	r2, r3
 80078ac:	687b      	ldr	r3, [r7, #4]
 80078ae:	715a      	strb	r2, [r3, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 80078b0:	2180      	movs	r1, #128	; 0x80
 80078b2:	6878      	ldr	r0, [r7, #4]
 80078b4:	f001 f927 	bl	8008b06 <USBH_AllocPipe>
 80078b8:	4603      	mov	r3, r0
 80078ba:	461a      	mov	r2, r3
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	711a      	strb	r2, [r3, #4]

      /* Open Control pipes */
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 80078c0:	687b      	ldr	r3, [r7, #4]
 80078c2:	7919      	ldrb	r1, [r3, #4]
 80078c4:	687b      	ldr	r3, [r7, #4]
 80078c6:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 80078ca:	687b      	ldr	r3, [r7, #4]
 80078cc:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                    phost->device.address, phost->device.speed,
                    USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 80078d0:	687a      	ldr	r2, [r7, #4]
 80078d2:	7992      	ldrb	r2, [r2, #6]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 80078d4:	b292      	uxth	r2, r2
 80078d6:	9202      	str	r2, [sp, #8]
 80078d8:	2200      	movs	r2, #0
 80078da:	9201      	str	r2, [sp, #4]
 80078dc:	9300      	str	r3, [sp, #0]
 80078de:	4603      	mov	r3, r0
 80078e0:	2280      	movs	r2, #128	; 0x80
 80078e2:	6878      	ldr	r0, [r7, #4]
 80078e4:	f001 f8e0 	bl	8008aa8 <USBH_OpenPipe>

      /* Open Control pipes */
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 80078e8:	687b      	ldr	r3, [r7, #4]
 80078ea:	7959      	ldrb	r1, [r3, #5]
 80078ec:	687b      	ldr	r3, [r7, #4]
 80078ee:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 80078f2:	687b      	ldr	r3, [r7, #4]
 80078f4:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                    phost->device.address, phost->device.speed,
                    USBH_EP_CONTROL, (uint16_t)phost->Control.pipe_size);
 80078f8:	687a      	ldr	r2, [r7, #4]
 80078fa:	7992      	ldrb	r2, [r2, #6]
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 80078fc:	b292      	uxth	r2, r2
 80078fe:	9202      	str	r2, [sp, #8]
 8007900:	2200      	movs	r2, #0
 8007902:	9201      	str	r2, [sp, #4]
 8007904:	9300      	str	r3, [sp, #0]
 8007906:	4603      	mov	r3, r0
 8007908:	2200      	movs	r2, #0
 800790a:	6878      	ldr	r0, [r7, #4]
 800790c:	f001 f8cc 	bl	8008aa8 <USBH_OpenPipe>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8007910:	e109      	b.n	8007b26 <USBH_Process+0x3b6>

    case HOST_ENUMERATION:
      /* Check for enumeration status */
      status = USBH_HandleEnum(phost);
 8007912:	6878      	ldr	r0, [r7, #4]
 8007914:	f000 f90c 	bl	8007b30 <USBH_HandleEnum>
 8007918:	4603      	mov	r3, r0
 800791a:	73bb      	strb	r3, [r7, #14]
      if (status == USBH_OK)
 800791c:	7bbb      	ldrb	r3, [r7, #14]
 800791e:	b2db      	uxtb	r3, r3
 8007920:	2b00      	cmp	r3, #0
 8007922:	f040 80f3 	bne.w	8007b0c <USBH_Process+0x39c>
      {
        /* The function shall return USBH_OK when full enumeration is complete */
        USBH_UsrLog("Enumeration done.");

        phost->device.current_interface = 0U;
 8007926:	687b      	ldr	r3, [r7, #4]
 8007928:	2200      	movs	r2, #0
 800792a:	f883 2324 	strb.w	r2, [r3, #804]	; 0x324

        if (phost->device.DevDesc.bNumConfigurations == 1U)
 800792e:	687b      	ldr	r3, [r7, #4]
 8007930:	f893 3337 	ldrb.w	r3, [r3, #823]	; 0x337
 8007934:	2b01      	cmp	r3, #1
 8007936:	d103      	bne.n	8007940 <USBH_Process+0x1d0>
        {
          USBH_UsrLog("This device has only 1 configuration.");
          phost->gState = HOST_SET_CONFIGURATION;
 8007938:	687b      	ldr	r3, [r7, #4]
 800793a:	2208      	movs	r2, #8
 800793c:	701a      	strb	r2, [r3, #0]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      }
      break;
 800793e:	e0e5      	b.n	8007b0c <USBH_Process+0x39c>
          phost->gState = HOST_INPUT;
 8007940:	687b      	ldr	r3, [r7, #4]
 8007942:	2207      	movs	r2, #7
 8007944:	701a      	strb	r2, [r3, #0]
      break;
 8007946:	e0e1      	b.n	8007b0c <USBH_Process+0x39c>

    case HOST_INPUT:
    {
      /* user callback for end of device basic enumeration */
      if (phost->pUser != NULL)
 8007948:	687b      	ldr	r3, [r7, #4]
 800794a:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 800794e:	2b00      	cmp	r3, #0
 8007950:	f000 80de 	beq.w	8007b10 <USBH_Process+0x3a0>
      {
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 8007954:	687b      	ldr	r3, [r7, #4]
 8007956:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 800795a:	2101      	movs	r1, #1
 800795c:	6878      	ldr	r0, [r7, #4]
 800795e:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 8007960:	687b      	ldr	r3, [r7, #4]
 8007962:	2208      	movs	r2, #8
 8007964:	701a      	strb	r2, [r3, #0]
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      }
    }
    break;
 8007966:	e0d3      	b.n	8007b10 <USBH_Process+0x3a0>

    case HOST_SET_CONFIGURATION:
      /* set configuration */
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 8007968:	687b      	ldr	r3, [r7, #4]
 800796a:	f893 333d 	ldrb.w	r3, [r3, #829]	; 0x33d
 800796e:	b29b      	uxth	r3, r3
 8007970:	4619      	mov	r1, r3
 8007972:	6878      	ldr	r0, [r7, #4]
 8007974:	f000 fc20 	bl	80081b8 <USBH_SetCfg>
 8007978:	4603      	mov	r3, r0
 800797a:	2b00      	cmp	r3, #0
 800797c:	f040 80ca 	bne.w	8007b14 <USBH_Process+0x3a4>
      {
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 8007980:	687b      	ldr	r3, [r7, #4]
 8007982:	2209      	movs	r2, #9
 8007984:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8007986:	e0c5      	b.n	8007b14 <USBH_Process+0x3a4>

    case  HOST_SET_WAKEUP_FEATURE:

      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
 8007988:	687b      	ldr	r3, [r7, #4]
 800798a:	f893 333f 	ldrb.w	r3, [r3, #831]	; 0x33f
 800798e:	f003 0320 	and.w	r3, r3, #32
 8007992:	2b00      	cmp	r3, #0
 8007994:	d00b      	beq.n	80079ae <USBH_Process+0x23e>
      {
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
 8007996:	2101      	movs	r1, #1
 8007998:	6878      	ldr	r0, [r7, #4]
 800799a:	f000 fc30 	bl	80081fe <USBH_SetFeature>
 800799e:	4603      	mov	r3, r0
 80079a0:	2b00      	cmp	r3, #0
 80079a2:	f040 80b9 	bne.w	8007b18 <USBH_Process+0x3a8>
        {
          USBH_UsrLog("Device remote wakeup enabled");
          phost->gState = HOST_CHECK_CLASS;
 80079a6:	687b      	ldr	r3, [r7, #4]
 80079a8:	220a      	movs	r2, #10
 80079aa:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 80079ac:	e0b4      	b.n	8007b18 <USBH_Process+0x3a8>
        phost->gState = HOST_CHECK_CLASS;
 80079ae:	687b      	ldr	r3, [r7, #4]
 80079b0:	220a      	movs	r2, #10
 80079b2:	701a      	strb	r2, [r3, #0]
      break;
 80079b4:	e0b0      	b.n	8007b18 <USBH_Process+0x3a8>

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
 80079b6:	687b      	ldr	r3, [r7, #4]
 80079b8:	f8d3 3380 	ldr.w	r3, [r3, #896]	; 0x380
 80079bc:	2b00      	cmp	r3, #0
 80079be:	f000 80ad 	beq.w	8007b1c <USBH_Process+0x3ac>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
 80079c2:	687b      	ldr	r3, [r7, #4]
 80079c4:	2200      	movs	r2, #0
 80079c6:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 80079ca:	2300      	movs	r3, #0
 80079cc:	73fb      	strb	r3, [r7, #15]
 80079ce:	e016      	b.n	80079fe <USBH_Process+0x28e>
        {
          if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
 80079d0:	7bfa      	ldrb	r2, [r7, #15]
 80079d2:	687b      	ldr	r3, [r7, #4]
 80079d4:	32de      	adds	r2, #222	; 0xde
 80079d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80079da:	791a      	ldrb	r2, [r3, #4]
 80079dc:	687b      	ldr	r3, [r7, #4]
 80079de:	f893 3347 	ldrb.w	r3, [r3, #839]	; 0x347
 80079e2:	429a      	cmp	r2, r3
 80079e4:	d108      	bne.n	80079f8 <USBH_Process+0x288>
          {
            phost->pActiveClass = phost->pClass[idx];
 80079e6:	7bfa      	ldrb	r2, [r7, #15]
 80079e8:	687b      	ldr	r3, [r7, #4]
 80079ea:	32de      	adds	r2, #222	; 0xde
 80079ec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80079f0:	687b      	ldr	r3, [r7, #4]
 80079f2:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
            break;
 80079f6:	e005      	b.n	8007a04 <USBH_Process+0x294>
        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
 80079f8:	7bfb      	ldrb	r3, [r7, #15]
 80079fa:	3301      	adds	r3, #1
 80079fc:	73fb      	strb	r3, [r7, #15]
 80079fe:	7bfb      	ldrb	r3, [r7, #15]
 8007a00:	2b00      	cmp	r3, #0
 8007a02:	d0e5      	beq.n	80079d0 <USBH_Process+0x260>
          }
        }

        if (phost->pActiveClass != NULL)
 8007a04:	687b      	ldr	r3, [r7, #4]
 8007a06:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a0a:	2b00      	cmp	r3, #0
 8007a0c:	d016      	beq.n	8007a3c <USBH_Process+0x2cc>
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 8007a0e:	687b      	ldr	r3, [r7, #4]
 8007a10:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a14:	689b      	ldr	r3, [r3, #8]
 8007a16:	6878      	ldr	r0, [r7, #4]
 8007a18:	4798      	blx	r3
 8007a1a:	4603      	mov	r3, r0
 8007a1c:	2b00      	cmp	r3, #0
 8007a1e:	d109      	bne.n	8007a34 <USBH_Process+0x2c4>
          {
            phost->gState = HOST_CLASS_REQUEST;
 8007a20:	687b      	ldr	r3, [r7, #4]
 8007a22:	2206      	movs	r2, #6
 8007a24:	701a      	strb	r2, [r3, #0]
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 8007a26:	687b      	ldr	r3, [r7, #4]
 8007a28:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8007a2c:	2103      	movs	r1, #3
 8007a2e:	6878      	ldr	r0, [r7, #4]
 8007a30:	4798      	blx	r3
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8007a32:	e073      	b.n	8007b1c <USBH_Process+0x3ac>
            phost->gState = HOST_ABORT_STATE;
 8007a34:	687b      	ldr	r3, [r7, #4]
 8007a36:	220d      	movs	r2, #13
 8007a38:	701a      	strb	r2, [r3, #0]
      break;
 8007a3a:	e06f      	b.n	8007b1c <USBH_Process+0x3ac>
          phost->gState = HOST_ABORT_STATE;
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	220d      	movs	r2, #13
 8007a40:	701a      	strb	r2, [r3, #0]
      break;
 8007a42:	e06b      	b.n	8007b1c <USBH_Process+0x3ac>

    case HOST_CLASS_REQUEST:
      /* process class standard control requests state machine */
      if (phost->pActiveClass != NULL)
 8007a44:	687b      	ldr	r3, [r7, #4]
 8007a46:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a4a:	2b00      	cmp	r3, #0
 8007a4c:	d017      	beq.n	8007a7e <USBH_Process+0x30e>
      {
        status = phost->pActiveClass->Requests(phost);
 8007a4e:	687b      	ldr	r3, [r7, #4]
 8007a50:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a54:	691b      	ldr	r3, [r3, #16]
 8007a56:	6878      	ldr	r0, [r7, #4]
 8007a58:	4798      	blx	r3
 8007a5a:	4603      	mov	r3, r0
 8007a5c:	73bb      	strb	r3, [r7, #14]

        if (status == USBH_OK)
 8007a5e:	7bbb      	ldrb	r3, [r7, #14]
 8007a60:	b2db      	uxtb	r3, r3
 8007a62:	2b00      	cmp	r3, #0
 8007a64:	d103      	bne.n	8007a6e <USBH_Process+0x2fe>
        {
          phost->gState = HOST_CLASS;
 8007a66:	687b      	ldr	r3, [r7, #4]
 8007a68:	220b      	movs	r2, #11
 8007a6a:	701a      	strb	r2, [r3, #0]
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8007a6c:	e058      	b.n	8007b20 <USBH_Process+0x3b0>
        else if (status == USBH_FAIL)
 8007a6e:	7bbb      	ldrb	r3, [r7, #14]
 8007a70:	b2db      	uxtb	r3, r3
 8007a72:	2b02      	cmp	r3, #2
 8007a74:	d154      	bne.n	8007b20 <USBH_Process+0x3b0>
          phost->gState = HOST_ABORT_STATE;
 8007a76:	687b      	ldr	r3, [r7, #4]
 8007a78:	220d      	movs	r2, #13
 8007a7a:	701a      	strb	r2, [r3, #0]
      break;
 8007a7c:	e050      	b.n	8007b20 <USBH_Process+0x3b0>
        phost->gState = HOST_ABORT_STATE;
 8007a7e:	687b      	ldr	r3, [r7, #4]
 8007a80:	220d      	movs	r2, #13
 8007a82:	701a      	strb	r2, [r3, #0]
      break;
 8007a84:	e04c      	b.n	8007b20 <USBH_Process+0x3b0>

    case HOST_CLASS:
      /* process class state machine */
      if (phost->pActiveClass != NULL)
 8007a86:	687b      	ldr	r3, [r7, #4]
 8007a88:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a8c:	2b00      	cmp	r3, #0
 8007a8e:	d049      	beq.n	8007b24 <USBH_Process+0x3b4>
      {
        phost->pActiveClass->BgndProcess(phost);
 8007a90:	687b      	ldr	r3, [r7, #4]
 8007a92:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007a96:	695b      	ldr	r3, [r3, #20]
 8007a98:	6878      	ldr	r0, [r7, #4]
 8007a9a:	4798      	blx	r3
      }
      break;
 8007a9c:	e042      	b.n	8007b24 <USBH_Process+0x3b4>

    case HOST_DEV_DISCONNECTED :
      phost->device.is_disconnected = 0U;
 8007a9e:	687b      	ldr	r3, [r7, #4]
 8007aa0:	2200      	movs	r2, #0
 8007aa2:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321

      DeInitStateMachine(phost);
 8007aa6:	6878      	ldr	r0, [r7, #4]
 8007aa8:	f7ff fd72 	bl	8007590 <DeInitStateMachine>

      /* Re-Initilaize Host for new Enumeration */
      if (phost->pActiveClass != NULL)
 8007aac:	687b      	ldr	r3, [r7, #4]
 8007aae:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007ab2:	2b00      	cmp	r3, #0
 8007ab4:	d009      	beq.n	8007aca <USBH_Process+0x35a>
      {
        phost->pActiveClass->DeInit(phost);
 8007ab6:	687b      	ldr	r3, [r7, #4]
 8007ab8:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007abc:	68db      	ldr	r3, [r3, #12]
 8007abe:	6878      	ldr	r0, [r7, #4]
 8007ac0:	4798      	blx	r3
        phost->pActiveClass = NULL;
 8007ac2:	687b      	ldr	r3, [r7, #4]
 8007ac4:	2200      	movs	r2, #0
 8007ac6:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
      }

      if (phost->pUser != NULL)
 8007aca:	687b      	ldr	r3, [r7, #4]
 8007acc:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8007ad0:	2b00      	cmp	r3, #0
 8007ad2:	d005      	beq.n	8007ae0 <USBH_Process+0x370>
      {
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 8007ad4:	687b      	ldr	r3, [r7, #4]
 8007ad6:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8007ada:	2105      	movs	r1, #5
 8007adc:	6878      	ldr	r0, [r7, #4]
 8007ade:	4798      	blx	r3
      }
      USBH_UsrLog("USB Device disconnected");

      if (phost->device.is_ReEnumerated == 1U)
 8007ae0:	687b      	ldr	r3, [r7, #4]
 8007ae2:	f893 3322 	ldrb.w	r3, [r3, #802]	; 0x322
 8007ae6:	b2db      	uxtb	r3, r3
 8007ae8:	2b01      	cmp	r3, #1
 8007aea:	d107      	bne.n	8007afc <USBH_Process+0x38c>
      {
        phost->device.is_ReEnumerated = 0U;
 8007aec:	687b      	ldr	r3, [r7, #4]
 8007aee:	2200      	movs	r2, #0
 8007af0:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322

        /* Start the host and re-enable Vbus */
        USBH_Start(phost);
 8007af4:	6878      	ldr	r0, [r7, #4]
 8007af6:	f7ff fe2b 	bl	8007750 <USBH_Start>
      (void)osMessagePut(phost->os_event, phost->os_msg, 0U);
#else
      (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      break;
 8007afa:	e014      	b.n	8007b26 <USBH_Process+0x3b6>
        USBH_LL_Start(phost);
 8007afc:	6878      	ldr	r0, [r7, #4]
 8007afe:	f020 f9b5 	bl	8027e6c <USBH_LL_Start>
      break;
 8007b02:	e010      	b.n	8007b26 <USBH_Process+0x3b6>

    case HOST_ABORT_STATE:
    default :
      break;
 8007b04:	bf00      	nop
 8007b06:	e00e      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b08:	bf00      	nop
 8007b0a:	e00c      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b0c:	bf00      	nop
 8007b0e:	e00a      	b.n	8007b26 <USBH_Process+0x3b6>
    break;
 8007b10:	bf00      	nop
 8007b12:	e008      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b14:	bf00      	nop
 8007b16:	e006      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b18:	bf00      	nop
 8007b1a:	e004      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b1c:	bf00      	nop
 8007b1e:	e002      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b20:	bf00      	nop
 8007b22:	e000      	b.n	8007b26 <USBH_Process+0x3b6>
      break;
 8007b24:	bf00      	nop
  }
  return USBH_OK;
 8007b26:	2300      	movs	r3, #0
}
 8007b28:	4618      	mov	r0, r3
 8007b2a:	3710      	adds	r7, #16
 8007b2c:	46bd      	mov	sp, r7
 8007b2e:	bd80      	pop	{r7, pc}

08007b30 <USBH_HandleEnum>:
  *         This function includes the complete enumeration process
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
 8007b30:	b580      	push	{r7, lr}
 8007b32:	b088      	sub	sp, #32
 8007b34:	af04      	add	r7, sp, #16
 8007b36:	6078      	str	r0, [r7, #4]
  USBH_StatusTypeDef Status = USBH_BUSY;
 8007b38:	2301      	movs	r3, #1
 8007b3a:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;
 8007b3c:	2301      	movs	r3, #1
 8007b3e:	73bb      	strb	r3, [r7, #14]

  switch (phost->EnumState)
 8007b40:	687b      	ldr	r3, [r7, #4]
 8007b42:	785b      	ldrb	r3, [r3, #1]
 8007b44:	2b07      	cmp	r3, #7
 8007b46:	f200 81c1 	bhi.w	8007ecc <USBH_HandleEnum+0x39c>
 8007b4a:	a201      	add	r2, pc, #4	; (adr r2, 8007b50 <USBH_HandleEnum+0x20>)
 8007b4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b50:	08007b71 	.word	0x08007b71
 8007b54:	08007c2f 	.word	0x08007c2f
 8007b58:	08007c99 	.word	0x08007c99
 8007b5c:	08007d27 	.word	0x08007d27
 8007b60:	08007d91 	.word	0x08007d91
 8007b64:	08007e01 	.word	0x08007e01
 8007b68:	08007e47 	.word	0x08007e47
 8007b6c:	08007e8d 	.word	0x08007e8d
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 8007b70:	2108      	movs	r1, #8
 8007b72:	6878      	ldr	r0, [r7, #4]
 8007b74:	f000 fa50 	bl	8008018 <USBH_Get_DevDesc>
 8007b78:	4603      	mov	r3, r0
 8007b7a:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 8007b7c:	7bbb      	ldrb	r3, [r7, #14]
 8007b7e:	2b00      	cmp	r3, #0
 8007b80:	d130      	bne.n	8007be4 <USBH_HandleEnum+0xb4>
      {
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 8007b82:	687b      	ldr	r3, [r7, #4]
 8007b84:	f893 232d 	ldrb.w	r2, [r3, #813]	; 0x32d
 8007b88:	687b      	ldr	r3, [r7, #4]
 8007b8a:	719a      	strb	r2, [r3, #6]

        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8007b8c:	687b      	ldr	r3, [r7, #4]
 8007b8e:	2201      	movs	r2, #1
 8007b90:	705a      	strb	r2, [r3, #1]

        /* modify control channels configuration for MaxPacket size */
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 8007b92:	687b      	ldr	r3, [r7, #4]
 8007b94:	7919      	ldrb	r1, [r3, #4]
 8007b96:	687b      	ldr	r3, [r7, #4]
 8007b98:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 8007b9c:	687b      	ldr	r3, [r7, #4]
 8007b9e:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
 8007ba2:	687a      	ldr	r2, [r7, #4]
 8007ba4:	7992      	ldrb	r2, [r2, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 8007ba6:	b292      	uxth	r2, r2
 8007ba8:	9202      	str	r2, [sp, #8]
 8007baa:	2200      	movs	r2, #0
 8007bac:	9201      	str	r2, [sp, #4]
 8007bae:	9300      	str	r3, [sp, #0]
 8007bb0:	4603      	mov	r3, r0
 8007bb2:	2280      	movs	r2, #128	; 0x80
 8007bb4:	6878      	ldr	r0, [r7, #4]
 8007bb6:	f000 ff77 	bl	8008aa8 <USBH_OpenPipe>

        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8007bba:	687b      	ldr	r3, [r7, #4]
 8007bbc:	7959      	ldrb	r1, [r3, #5]
 8007bbe:	687b      	ldr	r3, [r7, #4]
 8007bc0:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 8007bc4:	687b      	ldr	r3, [r7, #4]
 8007bc6:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
 8007bca:	687a      	ldr	r2, [r7, #4]
 8007bcc:	7992      	ldrb	r2, [r2, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8007bce:	b292      	uxth	r2, r2
 8007bd0:	9202      	str	r2, [sp, #8]
 8007bd2:	2200      	movs	r2, #0
 8007bd4:	9201      	str	r2, [sp, #4]
 8007bd6:	9300      	str	r3, [sp, #0]
 8007bd8:	4603      	mov	r3, r0
 8007bda:	2200      	movs	r2, #0
 8007bdc:	6878      	ldr	r0, [r7, #4]
 8007bde:	f000 ff63 	bl	8008aa8 <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 8007be2:	e175      	b.n	8007ed0 <USBH_HandleEnum+0x3a0>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007be4:	7bbb      	ldrb	r3, [r7, #14]
 8007be6:	2b03      	cmp	r3, #3
 8007be8:	f040 8172 	bne.w	8007ed0 <USBH_HandleEnum+0x3a0>
        phost->device.EnumCnt++;
 8007bec:	687b      	ldr	r3, [r7, #4]
 8007bee:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007bf2:	3301      	adds	r3, #1
 8007bf4:	b2da      	uxtb	r2, r3
 8007bf6:	687b      	ldr	r3, [r7, #4]
 8007bf8:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8007bfc:	687b      	ldr	r3, [r7, #4]
 8007bfe:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007c02:	2b03      	cmp	r3, #3
 8007c04:	d903      	bls.n	8007c0e <USBH_HandleEnum+0xde>
          phost->gState = HOST_ABORT_STATE;
 8007c06:	687b      	ldr	r3, [r7, #4]
 8007c08:	220d      	movs	r2, #13
 8007c0a:	701a      	strb	r2, [r3, #0]
      break;
 8007c0c:	e160      	b.n	8007ed0 <USBH_HandleEnum+0x3a0>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8007c0e:	687b      	ldr	r3, [r7, #4]
 8007c10:	795b      	ldrb	r3, [r3, #5]
 8007c12:	4619      	mov	r1, r3
 8007c14:	6878      	ldr	r0, [r7, #4]
 8007c16:	f000 ff97 	bl	8008b48 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 8007c1a:	687b      	ldr	r3, [r7, #4]
 8007c1c:	791b      	ldrb	r3, [r3, #4]
 8007c1e:	4619      	mov	r1, r3
 8007c20:	6878      	ldr	r0, [r7, #4]
 8007c22:	f000 ff91 	bl	8008b48 <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 8007c26:	687b      	ldr	r3, [r7, #4]
 8007c28:	2200      	movs	r2, #0
 8007c2a:	701a      	strb	r2, [r3, #0]
      break;
 8007c2c:	e150      	b.n	8007ed0 <USBH_HandleEnum+0x3a0>

    case ENUM_GET_FULL_DEV_DESC:
      /* Get FULL Device Desc  */
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 8007c2e:	2112      	movs	r1, #18
 8007c30:	6878      	ldr	r0, [r7, #4]
 8007c32:	f000 f9f1 	bl	8008018 <USBH_Get_DevDesc>
 8007c36:	4603      	mov	r3, r0
 8007c38:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 8007c3a:	7bbb      	ldrb	r3, [r7, #14]
 8007c3c:	2b00      	cmp	r3, #0
 8007c3e:	d103      	bne.n	8007c48 <USBH_HandleEnum+0x118>
      {
        USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct);
        USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor);

        phost->EnumState = ENUM_SET_ADDR;
 8007c40:	687b      	ldr	r3, [r7, #4]
 8007c42:	2202      	movs	r2, #2
 8007c44:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 8007c46:	e145      	b.n	8007ed4 <USBH_HandleEnum+0x3a4>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007c48:	7bbb      	ldrb	r3, [r7, #14]
 8007c4a:	2b03      	cmp	r3, #3
 8007c4c:	f040 8142 	bne.w	8007ed4 <USBH_HandleEnum+0x3a4>
        phost->device.EnumCnt++;
 8007c50:	687b      	ldr	r3, [r7, #4]
 8007c52:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007c56:	3301      	adds	r3, #1
 8007c58:	b2da      	uxtb	r2, r3
 8007c5a:	687b      	ldr	r3, [r7, #4]
 8007c5c:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8007c60:	687b      	ldr	r3, [r7, #4]
 8007c62:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007c66:	2b03      	cmp	r3, #3
 8007c68:	d903      	bls.n	8007c72 <USBH_HandleEnum+0x142>
          phost->gState = HOST_ABORT_STATE;
 8007c6a:	687b      	ldr	r3, [r7, #4]
 8007c6c:	220d      	movs	r2, #13
 8007c6e:	701a      	strb	r2, [r3, #0]
      break;
 8007c70:	e130      	b.n	8007ed4 <USBH_HandleEnum+0x3a4>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8007c72:	687b      	ldr	r3, [r7, #4]
 8007c74:	795b      	ldrb	r3, [r3, #5]
 8007c76:	4619      	mov	r1, r3
 8007c78:	6878      	ldr	r0, [r7, #4]
 8007c7a:	f000 ff65 	bl	8008b48 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 8007c7e:	687b      	ldr	r3, [r7, #4]
 8007c80:	791b      	ldrb	r3, [r3, #4]
 8007c82:	4619      	mov	r1, r3
 8007c84:	6878      	ldr	r0, [r7, #4]
 8007c86:	f000 ff5f 	bl	8008b48 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8007c8a:	687b      	ldr	r3, [r7, #4]
 8007c8c:	2200      	movs	r2, #0
 8007c8e:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 8007c90:	687b      	ldr	r3, [r7, #4]
 8007c92:	2200      	movs	r2, #0
 8007c94:	701a      	strb	r2, [r3, #0]
      break;
 8007c96:	e11d      	b.n	8007ed4 <USBH_HandleEnum+0x3a4>

    case ENUM_SET_ADDR:
      /* set address */
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 8007c98:	2101      	movs	r1, #1
 8007c9a:	6878      	ldr	r0, [r7, #4]
 8007c9c:	f000 fa68 	bl	8008170 <USBH_SetAddress>
 8007ca0:	4603      	mov	r3, r0
 8007ca2:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 8007ca4:	7bbb      	ldrb	r3, [r7, #14]
 8007ca6:	2b00      	cmp	r3, #0
 8007ca8:	d132      	bne.n	8007d10 <USBH_HandleEnum+0x1e0>
      {
        USBH_Delay(2U);
 8007caa:	2002      	movs	r0, #2
 8007cac:	f020 fa69 	bl	8028182 <USBH_Delay>
        phost->device.address = USBH_DEVICE_ADDRESS;
 8007cb0:	687b      	ldr	r3, [r7, #4]
 8007cb2:	2201      	movs	r2, #1
 8007cb4:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c

        /* user callback for device address assigned */
        USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
        phost->EnumState = ENUM_GET_CFG_DESC;
 8007cb8:	687b      	ldr	r3, [r7, #4]
 8007cba:	2203      	movs	r2, #3
 8007cbc:	705a      	strb	r2, [r3, #1]

        /* modify control channels to update device address */
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8007cbe:	687b      	ldr	r3, [r7, #4]
 8007cc0:	7919      	ldrb	r1, [r3, #4]
 8007cc2:	687b      	ldr	r3, [r7, #4]
 8007cc4:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 8007cc8:	687b      	ldr	r3, [r7, #4]
 8007cca:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
 8007cce:	687a      	ldr	r2, [r7, #4]
 8007cd0:	7992      	ldrb	r2, [r2, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8007cd2:	b292      	uxth	r2, r2
 8007cd4:	9202      	str	r2, [sp, #8]
 8007cd6:	2200      	movs	r2, #0
 8007cd8:	9201      	str	r2, [sp, #4]
 8007cda:	9300      	str	r3, [sp, #0]
 8007cdc:	4603      	mov	r3, r0
 8007cde:	2280      	movs	r2, #128	; 0x80
 8007ce0:	6878      	ldr	r0, [r7, #4]
 8007ce2:	f000 fee1 	bl	8008aa8 <USBH_OpenPipe>

        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8007ce6:	687b      	ldr	r3, [r7, #4]
 8007ce8:	7959      	ldrb	r1, [r3, #5]
 8007cea:	687b      	ldr	r3, [r7, #4]
 8007cec:	f893 031c 	ldrb.w	r0, [r3, #796]	; 0x31c
 8007cf0:	687b      	ldr	r3, [r7, #4]
 8007cf2:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
 8007cf6:	687a      	ldr	r2, [r7, #4]
 8007cf8:	7992      	ldrb	r2, [r2, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8007cfa:	b292      	uxth	r2, r2
 8007cfc:	9202      	str	r2, [sp, #8]
 8007cfe:	2200      	movs	r2, #0
 8007d00:	9201      	str	r2, [sp, #4]
 8007d02:	9300      	str	r3, [sp, #0]
 8007d04:	4603      	mov	r3, r0
 8007d06:	2200      	movs	r2, #0
 8007d08:	6878      	ldr	r0, [r7, #4]
 8007d0a:	f000 fecd 	bl	8008aa8 <USBH_OpenPipe>
      }
      else
      {
        /* .. */
      }
      break;
 8007d0e:	e0e3      	b.n	8007ed8 <USBH_HandleEnum+0x3a8>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007d10:	7bbb      	ldrb	r3, [r7, #14]
 8007d12:	2b03      	cmp	r3, #3
 8007d14:	f040 80e0 	bne.w	8007ed8 <USBH_HandleEnum+0x3a8>
        phost->gState = HOST_ABORT_STATE;
 8007d18:	687b      	ldr	r3, [r7, #4]
 8007d1a:	220d      	movs	r2, #13
 8007d1c:	701a      	strb	r2, [r3, #0]
        phost->EnumState = ENUM_IDLE;
 8007d1e:	687b      	ldr	r3, [r7, #4]
 8007d20:	2200      	movs	r2, #0
 8007d22:	705a      	strb	r2, [r3, #1]
      break;
 8007d24:	e0d8      	b.n	8007ed8 <USBH_HandleEnum+0x3a8>

    case ENUM_GET_CFG_DESC:
      /* get standard configuration descriptor */
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 8007d26:	2109      	movs	r1, #9
 8007d28:	6878      	ldr	r0, [r7, #4]
 8007d2a:	f000 f99d 	bl	8008068 <USBH_Get_CfgDesc>
 8007d2e:	4603      	mov	r3, r0
 8007d30:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 8007d32:	7bbb      	ldrb	r3, [r7, #14]
 8007d34:	2b00      	cmp	r3, #0
 8007d36:	d103      	bne.n	8007d40 <USBH_HandleEnum+0x210>
      {
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 8007d38:	687b      	ldr	r3, [r7, #4]
 8007d3a:	2204      	movs	r2, #4
 8007d3c:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 8007d3e:	e0cd      	b.n	8007edc <USBH_HandleEnum+0x3ac>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007d40:	7bbb      	ldrb	r3, [r7, #14]
 8007d42:	2b03      	cmp	r3, #3
 8007d44:	f040 80ca 	bne.w	8007edc <USBH_HandleEnum+0x3ac>
        phost->device.EnumCnt++;
 8007d48:	687b      	ldr	r3, [r7, #4]
 8007d4a:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007d4e:	3301      	adds	r3, #1
 8007d50:	b2da      	uxtb	r2, r3
 8007d52:	687b      	ldr	r3, [r7, #4]
 8007d54:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8007d58:	687b      	ldr	r3, [r7, #4]
 8007d5a:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007d5e:	2b03      	cmp	r3, #3
 8007d60:	d903      	bls.n	8007d6a <USBH_HandleEnum+0x23a>
          phost->gState = HOST_ABORT_STATE;
 8007d62:	687b      	ldr	r3, [r7, #4]
 8007d64:	220d      	movs	r2, #13
 8007d66:	701a      	strb	r2, [r3, #0]
      break;
 8007d68:	e0b8      	b.n	8007edc <USBH_HandleEnum+0x3ac>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8007d6a:	687b      	ldr	r3, [r7, #4]
 8007d6c:	795b      	ldrb	r3, [r3, #5]
 8007d6e:	4619      	mov	r1, r3
 8007d70:	6878      	ldr	r0, [r7, #4]
 8007d72:	f000 fee9 	bl	8008b48 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 8007d76:	687b      	ldr	r3, [r7, #4]
 8007d78:	791b      	ldrb	r3, [r3, #4]
 8007d7a:	4619      	mov	r1, r3
 8007d7c:	6878      	ldr	r0, [r7, #4]
 8007d7e:	f000 fee3 	bl	8008b48 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8007d82:	687b      	ldr	r3, [r7, #4]
 8007d84:	2200      	movs	r2, #0
 8007d86:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 8007d88:	687b      	ldr	r3, [r7, #4]
 8007d8a:	2200      	movs	r2, #0
 8007d8c:	701a      	strb	r2, [r3, #0]
      break;
 8007d8e:	e0a5      	b.n	8007edc <USBH_HandleEnum+0x3ac>

    case ENUM_GET_FULL_CFG_DESC:
      /* get FULL config descriptor (config, interface, endpoints) */
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 8007d90:	687b      	ldr	r3, [r7, #4]
 8007d92:	f8b3 333a 	ldrh.w	r3, [r3, #826]	; 0x33a
 8007d96:	4619      	mov	r1, r3
 8007d98:	6878      	ldr	r0, [r7, #4]
 8007d9a:	f000 f965 	bl	8008068 <USBH_Get_CfgDesc>
 8007d9e:	4603      	mov	r3, r0
 8007da0:	73bb      	strb	r3, [r7, #14]
      if (ReqStatus == USBH_OK)
 8007da2:	7bbb      	ldrb	r3, [r7, #14]
 8007da4:	2b00      	cmp	r3, #0
 8007da6:	d103      	bne.n	8007db0 <USBH_HandleEnum+0x280>
      {
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	2205      	movs	r2, #5
 8007dac:	705a      	strb	r2, [r3, #1]
      }
      else
      {
        /* .. */
      }
      break;
 8007dae:	e097      	b.n	8007ee0 <USBH_HandleEnum+0x3b0>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007db0:	7bbb      	ldrb	r3, [r7, #14]
 8007db2:	2b03      	cmp	r3, #3
 8007db4:	f040 8094 	bne.w	8007ee0 <USBH_HandleEnum+0x3b0>
        phost->device.EnumCnt++;
 8007db8:	687b      	ldr	r3, [r7, #4]
 8007dba:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007dbe:	3301      	adds	r3, #1
 8007dc0:	b2da      	uxtb	r2, r3
 8007dc2:	687b      	ldr	r3, [r7, #4]
 8007dc4:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8007dc8:	687b      	ldr	r3, [r7, #4]
 8007dca:	f893 331e 	ldrb.w	r3, [r3, #798]	; 0x31e
 8007dce:	2b03      	cmp	r3, #3
 8007dd0:	d903      	bls.n	8007dda <USBH_HandleEnum+0x2aa>
          phost->gState = HOST_ABORT_STATE;
 8007dd2:	687b      	ldr	r3, [r7, #4]
 8007dd4:	220d      	movs	r2, #13
 8007dd6:	701a      	strb	r2, [r3, #0]
      break;
 8007dd8:	e082      	b.n	8007ee0 <USBH_HandleEnum+0x3b0>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8007dda:	687b      	ldr	r3, [r7, #4]
 8007ddc:	795b      	ldrb	r3, [r3, #5]
 8007dde:	4619      	mov	r1, r3
 8007de0:	6878      	ldr	r0, [r7, #4]
 8007de2:	f000 feb1 	bl	8008b48 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 8007de6:	687b      	ldr	r3, [r7, #4]
 8007de8:	791b      	ldrb	r3, [r3, #4]
 8007dea:	4619      	mov	r1, r3
 8007dec:	6878      	ldr	r0, [r7, #4]
 8007dee:	f000 feab 	bl	8008b48 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8007df2:	687b      	ldr	r3, [r7, #4]
 8007df4:	2200      	movs	r2, #0
 8007df6:	705a      	strb	r2, [r3, #1]
          phost->gState = HOST_IDLE;
 8007df8:	687b      	ldr	r3, [r7, #4]
 8007dfa:	2200      	movs	r2, #0
 8007dfc:	701a      	strb	r2, [r3, #0]
      break;
 8007dfe:	e06f      	b.n	8007ee0 <USBH_HandleEnum+0x3b0>

    case ENUM_GET_MFC_STRING_DESC:
      if (phost->device.DevDesc.iManufacturer != 0U)
 8007e00:	687b      	ldr	r3, [r7, #4]
 8007e02:	f893 3334 	ldrb.w	r3, [r3, #820]	; 0x334
 8007e06:	2b00      	cmp	r3, #0
 8007e08:	d019      	beq.n	8007e3e <USBH_HandleEnum+0x30e>
      {
        /* Check that Manufacturer String is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 8007e0a:	687b      	ldr	r3, [r7, #4]
 8007e0c:	f893 1334 	ldrb.w	r1, [r3, #820]	; 0x334
                                        phost->device.Data, 0xFFU);
 8007e10:	687b      	ldr	r3, [r7, #4]
 8007e12:	f503 728e 	add.w	r2, r3, #284	; 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 8007e16:	23ff      	movs	r3, #255	; 0xff
 8007e18:	6878      	ldr	r0, [r7, #4]
 8007e1a:	f000 f949 	bl	80080b0 <USBH_Get_StringDesc>
 8007e1e:	4603      	mov	r3, r0
 8007e20:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 8007e22:	7bbb      	ldrb	r3, [r7, #14]
 8007e24:	2b00      	cmp	r3, #0
 8007e26:	d103      	bne.n	8007e30 <USBH_HandleEnum+0x300>
        {
          /* User callback for Manufacturing string */
          USBH_UsrLog("Manufacturer : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 8007e28:	687b      	ldr	r3, [r7, #4]
 8007e2a:	2206      	movs	r2, #6
 8007e2c:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      }
      break;
 8007e2e:	e059      	b.n	8007ee4 <USBH_HandleEnum+0x3b4>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007e30:	7bbb      	ldrb	r3, [r7, #14]
 8007e32:	2b03      	cmp	r3, #3
 8007e34:	d156      	bne.n	8007ee4 <USBH_HandleEnum+0x3b4>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 8007e36:	687b      	ldr	r3, [r7, #4]
 8007e38:	2206      	movs	r2, #6
 8007e3a:	705a      	strb	r2, [r3, #1]
      break;
 8007e3c:	e052      	b.n	8007ee4 <USBH_HandleEnum+0x3b4>
        phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 8007e3e:	687b      	ldr	r3, [r7, #4]
 8007e40:	2206      	movs	r2, #6
 8007e42:	705a      	strb	r2, [r3, #1]
      break;
 8007e44:	e04e      	b.n	8007ee4 <USBH_HandleEnum+0x3b4>

    case ENUM_GET_PRODUCT_STRING_DESC:
      if (phost->device.DevDesc.iProduct != 0U)
 8007e46:	687b      	ldr	r3, [r7, #4]
 8007e48:	f893 3335 	ldrb.w	r3, [r3, #821]	; 0x335
 8007e4c:	2b00      	cmp	r3, #0
 8007e4e:	d019      	beq.n	8007e84 <USBH_HandleEnum+0x354>
      {
        /* Check that Product string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 8007e50:	687b      	ldr	r3, [r7, #4]
 8007e52:	f893 1335 	ldrb.w	r1, [r3, #821]	; 0x335
                                        phost->device.Data, 0xFFU);
 8007e56:	687b      	ldr	r3, [r7, #4]
 8007e58:	f503 728e 	add.w	r2, r3, #284	; 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 8007e5c:	23ff      	movs	r3, #255	; 0xff
 8007e5e:	6878      	ldr	r0, [r7, #4]
 8007e60:	f000 f926 	bl	80080b0 <USBH_Get_StringDesc>
 8007e64:	4603      	mov	r3, r0
 8007e66:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 8007e68:	7bbb      	ldrb	r3, [r7, #14]
 8007e6a:	2b00      	cmp	r3, #0
 8007e6c:	d103      	bne.n	8007e76 <USBH_HandleEnum+0x346>
        {
          /* User callback for Product string */
          USBH_UsrLog("Product : %s", (char *)(void *)phost->device.Data);
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	2207      	movs	r2, #7
 8007e72:	705a      	strb	r2, [r3, #1]
#else
        (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
      }
      break;
 8007e74:	e038      	b.n	8007ee8 <USBH_HandleEnum+0x3b8>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007e76:	7bbb      	ldrb	r3, [r7, #14]
 8007e78:	2b03      	cmp	r3, #3
 8007e7a:	d135      	bne.n	8007ee8 <USBH_HandleEnum+0x3b8>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 8007e7c:	687b      	ldr	r3, [r7, #4]
 8007e7e:	2207      	movs	r2, #7
 8007e80:	705a      	strb	r2, [r3, #1]
      break;
 8007e82:	e031      	b.n	8007ee8 <USBH_HandleEnum+0x3b8>
        phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 8007e84:	687b      	ldr	r3, [r7, #4]
 8007e86:	2207      	movs	r2, #7
 8007e88:	705a      	strb	r2, [r3, #1]
      break;
 8007e8a:	e02d      	b.n	8007ee8 <USBH_HandleEnum+0x3b8>

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 8007e8c:	687b      	ldr	r3, [r7, #4]
 8007e8e:	f893 3336 	ldrb.w	r3, [r3, #822]	; 0x336
 8007e92:	2b00      	cmp	r3, #0
 8007e94:	d017      	beq.n	8007ec6 <USBH_HandleEnum+0x396>
      {
        /* Check that Serial number string is available */
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 8007e96:	687b      	ldr	r3, [r7, #4]
 8007e98:	f893 1336 	ldrb.w	r1, [r3, #822]	; 0x336
                                        phost->device.Data, 0xFFU);
 8007e9c:	687b      	ldr	r3, [r7, #4]
 8007e9e:	f503 728e 	add.w	r2, r3, #284	; 0x11c
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 8007ea2:	23ff      	movs	r3, #255	; 0xff
 8007ea4:	6878      	ldr	r0, [r7, #4]
 8007ea6:	f000 f903 	bl	80080b0 <USBH_Get_StringDesc>
 8007eaa:	4603      	mov	r3, r0
 8007eac:	73bb      	strb	r3, [r7, #14]
        if (ReqStatus == USBH_OK)
 8007eae:	7bbb      	ldrb	r3, [r7, #14]
 8007eb0:	2b00      	cmp	r3, #0
 8007eb2:	d102      	bne.n	8007eba <USBH_HandleEnum+0x38a>
        {
          /* User callback for Serial number string */
          USBH_UsrLog("Serial Number : %s", (char *)(void *)phost->device.Data);
          Status = USBH_OK;
 8007eb4:	2300      	movs	r3, #0
 8007eb6:	73fb      	strb	r3, [r7, #15]
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
      }
      break;
 8007eb8:	e018      	b.n	8007eec <USBH_HandleEnum+0x3bc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8007eba:	7bbb      	ldrb	r3, [r7, #14]
 8007ebc:	2b03      	cmp	r3, #3
 8007ebe:	d115      	bne.n	8007eec <USBH_HandleEnum+0x3bc>
          Status = USBH_OK;
 8007ec0:	2300      	movs	r3, #0
 8007ec2:	73fb      	strb	r3, [r7, #15]
      break;
 8007ec4:	e012      	b.n	8007eec <USBH_HandleEnum+0x3bc>
        Status = USBH_OK;
 8007ec6:	2300      	movs	r3, #0
 8007ec8:	73fb      	strb	r3, [r7, #15]
      break;
 8007eca:	e00f      	b.n	8007eec <USBH_HandleEnum+0x3bc>

    default:
      break;
 8007ecc:	bf00      	nop
 8007ece:	e00e      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ed0:	bf00      	nop
 8007ed2:	e00c      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ed4:	bf00      	nop
 8007ed6:	e00a      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ed8:	bf00      	nop
 8007eda:	e008      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007edc:	bf00      	nop
 8007ede:	e006      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ee0:	bf00      	nop
 8007ee2:	e004      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ee4:	bf00      	nop
 8007ee6:	e002      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007ee8:	bf00      	nop
 8007eea:	e000      	b.n	8007eee <USBH_HandleEnum+0x3be>
      break;
 8007eec:	bf00      	nop
  }
  return Status;
 8007eee:	7bfb      	ldrb	r3, [r7, #15]
}
 8007ef0:	4618      	mov	r0, r3
 8007ef2:	3710      	adds	r7, #16
 8007ef4:	46bd      	mov	sp, r7
 8007ef6:	bd80      	pop	{r7, pc}

08007ef8 <USBH_LL_SetTimer>:
  *         Set the initial Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
 8007ef8:	b480      	push	{r7}
 8007efa:	b083      	sub	sp, #12
 8007efc:	af00      	add	r7, sp, #0
 8007efe:	6078      	str	r0, [r7, #4]
 8007f00:	6039      	str	r1, [r7, #0]
  phost->Timer = time;
 8007f02:	687b      	ldr	r3, [r7, #4]
 8007f04:	683a      	ldr	r2, [r7, #0]
 8007f06:	f8c3 23c4 	str.w	r2, [r3, #964]	; 0x3c4
}
 8007f0a:	bf00      	nop
 8007f0c:	370c      	adds	r7, #12
 8007f0e:	46bd      	mov	sp, r7
 8007f10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f14:	4770      	bx	lr

08007f16 <USBH_LL_IncTimer>:
  *         Increment Host Timer tick
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
 8007f16:	b580      	push	{r7, lr}
 8007f18:	b082      	sub	sp, #8
 8007f1a:	af00      	add	r7, sp, #0
 8007f1c:	6078      	str	r0, [r7, #4]
  phost->Timer++;
 8007f1e:	687b      	ldr	r3, [r7, #4]
 8007f20:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 8007f24:	1c5a      	adds	r2, r3, #1
 8007f26:	687b      	ldr	r3, [r7, #4]
 8007f28:	f8c3 23c4 	str.w	r2, [r3, #964]	; 0x3c4
  USBH_HandleSof(phost);
 8007f2c:	6878      	ldr	r0, [r7, #4]
 8007f2e:	f000 f804 	bl	8007f3a <USBH_HandleSof>
}
 8007f32:	bf00      	nop
 8007f34:	3708      	adds	r7, #8
 8007f36:	46bd      	mov	sp, r7
 8007f38:	bd80      	pop	{r7, pc}

08007f3a <USBH_HandleSof>:
  *         Call SOF process
  * @param  phost: Host Handle
  * @retval None
  */
static void  USBH_HandleSof(USBH_HandleTypeDef *phost)
{
 8007f3a:	b580      	push	{r7, lr}
 8007f3c:	b082      	sub	sp, #8
 8007f3e:	af00      	add	r7, sp, #0
 8007f40:	6078      	str	r0, [r7, #4]
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 8007f42:	687b      	ldr	r3, [r7, #4]
 8007f44:	781b      	ldrb	r3, [r3, #0]
 8007f46:	b2db      	uxtb	r3, r3
 8007f48:	2b0b      	cmp	r3, #11
 8007f4a:	d10a      	bne.n	8007f62 <USBH_HandleSof+0x28>
 8007f4c:	687b      	ldr	r3, [r7, #4]
 8007f4e:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007f52:	2b00      	cmp	r3, #0
 8007f54:	d005      	beq.n	8007f62 <USBH_HandleSof+0x28>
  {
    phost->pActiveClass->SOFProcess(phost);
 8007f56:	687b      	ldr	r3, [r7, #4]
 8007f58:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 8007f5c:	699b      	ldr	r3, [r3, #24]
 8007f5e:	6878      	ldr	r0, [r7, #4]
 8007f60:	4798      	blx	r3
  }
}
 8007f62:	bf00      	nop
 8007f64:	3708      	adds	r7, #8
 8007f66:	46bd      	mov	sp, r7
 8007f68:	bd80      	pop	{r7, pc}

08007f6a <USBH_LL_PortEnabled>:
  *         Port Enabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
 8007f6a:	b480      	push	{r7}
 8007f6c:	b083      	sub	sp, #12
 8007f6e:	af00      	add	r7, sp, #0
 8007f70:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 1U;
 8007f72:	687b      	ldr	r3, [r7, #4]
 8007f74:	2201      	movs	r2, #1
 8007f76:	f883 2323 	strb.w	r2, [r3, #803]	; 0x323
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return;
 8007f7a:	bf00      	nop
}
 8007f7c:	370c      	adds	r7, #12
 8007f7e:	46bd      	mov	sp, r7
 8007f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f84:	4770      	bx	lr

08007f86 <USBH_LL_PortDisabled>:
  *         Port Disabled
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
 8007f86:	b480      	push	{r7}
 8007f88:	b083      	sub	sp, #12
 8007f8a:	af00      	add	r7, sp, #0
 8007f8c:	6078      	str	r0, [r7, #4]
  phost->device.PortEnabled = 0U;
 8007f8e:	687b      	ldr	r3, [r7, #4]
 8007f90:	2200      	movs	r2, #0
 8007f92:	f883 2323 	strb.w	r2, [r3, #803]	; 0x323

  return;
 8007f96:	bf00      	nop
}
 8007f98:	370c      	adds	r7, #12
 8007f9a:	46bd      	mov	sp, r7
 8007f9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fa0:	4770      	bx	lr

08007fa2 <USBH_LL_Connect>:
  *         Handle USB Host connexion event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 8007fa2:	b480      	push	{r7}
 8007fa4:	b083      	sub	sp, #12
 8007fa6:	af00      	add	r7, sp, #0
 8007fa8:	6078      	str	r0, [r7, #4]
  phost->device.is_connected = 1U;
 8007faa:	687b      	ldr	r3, [r7, #4]
 8007fac:	2201      	movs	r2, #1
 8007fae:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  phost->device.is_disconnected = 0U;
 8007fb2:	687b      	ldr	r3, [r7, #4]
 8007fb4:	2200      	movs	r2, #0
 8007fb6:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
  phost->device.is_ReEnumerated = 0U;
 8007fba:	687b      	ldr	r3, [r7, #4]
 8007fbc:	2200      	movs	r2, #0
 8007fbe:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
 8007fc2:	2300      	movs	r3, #0
}
 8007fc4:	4618      	mov	r0, r3
 8007fc6:	370c      	adds	r7, #12
 8007fc8:	46bd      	mov	sp, r7
 8007fca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fce:	4770      	bx	lr

08007fd0 <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 8007fd0:	b580      	push	{r7, lr}
 8007fd2:	b082      	sub	sp, #8
 8007fd4:	af00      	add	r7, sp, #0
 8007fd6:	6078      	str	r0, [r7, #4]
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 8007fd8:	687b      	ldr	r3, [r7, #4]
 8007fda:	2201      	movs	r2, #1
 8007fdc:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
  phost->device.is_connected = 0U;
 8007fe0:	687b      	ldr	r3, [r7, #4]
 8007fe2:	2200      	movs	r2, #0
 8007fe4:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  phost->device.PortEnabled = 0U;
 8007fe8:	687b      	ldr	r3, [r7, #4]
 8007fea:	2200      	movs	r2, #0
 8007fec:	f883 2323 	strb.w	r2, [r3, #803]	; 0x323

  /* Stop Host */
  USBH_LL_Stop(phost);
 8007ff0:	6878      	ldr	r0, [r7, #4]
 8007ff2:	f01f ff56 	bl	8027ea2 <USBH_LL_Stop>

  /* FRee Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	791b      	ldrb	r3, [r3, #4]
 8007ffa:	4619      	mov	r1, r3
 8007ffc:	6878      	ldr	r0, [r7, #4]
 8007ffe:	f000 fda3 	bl	8008b48 <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
 8008002:	687b      	ldr	r3, [r7, #4]
 8008004:	795b      	ldrb	r3, [r3, #5]
 8008006:	4619      	mov	r1, r3
 8008008:	6878      	ldr	r0, [r7, #4]
 800800a:	f000 fd9d 	bl	8008b48 <USBH_FreePipe>
#else
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
 800800e:	2300      	movs	r3, #0
}
 8008010:	4618      	mov	r0, r3
 8008012:	3708      	adds	r7, #8
 8008014:	46bd      	mov	sp, r7
 8008016:	bd80      	pop	{r7, pc}

08008018 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
 8008018:	b580      	push	{r7, lr}
 800801a:	b086      	sub	sp, #24
 800801c:	af02      	add	r7, sp, #8
 800801e:	6078      	str	r0, [r7, #4]
 8008020:	460b      	mov	r3, r1
 8008022:	70fb      	strb	r3, [r7, #3]
  USBH_StatusTypeDef status;

  if ((status = USBH_GetDescriptor(phost,
                                   USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                                   USB_DESC_DEVICE, phost->device.Data,
 8008024:	687b      	ldr	r3, [r7, #4]
 8008026:	f503 728e 	add.w	r2, r3, #284	; 0x11c
  if ((status = USBH_GetDescriptor(phost,
 800802a:	78fb      	ldrb	r3, [r7, #3]
 800802c:	b29b      	uxth	r3, r3
 800802e:	9300      	str	r3, [sp, #0]
 8008030:	4613      	mov	r3, r2
 8008032:	f44f 7280 	mov.w	r2, #256	; 0x100
 8008036:	2100      	movs	r1, #0
 8008038:	6878      	ldr	r0, [r7, #4]
 800803a:	f000 f864 	bl	8008106 <USBH_GetDescriptor>
 800803e:	4603      	mov	r3, r0
 8008040:	73fb      	strb	r3, [r7, #15]
 8008042:	7bfb      	ldrb	r3, [r7, #15]
 8008044:	2b00      	cmp	r3, #0
 8008046:	d10a      	bne.n	800805e <USBH_Get_DevDesc+0x46>
                                   (uint16_t)length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received */
    USBH_ParseDevDesc(&phost->device.DevDesc, phost->device.Data,
 8008048:	687b      	ldr	r3, [r7, #4]
 800804a:	f203 3026 	addw	r0, r3, #806	; 0x326
 800804e:	687b      	ldr	r3, [r7, #4]
 8008050:	f503 738e 	add.w	r3, r3, #284	; 0x11c
 8008054:	78fa      	ldrb	r2, [r7, #3]
 8008056:	b292      	uxth	r2, r2
 8008058:	4619      	mov	r1, r3
 800805a:	f000 f918 	bl	800828e <USBH_ParseDevDesc>
                      (uint16_t)length);
  }

  return status;
 800805e:	7bfb      	ldrb	r3, [r7, #15]
}
 8008060:	4618      	mov	r0, r3
 8008062:	3710      	adds	r7, #16
 8008064:	46bd      	mov	sp, r7
 8008066:	bd80      	pop	{r7, pc}

08008068 <USBH_Get_CfgDesc>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_CfgDesc(USBH_HandleTypeDef *phost,
                                    uint16_t length)

{
 8008068:	b580      	push	{r7, lr}
 800806a:	b086      	sub	sp, #24
 800806c:	af02      	add	r7, sp, #8
 800806e:	6078      	str	r0, [r7, #4]
 8008070:	460b      	mov	r3, r1
 8008072:	807b      	strh	r3, [r7, #2]
  USBH_StatusTypeDef status;
  uint8_t *pData = phost->device.CfgDesc_Raw;;
 8008074:	687b      	ldr	r3, [r7, #4]
 8008076:	331c      	adds	r3, #28
 8008078:	60fb      	str	r3, [r7, #12]

  if ((status = USBH_GetDescriptor(phost, (USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD),
 800807a:	887b      	ldrh	r3, [r7, #2]
 800807c:	9300      	str	r3, [sp, #0]
 800807e:	68fb      	ldr	r3, [r7, #12]
 8008080:	f44f 7200 	mov.w	r2, #512	; 0x200
 8008084:	2100      	movs	r1, #0
 8008086:	6878      	ldr	r0, [r7, #4]
 8008088:	f000 f83d 	bl	8008106 <USBH_GetDescriptor>
 800808c:	4603      	mov	r3, r0
 800808e:	72fb      	strb	r3, [r7, #11]
 8008090:	7afb      	ldrb	r3, [r7, #11]
 8008092:	2b00      	cmp	r3, #0
 8008094:	d107      	bne.n	80080a6 <USBH_Get_CfgDesc+0x3e>
                                   USB_DESC_CONFIGURATION, pData, length)) == USBH_OK)
  {
    /* Commands successfully sent and Response Received  */
    USBH_ParseCfgDesc(&phost->device.CfgDesc, pData, length);
 8008096:	687b      	ldr	r3, [r7, #4]
 8008098:	f503 734e 	add.w	r3, r3, #824	; 0x338
 800809c:	887a      	ldrh	r2, [r7, #2]
 800809e:	68f9      	ldr	r1, [r7, #12]
 80080a0:	4618      	mov	r0, r3
 80080a2:	f000 f964 	bl	800836e <USBH_ParseCfgDesc>
  }

  return status;
 80080a6:	7afb      	ldrb	r3, [r7, #11]
}
 80080a8:	4618      	mov	r0, r3
 80080aa:	3710      	adds	r7, #16
 80080ac:	46bd      	mov	sp, r7
 80080ae:	bd80      	pop	{r7, pc}

080080b0 <USBH_Get_StringDesc>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_StringDesc(USBH_HandleTypeDef *phost,
                                       uint8_t string_index, uint8_t *buff,
                                       uint16_t length)
{
 80080b0:	b580      	push	{r7, lr}
 80080b2:	b088      	sub	sp, #32
 80080b4:	af02      	add	r7, sp, #8
 80080b6:	60f8      	str	r0, [r7, #12]
 80080b8:	607a      	str	r2, [r7, #4]
 80080ba:	461a      	mov	r2, r3
 80080bc:	460b      	mov	r3, r1
 80080be:	72fb      	strb	r3, [r7, #11]
 80080c0:	4613      	mov	r3, r2
 80080c2:	813b      	strh	r3, [r7, #8]
  USBH_StatusTypeDef status;

  if ((status = USBH_GetDescriptor(phost,
 80080c4:	7afb      	ldrb	r3, [r7, #11]
 80080c6:	b29b      	uxth	r3, r3
 80080c8:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 80080cc:	b29a      	uxth	r2, r3
                                   USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,
                                   USB_DESC_STRING | string_index,
                                   phost->device.Data, length)) == USBH_OK)
 80080ce:	68fb      	ldr	r3, [r7, #12]
 80080d0:	f503 718e 	add.w	r1, r3, #284	; 0x11c
  if ((status = USBH_GetDescriptor(phost,
 80080d4:	893b      	ldrh	r3, [r7, #8]
 80080d6:	9300      	str	r3, [sp, #0]
 80080d8:	460b      	mov	r3, r1
 80080da:	2100      	movs	r1, #0
 80080dc:	68f8      	ldr	r0, [r7, #12]
 80080de:	f000 f812 	bl	8008106 <USBH_GetDescriptor>
 80080e2:	4603      	mov	r3, r0
 80080e4:	75fb      	strb	r3, [r7, #23]
 80080e6:	7dfb      	ldrb	r3, [r7, #23]
 80080e8:	2b00      	cmp	r3, #0
 80080ea:	d107      	bne.n	80080fc <USBH_Get_StringDesc+0x4c>
  {
    /* Commands successfully sent and Response Received  */
    USBH_ParseStringDesc(phost->device.Data, buff, length);
 80080ec:	68fb      	ldr	r3, [r7, #12]
 80080ee:	f503 738e 	add.w	r3, r3, #284	; 0x11c
 80080f2:	893a      	ldrh	r2, [r7, #8]
 80080f4:	6879      	ldr	r1, [r7, #4]
 80080f6:	4618      	mov	r0, r3
 80080f8:	f000 fa37 	bl	800856a <USBH_ParseStringDesc>
  }

  return status;
 80080fc:	7dfb      	ldrb	r3, [r7, #23]
}
 80080fe:	4618      	mov	r0, r3
 8008100:	3718      	adds	r7, #24
 8008102:	46bd      	mov	sp, r7
 8008104:	bd80      	pop	{r7, pc}

08008106 <USBH_GetDescriptor>:
USBH_StatusTypeDef USBH_GetDescriptor(USBH_HandleTypeDef *phost,
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
 8008106:	b580      	push	{r7, lr}
 8008108:	b084      	sub	sp, #16
 800810a:	af00      	add	r7, sp, #0
 800810c:	60f8      	str	r0, [r7, #12]
 800810e:	607b      	str	r3, [r7, #4]
 8008110:	460b      	mov	r3, r1
 8008112:	72fb      	strb	r3, [r7, #11]
 8008114:	4613      	mov	r3, r2
 8008116:	813b      	strh	r3, [r7, #8]
  if (phost->RequestState == CMD_SEND)
 8008118:	68fb      	ldr	r3, [r7, #12]
 800811a:	789b      	ldrb	r3, [r3, #2]
 800811c:	2b01      	cmp	r3, #1
 800811e:	d11c      	bne.n	800815a <USBH_GetDescriptor+0x54>
  {
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8008120:	7afb      	ldrb	r3, [r7, #11]
 8008122:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8008126:	b2da      	uxtb	r2, r3
 8008128:	68fb      	ldr	r3, [r7, #12]
 800812a:	741a      	strb	r2, [r3, #16]
    phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 800812c:	68fb      	ldr	r3, [r7, #12]
 800812e:	2206      	movs	r2, #6
 8008130:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = value_idx;
 8008132:	68fb      	ldr	r3, [r7, #12]
 8008134:	893a      	ldrh	r2, [r7, #8]
 8008136:	825a      	strh	r2, [r3, #18]

    if ((value_idx & 0xff00U) == USB_DESC_STRING)
 8008138:	893b      	ldrh	r3, [r7, #8]
 800813a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800813e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008142:	d104      	bne.n	800814e <USBH_GetDescriptor+0x48>
    {
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8008144:	68fb      	ldr	r3, [r7, #12]
 8008146:	f240 4209 	movw	r2, #1033	; 0x409
 800814a:	829a      	strh	r2, [r3, #20]
 800814c:	e002      	b.n	8008154 <USBH_GetDescriptor+0x4e>
    }
    else
    {
      phost->Control.setup.b.wIndex.w = 0U;
 800814e:	68fb      	ldr	r3, [r7, #12]
 8008150:	2200      	movs	r2, #0
 8008152:	829a      	strh	r2, [r3, #20]
    }
    phost->Control.setup.b.wLength.w = length;
 8008154:	68fb      	ldr	r3, [r7, #12]
 8008156:	8b3a      	ldrh	r2, [r7, #24]
 8008158:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, buff, length);
 800815a:	8b3b      	ldrh	r3, [r7, #24]
 800815c:	461a      	mov	r2, r3
 800815e:	6879      	ldr	r1, [r7, #4]
 8008160:	68f8      	ldr	r0, [r7, #12]
 8008162:	f000 fa50 	bl	8008606 <USBH_CtlReq>
 8008166:	4603      	mov	r3, r0
}
 8008168:	4618      	mov	r0, r3
 800816a:	3710      	adds	r7, #16
 800816c:	46bd      	mov	sp, r7
 800816e:	bd80      	pop	{r7, pc}

08008170 <USBH_SetAddress>:
  * @param  DeviceAddress: Device address to assign
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetAddress(USBH_HandleTypeDef *phost,
                                   uint8_t DeviceAddress)
{
 8008170:	b580      	push	{r7, lr}
 8008172:	b082      	sub	sp, #8
 8008174:	af00      	add	r7, sp, #0
 8008176:	6078      	str	r0, [r7, #4]
 8008178:	460b      	mov	r3, r1
 800817a:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800817c:	687b      	ldr	r3, [r7, #4]
 800817e:	789b      	ldrb	r3, [r3, #2]
 8008180:	2b01      	cmp	r3, #1
 8008182:	d10f      	bne.n	80081a4 <USBH_SetAddress+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8008184:	687b      	ldr	r3, [r7, #4]
 8008186:	2200      	movs	r2, #0
 8008188:	741a      	strb	r2, [r3, #16]
                                           USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
 800818a:	687b      	ldr	r3, [r7, #4]
 800818c:	2205      	movs	r2, #5
 800818e:	745a      	strb	r2, [r3, #17]

    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 8008190:	78fb      	ldrb	r3, [r7, #3]
 8008192:	b29a      	uxth	r2, r3
 8008194:	687b      	ldr	r3, [r7, #4]
 8008196:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 8008198:	687b      	ldr	r3, [r7, #4]
 800819a:	2200      	movs	r2, #0
 800819c:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800819e:	687b      	ldr	r3, [r7, #4]
 80081a0:	2200      	movs	r2, #0
 80081a2:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, 0U, 0U);
 80081a4:	2200      	movs	r2, #0
 80081a6:	2100      	movs	r1, #0
 80081a8:	6878      	ldr	r0, [r7, #4]
 80081aa:	f000 fa2c 	bl	8008606 <USBH_CtlReq>
 80081ae:	4603      	mov	r3, r0
}
 80081b0:	4618      	mov	r0, r3
 80081b2:	3708      	adds	r7, #8
 80081b4:	46bd      	mov	sp, r7
 80081b6:	bd80      	pop	{r7, pc}

080081b8 <USBH_SetCfg>:
  * @param  phost: Host Handle
  * @param  cfg_idx: Configuration value
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_SetCfg(USBH_HandleTypeDef *phost, uint16_t cfg_idx)
{
 80081b8:	b580      	push	{r7, lr}
 80081ba:	b082      	sub	sp, #8
 80081bc:	af00      	add	r7, sp, #0
 80081be:	6078      	str	r0, [r7, #4]
 80081c0:	460b      	mov	r3, r1
 80081c2:	807b      	strh	r3, [r7, #2]
  if (phost->RequestState == CMD_SEND)
 80081c4:	687b      	ldr	r3, [r7, #4]
 80081c6:	789b      	ldrb	r3, [r3, #2]
 80081c8:	2b01      	cmp	r3, #1
 80081ca:	d10e      	bne.n	80081ea <USBH_SetCfg+0x32>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 80081cc:	687b      	ldr	r3, [r7, #4]
 80081ce:	2200      	movs	r2, #0
 80081d0:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
 80081d2:	687b      	ldr	r3, [r7, #4]
 80081d4:	2209      	movs	r2, #9
 80081d6:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = cfg_idx;
 80081d8:	687b      	ldr	r3, [r7, #4]
 80081da:	887a      	ldrh	r2, [r7, #2]
 80081dc:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 80081de:	687b      	ldr	r3, [r7, #4]
 80081e0:	2200      	movs	r2, #0
 80081e2:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 80081e4:	687b      	ldr	r3, [r7, #4]
 80081e6:	2200      	movs	r2, #0
 80081e8:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, 0U, 0U);
 80081ea:	2200      	movs	r2, #0
 80081ec:	2100      	movs	r1, #0
 80081ee:	6878      	ldr	r0, [r7, #4]
 80081f0:	f000 fa09 	bl	8008606 <USBH_CtlReq>
 80081f4:	4603      	mov	r3, r0
}
 80081f6:	4618      	mov	r0, r3
 80081f8:	3708      	adds	r7, #8
 80081fa:	46bd      	mov	sp, r7
 80081fc:	bd80      	pop	{r7, pc}

080081fe <USBH_SetFeature>:
  * @param  pdev: Selected device
  * @param  itf_idx
  * @retval Status
*/
USBH_StatusTypeDef USBH_SetFeature(USBH_HandleTypeDef *phost, uint8_t wValue)
{
 80081fe:	b580      	push	{r7, lr}
 8008200:	b082      	sub	sp, #8
 8008202:	af00      	add	r7, sp, #0
 8008204:	6078      	str	r0, [r7, #4]
 8008206:	460b      	mov	r3, r1
 8008208:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 800820a:	687b      	ldr	r3, [r7, #4]
 800820c:	789b      	ldrb	r3, [r3, #2]
 800820e:	2b01      	cmp	r3, #1
 8008210:	d10f      	bne.n	8008232 <USBH_SetFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8008212:	687b      	ldr	r3, [r7, #4]
 8008214:	2200      	movs	r2, #0
 8008216:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_SET_FEATURE;
 8008218:	687b      	ldr	r3, [r7, #4]
 800821a:	2203      	movs	r2, #3
 800821c:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = wValue;
 800821e:	78fb      	ldrb	r3, [r7, #3]
 8008220:	b29a      	uxth	r2, r3
 8008222:	687b      	ldr	r3, [r7, #4]
 8008224:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = 0U;
 8008226:	687b      	ldr	r3, [r7, #4]
 8008228:	2200      	movs	r2, #0
 800822a:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 800822c:	687b      	ldr	r3, [r7, #4]
 800822e:	2200      	movs	r2, #0
 8008230:	82da      	strh	r2, [r3, #22]
  }

  return USBH_CtlReq(phost, 0U, 0U);
 8008232:	2200      	movs	r2, #0
 8008234:	2100      	movs	r1, #0
 8008236:	6878      	ldr	r0, [r7, #4]
 8008238:	f000 f9e5 	bl	8008606 <USBH_CtlReq>
 800823c:	4603      	mov	r3, r0
}
 800823e:	4618      	mov	r0, r3
 8008240:	3708      	adds	r7, #8
 8008242:	46bd      	mov	sp, r7
 8008244:	bd80      	pop	{r7, pc}

08008246 <USBH_ClrFeature>:
  * @param  ep_num: endpoint number
  * @param  hc_num: Host channel number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClrFeature(USBH_HandleTypeDef *phost, uint8_t ep_num)
{
 8008246:	b580      	push	{r7, lr}
 8008248:	b082      	sub	sp, #8
 800824a:	af00      	add	r7, sp, #0
 800824c:	6078      	str	r0, [r7, #4]
 800824e:	460b      	mov	r3, r1
 8008250:	70fb      	strb	r3, [r7, #3]
  if (phost->RequestState == CMD_SEND)
 8008252:	687b      	ldr	r3, [r7, #4]
 8008254:	789b      	ldrb	r3, [r3, #2]
 8008256:	2b01      	cmp	r3, #1
 8008258:	d10f      	bne.n	800827a <USBH_ClrFeature+0x34>
  {
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 800825a:	687b      	ldr	r3, [r7, #4]
 800825c:	2202      	movs	r2, #2
 800825e:	741a      	strb	r2, [r3, #16]
                                           | USB_REQ_TYPE_STANDARD;

    phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
 8008260:	687b      	ldr	r3, [r7, #4]
 8008262:	2201      	movs	r2, #1
 8008264:	745a      	strb	r2, [r3, #17]
    phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 8008266:	687b      	ldr	r3, [r7, #4]
 8008268:	2200      	movs	r2, #0
 800826a:	825a      	strh	r2, [r3, #18]
    phost->Control.setup.b.wIndex.w = ep_num;
 800826c:	78fb      	ldrb	r3, [r7, #3]
 800826e:	b29a      	uxth	r2, r3
 8008270:	687b      	ldr	r3, [r7, #4]
 8008272:	829a      	strh	r2, [r3, #20]
    phost->Control.setup.b.wLength.w = 0U;
 8008274:	687b      	ldr	r3, [r7, #4]
 8008276:	2200      	movs	r2, #0
 8008278:	82da      	strh	r2, [r3, #22]
  }
  return USBH_CtlReq(phost, 0U, 0U);
 800827a:	2200      	movs	r2, #0
 800827c:	2100      	movs	r1, #0
 800827e:	6878      	ldr	r0, [r7, #4]
 8008280:	f000 f9c1 	bl	8008606 <USBH_CtlReq>
 8008284:	4603      	mov	r3, r0
}
 8008286:	4618      	mov	r0, r3
 8008288:	3708      	adds	r7, #8
 800828a:	46bd      	mov	sp, r7
 800828c:	bd80      	pop	{r7, pc}

0800828e <USBH_ParseDevDesc>:
  * @param  length: Length of the descriptor
  * @retval None
  */
static void  USBH_ParseDevDesc(USBH_DevDescTypeDef *dev_desc, uint8_t *buf,
                               uint16_t length)
{
 800828e:	b480      	push	{r7}
 8008290:	b085      	sub	sp, #20
 8008292:	af00      	add	r7, sp, #0
 8008294:	60f8      	str	r0, [r7, #12]
 8008296:	60b9      	str	r1, [r7, #8]
 8008298:	4613      	mov	r3, r2
 800829a:	80fb      	strh	r3, [r7, #6]
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 800829c:	68bb      	ldr	r3, [r7, #8]
 800829e:	781a      	ldrb	r2, [r3, #0]
 80082a0:	68fb      	ldr	r3, [r7, #12]
 80082a2:	701a      	strb	r2, [r3, #0]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
 80082a4:	68bb      	ldr	r3, [r7, #8]
 80082a6:	785a      	ldrb	r2, [r3, #1]
 80082a8:	68fb      	ldr	r3, [r7, #12]
 80082aa:	705a      	strb	r2, [r3, #1]
  dev_desc->bcdUSB             = LE16(buf +  2);
 80082ac:	68bb      	ldr	r3, [r7, #8]
 80082ae:	3302      	adds	r3, #2
 80082b0:	781b      	ldrb	r3, [r3, #0]
 80082b2:	b29a      	uxth	r2, r3
 80082b4:	68bb      	ldr	r3, [r7, #8]
 80082b6:	3303      	adds	r3, #3
 80082b8:	781b      	ldrb	r3, [r3, #0]
 80082ba:	b29b      	uxth	r3, r3
 80082bc:	021b      	lsls	r3, r3, #8
 80082be:	b29b      	uxth	r3, r3
 80082c0:	4313      	orrs	r3, r2
 80082c2:	b29a      	uxth	r2, r3
 80082c4:	68fb      	ldr	r3, [r7, #12]
 80082c6:	805a      	strh	r2, [r3, #2]
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 80082c8:	68bb      	ldr	r3, [r7, #8]
 80082ca:	791a      	ldrb	r2, [r3, #4]
 80082cc:	68fb      	ldr	r3, [r7, #12]
 80082ce:	711a      	strb	r2, [r3, #4]
  dev_desc->bDeviceSubClass    = *(uint8_t *)(buf +  5);
 80082d0:	68bb      	ldr	r3, [r7, #8]
 80082d2:	795a      	ldrb	r2, [r3, #5]
 80082d4:	68fb      	ldr	r3, [r7, #12]
 80082d6:	715a      	strb	r2, [r3, #5]
  dev_desc->bDeviceProtocol    = *(uint8_t *)(buf +  6);
 80082d8:	68bb      	ldr	r3, [r7, #8]
 80082da:	799a      	ldrb	r2, [r3, #6]
 80082dc:	68fb      	ldr	r3, [r7, #12]
 80082de:	719a      	strb	r2, [r3, #6]
  dev_desc->bMaxPacketSize     = *(uint8_t *)(buf +  7);
 80082e0:	68bb      	ldr	r3, [r7, #8]
 80082e2:	79da      	ldrb	r2, [r3, #7]
 80082e4:	68fb      	ldr	r3, [r7, #12]
 80082e6:	71da      	strb	r2, [r3, #7]

  if (length > 8U)
 80082e8:	88fb      	ldrh	r3, [r7, #6]
 80082ea:	2b08      	cmp	r3, #8
 80082ec:	d939      	bls.n	8008362 <USBH_ParseDevDesc+0xd4>
  {
    /* For 1st time after device connection, Host may issue only 8 bytes for
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16(buf +  8);
 80082ee:	68bb      	ldr	r3, [r7, #8]
 80082f0:	3308      	adds	r3, #8
 80082f2:	781b      	ldrb	r3, [r3, #0]
 80082f4:	b29a      	uxth	r2, r3
 80082f6:	68bb      	ldr	r3, [r7, #8]
 80082f8:	3309      	adds	r3, #9
 80082fa:	781b      	ldrb	r3, [r3, #0]
 80082fc:	b29b      	uxth	r3, r3
 80082fe:	021b      	lsls	r3, r3, #8
 8008300:	b29b      	uxth	r3, r3
 8008302:	4313      	orrs	r3, r2
 8008304:	b29a      	uxth	r2, r3
 8008306:	68fb      	ldr	r3, [r7, #12]
 8008308:	811a      	strh	r2, [r3, #8]
    dev_desc->idProduct          = LE16(buf + 10);
 800830a:	68bb      	ldr	r3, [r7, #8]
 800830c:	330a      	adds	r3, #10
 800830e:	781b      	ldrb	r3, [r3, #0]
 8008310:	b29a      	uxth	r2, r3
 8008312:	68bb      	ldr	r3, [r7, #8]
 8008314:	330b      	adds	r3, #11
 8008316:	781b      	ldrb	r3, [r3, #0]
 8008318:	b29b      	uxth	r3, r3
 800831a:	021b      	lsls	r3, r3, #8
 800831c:	b29b      	uxth	r3, r3
 800831e:	4313      	orrs	r3, r2
 8008320:	b29a      	uxth	r2, r3
 8008322:	68fb      	ldr	r3, [r7, #12]
 8008324:	815a      	strh	r2, [r3, #10]
    dev_desc->bcdDevice          = LE16(buf + 12);
 8008326:	68bb      	ldr	r3, [r7, #8]
 8008328:	330c      	adds	r3, #12
 800832a:	781b      	ldrb	r3, [r3, #0]
 800832c:	b29a      	uxth	r2, r3
 800832e:	68bb      	ldr	r3, [r7, #8]
 8008330:	330d      	adds	r3, #13
 8008332:	781b      	ldrb	r3, [r3, #0]
 8008334:	b29b      	uxth	r3, r3
 8008336:	021b      	lsls	r3, r3, #8
 8008338:	b29b      	uxth	r3, r3
 800833a:	4313      	orrs	r3, r2
 800833c:	b29a      	uxth	r2, r3
 800833e:	68fb      	ldr	r3, [r7, #12]
 8008340:	819a      	strh	r2, [r3, #12]
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 8008342:	68bb      	ldr	r3, [r7, #8]
 8008344:	7b9a      	ldrb	r2, [r3, #14]
 8008346:	68fb      	ldr	r3, [r7, #12]
 8008348:	739a      	strb	r2, [r3, #14]
    dev_desc->iProduct           = *(uint8_t *)(buf + 15);
 800834a:	68bb      	ldr	r3, [r7, #8]
 800834c:	7bda      	ldrb	r2, [r3, #15]
 800834e:	68fb      	ldr	r3, [r7, #12]
 8008350:	73da      	strb	r2, [r3, #15]
    dev_desc->iSerialNumber      = *(uint8_t *)(buf + 16);
 8008352:	68bb      	ldr	r3, [r7, #8]
 8008354:	7c1a      	ldrb	r2, [r3, #16]
 8008356:	68fb      	ldr	r3, [r7, #12]
 8008358:	741a      	strb	r2, [r3, #16]
    dev_desc->bNumConfigurations = *(uint8_t *)(buf + 17);
 800835a:	68bb      	ldr	r3, [r7, #8]
 800835c:	7c5a      	ldrb	r2, [r3, #17]
 800835e:	68fb      	ldr	r3, [r7, #12]
 8008360:	745a      	strb	r2, [r3, #17]
  }
}
 8008362:	bf00      	nop
 8008364:	3714      	adds	r7, #20
 8008366:	46bd      	mov	sp, r7
 8008368:	f85d 7b04 	ldr.w	r7, [sp], #4
 800836c:	4770      	bx	lr

0800836e <USBH_ParseCfgDesc>:
  * @param  length: Length of the descriptor
  * @retval None
  */
static void USBH_ParseCfgDesc(USBH_CfgDescTypeDef *cfg_desc, uint8_t *buf,
                              uint16_t length)
{
 800836e:	b580      	push	{r7, lr}
 8008370:	b08a      	sub	sp, #40	; 0x28
 8008372:	af00      	add	r7, sp, #0
 8008374:	60f8      	str	r0, [r7, #12]
 8008376:	60b9      	str	r1, [r7, #8]
 8008378:	4613      	mov	r3, r2
 800837a:	80fb      	strh	r3, [r7, #6]
  USBH_InterfaceDescTypeDef    *pif ;
  USBH_EpDescTypeDef           *pep;
  USBH_DescHeader_t            *pdesc = (USBH_DescHeader_t *)(void *)buf;
 800837c:	68bb      	ldr	r3, [r7, #8]
 800837e:	627b      	str	r3, [r7, #36]	; 0x24
  uint16_t                     ptr;
  uint8_t                      if_ix = 0U;
 8008380:	2300      	movs	r3, #0
 8008382:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  uint8_t                      ep_ix = 0U;
 8008386:	2300      	movs	r3, #0
 8008388:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

  pdesc   = (USBH_DescHeader_t *)(void *)buf;
 800838c:	68bb      	ldr	r3, [r7, #8]
 800838e:	627b      	str	r3, [r7, #36]	; 0x24

  /* Parse configuration descriptor */
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8008390:	68bb      	ldr	r3, [r7, #8]
 8008392:	781a      	ldrb	r2, [r3, #0]
 8008394:	68fb      	ldr	r3, [r7, #12]
 8008396:	701a      	strb	r2, [r3, #0]
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
 8008398:	68bb      	ldr	r3, [r7, #8]
 800839a:	785a      	ldrb	r2, [r3, #1]
 800839c:	68fb      	ldr	r3, [r7, #12]
 800839e:	705a      	strb	r2, [r3, #1]
  cfg_desc->wTotalLength        = LE16(buf + 2);
 80083a0:	68bb      	ldr	r3, [r7, #8]
 80083a2:	3302      	adds	r3, #2
 80083a4:	781b      	ldrb	r3, [r3, #0]
 80083a6:	b29a      	uxth	r2, r3
 80083a8:	68bb      	ldr	r3, [r7, #8]
 80083aa:	3303      	adds	r3, #3
 80083ac:	781b      	ldrb	r3, [r3, #0]
 80083ae:	b29b      	uxth	r3, r3
 80083b0:	021b      	lsls	r3, r3, #8
 80083b2:	b29b      	uxth	r3, r3
 80083b4:	4313      	orrs	r3, r2
 80083b6:	b29a      	uxth	r2, r3
 80083b8:	68fb      	ldr	r3, [r7, #12]
 80083ba:	805a      	strh	r2, [r3, #2]
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 80083bc:	68bb      	ldr	r3, [r7, #8]
 80083be:	791a      	ldrb	r2, [r3, #4]
 80083c0:	68fb      	ldr	r3, [r7, #12]
 80083c2:	711a      	strb	r2, [r3, #4]
  cfg_desc->bConfigurationValue = *(uint8_t *)(buf + 5);
 80083c4:	68bb      	ldr	r3, [r7, #8]
 80083c6:	795a      	ldrb	r2, [r3, #5]
 80083c8:	68fb      	ldr	r3, [r7, #12]
 80083ca:	715a      	strb	r2, [r3, #5]
  cfg_desc->iConfiguration      = *(uint8_t *)(buf + 6);
 80083cc:	68bb      	ldr	r3, [r7, #8]
 80083ce:	799a      	ldrb	r2, [r3, #6]
 80083d0:	68fb      	ldr	r3, [r7, #12]
 80083d2:	719a      	strb	r2, [r3, #6]
  cfg_desc->bmAttributes        = *(uint8_t *)(buf + 7);
 80083d4:	68bb      	ldr	r3, [r7, #8]
 80083d6:	79da      	ldrb	r2, [r3, #7]
 80083d8:	68fb      	ldr	r3, [r7, #12]
 80083da:	71da      	strb	r2, [r3, #7]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 80083dc:	68bb      	ldr	r3, [r7, #8]
 80083de:	7a1a      	ldrb	r2, [r3, #8]
 80083e0:	68fb      	ldr	r3, [r7, #12]
 80083e2:	721a      	strb	r2, [r3, #8]

  if (length > USB_CONFIGURATION_DESC_SIZE)
 80083e4:	88fb      	ldrh	r3, [r7, #6]
 80083e6:	2b09      	cmp	r3, #9
 80083e8:	d95f      	bls.n	80084aa <USBH_ParseCfgDesc+0x13c>
  {
    ptr = USB_LEN_CFG_DESC;
 80083ea:	2309      	movs	r3, #9
 80083ec:	82fb      	strh	r3, [r7, #22]
    pif = (USBH_InterfaceDescTypeDef *)0;
 80083ee:	2300      	movs	r3, #0
 80083f0:	61fb      	str	r3, [r7, #28]

    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 80083f2:	e051      	b.n	8008498 <USBH_ParseCfgDesc+0x12a>
    {
      pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 80083f4:	f107 0316 	add.w	r3, r7, #22
 80083f8:	4619      	mov	r1, r3
 80083fa:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80083fc:	f000 f8e8 	bl	80085d0 <USBH_GetNextDesc>
 8008400:	6278      	str	r0, [r7, #36]	; 0x24
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
 8008402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008404:	785b      	ldrb	r3, [r3, #1]
 8008406:	2b04      	cmp	r3, #4
 8008408:	d146      	bne.n	8008498 <USBH_ParseCfgDesc+0x12a>
      {
        pif = &cfg_desc->Itf_Desc[if_ix];
 800840a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800840e:	221a      	movs	r2, #26
 8008410:	fb02 f303 	mul.w	r3, r2, r3
 8008414:	3308      	adds	r3, #8
 8008416:	68fa      	ldr	r2, [r7, #12]
 8008418:	4413      	add	r3, r2
 800841a:	3302      	adds	r3, #2
 800841c:	61fb      	str	r3, [r7, #28]
        USBH_ParseInterfaceDesc(pif, (uint8_t *)(void *)pdesc);
 800841e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8008420:	69f8      	ldr	r0, [r7, #28]
 8008422:	f000 f846 	bl	80084b2 <USBH_ParseInterfaceDesc>

        ep_ix = 0U;
 8008426:	2300      	movs	r3, #0
 8008428:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        pep = (USBH_EpDescTypeDef *)0;
 800842c:	2300      	movs	r3, #0
 800842e:	61bb      	str	r3, [r7, #24]
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8008430:	e022      	b.n	8008478 <USBH_ParseCfgDesc+0x10a>
        {
          pdesc = USBH_GetNextDesc((uint8_t *)(void *)pdesc, &ptr);
 8008432:	f107 0316 	add.w	r3, r7, #22
 8008436:	4619      	mov	r1, r3
 8008438:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800843a:	f000 f8c9 	bl	80085d0 <USBH_GetNextDesc>
 800843e:	6278      	str	r0, [r7, #36]	; 0x24
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
 8008440:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008442:	785b      	ldrb	r3, [r3, #1]
 8008444:	2b05      	cmp	r3, #5
 8008446:	d117      	bne.n	8008478 <USBH_ParseCfgDesc+0x10a>
          {
            pep = &cfg_desc->Itf_Desc[if_ix].Ep_Desc[ep_ix];
 8008448:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800844c:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 8008450:	3201      	adds	r2, #1
 8008452:	00d2      	lsls	r2, r2, #3
 8008454:	211a      	movs	r1, #26
 8008456:	fb01 f303 	mul.w	r3, r1, r3
 800845a:	4413      	add	r3, r2
 800845c:	3308      	adds	r3, #8
 800845e:	68fa      	ldr	r2, [r7, #12]
 8008460:	4413      	add	r3, r2
 8008462:	3304      	adds	r3, #4
 8008464:	61bb      	str	r3, [r7, #24]
            USBH_ParseEPDesc(pep, (uint8_t *)(void *)pdesc);
 8008466:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8008468:	69b8      	ldr	r0, [r7, #24]
 800846a:	f000 f851 	bl	8008510 <USBH_ParseEPDesc>
            ep_ix++;
 800846e:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8008472:	3301      	adds	r3, #1
 8008474:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 8008478:	69fb      	ldr	r3, [r7, #28]
 800847a:	791b      	ldrb	r3, [r3, #4]
 800847c:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 8008480:	429a      	cmp	r2, r3
 8008482:	d204      	bcs.n	800848e <USBH_ParseCfgDesc+0x120>
 8008484:	68fb      	ldr	r3, [r7, #12]
 8008486:	885a      	ldrh	r2, [r3, #2]
 8008488:	8afb      	ldrh	r3, [r7, #22]
 800848a:	429a      	cmp	r2, r3
 800848c:	d8d1      	bhi.n	8008432 <USBH_ParseCfgDesc+0xc4>
          }
        }
        if_ix++;
 800848e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8008492:	3301      	adds	r3, #1
 8008494:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 8008498:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800849c:	2b01      	cmp	r3, #1
 800849e:	d804      	bhi.n	80084aa <USBH_ParseCfgDesc+0x13c>
 80084a0:	68fb      	ldr	r3, [r7, #12]
 80084a2:	885a      	ldrh	r2, [r3, #2]
 80084a4:	8afb      	ldrh	r3, [r7, #22]
 80084a6:	429a      	cmp	r2, r3
 80084a8:	d8a4      	bhi.n	80083f4 <USBH_ParseCfgDesc+0x86>
      }
    }
  }
}
 80084aa:	bf00      	nop
 80084ac:	3728      	adds	r7, #40	; 0x28
 80084ae:	46bd      	mov	sp, r7
 80084b0:	bd80      	pop	{r7, pc}

080084b2 <USBH_ParseInterfaceDesc>:
  * @param  buf: Buffer where the descriptor data is available
  * @retval None
  */
static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor,
                                     uint8_t *buf)
{
 80084b2:	b480      	push	{r7}
 80084b4:	b083      	sub	sp, #12
 80084b6:	af00      	add	r7, sp, #0
 80084b8:	6078      	str	r0, [r7, #4]
 80084ba:	6039      	str	r1, [r7, #0]
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 80084bc:	683b      	ldr	r3, [r7, #0]
 80084be:	781a      	ldrb	r2, [r3, #0]
 80084c0:	687b      	ldr	r3, [r7, #4]
 80084c2:	701a      	strb	r2, [r3, #0]
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
 80084c4:	683b      	ldr	r3, [r7, #0]
 80084c6:	785a      	ldrb	r2, [r3, #1]
 80084c8:	687b      	ldr	r3, [r7, #4]
 80084ca:	705a      	strb	r2, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
 80084cc:	683b      	ldr	r3, [r7, #0]
 80084ce:	789a      	ldrb	r2, [r3, #2]
 80084d0:	687b      	ldr	r3, [r7, #4]
 80084d2:	709a      	strb	r2, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
 80084d4:	683b      	ldr	r3, [r7, #0]
 80084d6:	78da      	ldrb	r2, [r3, #3]
 80084d8:	687b      	ldr	r3, [r7, #4]
 80084da:	70da      	strb	r2, [r3, #3]
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
 80084dc:	683b      	ldr	r3, [r7, #0]
 80084de:	791a      	ldrb	r2, [r3, #4]
 80084e0:	687b      	ldr	r3, [r7, #4]
 80084e2:	711a      	strb	r2, [r3, #4]
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
 80084e4:	683b      	ldr	r3, [r7, #0]
 80084e6:	795a      	ldrb	r2, [r3, #5]
 80084e8:	687b      	ldr	r3, [r7, #4]
 80084ea:	715a      	strb	r2, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
 80084ec:	683b      	ldr	r3, [r7, #0]
 80084ee:	799a      	ldrb	r2, [r3, #6]
 80084f0:	687b      	ldr	r3, [r7, #4]
 80084f2:	719a      	strb	r2, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
 80084f4:	683b      	ldr	r3, [r7, #0]
 80084f6:	79da      	ldrb	r2, [r3, #7]
 80084f8:	687b      	ldr	r3, [r7, #4]
 80084fa:	71da      	strb	r2, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
 80084fc:	683b      	ldr	r3, [r7, #0]
 80084fe:	7a1a      	ldrb	r2, [r3, #8]
 8008500:	687b      	ldr	r3, [r7, #4]
 8008502:	721a      	strb	r2, [r3, #8]
}
 8008504:	bf00      	nop
 8008506:	370c      	adds	r7, #12
 8008508:	46bd      	mov	sp, r7
 800850a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800850e:	4770      	bx	lr

08008510 <USBH_ParseEPDesc>:
  * @param  buf: Buffer where the parsed descriptor stored
  * @retval None
  */
static void  USBH_ParseEPDesc(USBH_EpDescTypeDef  *ep_descriptor,
                              uint8_t *buf)
{
 8008510:	b480      	push	{r7}
 8008512:	b083      	sub	sp, #12
 8008514:	af00      	add	r7, sp, #0
 8008516:	6078      	str	r0, [r7, #4]
 8008518:	6039      	str	r1, [r7, #0]
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 800851a:	683b      	ldr	r3, [r7, #0]
 800851c:	781a      	ldrb	r2, [r3, #0]
 800851e:	687b      	ldr	r3, [r7, #4]
 8008520:	701a      	strb	r2, [r3, #0]
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
 8008522:	683b      	ldr	r3, [r7, #0]
 8008524:	785a      	ldrb	r2, [r3, #1]
 8008526:	687b      	ldr	r3, [r7, #4]
 8008528:	705a      	strb	r2, [r3, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
 800852a:	683b      	ldr	r3, [r7, #0]
 800852c:	789a      	ldrb	r2, [r3, #2]
 800852e:	687b      	ldr	r3, [r7, #4]
 8008530:	709a      	strb	r2, [r3, #2]
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
 8008532:	683b      	ldr	r3, [r7, #0]
 8008534:	78da      	ldrb	r2, [r3, #3]
 8008536:	687b      	ldr	r3, [r7, #4]
 8008538:	70da      	strb	r2, [r3, #3]
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
 800853a:	683b      	ldr	r3, [r7, #0]
 800853c:	3304      	adds	r3, #4
 800853e:	781b      	ldrb	r3, [r3, #0]
 8008540:	b29a      	uxth	r2, r3
 8008542:	683b      	ldr	r3, [r7, #0]
 8008544:	3305      	adds	r3, #5
 8008546:	781b      	ldrb	r3, [r3, #0]
 8008548:	b29b      	uxth	r3, r3
 800854a:	021b      	lsls	r3, r3, #8
 800854c:	b29b      	uxth	r3, r3
 800854e:	4313      	orrs	r3, r2
 8008550:	b29a      	uxth	r2, r3
 8008552:	687b      	ldr	r3, [r7, #4]
 8008554:	809a      	strh	r2, [r3, #4]
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
 8008556:	683b      	ldr	r3, [r7, #0]
 8008558:	799a      	ldrb	r2, [r3, #6]
 800855a:	687b      	ldr	r3, [r7, #4]
 800855c:	719a      	strb	r2, [r3, #6]
}
 800855e:	bf00      	nop
 8008560:	370c      	adds	r7, #12
 8008562:	46bd      	mov	sp, r7
 8008564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008568:	4770      	bx	lr

0800856a <USBH_ParseStringDesc>:
  * @param  pdest: Destination address pointer
  * @param  length: Length of the descriptor
  * @retval None
  */
static void USBH_ParseStringDesc(uint8_t *psrc, uint8_t *pdest, uint16_t length)
{
 800856a:	b480      	push	{r7}
 800856c:	b087      	sub	sp, #28
 800856e:	af00      	add	r7, sp, #0
 8008570:	60f8      	str	r0, [r7, #12]
 8008572:	60b9      	str	r1, [r7, #8]
 8008574:	4613      	mov	r3, r2
 8008576:	80fb      	strh	r3, [r7, #6]
  */

  /* Check which is lower size, the Size of string or the length of bytes read
  from the device */

  if (psrc[1] == USB_DESC_TYPE_STRING)
 8008578:	68fb      	ldr	r3, [r7, #12]
 800857a:	3301      	adds	r3, #1
 800857c:	781b      	ldrb	r3, [r3, #0]
 800857e:	2b03      	cmp	r3, #3
 8008580:	d120      	bne.n	80085c4 <USBH_ParseStringDesc+0x5a>
  {
    /* Make sure the Descriptor is String Type */

    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 8008582:	68fb      	ldr	r3, [r7, #12]
 8008584:	781b      	ldrb	r3, [r3, #0]
 8008586:	1e9a      	subs	r2, r3, #2
 8008588:	88fb      	ldrh	r3, [r7, #6]
 800858a:	4293      	cmp	r3, r2
 800858c:	bf28      	it	cs
 800858e:	4613      	movcs	r3, r2
 8008590:	82bb      	strh	r3, [r7, #20]

    /* Adjust the offset ignoring the String Len and Descriptor type */
    psrc += 2U;
 8008592:	68fb      	ldr	r3, [r7, #12]
 8008594:	3302      	adds	r3, #2
 8008596:	60fb      	str	r3, [r7, #12]

    for (idx = 0U; idx < strlength; idx += 2U)
 8008598:	2300      	movs	r3, #0
 800859a:	82fb      	strh	r3, [r7, #22]
 800859c:	e00b      	b.n	80085b6 <USBH_ParseStringDesc+0x4c>
    {
      /* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
 800859e:	8afb      	ldrh	r3, [r7, #22]
 80085a0:	68fa      	ldr	r2, [r7, #12]
 80085a2:	4413      	add	r3, r2
 80085a4:	781a      	ldrb	r2, [r3, #0]
 80085a6:	68bb      	ldr	r3, [r7, #8]
 80085a8:	701a      	strb	r2, [r3, #0]
      pdest++;
 80085aa:	68bb      	ldr	r3, [r7, #8]
 80085ac:	3301      	adds	r3, #1
 80085ae:	60bb      	str	r3, [r7, #8]
    for (idx = 0U; idx < strlength; idx += 2U)
 80085b0:	8afb      	ldrh	r3, [r7, #22]
 80085b2:	3302      	adds	r3, #2
 80085b4:	82fb      	strh	r3, [r7, #22]
 80085b6:	8afa      	ldrh	r2, [r7, #22]
 80085b8:	8abb      	ldrh	r3, [r7, #20]
 80085ba:	429a      	cmp	r2, r3
 80085bc:	d3ef      	bcc.n	800859e <USBH_ParseStringDesc+0x34>
    }
    *pdest = 0U; /* mark end of string */
 80085be:	68bb      	ldr	r3, [r7, #8]
 80085c0:	2200      	movs	r2, #0
 80085c2:	701a      	strb	r2, [r3, #0]
  }
}
 80085c4:	bf00      	nop
 80085c6:	371c      	adds	r7, #28
 80085c8:	46bd      	mov	sp, r7
 80085ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80085ce:	4770      	bx	lr

080085d0 <USBH_GetNextDesc>:
  * @param  buf: Buffer where the cfg descriptor is available
  * @param  ptr: data pointer inside the cfg descriptor
  * @retval next header
  */
USBH_DescHeader_t  *USBH_GetNextDesc(uint8_t   *pbuf, uint16_t  *ptr)
{
 80085d0:	b480      	push	{r7}
 80085d2:	b085      	sub	sp, #20
 80085d4:	af00      	add	r7, sp, #0
 80085d6:	6078      	str	r0, [r7, #4]
 80085d8:	6039      	str	r1, [r7, #0]
  USBH_DescHeader_t  *pnext;

  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80085da:	683b      	ldr	r3, [r7, #0]
 80085dc:	881a      	ldrh	r2, [r3, #0]
 80085de:	687b      	ldr	r3, [r7, #4]
 80085e0:	781b      	ldrb	r3, [r3, #0]
 80085e2:	b29b      	uxth	r3, r3
 80085e4:	4413      	add	r3, r2
 80085e6:	b29a      	uxth	r2, r3
 80085e8:	683b      	ldr	r3, [r7, #0]
 80085ea:	801a      	strh	r2, [r3, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
                                        ((USBH_DescHeader_t *)(void *)pbuf)->bLength);
 80085ec:	687b      	ldr	r3, [r7, #4]
 80085ee:	781b      	ldrb	r3, [r3, #0]
 80085f0:	461a      	mov	r2, r3
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 80085f2:	687b      	ldr	r3, [r7, #4]
 80085f4:	4413      	add	r3, r2
 80085f6:	60fb      	str	r3, [r7, #12]

  return (pnext);
 80085f8:	68fb      	ldr	r3, [r7, #12]
}
 80085fa:	4618      	mov	r0, r3
 80085fc:	3714      	adds	r7, #20
 80085fe:	46bd      	mov	sp, r7
 8008600:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008604:	4770      	bx	lr

08008606 <USBH_CtlReq>:
  * @param  length: length of the response
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlReq(USBH_HandleTypeDef *phost, uint8_t *buff,
                               uint16_t length)
{
 8008606:	b580      	push	{r7, lr}
 8008608:	b086      	sub	sp, #24
 800860a:	af00      	add	r7, sp, #0
 800860c:	60f8      	str	r0, [r7, #12]
 800860e:	60b9      	str	r1, [r7, #8]
 8008610:	4613      	mov	r3, r2
 8008612:	80fb      	strh	r3, [r7, #6]
  USBH_StatusTypeDef status;
  status = USBH_BUSY;
 8008614:	2301      	movs	r3, #1
 8008616:	75fb      	strb	r3, [r7, #23]

  switch (phost->RequestState)
 8008618:	68fb      	ldr	r3, [r7, #12]
 800861a:	789b      	ldrb	r3, [r3, #2]
 800861c:	2b01      	cmp	r3, #1
 800861e:	d002      	beq.n	8008626 <USBH_CtlReq+0x20>
 8008620:	2b02      	cmp	r3, #2
 8008622:	d00f      	beq.n	8008644 <USBH_CtlReq+0x3e>
#endif
#endif
      break;

    default:
      break;
 8008624:	e027      	b.n	8008676 <USBH_CtlReq+0x70>
      phost->Control.buff = buff;
 8008626:	68fb      	ldr	r3, [r7, #12]
 8008628:	68ba      	ldr	r2, [r7, #8]
 800862a:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 800862c:	68fb      	ldr	r3, [r7, #12]
 800862e:	88fa      	ldrh	r2, [r7, #6]
 8008630:	819a      	strh	r2, [r3, #12]
      phost->Control.state = CTRL_SETUP;
 8008632:	68fb      	ldr	r3, [r7, #12]
 8008634:	2201      	movs	r2, #1
 8008636:	761a      	strb	r2, [r3, #24]
      phost->RequestState = CMD_WAIT;
 8008638:	68fb      	ldr	r3, [r7, #12]
 800863a:	2202      	movs	r2, #2
 800863c:	709a      	strb	r2, [r3, #2]
      status = USBH_BUSY;
 800863e:	2301      	movs	r3, #1
 8008640:	75fb      	strb	r3, [r7, #23]
      break;
 8008642:	e018      	b.n	8008676 <USBH_CtlReq+0x70>
      status = USBH_HandleControl(phost);
 8008644:	68f8      	ldr	r0, [r7, #12]
 8008646:	f000 f81b 	bl	8008680 <USBH_HandleControl>
 800864a:	4603      	mov	r3, r0
 800864c:	75fb      	strb	r3, [r7, #23]
      if ((status == USBH_OK) || (status == USBH_NOT_SUPPORTED))
 800864e:	7dfb      	ldrb	r3, [r7, #23]
 8008650:	2b00      	cmp	r3, #0
 8008652:	d002      	beq.n	800865a <USBH_CtlReq+0x54>
 8008654:	7dfb      	ldrb	r3, [r7, #23]
 8008656:	2b03      	cmp	r3, #3
 8008658:	d106      	bne.n	8008668 <USBH_CtlReq+0x62>
        phost->RequestState = CMD_SEND;
 800865a:	68fb      	ldr	r3, [r7, #12]
 800865c:	2201      	movs	r2, #1
 800865e:	709a      	strb	r2, [r3, #2]
        phost->Control.state = CTRL_IDLE;
 8008660:	68fb      	ldr	r3, [r7, #12]
 8008662:	2200      	movs	r2, #0
 8008664:	761a      	strb	r2, [r3, #24]
      break;
 8008666:	e005      	b.n	8008674 <USBH_CtlReq+0x6e>
      else if (status == USBH_FAIL)
 8008668:	7dfb      	ldrb	r3, [r7, #23]
 800866a:	2b02      	cmp	r3, #2
 800866c:	d102      	bne.n	8008674 <USBH_CtlReq+0x6e>
        phost->RequestState = CMD_SEND;
 800866e:	68fb      	ldr	r3, [r7, #12]
 8008670:	2201      	movs	r2, #1
 8008672:	709a      	strb	r2, [r3, #2]
      break;
 8008674:	bf00      	nop
  }
  return status;
 8008676:	7dfb      	ldrb	r3, [r7, #23]
}
 8008678:	4618      	mov	r0, r3
 800867a:	3718      	adds	r7, #24
 800867c:	46bd      	mov	sp, r7
 800867e:	bd80      	pop	{r7, pc}

08008680 <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  phost: Host Handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_HandleControl(USBH_HandleTypeDef *phost)
{
 8008680:	b580      	push	{r7, lr}
 8008682:	b086      	sub	sp, #24
 8008684:	af02      	add	r7, sp, #8
 8008686:	6078      	str	r0, [r7, #4]
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
 8008688:	2301      	movs	r3, #1
 800868a:	73fb      	strb	r3, [r7, #15]
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
 800868c:	2300      	movs	r3, #0
 800868e:	73bb      	strb	r3, [r7, #14]

  switch (phost->Control.state)
 8008690:	687b      	ldr	r3, [r7, #4]
 8008692:	7e1b      	ldrb	r3, [r3, #24]
 8008694:	3b01      	subs	r3, #1
 8008696:	2b0a      	cmp	r3, #10
 8008698:	f200 8156 	bhi.w	8008948 <USBH_HandleControl+0x2c8>
 800869c:	a201      	add	r2, pc, #4	; (adr r2, 80086a4 <USBH_HandleControl+0x24>)
 800869e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80086a2:	bf00      	nop
 80086a4:	080086d1 	.word	0x080086d1
 80086a8:	080086eb 	.word	0x080086eb
 80086ac:	08008755 	.word	0x08008755
 80086b0:	0800877b 	.word	0x0800877b
 80086b4:	080087b3 	.word	0x080087b3
 80086b8:	080087dd 	.word	0x080087dd
 80086bc:	0800882f 	.word	0x0800882f
 80086c0:	08008851 	.word	0x08008851
 80086c4:	0800888d 	.word	0x0800888d
 80086c8:	080088b3 	.word	0x080088b3
 80086cc:	080088f1 	.word	0x080088f1
  {
    case CTRL_SETUP:
      /* send a SETUP packet */
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 80086d0:	687b      	ldr	r3, [r7, #4]
 80086d2:	f103 0110 	add.w	r1, r3, #16
 80086d6:	687b      	ldr	r3, [r7, #4]
 80086d8:	795b      	ldrb	r3, [r3, #5]
 80086da:	461a      	mov	r2, r3
 80086dc:	6878      	ldr	r0, [r7, #4]
 80086de:	f000 f943 	bl	8008968 <USBH_CtlSendSetup>
                        phost->Control.pipe_out);

      phost->Control.state = CTRL_SETUP_WAIT;
 80086e2:	687b      	ldr	r3, [r7, #4]
 80086e4:	2202      	movs	r2, #2
 80086e6:	761a      	strb	r2, [r3, #24]
      break;
 80086e8:	e139      	b.n	800895e <USBH_HandleControl+0x2de>

    case CTRL_SETUP_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80086ea:	687b      	ldr	r3, [r7, #4]
 80086ec:	795b      	ldrb	r3, [r3, #5]
 80086ee:	4619      	mov	r1, r3
 80086f0:	6878      	ldr	r0, [r7, #4]
 80086f2:	f01f fcc5 	bl	8028080 <USBH_LL_GetURBState>
 80086f6:	4603      	mov	r3, r0
 80086f8:	73bb      	strb	r3, [r7, #14]
      /* case SETUP packet sent successfully */
      if (URB_Status == USBH_URB_DONE)
 80086fa:	7bbb      	ldrb	r3, [r7, #14]
 80086fc:	2b01      	cmp	r3, #1
 80086fe:	d11e      	bne.n	800873e <USBH_HandleControl+0xbe>
      {
        direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
 8008700:	687b      	ldr	r3, [r7, #4]
 8008702:	7c1b      	ldrb	r3, [r3, #16]
 8008704:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8008708:	737b      	strb	r3, [r7, #13]

        /* check if there is a data stage */
        if (phost->Control.setup.b.wLength.w != 0U)
 800870a:	687b      	ldr	r3, [r7, #4]
 800870c:	8adb      	ldrh	r3, [r3, #22]
 800870e:	2b00      	cmp	r3, #0
 8008710:	d00a      	beq.n	8008728 <USBH_HandleControl+0xa8>
        {
          if (direction == USB_D2H)
 8008712:	7b7b      	ldrb	r3, [r7, #13]
 8008714:	2b80      	cmp	r3, #128	; 0x80
 8008716:	d103      	bne.n	8008720 <USBH_HandleControl+0xa0>
          {
            /* Data Direction is IN */
            phost->Control.state = CTRL_DATA_IN;
 8008718:	687b      	ldr	r3, [r7, #4]
 800871a:	2203      	movs	r2, #3
 800871c:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 800871e:	e115      	b.n	800894c <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_DATA_OUT;
 8008720:	687b      	ldr	r3, [r7, #4]
 8008722:	2205      	movs	r2, #5
 8008724:	761a      	strb	r2, [r3, #24]
      break;
 8008726:	e111      	b.n	800894c <USBH_HandleControl+0x2cc>
          if (direction == USB_D2H)
 8008728:	7b7b      	ldrb	r3, [r7, #13]
 800872a:	2b80      	cmp	r3, #128	; 0x80
 800872c:	d103      	bne.n	8008736 <USBH_HandleControl+0xb6>
            phost->Control.state = CTRL_STATUS_OUT;
 800872e:	687b      	ldr	r3, [r7, #4]
 8008730:	2209      	movs	r2, #9
 8008732:	761a      	strb	r2, [r3, #24]
      break;
 8008734:	e10a      	b.n	800894c <USBH_HandleControl+0x2cc>
            phost->Control.state = CTRL_STATUS_IN;
 8008736:	687b      	ldr	r3, [r7, #4]
 8008738:	2207      	movs	r2, #7
 800873a:	761a      	strb	r2, [r3, #24]
      break;
 800873c:	e106      	b.n	800894c <USBH_HandleControl+0x2cc>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 800873e:	7bbb      	ldrb	r3, [r7, #14]
 8008740:	2b04      	cmp	r3, #4
 8008742:	d003      	beq.n	800874c <USBH_HandleControl+0xcc>
 8008744:	7bbb      	ldrb	r3, [r7, #14]
 8008746:	2b02      	cmp	r3, #2
 8008748:	f040 8100 	bne.w	800894c <USBH_HandleControl+0x2cc>
          phost->Control.state = CTRL_ERROR;
 800874c:	687b      	ldr	r3, [r7, #4]
 800874e:	220b      	movs	r2, #11
 8008750:	761a      	strb	r2, [r3, #24]
      break;
 8008752:	e0fb      	b.n	800894c <USBH_HandleControl+0x2cc>

    case CTRL_DATA_IN:
      /* Issue an IN token */
      phost->Control.timer = (uint16_t)phost->Timer;
 8008754:	687b      	ldr	r3, [r7, #4]
 8008756:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 800875a:	b29a      	uxth	r2, r3
 800875c:	687b      	ldr	r3, [r7, #4]
 800875e:	81da      	strh	r2, [r3, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8008760:	687b      	ldr	r3, [r7, #4]
 8008762:	6899      	ldr	r1, [r3, #8]
 8008764:	687b      	ldr	r3, [r7, #4]
 8008766:	899a      	ldrh	r2, [r3, #12]
 8008768:	687b      	ldr	r3, [r7, #4]
 800876a:	791b      	ldrb	r3, [r3, #4]
 800876c:	6878      	ldr	r0, [r7, #4]
 800876e:	f000 f93a 	bl	80089e6 <USBH_CtlReceiveData>
                          phost->Control.pipe_in);

      phost->Control.state = CTRL_DATA_IN_WAIT;
 8008772:	687b      	ldr	r3, [r7, #4]
 8008774:	2204      	movs	r2, #4
 8008776:	761a      	strb	r2, [r3, #24]
      break;
 8008778:	e0f1      	b.n	800895e <USBH_HandleControl+0x2de>

    case CTRL_DATA_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 800877a:	687b      	ldr	r3, [r7, #4]
 800877c:	791b      	ldrb	r3, [r3, #4]
 800877e:	4619      	mov	r1, r3
 8008780:	6878      	ldr	r0, [r7, #4]
 8008782:	f01f fc7d 	bl	8028080 <USBH_LL_GetURBState>
 8008786:	4603      	mov	r3, r0
 8008788:	73bb      	strb	r3, [r7, #14]

      /* check is DATA packet transferred successfully */
      if (URB_Status == USBH_URB_DONE)
 800878a:	7bbb      	ldrb	r3, [r7, #14]
 800878c:	2b01      	cmp	r3, #1
 800878e:	d102      	bne.n	8008796 <USBH_HandleControl+0x116>
      {
        phost->Control.state = CTRL_STATUS_OUT;
 8008790:	687b      	ldr	r3, [r7, #4]
 8008792:	2209      	movs	r2, #9
 8008794:	761a      	strb	r2, [r3, #24]
#endif
#endif
      }

      /* manage error cases*/
      if (URB_Status == USBH_URB_STALL)
 8008796:	7bbb      	ldrb	r3, [r7, #14]
 8008798:	2b05      	cmp	r3, #5
 800879a:	d102      	bne.n	80087a2 <USBH_HandleControl+0x122>
      {
        /* In stall case, return to previous machine state*/
        status = USBH_NOT_SUPPORTED;
 800879c:	2303      	movs	r3, #3
 800879e:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 80087a0:	e0d6      	b.n	8008950 <USBH_HandleControl+0x2d0>
        if (URB_Status == USBH_URB_ERROR)
 80087a2:	7bbb      	ldrb	r3, [r7, #14]
 80087a4:	2b04      	cmp	r3, #4
 80087a6:	f040 80d3 	bne.w	8008950 <USBH_HandleControl+0x2d0>
          phost->Control.state = CTRL_ERROR;
 80087aa:	687b      	ldr	r3, [r7, #4]
 80087ac:	220b      	movs	r2, #11
 80087ae:	761a      	strb	r2, [r3, #24]
      break;
 80087b0:	e0ce      	b.n	8008950 <USBH_HandleControl+0x2d0>

    case CTRL_DATA_OUT:

      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 80087b2:	687b      	ldr	r3, [r7, #4]
 80087b4:	6899      	ldr	r1, [r3, #8]
 80087b6:	687b      	ldr	r3, [r7, #4]
 80087b8:	899a      	ldrh	r2, [r3, #12]
 80087ba:	687b      	ldr	r3, [r7, #4]
 80087bc:	795b      	ldrb	r3, [r3, #5]
 80087be:	2001      	movs	r0, #1
 80087c0:	9000      	str	r0, [sp, #0]
 80087c2:	6878      	ldr	r0, [r7, #4]
 80087c4:	f000 f8ea 	bl	800899c <USBH_CtlSendData>
                       phost->Control.pipe_out, 1U);

      phost->Control.timer = (uint16_t)phost->Timer;
 80087c8:	687b      	ldr	r3, [r7, #4]
 80087ca:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 80087ce:	b29a      	uxth	r2, r3
 80087d0:	687b      	ldr	r3, [r7, #4]
 80087d2:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80087d4:	687b      	ldr	r3, [r7, #4]
 80087d6:	2206      	movs	r2, #6
 80087d8:	761a      	strb	r2, [r3, #24]
      break;
 80087da:	e0c0      	b.n	800895e <USBH_HandleControl+0x2de>

    case CTRL_DATA_OUT_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80087dc:	687b      	ldr	r3, [r7, #4]
 80087de:	795b      	ldrb	r3, [r3, #5]
 80087e0:	4619      	mov	r1, r3
 80087e2:	6878      	ldr	r0, [r7, #4]
 80087e4:	f01f fc4c 	bl	8028080 <USBH_LL_GetURBState>
 80087e8:	4603      	mov	r3, r0
 80087ea:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 80087ec:	7bbb      	ldrb	r3, [r7, #14]
 80087ee:	2b01      	cmp	r3, #1
 80087f0:	d103      	bne.n	80087fa <USBH_HandleControl+0x17a>
      {
        /* If the Setup Pkt is sent successful, then change the state */
        phost->Control.state = CTRL_STATUS_IN;
 80087f2:	687b      	ldr	r3, [r7, #4]
 80087f4:	2207      	movs	r2, #7
 80087f6:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 80087f8:	e0ac      	b.n	8008954 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_STALL)
 80087fa:	7bbb      	ldrb	r3, [r7, #14]
 80087fc:	2b05      	cmp	r3, #5
 80087fe:	d105      	bne.n	800880c <USBH_HandleControl+0x18c>
        phost->Control.state = CTRL_STALLED;
 8008800:	687b      	ldr	r3, [r7, #4]
 8008802:	220c      	movs	r2, #12
 8008804:	761a      	strb	r2, [r3, #24]
        status = USBH_NOT_SUPPORTED;
 8008806:	2303      	movs	r3, #3
 8008808:	73fb      	strb	r3, [r7, #15]
      break;
 800880a:	e0a3      	b.n	8008954 <USBH_HandleControl+0x2d4>
      else if (URB_Status == USBH_URB_NOTREADY)
 800880c:	7bbb      	ldrb	r3, [r7, #14]
 800880e:	2b02      	cmp	r3, #2
 8008810:	d103      	bne.n	800881a <USBH_HandleControl+0x19a>
        phost->Control.state = CTRL_DATA_OUT;
 8008812:	687b      	ldr	r3, [r7, #4]
 8008814:	2205      	movs	r2, #5
 8008816:	761a      	strb	r2, [r3, #24]
      break;
 8008818:	e09c      	b.n	8008954 <USBH_HandleControl+0x2d4>
        if (URB_Status == USBH_URB_ERROR)
 800881a:	7bbb      	ldrb	r3, [r7, #14]
 800881c:	2b04      	cmp	r3, #4
 800881e:	f040 8099 	bne.w	8008954 <USBH_HandleControl+0x2d4>
          phost->Control.state = CTRL_ERROR;
 8008822:	687b      	ldr	r3, [r7, #4]
 8008824:	220b      	movs	r2, #11
 8008826:	761a      	strb	r2, [r3, #24]
          status = USBH_FAIL;
 8008828:	2302      	movs	r3, #2
 800882a:	73fb      	strb	r3, [r7, #15]
      break;
 800882c:	e092      	b.n	8008954 <USBH_HandleControl+0x2d4>

    case CTRL_STATUS_IN:
      /* Send 0 bytes out packet */
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 800882e:	687b      	ldr	r3, [r7, #4]
 8008830:	791b      	ldrb	r3, [r3, #4]
 8008832:	2200      	movs	r2, #0
 8008834:	2100      	movs	r1, #0
 8008836:	6878      	ldr	r0, [r7, #4]
 8008838:	f000 f8d5 	bl	80089e6 <USBH_CtlReceiveData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800883c:	687b      	ldr	r3, [r7, #4]
 800883e:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 8008842:	b29a      	uxth	r2, r3
 8008844:	687b      	ldr	r3, [r7, #4]
 8008846:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8008848:	687b      	ldr	r3, [r7, #4]
 800884a:	2208      	movs	r2, #8
 800884c:	761a      	strb	r2, [r3, #24]

      break;
 800884e:	e086      	b.n	800895e <USBH_HandleControl+0x2de>

    case CTRL_STATUS_IN_WAIT:

      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8008850:	687b      	ldr	r3, [r7, #4]
 8008852:	791b      	ldrb	r3, [r3, #4]
 8008854:	4619      	mov	r1, r3
 8008856:	6878      	ldr	r0, [r7, #4]
 8008858:	f01f fc12 	bl	8028080 <USBH_LL_GetURBState>
 800885c:	4603      	mov	r3, r0
 800885e:	73bb      	strb	r3, [r7, #14]

      if (URB_Status == USBH_URB_DONE)
 8008860:	7bbb      	ldrb	r3, [r7, #14]
 8008862:	2b01      	cmp	r3, #1
 8008864:	d105      	bne.n	8008872 <USBH_HandleControl+0x1f2>
      {
        /* Control transfers completed, Exit the State Machine */
        phost->Control.state = CTRL_COMPLETE;
 8008866:	687b      	ldr	r3, [r7, #4]
 8008868:	220d      	movs	r2, #13
 800886a:	761a      	strb	r2, [r3, #24]
        status = USBH_OK;
 800886c:	2300      	movs	r3, #0
 800886e:	73fb      	strb	r3, [r7, #15]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 8008870:	e072      	b.n	8008958 <USBH_HandleControl+0x2d8>
      else if (URB_Status == USBH_URB_ERROR)
 8008872:	7bbb      	ldrb	r3, [r7, #14]
 8008874:	2b04      	cmp	r3, #4
 8008876:	d103      	bne.n	8008880 <USBH_HandleControl+0x200>
        phost->Control.state = CTRL_ERROR;
 8008878:	687b      	ldr	r3, [r7, #4]
 800887a:	220b      	movs	r2, #11
 800887c:	761a      	strb	r2, [r3, #24]
      break;
 800887e:	e06b      	b.n	8008958 <USBH_HandleControl+0x2d8>
        if (URB_Status == USBH_URB_STALL)
 8008880:	7bbb      	ldrb	r3, [r7, #14]
 8008882:	2b05      	cmp	r3, #5
 8008884:	d168      	bne.n	8008958 <USBH_HandleControl+0x2d8>
          status = USBH_NOT_SUPPORTED;
 8008886:	2303      	movs	r3, #3
 8008888:	73fb      	strb	r3, [r7, #15]
      break;
 800888a:	e065      	b.n	8008958 <USBH_HandleControl+0x2d8>

    case CTRL_STATUS_OUT:
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 800888c:	687b      	ldr	r3, [r7, #4]
 800888e:	795b      	ldrb	r3, [r3, #5]
 8008890:	2201      	movs	r2, #1
 8008892:	9200      	str	r2, [sp, #0]
 8008894:	2200      	movs	r2, #0
 8008896:	2100      	movs	r1, #0
 8008898:	6878      	ldr	r0, [r7, #4]
 800889a:	f000 f87f 	bl	800899c <USBH_CtlSendData>

      phost->Control.timer = (uint16_t)phost->Timer;
 800889e:	687b      	ldr	r3, [r7, #4]
 80088a0:	f8d3 33c4 	ldr.w	r3, [r3, #964]	; 0x3c4
 80088a4:	b29a      	uxth	r2, r3
 80088a6:	687b      	ldr	r3, [r7, #4]
 80088a8:	81da      	strh	r2, [r3, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80088aa:	687b      	ldr	r3, [r7, #4]
 80088ac:	220a      	movs	r2, #10
 80088ae:	761a      	strb	r2, [r3, #24]
      break;
 80088b0:	e055      	b.n	800895e <USBH_HandleControl+0x2de>

    case CTRL_STATUS_OUT_WAIT:
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	795b      	ldrb	r3, [r3, #5]
 80088b6:	4619      	mov	r1, r3
 80088b8:	6878      	ldr	r0, [r7, #4]
 80088ba:	f01f fbe1 	bl	8028080 <USBH_LL_GetURBState>
 80088be:	4603      	mov	r3, r0
 80088c0:	73bb      	strb	r3, [r7, #14]
      if (URB_Status == USBH_URB_DONE)
 80088c2:	7bbb      	ldrb	r3, [r7, #14]
 80088c4:	2b01      	cmp	r3, #1
 80088c6:	d105      	bne.n	80088d4 <USBH_HandleControl+0x254>
      {
        status = USBH_OK;
 80088c8:	2300      	movs	r3, #0
 80088ca:	73fb      	strb	r3, [r7, #15]
        phost->Control.state = CTRL_COMPLETE;
 80088cc:	687b      	ldr	r3, [r7, #4]
 80088ce:	220d      	movs	r2, #13
 80088d0:	761a      	strb	r2, [r3, #24]
          (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif
        }
      }
      break;
 80088d2:	e043      	b.n	800895c <USBH_HandleControl+0x2dc>
      else if (URB_Status == USBH_URB_NOTREADY)
 80088d4:	7bbb      	ldrb	r3, [r7, #14]
 80088d6:	2b02      	cmp	r3, #2
 80088d8:	d103      	bne.n	80088e2 <USBH_HandleControl+0x262>
        phost->Control.state = CTRL_STATUS_OUT;
 80088da:	687b      	ldr	r3, [r7, #4]
 80088dc:	2209      	movs	r2, #9
 80088de:	761a      	strb	r2, [r3, #24]
      break;
 80088e0:	e03c      	b.n	800895c <USBH_HandleControl+0x2dc>
        if (URB_Status == USBH_URB_ERROR)
 80088e2:	7bbb      	ldrb	r3, [r7, #14]
 80088e4:	2b04      	cmp	r3, #4
 80088e6:	d139      	bne.n	800895c <USBH_HandleControl+0x2dc>
          phost->Control.state = CTRL_ERROR;
 80088e8:	687b      	ldr	r3, [r7, #4]
 80088ea:	220b      	movs	r2, #11
 80088ec:	761a      	strb	r2, [r3, #24]
      break;
 80088ee:	e035      	b.n	800895c <USBH_HandleControl+0x2dc>
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80088f0:	687b      	ldr	r3, [r7, #4]
 80088f2:	7e5b      	ldrb	r3, [r3, #25]
 80088f4:	3301      	adds	r3, #1
 80088f6:	b2da      	uxtb	r2, r3
 80088f8:	687b      	ldr	r3, [r7, #4]
 80088fa:	765a      	strb	r2, [r3, #25]
 80088fc:	687b      	ldr	r3, [r7, #4]
 80088fe:	7e5b      	ldrb	r3, [r3, #25]
 8008900:	2b02      	cmp	r3, #2
 8008902:	d806      	bhi.n	8008912 <USBH_HandleControl+0x292>
      {
        /* Do the transmission again, starting from SETUP Packet */
        phost->Control.state = CTRL_SETUP;
 8008904:	687b      	ldr	r3, [r7, #4]
 8008906:	2201      	movs	r2, #1
 8008908:	761a      	strb	r2, [r3, #24]
        phost->RequestState = CMD_SEND;
 800890a:	687b      	ldr	r3, [r7, #4]
 800890c:	2201      	movs	r2, #1
 800890e:	709a      	strb	r2, [r3, #2]
        USBH_FreePipe(phost, phost->Control.pipe_in);

        phost->gState = HOST_IDLE;
        status = USBH_FAIL;
      }
      break;
 8008910:	e025      	b.n	800895e <USBH_HandleControl+0x2de>
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8008912:	687b      	ldr	r3, [r7, #4]
 8008914:	f8d3 33d4 	ldr.w	r3, [r3, #980]	; 0x3d4
 8008918:	2106      	movs	r1, #6
 800891a:	6878      	ldr	r0, [r7, #4]
 800891c:	4798      	blx	r3
        phost->Control.errorcount = 0U;
 800891e:	687b      	ldr	r3, [r7, #4]
 8008920:	2200      	movs	r2, #0
 8008922:	765a      	strb	r2, [r3, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8008924:	687b      	ldr	r3, [r7, #4]
 8008926:	795b      	ldrb	r3, [r3, #5]
 8008928:	4619      	mov	r1, r3
 800892a:	6878      	ldr	r0, [r7, #4]
 800892c:	f000 f90c 	bl	8008b48 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8008930:	687b      	ldr	r3, [r7, #4]
 8008932:	791b      	ldrb	r3, [r3, #4]
 8008934:	4619      	mov	r1, r3
 8008936:	6878      	ldr	r0, [r7, #4]
 8008938:	f000 f906 	bl	8008b48 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 800893c:	687b      	ldr	r3, [r7, #4]
 800893e:	2200      	movs	r2, #0
 8008940:	701a      	strb	r2, [r3, #0]
        status = USBH_FAIL;
 8008942:	2302      	movs	r3, #2
 8008944:	73fb      	strb	r3, [r7, #15]
      break;
 8008946:	e00a      	b.n	800895e <USBH_HandleControl+0x2de>

    default:
      break;
 8008948:	bf00      	nop
 800894a:	e008      	b.n	800895e <USBH_HandleControl+0x2de>
      break;
 800894c:	bf00      	nop
 800894e:	e006      	b.n	800895e <USBH_HandleControl+0x2de>
      break;
 8008950:	bf00      	nop
 8008952:	e004      	b.n	800895e <USBH_HandleControl+0x2de>
      break;
 8008954:	bf00      	nop
 8008956:	e002      	b.n	800895e <USBH_HandleControl+0x2de>
      break;
 8008958:	bf00      	nop
 800895a:	e000      	b.n	800895e <USBH_HandleControl+0x2de>
      break;
 800895c:	bf00      	nop
  }

  return status;
 800895e:	7bfb      	ldrb	r3, [r7, #15]
}
 8008960:	4618      	mov	r0, r3
 8008962:	3710      	adds	r7, #16
 8008964:	46bd      	mov	sp, r7
 8008966:	bd80      	pop	{r7, pc}

08008968 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 8008968:	b580      	push	{r7, lr}
 800896a:	b088      	sub	sp, #32
 800896c:	af04      	add	r7, sp, #16
 800896e:	60f8      	str	r0, [r7, #12]
 8008970:	60b9      	str	r1, [r7, #8]
 8008972:	4613      	mov	r3, r2
 8008974:	71fb      	strb	r3, [r7, #7]

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8008976:	79f9      	ldrb	r1, [r7, #7]
 8008978:	2300      	movs	r3, #0
 800897a:	9303      	str	r3, [sp, #12]
 800897c:	2308      	movs	r3, #8
 800897e:	9302      	str	r3, [sp, #8]
 8008980:	68bb      	ldr	r3, [r7, #8]
 8008982:	9301      	str	r3, [sp, #4]
 8008984:	2300      	movs	r3, #0
 8008986:	9300      	str	r3, [sp, #0]
 8008988:	2300      	movs	r3, #0
 800898a:	2200      	movs	r2, #0
 800898c:	68f8      	ldr	r0, [r7, #12]
 800898e:	f01f fb46 	bl	802801e <USBH_LL_SubmitURB>
                    USBH_EP_CONTROL,      /* EP type          */
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
 8008992:	2300      	movs	r3, #0
}
 8008994:	4618      	mov	r0, r3
 8008996:	3710      	adds	r7, #16
 8008998:	46bd      	mov	sp, r7
 800899a:	bd80      	pop	{r7, pc}

0800899c <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 800899c:	b580      	push	{r7, lr}
 800899e:	b088      	sub	sp, #32
 80089a0:	af04      	add	r7, sp, #16
 80089a2:	60f8      	str	r0, [r7, #12]
 80089a4:	60b9      	str	r1, [r7, #8]
 80089a6:	4611      	mov	r1, r2
 80089a8:	461a      	mov	r2, r3
 80089aa:	460b      	mov	r3, r1
 80089ac:	80fb      	strh	r3, [r7, #6]
 80089ae:	4613      	mov	r3, r2
 80089b0:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 80089b2:	68fb      	ldr	r3, [r7, #12]
 80089b4:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
 80089b8:	2b00      	cmp	r3, #0
 80089ba:	d001      	beq.n	80089c0 <USBH_CtlSendData+0x24>
  {
    do_ping = 0U;
 80089bc:	2300      	movs	r3, #0
 80089be:	763b      	strb	r3, [r7, #24]
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80089c0:	7979      	ldrb	r1, [r7, #5]
 80089c2:	7e3b      	ldrb	r3, [r7, #24]
 80089c4:	9303      	str	r3, [sp, #12]
 80089c6:	88fb      	ldrh	r3, [r7, #6]
 80089c8:	9302      	str	r3, [sp, #8]
 80089ca:	68bb      	ldr	r3, [r7, #8]
 80089cc:	9301      	str	r3, [sp, #4]
 80089ce:	2301      	movs	r3, #1
 80089d0:	9300      	str	r3, [sp, #0]
 80089d2:	2300      	movs	r3, #0
 80089d4:	2200      	movs	r2, #0
 80089d6:	68f8      	ldr	r0, [r7, #12]
 80089d8:	f01f fb21 	bl	802801e <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
 80089dc:	2300      	movs	r3, #0
}
 80089de:	4618      	mov	r0, r3
 80089e0:	3710      	adds	r7, #16
 80089e2:	46bd      	mov	sp, r7
 80089e4:	bd80      	pop	{r7, pc}

080089e6 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 80089e6:	b580      	push	{r7, lr}
 80089e8:	b088      	sub	sp, #32
 80089ea:	af04      	add	r7, sp, #16
 80089ec:	60f8      	str	r0, [r7, #12]
 80089ee:	60b9      	str	r1, [r7, #8]
 80089f0:	4611      	mov	r1, r2
 80089f2:	461a      	mov	r2, r3
 80089f4:	460b      	mov	r3, r1
 80089f6:	80fb      	strh	r3, [r7, #6]
 80089f8:	4613      	mov	r3, r2
 80089fa:	717b      	strb	r3, [r7, #5]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80089fc:	7979      	ldrb	r1, [r7, #5]
 80089fe:	2300      	movs	r3, #0
 8008a00:	9303      	str	r3, [sp, #12]
 8008a02:	88fb      	ldrh	r3, [r7, #6]
 8008a04:	9302      	str	r3, [sp, #8]
 8008a06:	68bb      	ldr	r3, [r7, #8]
 8008a08:	9301      	str	r3, [sp, #4]
 8008a0a:	2301      	movs	r3, #1
 8008a0c:	9300      	str	r3, [sp, #0]
 8008a0e:	2300      	movs	r3, #0
 8008a10:	2201      	movs	r2, #1
 8008a12:	68f8      	ldr	r0, [r7, #12]
 8008a14:	f01f fb03 	bl	802801e <USBH_LL_SubmitURB>
                    USBH_EP_CONTROL,      /* EP type          */
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
 8008a18:	2300      	movs	r3, #0

}
 8008a1a:	4618      	mov	r0, r3
 8008a1c:	3710      	adds	r7, #16
 8008a1e:	46bd      	mov	sp, r7
 8008a20:	bd80      	pop	{r7, pc}

08008a22 <USBH_BulkSendData>:
USBH_StatusTypeDef USBH_BulkSendData(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint16_t length,
                                     uint8_t pipe_num,
                                     uint8_t do_ping)
{
 8008a22:	b580      	push	{r7, lr}
 8008a24:	b088      	sub	sp, #32
 8008a26:	af04      	add	r7, sp, #16
 8008a28:	60f8      	str	r0, [r7, #12]
 8008a2a:	60b9      	str	r1, [r7, #8]
 8008a2c:	4611      	mov	r1, r2
 8008a2e:	461a      	mov	r2, r3
 8008a30:	460b      	mov	r3, r1
 8008a32:	80fb      	strh	r3, [r7, #6]
 8008a34:	4613      	mov	r3, r2
 8008a36:	717b      	strb	r3, [r7, #5]
  if (phost->device.speed != USBH_SPEED_HIGH)
 8008a38:	68fb      	ldr	r3, [r7, #12]
 8008a3a:	f893 331d 	ldrb.w	r3, [r3, #797]	; 0x31d
 8008a3e:	2b00      	cmp	r3, #0
 8008a40:	d001      	beq.n	8008a46 <USBH_BulkSendData+0x24>
  {
    do_ping = 0U;
 8008a42:	2300      	movs	r3, #0
 8008a44:	763b      	strb	r3, [r7, #24]
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8008a46:	7979      	ldrb	r1, [r7, #5]
 8008a48:	7e3b      	ldrb	r3, [r7, #24]
 8008a4a:	9303      	str	r3, [sp, #12]
 8008a4c:	88fb      	ldrh	r3, [r7, #6]
 8008a4e:	9302      	str	r3, [sp, #8]
 8008a50:	68bb      	ldr	r3, [r7, #8]
 8008a52:	9301      	str	r3, [sp, #4]
 8008a54:	2301      	movs	r3, #1
 8008a56:	9300      	str	r3, [sp, #0]
 8008a58:	2302      	movs	r3, #2
 8008a5a:	2200      	movs	r2, #0
 8008a5c:	68f8      	ldr	r0, [r7, #12]
 8008a5e:	f01f fade 	bl	802801e <USBH_LL_SubmitURB>
                    USBH_EP_BULK,         /* EP type          */
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/
  return USBH_OK;
 8008a62:	2300      	movs	r3, #0
}
 8008a64:	4618      	mov	r0, r3
 8008a66:	3710      	adds	r7, #16
 8008a68:	46bd      	mov	sp, r7
 8008a6a:	bd80      	pop	{r7, pc}

08008a6c <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 8008a6c:	b580      	push	{r7, lr}
 8008a6e:	b088      	sub	sp, #32
 8008a70:	af04      	add	r7, sp, #16
 8008a72:	60f8      	str	r0, [r7, #12]
 8008a74:	60b9      	str	r1, [r7, #8]
 8008a76:	4611      	mov	r1, r2
 8008a78:	461a      	mov	r2, r3
 8008a7a:	460b      	mov	r3, r1
 8008a7c:	80fb      	strh	r3, [r7, #6]
 8008a7e:	4613      	mov	r3, r2
 8008a80:	717b      	strb	r3, [r7, #5]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8008a82:	7979      	ldrb	r1, [r7, #5]
 8008a84:	2300      	movs	r3, #0
 8008a86:	9303      	str	r3, [sp, #12]
 8008a88:	88fb      	ldrh	r3, [r7, #6]
 8008a8a:	9302      	str	r3, [sp, #8]
 8008a8c:	68bb      	ldr	r3, [r7, #8]
 8008a8e:	9301      	str	r3, [sp, #4]
 8008a90:	2301      	movs	r3, #1
 8008a92:	9300      	str	r3, [sp, #0]
 8008a94:	2302      	movs	r3, #2
 8008a96:	2201      	movs	r2, #1
 8008a98:	68f8      	ldr	r0, [r7, #12]
 8008a9a:	f01f fac0 	bl	802801e <USBH_LL_SubmitURB>
                    USBH_EP_BULK,         /* EP type          */
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
 8008a9e:	2300      	movs	r3, #0
}
 8008aa0:	4618      	mov	r0, r3
 8008aa2:	3710      	adds	r7, #16
 8008aa4:	46bd      	mov	sp, r7
 8008aa6:	bd80      	pop	{r7, pc}

08008aa8 <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8008aa8:	b580      	push	{r7, lr}
 8008aaa:	b086      	sub	sp, #24
 8008aac:	af04      	add	r7, sp, #16
 8008aae:	6078      	str	r0, [r7, #4]
 8008ab0:	4608      	mov	r0, r1
 8008ab2:	4611      	mov	r1, r2
 8008ab4:	461a      	mov	r2, r3
 8008ab6:	4603      	mov	r3, r0
 8008ab8:	70fb      	strb	r3, [r7, #3]
 8008aba:	460b      	mov	r3, r1
 8008abc:	70bb      	strb	r3, [r7, #2]
 8008abe:	4613      	mov	r3, r2
 8008ac0:	707b      	strb	r3, [r7, #1]
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8008ac2:	7878      	ldrb	r0, [r7, #1]
 8008ac4:	78ba      	ldrb	r2, [r7, #2]
 8008ac6:	78f9      	ldrb	r1, [r7, #3]
 8008ac8:	8b3b      	ldrh	r3, [r7, #24]
 8008aca:	9302      	str	r3, [sp, #8]
 8008acc:	7d3b      	ldrb	r3, [r7, #20]
 8008ace:	9301      	str	r3, [sp, #4]
 8008ad0:	7c3b      	ldrb	r3, [r7, #16]
 8008ad2:	9300      	str	r3, [sp, #0]
 8008ad4:	4603      	mov	r3, r0
 8008ad6:	6878      	ldr	r0, [r7, #4]
 8008ad8:	f01f fa53 	bl	8027f82 <USBH_LL_OpenPipe>

  return USBH_OK;
 8008adc:	2300      	movs	r3, #0
}
 8008ade:	4618      	mov	r0, r3
 8008ae0:	3708      	adds	r7, #8
 8008ae2:	46bd      	mov	sp, r7
 8008ae4:	bd80      	pop	{r7, pc}

08008ae6 <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 8008ae6:	b580      	push	{r7, lr}
 8008ae8:	b082      	sub	sp, #8
 8008aea:	af00      	add	r7, sp, #0
 8008aec:	6078      	str	r0, [r7, #4]
 8008aee:	460b      	mov	r3, r1
 8008af0:	70fb      	strb	r3, [r7, #3]
  USBH_LL_ClosePipe(phost, pipe_num);
 8008af2:	78fb      	ldrb	r3, [r7, #3]
 8008af4:	4619      	mov	r1, r3
 8008af6:	6878      	ldr	r0, [r7, #4]
 8008af8:	f01f fa72 	bl	8027fe0 <USBH_LL_ClosePipe>

  return USBH_OK;
 8008afc:	2300      	movs	r3, #0
}
 8008afe:	4618      	mov	r0, r3
 8008b00:	3708      	adds	r7, #8
 8008b02:	46bd      	mov	sp, r7
 8008b04:	bd80      	pop	{r7, pc}

08008b06 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 8008b06:	b580      	push	{r7, lr}
 8008b08:	b084      	sub	sp, #16
 8008b0a:	af00      	add	r7, sp, #0
 8008b0c:	6078      	str	r0, [r7, #4]
 8008b0e:	460b      	mov	r3, r1
 8008b10:	70fb      	strb	r3, [r7, #3]
  uint16_t pipe;

  pipe =  USBH_GetFreePipe(phost);
 8008b12:	6878      	ldr	r0, [r7, #4]
 8008b14:	f000 f836 	bl	8008b84 <USBH_GetFreePipe>
 8008b18:	4603      	mov	r3, r0
 8008b1a:	81fb      	strh	r3, [r7, #14]

  if (pipe != 0xFFFFU)
 8008b1c:	89fb      	ldrh	r3, [r7, #14]
 8008b1e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008b22:	4293      	cmp	r3, r2
 8008b24:	d00a      	beq.n	8008b3c <USBH_AllocPipe+0x36>
  {
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
 8008b26:	78fa      	ldrb	r2, [r7, #3]
 8008b28:	89fb      	ldrh	r3, [r7, #14]
 8008b2a:	f003 030f 	and.w	r3, r3, #15
 8008b2e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8008b32:	6879      	ldr	r1, [r7, #4]
 8008b34:	33e0      	adds	r3, #224	; 0xe0
 8008b36:	009b      	lsls	r3, r3, #2
 8008b38:	440b      	add	r3, r1
 8008b3a:	605a      	str	r2, [r3, #4]
  }

  return (uint8_t)pipe;
 8008b3c:	89fb      	ldrh	r3, [r7, #14]
 8008b3e:	b2db      	uxtb	r3, r3
}
 8008b40:	4618      	mov	r0, r3
 8008b42:	3710      	adds	r7, #16
 8008b44:	46bd      	mov	sp, r7
 8008b46:	bd80      	pop	{r7, pc}

08008b48 <USBH_FreePipe>:
  * @param  phost: Host Handle
  * @param  idx: Pipe number to be freed
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_FreePipe(USBH_HandleTypeDef *phost, uint8_t idx)
{
 8008b48:	b480      	push	{r7}
 8008b4a:	b083      	sub	sp, #12
 8008b4c:	af00      	add	r7, sp, #0
 8008b4e:	6078      	str	r0, [r7, #4]
 8008b50:	460b      	mov	r3, r1
 8008b52:	70fb      	strb	r3, [r7, #3]
  if (idx < 11U)
 8008b54:	78fb      	ldrb	r3, [r7, #3]
 8008b56:	2b0a      	cmp	r3, #10
 8008b58:	d80d      	bhi.n	8008b76 <USBH_FreePipe+0x2e>
  {
    phost->Pipes[idx] &= 0x7FFFU;
 8008b5a:	78fb      	ldrb	r3, [r7, #3]
 8008b5c:	687a      	ldr	r2, [r7, #4]
 8008b5e:	33e0      	adds	r3, #224	; 0xe0
 8008b60:	009b      	lsls	r3, r3, #2
 8008b62:	4413      	add	r3, r2
 8008b64:	685a      	ldr	r2, [r3, #4]
 8008b66:	78fb      	ldrb	r3, [r7, #3]
 8008b68:	f3c2 020e 	ubfx	r2, r2, #0, #15
 8008b6c:	6879      	ldr	r1, [r7, #4]
 8008b6e:	33e0      	adds	r3, #224	; 0xe0
 8008b70:	009b      	lsls	r3, r3, #2
 8008b72:	440b      	add	r3, r1
 8008b74:	605a      	str	r2, [r3, #4]
  }

  return USBH_OK;
 8008b76:	2300      	movs	r3, #0
}
 8008b78:	4618      	mov	r0, r3
 8008b7a:	370c      	adds	r7, #12
 8008b7c:	46bd      	mov	sp, r7
 8008b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b82:	4770      	bx	lr

08008b84 <USBH_GetFreePipe>:
  * @param  phost: Host Handle
  *         Get a free Pipe number for allocation to a device endpoint
  * @retval idx: Free Pipe number
  */
static uint16_t USBH_GetFreePipe(USBH_HandleTypeDef *phost)
{
 8008b84:	b480      	push	{r7}
 8008b86:	b085      	sub	sp, #20
 8008b88:	af00      	add	r7, sp, #0
 8008b8a:	6078      	str	r0, [r7, #4]
  uint8_t idx = 0U;
 8008b8c:	2300      	movs	r3, #0
 8008b8e:	73fb      	strb	r3, [r7, #15]

  for (idx = 0U ; idx < 11U ; idx++)
 8008b90:	2300      	movs	r3, #0
 8008b92:	73fb      	strb	r3, [r7, #15]
 8008b94:	e00f      	b.n	8008bb6 <USBH_GetFreePipe+0x32>
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 8008b96:	7bfb      	ldrb	r3, [r7, #15]
 8008b98:	687a      	ldr	r2, [r7, #4]
 8008b9a:	33e0      	adds	r3, #224	; 0xe0
 8008b9c:	009b      	lsls	r3, r3, #2
 8008b9e:	4413      	add	r3, r2
 8008ba0:	685b      	ldr	r3, [r3, #4]
 8008ba2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8008ba6:	2b00      	cmp	r3, #0
 8008ba8:	d102      	bne.n	8008bb0 <USBH_GetFreePipe+0x2c>
    {
      return (uint16_t)idx;
 8008baa:	7bfb      	ldrb	r3, [r7, #15]
 8008bac:	b29b      	uxth	r3, r3
 8008bae:	e007      	b.n	8008bc0 <USBH_GetFreePipe+0x3c>
  for (idx = 0U ; idx < 11U ; idx++)
 8008bb0:	7bfb      	ldrb	r3, [r7, #15]
 8008bb2:	3301      	adds	r3, #1
 8008bb4:	73fb      	strb	r3, [r7, #15]
 8008bb6:	7bfb      	ldrb	r3, [r7, #15]
 8008bb8:	2b0a      	cmp	r3, #10
 8008bba:	d9ec      	bls.n	8008b96 <USBH_GetFreePipe+0x12>
    }
  }

  return 0xFFFFU;
 8008bbc:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 8008bc0:	4618      	mov	r0, r3
 8008bc2:	3714      	adds	r7, #20
 8008bc4:	46bd      	mov	sp, r7
 8008bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bca:	4770      	bx	lr

08008bcc <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
 8008bcc:	b580      	push	{r7, lr}
 8008bce:	b084      	sub	sp, #16
 8008bd0:	af00      	add	r7, sp, #0
 8008bd2:	4603      	mov	r3, r0
 8008bd4:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8008bd6:	79fb      	ldrb	r3, [r7, #7]
 8008bd8:	4a08      	ldr	r2, [pc, #32]	; (8008bfc <disk_status+0x30>)
 8008bda:	009b      	lsls	r3, r3, #2
 8008bdc:	4413      	add	r3, r2
 8008bde:	685b      	ldr	r3, [r3, #4]
 8008be0:	685b      	ldr	r3, [r3, #4]
 8008be2:	79fa      	ldrb	r2, [r7, #7]
 8008be4:	4905      	ldr	r1, [pc, #20]	; (8008bfc <disk_status+0x30>)
 8008be6:	440a      	add	r2, r1
 8008be8:	7a12      	ldrb	r2, [r2, #8]
 8008bea:	4610      	mov	r0, r2
 8008bec:	4798      	blx	r3
 8008bee:	4603      	mov	r3, r0
 8008bf0:	73fb      	strb	r3, [r7, #15]
  return stat;
 8008bf2:	7bfb      	ldrb	r3, [r7, #15]
}
 8008bf4:	4618      	mov	r0, r3
 8008bf6:	3710      	adds	r7, #16
 8008bf8:	46bd      	mov	sp, r7
 8008bfa:	bd80      	pop	{r7, pc}
 8008bfc:	200002dc 	.word	0x200002dc

08008c00 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 8008c00:	b580      	push	{r7, lr}
 8008c02:	b084      	sub	sp, #16
 8008c04:	af00      	add	r7, sp, #0
 8008c06:	4603      	mov	r3, r0
 8008c08:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat = RES_OK;
 8008c0a:	2300      	movs	r3, #0
 8008c0c:	73fb      	strb	r3, [r7, #15]

  if(disk.is_initialized[pdrv] == 0)
 8008c0e:	79fb      	ldrb	r3, [r7, #7]
 8008c10:	4a0d      	ldr	r2, [pc, #52]	; (8008c48 <disk_initialize+0x48>)
 8008c12:	5cd3      	ldrb	r3, [r2, r3]
 8008c14:	2b00      	cmp	r3, #0
 8008c16:	d111      	bne.n	8008c3c <disk_initialize+0x3c>
  {
    disk.is_initialized[pdrv] = 1;
 8008c18:	79fb      	ldrb	r3, [r7, #7]
 8008c1a:	4a0b      	ldr	r2, [pc, #44]	; (8008c48 <disk_initialize+0x48>)
 8008c1c:	2101      	movs	r1, #1
 8008c1e:	54d1      	strb	r1, [r2, r3]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8008c20:	79fb      	ldrb	r3, [r7, #7]
 8008c22:	4a09      	ldr	r2, [pc, #36]	; (8008c48 <disk_initialize+0x48>)
 8008c24:	009b      	lsls	r3, r3, #2
 8008c26:	4413      	add	r3, r2
 8008c28:	685b      	ldr	r3, [r3, #4]
 8008c2a:	681b      	ldr	r3, [r3, #0]
 8008c2c:	79fa      	ldrb	r2, [r7, #7]
 8008c2e:	4906      	ldr	r1, [pc, #24]	; (8008c48 <disk_initialize+0x48>)
 8008c30:	440a      	add	r2, r1
 8008c32:	7a12      	ldrb	r2, [r2, #8]
 8008c34:	4610      	mov	r0, r2
 8008c36:	4798      	blx	r3
 8008c38:	4603      	mov	r3, r0
 8008c3a:	73fb      	strb	r3, [r7, #15]
  }
  return stat;
 8008c3c:	7bfb      	ldrb	r3, [r7, #15]
}
 8008c3e:	4618      	mov	r0, r3
 8008c40:	3710      	adds	r7, #16
 8008c42:	46bd      	mov	sp, r7
 8008c44:	bd80      	pop	{r7, pc}
 8008c46:	bf00      	nop
 8008c48:	200002dc 	.word	0x200002dc

08008c4c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 8008c4c:	b590      	push	{r4, r7, lr}
 8008c4e:	b087      	sub	sp, #28
 8008c50:	af00      	add	r7, sp, #0
 8008c52:	60b9      	str	r1, [r7, #8]
 8008c54:	607a      	str	r2, [r7, #4]
 8008c56:	603b      	str	r3, [r7, #0]
 8008c58:	4603      	mov	r3, r0
 8008c5a:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8008c5c:	7bfb      	ldrb	r3, [r7, #15]
 8008c5e:	4a0a      	ldr	r2, [pc, #40]	; (8008c88 <disk_read+0x3c>)
 8008c60:	009b      	lsls	r3, r3, #2
 8008c62:	4413      	add	r3, r2
 8008c64:	685b      	ldr	r3, [r3, #4]
 8008c66:	689c      	ldr	r4, [r3, #8]
 8008c68:	7bfb      	ldrb	r3, [r7, #15]
 8008c6a:	4a07      	ldr	r2, [pc, #28]	; (8008c88 <disk_read+0x3c>)
 8008c6c:	4413      	add	r3, r2
 8008c6e:	7a18      	ldrb	r0, [r3, #8]
 8008c70:	683b      	ldr	r3, [r7, #0]
 8008c72:	687a      	ldr	r2, [r7, #4]
 8008c74:	68b9      	ldr	r1, [r7, #8]
 8008c76:	47a0      	blx	r4
 8008c78:	4603      	mov	r3, r0
 8008c7a:	75fb      	strb	r3, [r7, #23]
  return res;
 8008c7c:	7dfb      	ldrb	r3, [r7, #23]
}
 8008c7e:	4618      	mov	r0, r3
 8008c80:	371c      	adds	r7, #28
 8008c82:	46bd      	mov	sp, r7
 8008c84:	bd90      	pop	{r4, r7, pc}
 8008c86:	bf00      	nop
 8008c88:	200002dc 	.word	0x200002dc

08008c8c <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 8008c8c:	b590      	push	{r4, r7, lr}
 8008c8e:	b087      	sub	sp, #28
 8008c90:	af00      	add	r7, sp, #0
 8008c92:	60b9      	str	r1, [r7, #8]
 8008c94:	607a      	str	r2, [r7, #4]
 8008c96:	603b      	str	r3, [r7, #0]
 8008c98:	4603      	mov	r3, r0
 8008c9a:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8008c9c:	7bfb      	ldrb	r3, [r7, #15]
 8008c9e:	4a0a      	ldr	r2, [pc, #40]	; (8008cc8 <disk_write+0x3c>)
 8008ca0:	009b      	lsls	r3, r3, #2
 8008ca2:	4413      	add	r3, r2
 8008ca4:	685b      	ldr	r3, [r3, #4]
 8008ca6:	68dc      	ldr	r4, [r3, #12]
 8008ca8:	7bfb      	ldrb	r3, [r7, #15]
 8008caa:	4a07      	ldr	r2, [pc, #28]	; (8008cc8 <disk_write+0x3c>)
 8008cac:	4413      	add	r3, r2
 8008cae:	7a18      	ldrb	r0, [r3, #8]
 8008cb0:	683b      	ldr	r3, [r7, #0]
 8008cb2:	687a      	ldr	r2, [r7, #4]
 8008cb4:	68b9      	ldr	r1, [r7, #8]
 8008cb6:	47a0      	blx	r4
 8008cb8:	4603      	mov	r3, r0
 8008cba:	75fb      	strb	r3, [r7, #23]
  return res;
 8008cbc:	7dfb      	ldrb	r3, [r7, #23]
}
 8008cbe:	4618      	mov	r0, r3
 8008cc0:	371c      	adds	r7, #28
 8008cc2:	46bd      	mov	sp, r7
 8008cc4:	bd90      	pop	{r4, r7, pc}
 8008cc6:	bf00      	nop
 8008cc8:	200002dc 	.word	0x200002dc

08008ccc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 8008ccc:	b580      	push	{r7, lr}
 8008cce:	b084      	sub	sp, #16
 8008cd0:	af00      	add	r7, sp, #0
 8008cd2:	4603      	mov	r3, r0
 8008cd4:	603a      	str	r2, [r7, #0]
 8008cd6:	71fb      	strb	r3, [r7, #7]
 8008cd8:	460b      	mov	r3, r1
 8008cda:	71bb      	strb	r3, [r7, #6]
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8008cdc:	79fb      	ldrb	r3, [r7, #7]
 8008cde:	4a09      	ldr	r2, [pc, #36]	; (8008d04 <disk_ioctl+0x38>)
 8008ce0:	009b      	lsls	r3, r3, #2
 8008ce2:	4413      	add	r3, r2
 8008ce4:	685b      	ldr	r3, [r3, #4]
 8008ce6:	691b      	ldr	r3, [r3, #16]
 8008ce8:	79fa      	ldrb	r2, [r7, #7]
 8008cea:	4906      	ldr	r1, [pc, #24]	; (8008d04 <disk_ioctl+0x38>)
 8008cec:	440a      	add	r2, r1
 8008cee:	7a10      	ldrb	r0, [r2, #8]
 8008cf0:	79b9      	ldrb	r1, [r7, #6]
 8008cf2:	683a      	ldr	r2, [r7, #0]
 8008cf4:	4798      	blx	r3
 8008cf6:	4603      	mov	r3, r0
 8008cf8:	73fb      	strb	r3, [r7, #15]
  return res;
 8008cfa:	7bfb      	ldrb	r3, [r7, #15]
}
 8008cfc:	4618      	mov	r0, r3
 8008cfe:	3710      	adds	r7, #16
 8008d00:	46bd      	mov	sp, r7
 8008d02:	bd80      	pop	{r7, pc}
 8008d04:	200002dc 	.word	0x200002dc

08008d08 <ld_word>:
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static
WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
 8008d08:	b480      	push	{r7}
 8008d0a:	b085      	sub	sp, #20
 8008d0c:	af00      	add	r7, sp, #0
 8008d0e:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
 8008d10:	687b      	ldr	r3, [r7, #4]
 8008d12:	3301      	adds	r3, #1
 8008d14:	781b      	ldrb	r3, [r3, #0]
 8008d16:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
 8008d18:	89fb      	ldrh	r3, [r7, #14]
 8008d1a:	021b      	lsls	r3, r3, #8
 8008d1c:	b21a      	sxth	r2, r3
 8008d1e:	687b      	ldr	r3, [r7, #4]
 8008d20:	781b      	ldrb	r3, [r3, #0]
 8008d22:	b21b      	sxth	r3, r3
 8008d24:	4313      	orrs	r3, r2
 8008d26:	b21b      	sxth	r3, r3
 8008d28:	81fb      	strh	r3, [r7, #14]
	return rv;
 8008d2a:	89fb      	ldrh	r3, [r7, #14]
}
 8008d2c:	4618      	mov	r0, r3
 8008d2e:	3714      	adds	r7, #20
 8008d30:	46bd      	mov	sp, r7
 8008d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d36:	4770      	bx	lr

08008d38 <ld_dword>:

static
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
 8008d38:	b480      	push	{r7}
 8008d3a:	b085      	sub	sp, #20
 8008d3c:	af00      	add	r7, sp, #0
 8008d3e:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
 8008d40:	687b      	ldr	r3, [r7, #4]
 8008d42:	3303      	adds	r3, #3
 8008d44:	781b      	ldrb	r3, [r3, #0]
 8008d46:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
 8008d48:	68fb      	ldr	r3, [r7, #12]
 8008d4a:	021b      	lsls	r3, r3, #8
 8008d4c:	687a      	ldr	r2, [r7, #4]
 8008d4e:	3202      	adds	r2, #2
 8008d50:	7812      	ldrb	r2, [r2, #0]
 8008d52:	4313      	orrs	r3, r2
 8008d54:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
 8008d56:	68fb      	ldr	r3, [r7, #12]
 8008d58:	021b      	lsls	r3, r3, #8
 8008d5a:	687a      	ldr	r2, [r7, #4]
 8008d5c:	3201      	adds	r2, #1
 8008d5e:	7812      	ldrb	r2, [r2, #0]
 8008d60:	4313      	orrs	r3, r2
 8008d62:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
 8008d64:	68fb      	ldr	r3, [r7, #12]
 8008d66:	021b      	lsls	r3, r3, #8
 8008d68:	687a      	ldr	r2, [r7, #4]
 8008d6a:	7812      	ldrb	r2, [r2, #0]
 8008d6c:	4313      	orrs	r3, r2
 8008d6e:	60fb      	str	r3, [r7, #12]
	return rv;
 8008d70:	68fb      	ldr	r3, [r7, #12]
}
 8008d72:	4618      	mov	r0, r3
 8008d74:	3714      	adds	r7, #20
 8008d76:	46bd      	mov	sp, r7
 8008d78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d7c:	4770      	bx	lr

08008d7e <st_word>:
#endif

#if !_FS_READONLY
static
void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
 8008d7e:	b480      	push	{r7}
 8008d80:	b083      	sub	sp, #12
 8008d82:	af00      	add	r7, sp, #0
 8008d84:	6078      	str	r0, [r7, #4]
 8008d86:	460b      	mov	r3, r1
 8008d88:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 8008d8a:	687b      	ldr	r3, [r7, #4]
 8008d8c:	1c5a      	adds	r2, r3, #1
 8008d8e:	607a      	str	r2, [r7, #4]
 8008d90:	887a      	ldrh	r2, [r7, #2]
 8008d92:	b2d2      	uxtb	r2, r2
 8008d94:	701a      	strb	r2, [r3, #0]
 8008d96:	887b      	ldrh	r3, [r7, #2]
 8008d98:	0a1b      	lsrs	r3, r3, #8
 8008d9a:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
 8008d9c:	687b      	ldr	r3, [r7, #4]
 8008d9e:	1c5a      	adds	r2, r3, #1
 8008da0:	607a      	str	r2, [r7, #4]
 8008da2:	887a      	ldrh	r2, [r7, #2]
 8008da4:	b2d2      	uxtb	r2, r2
 8008da6:	701a      	strb	r2, [r3, #0]
}
 8008da8:	bf00      	nop
 8008daa:	370c      	adds	r7, #12
 8008dac:	46bd      	mov	sp, r7
 8008dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008db2:	4770      	bx	lr

08008db4 <st_dword>:

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
 8008db4:	b480      	push	{r7}
 8008db6:	b083      	sub	sp, #12
 8008db8:	af00      	add	r7, sp, #0
 8008dba:	6078      	str	r0, [r7, #4]
 8008dbc:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8008dbe:	687b      	ldr	r3, [r7, #4]
 8008dc0:	1c5a      	adds	r2, r3, #1
 8008dc2:	607a      	str	r2, [r7, #4]
 8008dc4:	683a      	ldr	r2, [r7, #0]
 8008dc6:	b2d2      	uxtb	r2, r2
 8008dc8:	701a      	strb	r2, [r3, #0]
 8008dca:	683b      	ldr	r3, [r7, #0]
 8008dcc:	0a1b      	lsrs	r3, r3, #8
 8008dce:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8008dd0:	687b      	ldr	r3, [r7, #4]
 8008dd2:	1c5a      	adds	r2, r3, #1
 8008dd4:	607a      	str	r2, [r7, #4]
 8008dd6:	683a      	ldr	r2, [r7, #0]
 8008dd8:	b2d2      	uxtb	r2, r2
 8008dda:	701a      	strb	r2, [r3, #0]
 8008ddc:	683b      	ldr	r3, [r7, #0]
 8008dde:	0a1b      	lsrs	r3, r3, #8
 8008de0:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8008de2:	687b      	ldr	r3, [r7, #4]
 8008de4:	1c5a      	adds	r2, r3, #1
 8008de6:	607a      	str	r2, [r7, #4]
 8008de8:	683a      	ldr	r2, [r7, #0]
 8008dea:	b2d2      	uxtb	r2, r2
 8008dec:	701a      	strb	r2, [r3, #0]
 8008dee:	683b      	ldr	r3, [r7, #0]
 8008df0:	0a1b      	lsrs	r3, r3, #8
 8008df2:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
 8008df4:	687b      	ldr	r3, [r7, #4]
 8008df6:	1c5a      	adds	r2, r3, #1
 8008df8:	607a      	str	r2, [r7, #4]
 8008dfa:	683a      	ldr	r2, [r7, #0]
 8008dfc:	b2d2      	uxtb	r2, r2
 8008dfe:	701a      	strb	r2, [r3, #0]
}
 8008e00:	bf00      	nop
 8008e02:	370c      	adds	r7, #12
 8008e04:	46bd      	mov	sp, r7
 8008e06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e0a:	4770      	bx	lr

08008e0c <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 8008e0c:	b480      	push	{r7}
 8008e0e:	b087      	sub	sp, #28
 8008e10:	af00      	add	r7, sp, #0
 8008e12:	60f8      	str	r0, [r7, #12]
 8008e14:	60b9      	str	r1, [r7, #8]
 8008e16:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 8008e18:	68fb      	ldr	r3, [r7, #12]
 8008e1a:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 8008e1c:	68bb      	ldr	r3, [r7, #8]
 8008e1e:	613b      	str	r3, [r7, #16]

	if (cnt) {
 8008e20:	687b      	ldr	r3, [r7, #4]
 8008e22:	2b00      	cmp	r3, #0
 8008e24:	d00d      	beq.n	8008e42 <mem_cpy+0x36>
		do {
			*d++ = *s++;
 8008e26:	693a      	ldr	r2, [r7, #16]
 8008e28:	1c53      	adds	r3, r2, #1
 8008e2a:	613b      	str	r3, [r7, #16]
 8008e2c:	697b      	ldr	r3, [r7, #20]
 8008e2e:	1c59      	adds	r1, r3, #1
 8008e30:	6179      	str	r1, [r7, #20]
 8008e32:	7812      	ldrb	r2, [r2, #0]
 8008e34:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
 8008e36:	687b      	ldr	r3, [r7, #4]
 8008e38:	3b01      	subs	r3, #1
 8008e3a:	607b      	str	r3, [r7, #4]
 8008e3c:	687b      	ldr	r3, [r7, #4]
 8008e3e:	2b00      	cmp	r3, #0
 8008e40:	d1f1      	bne.n	8008e26 <mem_cpy+0x1a>
	}
}
 8008e42:	bf00      	nop
 8008e44:	371c      	adds	r7, #28
 8008e46:	46bd      	mov	sp, r7
 8008e48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e4c:	4770      	bx	lr

08008e4e <mem_set>:

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
 8008e4e:	b480      	push	{r7}
 8008e50:	b087      	sub	sp, #28
 8008e52:	af00      	add	r7, sp, #0
 8008e54:	60f8      	str	r0, [r7, #12]
 8008e56:	60b9      	str	r1, [r7, #8]
 8008e58:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 8008e5a:	68fb      	ldr	r3, [r7, #12]
 8008e5c:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
 8008e5e:	697b      	ldr	r3, [r7, #20]
 8008e60:	1c5a      	adds	r2, r3, #1
 8008e62:	617a      	str	r2, [r7, #20]
 8008e64:	68ba      	ldr	r2, [r7, #8]
 8008e66:	b2d2      	uxtb	r2, r2
 8008e68:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
 8008e6a:	687b      	ldr	r3, [r7, #4]
 8008e6c:	3b01      	subs	r3, #1
 8008e6e:	607b      	str	r3, [r7, #4]
 8008e70:	687b      	ldr	r3, [r7, #4]
 8008e72:	2b00      	cmp	r3, #0
 8008e74:	d1f3      	bne.n	8008e5e <mem_set+0x10>
}
 8008e76:	bf00      	nop
 8008e78:	bf00      	nop
 8008e7a:	371c      	adds	r7, #28
 8008e7c:	46bd      	mov	sp, r7
 8008e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e82:	4770      	bx	lr

08008e84 <mem_cmp>:

/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
 8008e84:	b480      	push	{r7}
 8008e86:	b089      	sub	sp, #36	; 0x24
 8008e88:	af00      	add	r7, sp, #0
 8008e8a:	60f8      	str	r0, [r7, #12]
 8008e8c:	60b9      	str	r1, [r7, #8]
 8008e8e:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 8008e90:	68fb      	ldr	r3, [r7, #12]
 8008e92:	61fb      	str	r3, [r7, #28]
 8008e94:	68bb      	ldr	r3, [r7, #8]
 8008e96:	61bb      	str	r3, [r7, #24]
	int r = 0;
 8008e98:	2300      	movs	r3, #0
 8008e9a:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
 8008e9c:	69fb      	ldr	r3, [r7, #28]
 8008e9e:	1c5a      	adds	r2, r3, #1
 8008ea0:	61fa      	str	r2, [r7, #28]
 8008ea2:	781b      	ldrb	r3, [r3, #0]
 8008ea4:	4619      	mov	r1, r3
 8008ea6:	69bb      	ldr	r3, [r7, #24]
 8008ea8:	1c5a      	adds	r2, r3, #1
 8008eaa:	61ba      	str	r2, [r7, #24]
 8008eac:	781b      	ldrb	r3, [r3, #0]
 8008eae:	1acb      	subs	r3, r1, r3
 8008eb0:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
 8008eb2:	687b      	ldr	r3, [r7, #4]
 8008eb4:	3b01      	subs	r3, #1
 8008eb6:	607b      	str	r3, [r7, #4]
 8008eb8:	687b      	ldr	r3, [r7, #4]
 8008eba:	2b00      	cmp	r3, #0
 8008ebc:	d002      	beq.n	8008ec4 <mem_cmp+0x40>
 8008ebe:	697b      	ldr	r3, [r7, #20]
 8008ec0:	2b00      	cmp	r3, #0
 8008ec2:	d0eb      	beq.n	8008e9c <mem_cmp+0x18>

	return r;
 8008ec4:	697b      	ldr	r3, [r7, #20]
}
 8008ec6:	4618      	mov	r0, r3
 8008ec8:	3724      	adds	r7, #36	; 0x24
 8008eca:	46bd      	mov	sp, r7
 8008ecc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ed0:	4770      	bx	lr

08008ed2 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
 8008ed2:	b480      	push	{r7}
 8008ed4:	b083      	sub	sp, #12
 8008ed6:	af00      	add	r7, sp, #0
 8008ed8:	6078      	str	r0, [r7, #4]
 8008eda:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 8008edc:	e002      	b.n	8008ee4 <chk_chr+0x12>
 8008ede:	687b      	ldr	r3, [r7, #4]
 8008ee0:	3301      	adds	r3, #1
 8008ee2:	607b      	str	r3, [r7, #4]
 8008ee4:	687b      	ldr	r3, [r7, #4]
 8008ee6:	781b      	ldrb	r3, [r3, #0]
 8008ee8:	2b00      	cmp	r3, #0
 8008eea:	d005      	beq.n	8008ef8 <chk_chr+0x26>
 8008eec:	687b      	ldr	r3, [r7, #4]
 8008eee:	781b      	ldrb	r3, [r3, #0]
 8008ef0:	461a      	mov	r2, r3
 8008ef2:	683b      	ldr	r3, [r7, #0]
 8008ef4:	4293      	cmp	r3, r2
 8008ef6:	d1f2      	bne.n	8008ede <chk_chr+0xc>
	return *str;
 8008ef8:	687b      	ldr	r3, [r7, #4]
 8008efa:	781b      	ldrb	r3, [r3, #0]
}
 8008efc:	4618      	mov	r0, r3
 8008efe:	370c      	adds	r7, #12
 8008f00:	46bd      	mov	sp, r7
 8008f02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f06:	4770      	bx	lr

08008f08 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8008f08:	b480      	push	{r7}
 8008f0a:	b085      	sub	sp, #20
 8008f0c:	af00      	add	r7, sp, #0
 8008f0e:	6078      	str	r0, [r7, #4]
 8008f10:	6039      	str	r1, [r7, #0]
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 8008f12:	2300      	movs	r3, #0
 8008f14:	60bb      	str	r3, [r7, #8]
 8008f16:	68bb      	ldr	r3, [r7, #8]
 8008f18:	60fb      	str	r3, [r7, #12]
 8008f1a:	e029      	b.n	8008f70 <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
 8008f1c:	4a27      	ldr	r2, [pc, #156]	; (8008fbc <chk_lock+0xb4>)
 8008f1e:	68fb      	ldr	r3, [r7, #12]
 8008f20:	011b      	lsls	r3, r3, #4
 8008f22:	4413      	add	r3, r2
 8008f24:	681b      	ldr	r3, [r3, #0]
 8008f26:	2b00      	cmp	r3, #0
 8008f28:	d01d      	beq.n	8008f66 <chk_lock+0x5e>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8008f2a:	4a24      	ldr	r2, [pc, #144]	; (8008fbc <chk_lock+0xb4>)
 8008f2c:	68fb      	ldr	r3, [r7, #12]
 8008f2e:	011b      	lsls	r3, r3, #4
 8008f30:	4413      	add	r3, r2
 8008f32:	681a      	ldr	r2, [r3, #0]
 8008f34:	687b      	ldr	r3, [r7, #4]
 8008f36:	681b      	ldr	r3, [r3, #0]
 8008f38:	429a      	cmp	r2, r3
 8008f3a:	d116      	bne.n	8008f6a <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
 8008f3c:	4a1f      	ldr	r2, [pc, #124]	; (8008fbc <chk_lock+0xb4>)
 8008f3e:	68fb      	ldr	r3, [r7, #12]
 8008f40:	011b      	lsls	r3, r3, #4
 8008f42:	4413      	add	r3, r2
 8008f44:	3304      	adds	r3, #4
 8008f46:	681a      	ldr	r2, [r3, #0]
 8008f48:	687b      	ldr	r3, [r7, #4]
 8008f4a:	689b      	ldr	r3, [r3, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8008f4c:	429a      	cmp	r2, r3
 8008f4e:	d10c      	bne.n	8008f6a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 8008f50:	4a1a      	ldr	r2, [pc, #104]	; (8008fbc <chk_lock+0xb4>)
 8008f52:	68fb      	ldr	r3, [r7, #12]
 8008f54:	011b      	lsls	r3, r3, #4
 8008f56:	4413      	add	r3, r2
 8008f58:	3308      	adds	r3, #8
 8008f5a:	681a      	ldr	r2, [r3, #0]
 8008f5c:	687b      	ldr	r3, [r7, #4]
 8008f5e:	695b      	ldr	r3, [r3, #20]
				Files[i].clu == dp->obj.sclust &&
 8008f60:	429a      	cmp	r2, r3
 8008f62:	d102      	bne.n	8008f6a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 8008f64:	e007      	b.n	8008f76 <chk_lock+0x6e>
		} else {			/* Blank entry */
			be = 1;
 8008f66:	2301      	movs	r3, #1
 8008f68:	60bb      	str	r3, [r7, #8]
	for (i = be = 0; i < _FS_LOCK; i++) {
 8008f6a:	68fb      	ldr	r3, [r7, #12]
 8008f6c:	3301      	adds	r3, #1
 8008f6e:	60fb      	str	r3, [r7, #12]
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	2b01      	cmp	r3, #1
 8008f74:	d9d2      	bls.n	8008f1c <chk_lock+0x14>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
 8008f76:	68fb      	ldr	r3, [r7, #12]
 8008f78:	2b02      	cmp	r3, #2
 8008f7a:	d109      	bne.n	8008f90 <chk_lock+0x88>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8008f7c:	68bb      	ldr	r3, [r7, #8]
 8008f7e:	2b00      	cmp	r3, #0
 8008f80:	d102      	bne.n	8008f88 <chk_lock+0x80>
 8008f82:	683b      	ldr	r3, [r7, #0]
 8008f84:	2b02      	cmp	r3, #2
 8008f86:	d101      	bne.n	8008f8c <chk_lock+0x84>
 8008f88:	2300      	movs	r3, #0
 8008f8a:	e010      	b.n	8008fae <chk_lock+0xa6>
 8008f8c:	2312      	movs	r3, #18
 8008f8e:	e00e      	b.n	8008fae <chk_lock+0xa6>
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8008f90:	683b      	ldr	r3, [r7, #0]
 8008f92:	2b00      	cmp	r3, #0
 8008f94:	d108      	bne.n	8008fa8 <chk_lock+0xa0>
 8008f96:	4a09      	ldr	r2, [pc, #36]	; (8008fbc <chk_lock+0xb4>)
 8008f98:	68fb      	ldr	r3, [r7, #12]
 8008f9a:	011b      	lsls	r3, r3, #4
 8008f9c:	4413      	add	r3, r2
 8008f9e:	330c      	adds	r3, #12
 8008fa0:	881b      	ldrh	r3, [r3, #0]
 8008fa2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008fa6:	d101      	bne.n	8008fac <chk_lock+0xa4>
 8008fa8:	2310      	movs	r3, #16
 8008faa:	e000      	b.n	8008fae <chk_lock+0xa6>
 8008fac:	2300      	movs	r3, #0
}
 8008fae:	4618      	mov	r0, r3
 8008fb0:	3714      	adds	r7, #20
 8008fb2:	46bd      	mov	sp, r7
 8008fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008fb8:	4770      	bx	lr
 8008fba:	bf00      	nop
 8008fbc:	200000bc 	.word	0x200000bc

08008fc0 <enq_lock>:


static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
 8008fc0:	b480      	push	{r7}
 8008fc2:	b083      	sub	sp, #12
 8008fc4:	af00      	add	r7, sp, #0
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8008fc6:	2300      	movs	r3, #0
 8008fc8:	607b      	str	r3, [r7, #4]
 8008fca:	e002      	b.n	8008fd2 <enq_lock+0x12>
 8008fcc:	687b      	ldr	r3, [r7, #4]
 8008fce:	3301      	adds	r3, #1
 8008fd0:	607b      	str	r3, [r7, #4]
 8008fd2:	687b      	ldr	r3, [r7, #4]
 8008fd4:	2b01      	cmp	r3, #1
 8008fd6:	d806      	bhi.n	8008fe6 <enq_lock+0x26>
 8008fd8:	4a09      	ldr	r2, [pc, #36]	; (8009000 <enq_lock+0x40>)
 8008fda:	687b      	ldr	r3, [r7, #4]
 8008fdc:	011b      	lsls	r3, r3, #4
 8008fde:	4413      	add	r3, r2
 8008fe0:	681b      	ldr	r3, [r3, #0]
 8008fe2:	2b00      	cmp	r3, #0
 8008fe4:	d1f2      	bne.n	8008fcc <enq_lock+0xc>
	return (i == _FS_LOCK) ? 0 : 1;
 8008fe6:	687b      	ldr	r3, [r7, #4]
 8008fe8:	2b02      	cmp	r3, #2
 8008fea:	bf14      	ite	ne
 8008fec:	2301      	movne	r3, #1
 8008fee:	2300      	moveq	r3, #0
 8008ff0:	b2db      	uxtb	r3, r3
}
 8008ff2:	4618      	mov	r0, r3
 8008ff4:	370c      	adds	r7, #12
 8008ff6:	46bd      	mov	sp, r7
 8008ff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ffc:	4770      	bx	lr
 8008ffe:	bf00      	nop
 8009000:	200000bc 	.word	0x200000bc

08009004 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8009004:	b480      	push	{r7}
 8009006:	b085      	sub	sp, #20
 8009008:	af00      	add	r7, sp, #0
 800900a:	6078      	str	r0, [r7, #4]
 800900c:	6039      	str	r1, [r7, #0]
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800900e:	2300      	movs	r3, #0
 8009010:	60fb      	str	r3, [r7, #12]
 8009012:	e01f      	b.n	8009054 <inc_lock+0x50>
		if (Files[i].fs == dp->obj.fs &&
 8009014:	4a41      	ldr	r2, [pc, #260]	; (800911c <inc_lock+0x118>)
 8009016:	68fb      	ldr	r3, [r7, #12]
 8009018:	011b      	lsls	r3, r3, #4
 800901a:	4413      	add	r3, r2
 800901c:	681a      	ldr	r2, [r3, #0]
 800901e:	687b      	ldr	r3, [r7, #4]
 8009020:	681b      	ldr	r3, [r3, #0]
 8009022:	429a      	cmp	r2, r3
 8009024:	d113      	bne.n	800904e <inc_lock+0x4a>
			Files[i].clu == dp->obj.sclust &&
 8009026:	4a3d      	ldr	r2, [pc, #244]	; (800911c <inc_lock+0x118>)
 8009028:	68fb      	ldr	r3, [r7, #12]
 800902a:	011b      	lsls	r3, r3, #4
 800902c:	4413      	add	r3, r2
 800902e:	3304      	adds	r3, #4
 8009030:	681a      	ldr	r2, [r3, #0]
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	689b      	ldr	r3, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
 8009036:	429a      	cmp	r2, r3
 8009038:	d109      	bne.n	800904e <inc_lock+0x4a>
			Files[i].ofs == dp->dptr) break;
 800903a:	4a38      	ldr	r2, [pc, #224]	; (800911c <inc_lock+0x118>)
 800903c:	68fb      	ldr	r3, [r7, #12]
 800903e:	011b      	lsls	r3, r3, #4
 8009040:	4413      	add	r3, r2
 8009042:	3308      	adds	r3, #8
 8009044:	681a      	ldr	r2, [r3, #0]
 8009046:	687b      	ldr	r3, [r7, #4]
 8009048:	695b      	ldr	r3, [r3, #20]
			Files[i].clu == dp->obj.sclust &&
 800904a:	429a      	cmp	r2, r3
 800904c:	d006      	beq.n	800905c <inc_lock+0x58>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800904e:	68fb      	ldr	r3, [r7, #12]
 8009050:	3301      	adds	r3, #1
 8009052:	60fb      	str	r3, [r7, #12]
 8009054:	68fb      	ldr	r3, [r7, #12]
 8009056:	2b01      	cmp	r3, #1
 8009058:	d9dc      	bls.n	8009014 <inc_lock+0x10>
 800905a:	e000      	b.n	800905e <inc_lock+0x5a>
			Files[i].ofs == dp->dptr) break;
 800905c:	bf00      	nop
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 800905e:	68fb      	ldr	r3, [r7, #12]
 8009060:	2b02      	cmp	r3, #2
 8009062:	d132      	bne.n	80090ca <inc_lock+0xc6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8009064:	2300      	movs	r3, #0
 8009066:	60fb      	str	r3, [r7, #12]
 8009068:	e002      	b.n	8009070 <inc_lock+0x6c>
 800906a:	68fb      	ldr	r3, [r7, #12]
 800906c:	3301      	adds	r3, #1
 800906e:	60fb      	str	r3, [r7, #12]
 8009070:	68fb      	ldr	r3, [r7, #12]
 8009072:	2b01      	cmp	r3, #1
 8009074:	d806      	bhi.n	8009084 <inc_lock+0x80>
 8009076:	4a29      	ldr	r2, [pc, #164]	; (800911c <inc_lock+0x118>)
 8009078:	68fb      	ldr	r3, [r7, #12]
 800907a:	011b      	lsls	r3, r3, #4
 800907c:	4413      	add	r3, r2
 800907e:	681b      	ldr	r3, [r3, #0]
 8009080:	2b00      	cmp	r3, #0
 8009082:	d1f2      	bne.n	800906a <inc_lock+0x66>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8009084:	68fb      	ldr	r3, [r7, #12]
 8009086:	2b02      	cmp	r3, #2
 8009088:	d101      	bne.n	800908e <inc_lock+0x8a>
 800908a:	2300      	movs	r3, #0
 800908c:	e040      	b.n	8009110 <inc_lock+0x10c>
		Files[i].fs = dp->obj.fs;
 800908e:	687b      	ldr	r3, [r7, #4]
 8009090:	681a      	ldr	r2, [r3, #0]
 8009092:	4922      	ldr	r1, [pc, #136]	; (800911c <inc_lock+0x118>)
 8009094:	68fb      	ldr	r3, [r7, #12]
 8009096:	011b      	lsls	r3, r3, #4
 8009098:	440b      	add	r3, r1
 800909a:	601a      	str	r2, [r3, #0]
		Files[i].clu = dp->obj.sclust;
 800909c:	687b      	ldr	r3, [r7, #4]
 800909e:	689a      	ldr	r2, [r3, #8]
 80090a0:	491e      	ldr	r1, [pc, #120]	; (800911c <inc_lock+0x118>)
 80090a2:	68fb      	ldr	r3, [r7, #12]
 80090a4:	011b      	lsls	r3, r3, #4
 80090a6:	440b      	add	r3, r1
 80090a8:	3304      	adds	r3, #4
 80090aa:	601a      	str	r2, [r3, #0]
		Files[i].ofs = dp->dptr;
 80090ac:	687b      	ldr	r3, [r7, #4]
 80090ae:	695a      	ldr	r2, [r3, #20]
 80090b0:	491a      	ldr	r1, [pc, #104]	; (800911c <inc_lock+0x118>)
 80090b2:	68fb      	ldr	r3, [r7, #12]
 80090b4:	011b      	lsls	r3, r3, #4
 80090b6:	440b      	add	r3, r1
 80090b8:	3308      	adds	r3, #8
 80090ba:	601a      	str	r2, [r3, #0]
		Files[i].ctr = 0;
 80090bc:	4a17      	ldr	r2, [pc, #92]	; (800911c <inc_lock+0x118>)
 80090be:	68fb      	ldr	r3, [r7, #12]
 80090c0:	011b      	lsls	r3, r3, #4
 80090c2:	4413      	add	r3, r2
 80090c4:	330c      	adds	r3, #12
 80090c6:	2200      	movs	r2, #0
 80090c8:	801a      	strh	r2, [r3, #0]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80090ca:	683b      	ldr	r3, [r7, #0]
 80090cc:	2b00      	cmp	r3, #0
 80090ce:	d009      	beq.n	80090e4 <inc_lock+0xe0>
 80090d0:	4a12      	ldr	r2, [pc, #72]	; (800911c <inc_lock+0x118>)
 80090d2:	68fb      	ldr	r3, [r7, #12]
 80090d4:	011b      	lsls	r3, r3, #4
 80090d6:	4413      	add	r3, r2
 80090d8:	330c      	adds	r3, #12
 80090da:	881b      	ldrh	r3, [r3, #0]
 80090dc:	2b00      	cmp	r3, #0
 80090de:	d001      	beq.n	80090e4 <inc_lock+0xe0>
 80090e0:	2300      	movs	r3, #0
 80090e2:	e015      	b.n	8009110 <inc_lock+0x10c>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80090e4:	683b      	ldr	r3, [r7, #0]
 80090e6:	2b00      	cmp	r3, #0
 80090e8:	d108      	bne.n	80090fc <inc_lock+0xf8>
 80090ea:	4a0c      	ldr	r2, [pc, #48]	; (800911c <inc_lock+0x118>)
 80090ec:	68fb      	ldr	r3, [r7, #12]
 80090ee:	011b      	lsls	r3, r3, #4
 80090f0:	4413      	add	r3, r2
 80090f2:	330c      	adds	r3, #12
 80090f4:	881b      	ldrh	r3, [r3, #0]
 80090f6:	3301      	adds	r3, #1
 80090f8:	b29a      	uxth	r2, r3
 80090fa:	e001      	b.n	8009100 <inc_lock+0xfc>
 80090fc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8009100:	4906      	ldr	r1, [pc, #24]	; (800911c <inc_lock+0x118>)
 8009102:	68fb      	ldr	r3, [r7, #12]
 8009104:	011b      	lsls	r3, r3, #4
 8009106:	440b      	add	r3, r1
 8009108:	330c      	adds	r3, #12
 800910a:	801a      	strh	r2, [r3, #0]

	return i + 1;
 800910c:	68fb      	ldr	r3, [r7, #12]
 800910e:	3301      	adds	r3, #1
}
 8009110:	4618      	mov	r0, r3
 8009112:	3714      	adds	r7, #20
 8009114:	46bd      	mov	sp, r7
 8009116:	f85d 7b04 	ldr.w	r7, [sp], #4
 800911a:	4770      	bx	lr
 800911c:	200000bc 	.word	0x200000bc

08009120 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
 8009120:	b480      	push	{r7}
 8009122:	b085      	sub	sp, #20
 8009124:	af00      	add	r7, sp, #0
 8009126:	6078      	str	r0, [r7, #4]
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8009128:	687b      	ldr	r3, [r7, #4]
 800912a:	3b01      	subs	r3, #1
 800912c:	607b      	str	r3, [r7, #4]
 800912e:	687b      	ldr	r3, [r7, #4]
 8009130:	2b01      	cmp	r3, #1
 8009132:	d825      	bhi.n	8009180 <dec_lock+0x60>
		n = Files[i].ctr;
 8009134:	4a17      	ldr	r2, [pc, #92]	; (8009194 <dec_lock+0x74>)
 8009136:	687b      	ldr	r3, [r7, #4]
 8009138:	011b      	lsls	r3, r3, #4
 800913a:	4413      	add	r3, r2
 800913c:	330c      	adds	r3, #12
 800913e:	881b      	ldrh	r3, [r3, #0]
 8009140:	81fb      	strh	r3, [r7, #14]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8009142:	89fb      	ldrh	r3, [r7, #14]
 8009144:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009148:	d101      	bne.n	800914e <dec_lock+0x2e>
 800914a:	2300      	movs	r3, #0
 800914c:	81fb      	strh	r3, [r7, #14]
		if (n > 0) n--;				/* Decrement read mode open count */
 800914e:	89fb      	ldrh	r3, [r7, #14]
 8009150:	2b00      	cmp	r3, #0
 8009152:	d002      	beq.n	800915a <dec_lock+0x3a>
 8009154:	89fb      	ldrh	r3, [r7, #14]
 8009156:	3b01      	subs	r3, #1
 8009158:	81fb      	strh	r3, [r7, #14]
		Files[i].ctr = n;
 800915a:	4a0e      	ldr	r2, [pc, #56]	; (8009194 <dec_lock+0x74>)
 800915c:	687b      	ldr	r3, [r7, #4]
 800915e:	011b      	lsls	r3, r3, #4
 8009160:	4413      	add	r3, r2
 8009162:	330c      	adds	r3, #12
 8009164:	89fa      	ldrh	r2, [r7, #14]
 8009166:	801a      	strh	r2, [r3, #0]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8009168:	89fb      	ldrh	r3, [r7, #14]
 800916a:	2b00      	cmp	r3, #0
 800916c:	d105      	bne.n	800917a <dec_lock+0x5a>
 800916e:	4a09      	ldr	r2, [pc, #36]	; (8009194 <dec_lock+0x74>)
 8009170:	687b      	ldr	r3, [r7, #4]
 8009172:	011b      	lsls	r3, r3, #4
 8009174:	4413      	add	r3, r2
 8009176:	2200      	movs	r2, #0
 8009178:	601a      	str	r2, [r3, #0]
		res = FR_OK;
 800917a:	2300      	movs	r3, #0
 800917c:	737b      	strb	r3, [r7, #13]
 800917e:	e001      	b.n	8009184 <dec_lock+0x64>
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 8009180:	2302      	movs	r3, #2
 8009182:	737b      	strb	r3, [r7, #13]
	}
	return res;
 8009184:	7b7b      	ldrb	r3, [r7, #13]
}
 8009186:	4618      	mov	r0, r3
 8009188:	3714      	adds	r7, #20
 800918a:	46bd      	mov	sp, r7
 800918c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009190:	4770      	bx	lr
 8009192:	bf00      	nop
 8009194:	200000bc 	.word	0x200000bc

08009198 <clear_lock>:

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
 8009198:	b480      	push	{r7}
 800919a:	b085      	sub	sp, #20
 800919c:	af00      	add	r7, sp, #0
 800919e:	6078      	str	r0, [r7, #4]
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 80091a0:	2300      	movs	r3, #0
 80091a2:	60fb      	str	r3, [r7, #12]
 80091a4:	e010      	b.n	80091c8 <clear_lock+0x30>
		if (Files[i].fs == fs) Files[i].fs = 0;
 80091a6:	4a0d      	ldr	r2, [pc, #52]	; (80091dc <clear_lock+0x44>)
 80091a8:	68fb      	ldr	r3, [r7, #12]
 80091aa:	011b      	lsls	r3, r3, #4
 80091ac:	4413      	add	r3, r2
 80091ae:	681b      	ldr	r3, [r3, #0]
 80091b0:	687a      	ldr	r2, [r7, #4]
 80091b2:	429a      	cmp	r2, r3
 80091b4:	d105      	bne.n	80091c2 <clear_lock+0x2a>
 80091b6:	4a09      	ldr	r2, [pc, #36]	; (80091dc <clear_lock+0x44>)
 80091b8:	68fb      	ldr	r3, [r7, #12]
 80091ba:	011b      	lsls	r3, r3, #4
 80091bc:	4413      	add	r3, r2
 80091be:	2200      	movs	r2, #0
 80091c0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < _FS_LOCK; i++) {
 80091c2:	68fb      	ldr	r3, [r7, #12]
 80091c4:	3301      	adds	r3, #1
 80091c6:	60fb      	str	r3, [r7, #12]
 80091c8:	68fb      	ldr	r3, [r7, #12]
 80091ca:	2b01      	cmp	r3, #1
 80091cc:	d9eb      	bls.n	80091a6 <clear_lock+0xe>
	}
}
 80091ce:	bf00      	nop
 80091d0:	bf00      	nop
 80091d2:	3714      	adds	r7, #20
 80091d4:	46bd      	mov	sp, r7
 80091d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091da:	4770      	bx	lr
 80091dc:	200000bc 	.word	0x200000bc

080091e0 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs			/* File system object */
)
{
 80091e0:	b580      	push	{r7, lr}
 80091e2:	b086      	sub	sp, #24
 80091e4:	af00      	add	r7, sp, #0
 80091e6:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 80091e8:	2300      	movs	r3, #0
 80091ea:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80091ec:	687b      	ldr	r3, [r7, #4]
 80091ee:	78db      	ldrb	r3, [r3, #3]
 80091f0:	2b00      	cmp	r3, #0
 80091f2:	d034      	beq.n	800925e <sync_window+0x7e>
		wsect = fs->winsect;	/* Current sector number */
 80091f4:	687b      	ldr	r3, [r7, #4]
 80091f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80091f8:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80091fa:	687b      	ldr	r3, [r7, #4]
 80091fc:	7858      	ldrb	r0, [r3, #1]
 80091fe:	687b      	ldr	r3, [r7, #4]
 8009200:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8009204:	2301      	movs	r3, #1
 8009206:	697a      	ldr	r2, [r7, #20]
 8009208:	f7ff fd40 	bl	8008c8c <disk_write>
 800920c:	4603      	mov	r3, r0
 800920e:	2b00      	cmp	r3, #0
 8009210:	d002      	beq.n	8009218 <sync_window+0x38>
			res = FR_DISK_ERR;
 8009212:	2301      	movs	r3, #1
 8009214:	73fb      	strb	r3, [r7, #15]
 8009216:	e022      	b.n	800925e <sync_window+0x7e>
		} else {
			fs->wflag = 0;
 8009218:	687b      	ldr	r3, [r7, #4]
 800921a:	2200      	movs	r2, #0
 800921c:	70da      	strb	r2, [r3, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800921e:	687b      	ldr	r3, [r7, #4]
 8009220:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009222:	697a      	ldr	r2, [r7, #20]
 8009224:	1ad2      	subs	r2, r2, r3
 8009226:	687b      	ldr	r3, [r7, #4]
 8009228:	69db      	ldr	r3, [r3, #28]
 800922a:	429a      	cmp	r2, r3
 800922c:	d217      	bcs.n	800925e <sync_window+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800922e:	687b      	ldr	r3, [r7, #4]
 8009230:	789b      	ldrb	r3, [r3, #2]
 8009232:	613b      	str	r3, [r7, #16]
 8009234:	e010      	b.n	8009258 <sync_window+0x78>
					wsect += fs->fsize;
 8009236:	687b      	ldr	r3, [r7, #4]
 8009238:	69db      	ldr	r3, [r3, #28]
 800923a:	697a      	ldr	r2, [r7, #20]
 800923c:	4413      	add	r3, r2
 800923e:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	7858      	ldrb	r0, [r3, #1]
 8009244:	687b      	ldr	r3, [r7, #4]
 8009246:	f103 0134 	add.w	r1, r3, #52	; 0x34
 800924a:	2301      	movs	r3, #1
 800924c:	697a      	ldr	r2, [r7, #20]
 800924e:	f7ff fd1d 	bl	8008c8c <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8009252:	693b      	ldr	r3, [r7, #16]
 8009254:	3b01      	subs	r3, #1
 8009256:	613b      	str	r3, [r7, #16]
 8009258:	693b      	ldr	r3, [r7, #16]
 800925a:	2b01      	cmp	r3, #1
 800925c:	d8eb      	bhi.n	8009236 <sync_window+0x56>
				}
			}
		}
	}
	return res;
 800925e:	7bfb      	ldrb	r3, [r7, #15]
}
 8009260:	4618      	mov	r0, r3
 8009262:	3718      	adds	r7, #24
 8009264:	46bd      	mov	sp, r7
 8009266:	bd80      	pop	{r7, pc}

08009268 <move_window>:
static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs,			/* File system object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
 8009268:	b580      	push	{r7, lr}
 800926a:	b084      	sub	sp, #16
 800926c:	af00      	add	r7, sp, #0
 800926e:	6078      	str	r0, [r7, #4]
 8009270:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
 8009272:	2300      	movs	r3, #0
 8009274:	73fb      	strb	r3, [r7, #15]


	if (sector != fs->winsect) {	/* Window offset changed? */
 8009276:	687b      	ldr	r3, [r7, #4]
 8009278:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800927a:	683a      	ldr	r2, [r7, #0]
 800927c:	429a      	cmp	r2, r3
 800927e:	d01b      	beq.n	80092b8 <move_window+0x50>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 8009280:	6878      	ldr	r0, [r7, #4]
 8009282:	f7ff ffad 	bl	80091e0 <sync_window>
 8009286:	4603      	mov	r3, r0
 8009288:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 800928a:	7bfb      	ldrb	r3, [r7, #15]
 800928c:	2b00      	cmp	r3, #0
 800928e:	d113      	bne.n	80092b8 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8009290:	687b      	ldr	r3, [r7, #4]
 8009292:	7858      	ldrb	r0, [r3, #1]
 8009294:	687b      	ldr	r3, [r7, #4]
 8009296:	f103 0134 	add.w	r1, r3, #52	; 0x34
 800929a:	2301      	movs	r3, #1
 800929c:	683a      	ldr	r2, [r7, #0]
 800929e:	f7ff fcd5 	bl	8008c4c <disk_read>
 80092a2:	4603      	mov	r3, r0
 80092a4:	2b00      	cmp	r3, #0
 80092a6:	d004      	beq.n	80092b2 <move_window+0x4a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 80092a8:	f04f 33ff 	mov.w	r3, #4294967295
 80092ac:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
 80092ae:	2301      	movs	r3, #1
 80092b0:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sector;
 80092b2:	687b      	ldr	r3, [r7, #4]
 80092b4:	683a      	ldr	r2, [r7, #0]
 80092b6:	631a      	str	r2, [r3, #48]	; 0x30
		}
	}
	return res;
 80092b8:	7bfb      	ldrb	r3, [r7, #15]
}
 80092ba:	4618      	mov	r0, r3
 80092bc:	3710      	adds	r7, #16
 80092be:	46bd      	mov	sp, r7
 80092c0:	bd80      	pop	{r7, pc}
	...

080092c4 <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 80092c4:	b580      	push	{r7, lr}
 80092c6:	b084      	sub	sp, #16
 80092c8:	af00      	add	r7, sp, #0
 80092ca:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
 80092cc:	6878      	ldr	r0, [r7, #4]
 80092ce:	f7ff ff87 	bl	80091e0 <sync_window>
 80092d2:	4603      	mov	r3, r0
 80092d4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80092d6:	7bfb      	ldrb	r3, [r7, #15]
 80092d8:	2b00      	cmp	r3, #0
 80092da:	d158      	bne.n	800938e <sync_fs+0xca>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80092dc:	687b      	ldr	r3, [r7, #4]
 80092de:	781b      	ldrb	r3, [r3, #0]
 80092e0:	2b03      	cmp	r3, #3
 80092e2:	d148      	bne.n	8009376 <sync_fs+0xb2>
 80092e4:	687b      	ldr	r3, [r7, #4]
 80092e6:	791b      	ldrb	r3, [r3, #4]
 80092e8:	2b01      	cmp	r3, #1
 80092ea:	d144      	bne.n	8009376 <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
 80092ec:	687b      	ldr	r3, [r7, #4]
 80092ee:	3334      	adds	r3, #52	; 0x34
 80092f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80092f4:	2100      	movs	r1, #0
 80092f6:	4618      	mov	r0, r3
 80092f8:	f7ff fda9 	bl	8008e4e <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
 80092fc:	687b      	ldr	r3, [r7, #4]
 80092fe:	3334      	adds	r3, #52	; 0x34
 8009300:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 8009304:	f64a 2155 	movw	r1, #43605	; 0xaa55
 8009308:	4618      	mov	r0, r3
 800930a:	f7ff fd38 	bl	8008d7e <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
 800930e:	687b      	ldr	r3, [r7, #4]
 8009310:	3334      	adds	r3, #52	; 0x34
 8009312:	4921      	ldr	r1, [pc, #132]	; (8009398 <sync_fs+0xd4>)
 8009314:	4618      	mov	r0, r3
 8009316:	f7ff fd4d 	bl	8008db4 <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
 800931a:	687b      	ldr	r3, [r7, #4]
 800931c:	3334      	adds	r3, #52	; 0x34
 800931e:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8009322:	491e      	ldr	r1, [pc, #120]	; (800939c <sync_fs+0xd8>)
 8009324:	4618      	mov	r0, r3
 8009326:	f7ff fd45 	bl	8008db4 <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 800932a:	687b      	ldr	r3, [r7, #4]
 800932c:	3334      	adds	r3, #52	; 0x34
 800932e:	f503 72f4 	add.w	r2, r3, #488	; 0x1e8
 8009332:	687b      	ldr	r3, [r7, #4]
 8009334:	695b      	ldr	r3, [r3, #20]
 8009336:	4619      	mov	r1, r3
 8009338:	4610      	mov	r0, r2
 800933a:	f7ff fd3b 	bl	8008db4 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 800933e:	687b      	ldr	r3, [r7, #4]
 8009340:	3334      	adds	r3, #52	; 0x34
 8009342:	f503 72f6 	add.w	r2, r3, #492	; 0x1ec
 8009346:	687b      	ldr	r3, [r7, #4]
 8009348:	691b      	ldr	r3, [r3, #16]
 800934a:	4619      	mov	r1, r3
 800934c:	4610      	mov	r0, r2
 800934e:	f7ff fd31 	bl	8008db4 <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
 8009352:	687b      	ldr	r3, [r7, #4]
 8009354:	6a1b      	ldr	r3, [r3, #32]
 8009356:	1c5a      	adds	r2, r3, #1
 8009358:	687b      	ldr	r3, [r7, #4]
 800935a:	631a      	str	r2, [r3, #48]	; 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800935c:	687b      	ldr	r3, [r7, #4]
 800935e:	7858      	ldrb	r0, [r3, #1]
 8009360:	687b      	ldr	r3, [r7, #4]
 8009362:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8009366:	687b      	ldr	r3, [r7, #4]
 8009368:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800936a:	2301      	movs	r3, #1
 800936c:	f7ff fc8e 	bl	8008c8c <disk_write>
			fs->fsi_flag = 0;
 8009370:	687b      	ldr	r3, [r7, #4]
 8009372:	2200      	movs	r2, #0
 8009374:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8009376:	687b      	ldr	r3, [r7, #4]
 8009378:	785b      	ldrb	r3, [r3, #1]
 800937a:	2200      	movs	r2, #0
 800937c:	2100      	movs	r1, #0
 800937e:	4618      	mov	r0, r3
 8009380:	f7ff fca4 	bl	8008ccc <disk_ioctl>
 8009384:	4603      	mov	r3, r0
 8009386:	2b00      	cmp	r3, #0
 8009388:	d001      	beq.n	800938e <sync_fs+0xca>
 800938a:	2301      	movs	r3, #1
 800938c:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 800938e:	7bfb      	ldrb	r3, [r7, #15]
}
 8009390:	4618      	mov	r0, r3
 8009392:	3710      	adds	r7, #16
 8009394:	46bd      	mov	sp, r7
 8009396:	bd80      	pop	{r7, pc}
 8009398:	41615252 	.word	0x41615252
 800939c:	61417272 	.word	0x61417272

080093a0 <clust2sect>:
static
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 80093a0:	b480      	push	{r7}
 80093a2:	b083      	sub	sp, #12
 80093a4:	af00      	add	r7, sp, #0
 80093a6:	6078      	str	r0, [r7, #4]
 80093a8:	6039      	str	r1, [r7, #0]
	clst -= 2;
 80093aa:	683b      	ldr	r3, [r7, #0]
 80093ac:	3b02      	subs	r3, #2
 80093ae:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80093b0:	687b      	ldr	r3, [r7, #4]
 80093b2:	699b      	ldr	r3, [r3, #24]
 80093b4:	3b02      	subs	r3, #2
 80093b6:	683a      	ldr	r2, [r7, #0]
 80093b8:	429a      	cmp	r2, r3
 80093ba:	d301      	bcc.n	80093c0 <clust2sect+0x20>
 80093bc:	2300      	movs	r3, #0
 80093be:	e008      	b.n	80093d2 <clust2sect+0x32>
	return clst * fs->csize + fs->database;
 80093c0:	687b      	ldr	r3, [r7, #4]
 80093c2:	895b      	ldrh	r3, [r3, #10]
 80093c4:	461a      	mov	r2, r3
 80093c6:	683b      	ldr	r3, [r7, #0]
 80093c8:	fb03 f202 	mul.w	r2, r3, r2
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80093d0:	4413      	add	r3, r2
}
 80093d2:	4618      	mov	r0, r3
 80093d4:	370c      	adds	r7, #12
 80093d6:	46bd      	mov	sp, r7
 80093d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093dc:	4770      	bx	lr

080093de <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	_FDID* obj,	/* Corresponding object */
	DWORD clst	/* Cluster number to get the value */
)
{
 80093de:	b580      	push	{r7, lr}
 80093e0:	b086      	sub	sp, #24
 80093e2:	af00      	add	r7, sp, #0
 80093e4:	6078      	str	r0, [r7, #4]
 80093e6:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
 80093e8:	687b      	ldr	r3, [r7, #4]
 80093ea:	681b      	ldr	r3, [r3, #0]
 80093ec:	613b      	str	r3, [r7, #16]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80093ee:	683b      	ldr	r3, [r7, #0]
 80093f0:	2b01      	cmp	r3, #1
 80093f2:	d904      	bls.n	80093fe <get_fat+0x20>
 80093f4:	693b      	ldr	r3, [r7, #16]
 80093f6:	699b      	ldr	r3, [r3, #24]
 80093f8:	683a      	ldr	r2, [r7, #0]
 80093fa:	429a      	cmp	r2, r3
 80093fc:	d302      	bcc.n	8009404 <get_fat+0x26>
		val = 1;	/* Internal error */
 80093fe:	2301      	movs	r3, #1
 8009400:	617b      	str	r3, [r7, #20]
 8009402:	e08f      	b.n	8009524 <get_fat+0x146>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8009404:	f04f 33ff 	mov.w	r3, #4294967295
 8009408:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
 800940a:	693b      	ldr	r3, [r7, #16]
 800940c:	781b      	ldrb	r3, [r3, #0]
 800940e:	2b03      	cmp	r3, #3
 8009410:	d062      	beq.n	80094d8 <get_fat+0xfa>
 8009412:	2b03      	cmp	r3, #3
 8009414:	dc7c      	bgt.n	8009510 <get_fat+0x132>
 8009416:	2b01      	cmp	r3, #1
 8009418:	d002      	beq.n	8009420 <get_fat+0x42>
 800941a:	2b02      	cmp	r3, #2
 800941c:	d042      	beq.n	80094a4 <get_fat+0xc6>
 800941e:	e077      	b.n	8009510 <get_fat+0x132>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8009420:	683b      	ldr	r3, [r7, #0]
 8009422:	60fb      	str	r3, [r7, #12]
 8009424:	68fb      	ldr	r3, [r7, #12]
 8009426:	085b      	lsrs	r3, r3, #1
 8009428:	68fa      	ldr	r2, [r7, #12]
 800942a:	4413      	add	r3, r2
 800942c:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800942e:	693b      	ldr	r3, [r7, #16]
 8009430:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009432:	68fb      	ldr	r3, [r7, #12]
 8009434:	0a5b      	lsrs	r3, r3, #9
 8009436:	4413      	add	r3, r2
 8009438:	4619      	mov	r1, r3
 800943a:	6938      	ldr	r0, [r7, #16]
 800943c:	f7ff ff14 	bl	8009268 <move_window>
 8009440:	4603      	mov	r3, r0
 8009442:	2b00      	cmp	r3, #0
 8009444:	d167      	bne.n	8009516 <get_fat+0x138>
			wc = fs->win[bc++ % SS(fs)];
 8009446:	68fb      	ldr	r3, [r7, #12]
 8009448:	1c5a      	adds	r2, r3, #1
 800944a:	60fa      	str	r2, [r7, #12]
 800944c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009450:	693a      	ldr	r2, [r7, #16]
 8009452:	4413      	add	r3, r2
 8009454:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8009458:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800945a:	693b      	ldr	r3, [r7, #16]
 800945c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800945e:	68fb      	ldr	r3, [r7, #12]
 8009460:	0a5b      	lsrs	r3, r3, #9
 8009462:	4413      	add	r3, r2
 8009464:	4619      	mov	r1, r3
 8009466:	6938      	ldr	r0, [r7, #16]
 8009468:	f7ff fefe 	bl	8009268 <move_window>
 800946c:	4603      	mov	r3, r0
 800946e:	2b00      	cmp	r3, #0
 8009470:	d153      	bne.n	800951a <get_fat+0x13c>
			wc |= fs->win[bc % SS(fs)] << 8;
 8009472:	68fb      	ldr	r3, [r7, #12]
 8009474:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009478:	693a      	ldr	r2, [r7, #16]
 800947a:	4413      	add	r3, r2
 800947c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8009480:	021b      	lsls	r3, r3, #8
 8009482:	461a      	mov	r2, r3
 8009484:	68bb      	ldr	r3, [r7, #8]
 8009486:	4313      	orrs	r3, r2
 8009488:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800948a:	683b      	ldr	r3, [r7, #0]
 800948c:	f003 0301 	and.w	r3, r3, #1
 8009490:	2b00      	cmp	r3, #0
 8009492:	d002      	beq.n	800949a <get_fat+0xbc>
 8009494:	68bb      	ldr	r3, [r7, #8]
 8009496:	091b      	lsrs	r3, r3, #4
 8009498:	e002      	b.n	80094a0 <get_fat+0xc2>
 800949a:	68bb      	ldr	r3, [r7, #8]
 800949c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80094a0:	617b      	str	r3, [r7, #20]
			break;
 80094a2:	e03f      	b.n	8009524 <get_fat+0x146>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80094a4:	693b      	ldr	r3, [r7, #16]
 80094a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80094a8:	683b      	ldr	r3, [r7, #0]
 80094aa:	0a1b      	lsrs	r3, r3, #8
 80094ac:	4413      	add	r3, r2
 80094ae:	4619      	mov	r1, r3
 80094b0:	6938      	ldr	r0, [r7, #16]
 80094b2:	f7ff fed9 	bl	8009268 <move_window>
 80094b6:	4603      	mov	r3, r0
 80094b8:	2b00      	cmp	r3, #0
 80094ba:	d130      	bne.n	800951e <get_fat+0x140>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80094bc:	693b      	ldr	r3, [r7, #16]
 80094be:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80094c2:	683b      	ldr	r3, [r7, #0]
 80094c4:	005b      	lsls	r3, r3, #1
 80094c6:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 80094ca:	4413      	add	r3, r2
 80094cc:	4618      	mov	r0, r3
 80094ce:	f7ff fc1b 	bl	8008d08 <ld_word>
 80094d2:	4603      	mov	r3, r0
 80094d4:	617b      	str	r3, [r7, #20]
			break;
 80094d6:	e025      	b.n	8009524 <get_fat+0x146>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80094d8:	693b      	ldr	r3, [r7, #16]
 80094da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80094dc:	683b      	ldr	r3, [r7, #0]
 80094de:	09db      	lsrs	r3, r3, #7
 80094e0:	4413      	add	r3, r2
 80094e2:	4619      	mov	r1, r3
 80094e4:	6938      	ldr	r0, [r7, #16]
 80094e6:	f7ff febf 	bl	8009268 <move_window>
 80094ea:	4603      	mov	r3, r0
 80094ec:	2b00      	cmp	r3, #0
 80094ee:	d118      	bne.n	8009522 <get_fat+0x144>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 80094f0:	693b      	ldr	r3, [r7, #16]
 80094f2:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80094f6:	683b      	ldr	r3, [r7, #0]
 80094f8:	009b      	lsls	r3, r3, #2
 80094fa:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80094fe:	4413      	add	r3, r2
 8009500:	4618      	mov	r0, r3
 8009502:	f7ff fc19 	bl	8008d38 <ld_dword>
 8009506:	4603      	mov	r3, r0
 8009508:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800950c:	617b      	str	r3, [r7, #20]
			break;
 800950e:	e009      	b.n	8009524 <get_fat+0x146>
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
 8009510:	2301      	movs	r3, #1
 8009512:	617b      	str	r3, [r7, #20]
 8009514:	e006      	b.n	8009524 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8009516:	bf00      	nop
 8009518:	e004      	b.n	8009524 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800951a:	bf00      	nop
 800951c:	e002      	b.n	8009524 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800951e:	bf00      	nop
 8009520:	e000      	b.n	8009524 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8009522:	bf00      	nop
		}
	}

	return val;
 8009524:	697b      	ldr	r3, [r7, #20]
}
 8009526:	4618      	mov	r0, r3
 8009528:	3718      	adds	r7, #24
 800952a:	46bd      	mov	sp, r7
 800952c:	bd80      	pop	{r7, pc}

0800952e <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding file system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 800952e:	b590      	push	{r4, r7, lr}
 8009530:	b089      	sub	sp, #36	; 0x24
 8009532:	af00      	add	r7, sp, #0
 8009534:	60f8      	str	r0, [r7, #12]
 8009536:	60b9      	str	r1, [r7, #8]
 8009538:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
 800953a:	2302      	movs	r3, #2
 800953c:	77fb      	strb	r3, [r7, #31]

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800953e:	68bb      	ldr	r3, [r7, #8]
 8009540:	2b01      	cmp	r3, #1
 8009542:	f240 80d2 	bls.w	80096ea <put_fat+0x1bc>
 8009546:	68fb      	ldr	r3, [r7, #12]
 8009548:	699b      	ldr	r3, [r3, #24]
 800954a:	68ba      	ldr	r2, [r7, #8]
 800954c:	429a      	cmp	r2, r3
 800954e:	f080 80cc 	bcs.w	80096ea <put_fat+0x1bc>
		switch (fs->fs_type) {
 8009552:	68fb      	ldr	r3, [r7, #12]
 8009554:	781b      	ldrb	r3, [r3, #0]
 8009556:	2b03      	cmp	r3, #3
 8009558:	f000 8096 	beq.w	8009688 <put_fat+0x15a>
 800955c:	2b03      	cmp	r3, #3
 800955e:	f300 80cd 	bgt.w	80096fc <put_fat+0x1ce>
 8009562:	2b01      	cmp	r3, #1
 8009564:	d002      	beq.n	800956c <put_fat+0x3e>
 8009566:	2b02      	cmp	r3, #2
 8009568:	d06e      	beq.n	8009648 <put_fat+0x11a>
 800956a:	e0c7      	b.n	80096fc <put_fat+0x1ce>
		case FS_FAT12 :	/* Bitfield items */
			bc = (UINT)clst; bc += bc / 2;
 800956c:	68bb      	ldr	r3, [r7, #8]
 800956e:	61bb      	str	r3, [r7, #24]
 8009570:	69bb      	ldr	r3, [r7, #24]
 8009572:	085b      	lsrs	r3, r3, #1
 8009574:	69ba      	ldr	r2, [r7, #24]
 8009576:	4413      	add	r3, r2
 8009578:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800957a:	68fb      	ldr	r3, [r7, #12]
 800957c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800957e:	69bb      	ldr	r3, [r7, #24]
 8009580:	0a5b      	lsrs	r3, r3, #9
 8009582:	4413      	add	r3, r2
 8009584:	4619      	mov	r1, r3
 8009586:	68f8      	ldr	r0, [r7, #12]
 8009588:	f7ff fe6e 	bl	8009268 <move_window>
 800958c:	4603      	mov	r3, r0
 800958e:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8009590:	7ffb      	ldrb	r3, [r7, #31]
 8009592:	2b00      	cmp	r3, #0
 8009594:	f040 80ab 	bne.w	80096ee <put_fat+0x1c0>
			p = fs->win + bc++ % SS(fs);
 8009598:	68fb      	ldr	r3, [r7, #12]
 800959a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800959e:	69bb      	ldr	r3, [r7, #24]
 80095a0:	1c59      	adds	r1, r3, #1
 80095a2:	61b9      	str	r1, [r7, #24]
 80095a4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80095a8:	4413      	add	r3, r2
 80095aa:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80095ac:	68bb      	ldr	r3, [r7, #8]
 80095ae:	f003 0301 	and.w	r3, r3, #1
 80095b2:	2b00      	cmp	r3, #0
 80095b4:	d00d      	beq.n	80095d2 <put_fat+0xa4>
 80095b6:	697b      	ldr	r3, [r7, #20]
 80095b8:	781b      	ldrb	r3, [r3, #0]
 80095ba:	b25b      	sxtb	r3, r3
 80095bc:	f003 030f 	and.w	r3, r3, #15
 80095c0:	b25a      	sxtb	r2, r3
 80095c2:	687b      	ldr	r3, [r7, #4]
 80095c4:	b2db      	uxtb	r3, r3
 80095c6:	011b      	lsls	r3, r3, #4
 80095c8:	b25b      	sxtb	r3, r3
 80095ca:	4313      	orrs	r3, r2
 80095cc:	b25b      	sxtb	r3, r3
 80095ce:	b2db      	uxtb	r3, r3
 80095d0:	e001      	b.n	80095d6 <put_fat+0xa8>
 80095d2:	687b      	ldr	r3, [r7, #4]
 80095d4:	b2db      	uxtb	r3, r3
 80095d6:	697a      	ldr	r2, [r7, #20]
 80095d8:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 80095da:	68fb      	ldr	r3, [r7, #12]
 80095dc:	2201      	movs	r2, #1
 80095de:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80095e0:	68fb      	ldr	r3, [r7, #12]
 80095e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80095e4:	69bb      	ldr	r3, [r7, #24]
 80095e6:	0a5b      	lsrs	r3, r3, #9
 80095e8:	4413      	add	r3, r2
 80095ea:	4619      	mov	r1, r3
 80095ec:	68f8      	ldr	r0, [r7, #12]
 80095ee:	f7ff fe3b 	bl	8009268 <move_window>
 80095f2:	4603      	mov	r3, r0
 80095f4:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 80095f6:	7ffb      	ldrb	r3, [r7, #31]
 80095f8:	2b00      	cmp	r3, #0
 80095fa:	d17a      	bne.n	80096f2 <put_fat+0x1c4>
			p = fs->win + bc % SS(fs);
 80095fc:	68fb      	ldr	r3, [r7, #12]
 80095fe:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8009602:	69bb      	ldr	r3, [r7, #24]
 8009604:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009608:	4413      	add	r3, r2
 800960a:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800960c:	68bb      	ldr	r3, [r7, #8]
 800960e:	f003 0301 	and.w	r3, r3, #1
 8009612:	2b00      	cmp	r3, #0
 8009614:	d003      	beq.n	800961e <put_fat+0xf0>
 8009616:	687b      	ldr	r3, [r7, #4]
 8009618:	091b      	lsrs	r3, r3, #4
 800961a:	b2db      	uxtb	r3, r3
 800961c:	e00e      	b.n	800963c <put_fat+0x10e>
 800961e:	697b      	ldr	r3, [r7, #20]
 8009620:	781b      	ldrb	r3, [r3, #0]
 8009622:	b25b      	sxtb	r3, r3
 8009624:	f023 030f 	bic.w	r3, r3, #15
 8009628:	b25a      	sxtb	r2, r3
 800962a:	687b      	ldr	r3, [r7, #4]
 800962c:	0a1b      	lsrs	r3, r3, #8
 800962e:	b25b      	sxtb	r3, r3
 8009630:	f003 030f 	and.w	r3, r3, #15
 8009634:	b25b      	sxtb	r3, r3
 8009636:	4313      	orrs	r3, r2
 8009638:	b25b      	sxtb	r3, r3
 800963a:	b2db      	uxtb	r3, r3
 800963c:	697a      	ldr	r2, [r7, #20]
 800963e:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8009640:	68fb      	ldr	r3, [r7, #12]
 8009642:	2201      	movs	r2, #1
 8009644:	70da      	strb	r2, [r3, #3]
			break;
 8009646:	e059      	b.n	80096fc <put_fat+0x1ce>

		case FS_FAT16 :	/* WORD aligned items */
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8009648:	68fb      	ldr	r3, [r7, #12]
 800964a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800964c:	68bb      	ldr	r3, [r7, #8]
 800964e:	0a1b      	lsrs	r3, r3, #8
 8009650:	4413      	add	r3, r2
 8009652:	4619      	mov	r1, r3
 8009654:	68f8      	ldr	r0, [r7, #12]
 8009656:	f7ff fe07 	bl	8009268 <move_window>
 800965a:	4603      	mov	r3, r0
 800965c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800965e:	7ffb      	ldrb	r3, [r7, #31]
 8009660:	2b00      	cmp	r3, #0
 8009662:	d148      	bne.n	80096f6 <put_fat+0x1c8>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8009664:	68fb      	ldr	r3, [r7, #12]
 8009666:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800966a:	68bb      	ldr	r3, [r7, #8]
 800966c:	005b      	lsls	r3, r3, #1
 800966e:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 8009672:	4413      	add	r3, r2
 8009674:	687a      	ldr	r2, [r7, #4]
 8009676:	b292      	uxth	r2, r2
 8009678:	4611      	mov	r1, r2
 800967a:	4618      	mov	r0, r3
 800967c:	f7ff fb7f 	bl	8008d7e <st_word>
			fs->wflag = 1;
 8009680:	68fb      	ldr	r3, [r7, #12]
 8009682:	2201      	movs	r2, #1
 8009684:	70da      	strb	r2, [r3, #3]
			break;
 8009686:	e039      	b.n	80096fc <put_fat+0x1ce>

		case FS_FAT32 :	/* DWORD aligned items */
#if _FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8009688:	68fb      	ldr	r3, [r7, #12]
 800968a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800968c:	68bb      	ldr	r3, [r7, #8]
 800968e:	09db      	lsrs	r3, r3, #7
 8009690:	4413      	add	r3, r2
 8009692:	4619      	mov	r1, r3
 8009694:	68f8      	ldr	r0, [r7, #12]
 8009696:	f7ff fde7 	bl	8009268 <move_window>
 800969a:	4603      	mov	r3, r0
 800969c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800969e:	7ffb      	ldrb	r3, [r7, #31]
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d12a      	bne.n	80096fa <put_fat+0x1cc>
			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 80096a4:	687b      	ldr	r3, [r7, #4]
 80096a6:	f023 4470 	bic.w	r4, r3, #4026531840	; 0xf0000000
 80096aa:	68fb      	ldr	r3, [r7, #12]
 80096ac:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80096b0:	68bb      	ldr	r3, [r7, #8]
 80096b2:	009b      	lsls	r3, r3, #2
 80096b4:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80096b8:	4413      	add	r3, r2
 80096ba:	4618      	mov	r0, r3
 80096bc:	f7ff fb3c 	bl	8008d38 <ld_dword>
 80096c0:	4603      	mov	r3, r0
 80096c2:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80096c6:	4323      	orrs	r3, r4
 80096c8:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
 80096ca:	68fb      	ldr	r3, [r7, #12]
 80096cc:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80096d0:	68bb      	ldr	r3, [r7, #8]
 80096d2:	009b      	lsls	r3, r3, #2
 80096d4:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80096d8:	4413      	add	r3, r2
 80096da:	6879      	ldr	r1, [r7, #4]
 80096dc:	4618      	mov	r0, r3
 80096de:	f7ff fb69 	bl	8008db4 <st_dword>
			fs->wflag = 1;
 80096e2:	68fb      	ldr	r3, [r7, #12]
 80096e4:	2201      	movs	r2, #1
 80096e6:	70da      	strb	r2, [r3, #3]
			break;
 80096e8:	e008      	b.n	80096fc <put_fat+0x1ce>
		}
	}
 80096ea:	bf00      	nop
 80096ec:	e006      	b.n	80096fc <put_fat+0x1ce>
			if (res != FR_OK) break;
 80096ee:	bf00      	nop
 80096f0:	e004      	b.n	80096fc <put_fat+0x1ce>
			if (res != FR_OK) break;
 80096f2:	bf00      	nop
 80096f4:	e002      	b.n	80096fc <put_fat+0x1ce>
			if (res != FR_OK) break;
 80096f6:	bf00      	nop
 80096f8:	e000      	b.n	80096fc <put_fat+0x1ce>
			if (res != FR_OK) break;
 80096fa:	bf00      	nop
	return res;
 80096fc:	7ffb      	ldrb	r3, [r7, #31]
}
 80096fe:	4618      	mov	r0, r3
 8009700:	3724      	adds	r7, #36	; 0x24
 8009702:	46bd      	mov	sp, r7
 8009704:	bd90      	pop	{r4, r7, pc}

08009706 <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
 8009706:	b580      	push	{r7, lr}
 8009708:	b088      	sub	sp, #32
 800970a:	af00      	add	r7, sp, #0
 800970c:	60f8      	str	r0, [r7, #12]
 800970e:	60b9      	str	r1, [r7, #8]
 8009710:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
 8009712:	2300      	movs	r3, #0
 8009714:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
 8009716:	68fb      	ldr	r3, [r7, #12]
 8009718:	681b      	ldr	r3, [r3, #0]
 800971a:	61bb      	str	r3, [r7, #24]
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800971c:	68bb      	ldr	r3, [r7, #8]
 800971e:	2b01      	cmp	r3, #1
 8009720:	d904      	bls.n	800972c <remove_chain+0x26>
 8009722:	69bb      	ldr	r3, [r7, #24]
 8009724:	699b      	ldr	r3, [r3, #24]
 8009726:	68ba      	ldr	r2, [r7, #8]
 8009728:	429a      	cmp	r2, r3
 800972a:	d301      	bcc.n	8009730 <remove_chain+0x2a>
 800972c:	2302      	movs	r3, #2
 800972e:	e04b      	b.n	80097c8 <remove_chain+0xc2>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	2b00      	cmp	r3, #0
 8009734:	d00c      	beq.n	8009750 <remove_chain+0x4a>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 8009736:	f04f 32ff 	mov.w	r2, #4294967295
 800973a:	6879      	ldr	r1, [r7, #4]
 800973c:	69b8      	ldr	r0, [r7, #24]
 800973e:	f7ff fef6 	bl	800952e <put_fat>
 8009742:	4603      	mov	r3, r0
 8009744:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
 8009746:	7ffb      	ldrb	r3, [r7, #31]
 8009748:	2b00      	cmp	r3, #0
 800974a:	d001      	beq.n	8009750 <remove_chain+0x4a>
 800974c:	7ffb      	ldrb	r3, [r7, #31]
 800974e:	e03b      	b.n	80097c8 <remove_chain+0xc2>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8009750:	68b9      	ldr	r1, [r7, #8]
 8009752:	68f8      	ldr	r0, [r7, #12]
 8009754:	f7ff fe43 	bl	80093de <get_fat>
 8009758:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
 800975a:	697b      	ldr	r3, [r7, #20]
 800975c:	2b00      	cmp	r3, #0
 800975e:	d031      	beq.n	80097c4 <remove_chain+0xbe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8009760:	697b      	ldr	r3, [r7, #20]
 8009762:	2b01      	cmp	r3, #1
 8009764:	d101      	bne.n	800976a <remove_chain+0x64>
 8009766:	2302      	movs	r3, #2
 8009768:	e02e      	b.n	80097c8 <remove_chain+0xc2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800976a:	697b      	ldr	r3, [r7, #20]
 800976c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009770:	d101      	bne.n	8009776 <remove_chain+0x70>
 8009772:	2301      	movs	r3, #1
 8009774:	e028      	b.n	80097c8 <remove_chain+0xc2>
		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 8009776:	2200      	movs	r2, #0
 8009778:	68b9      	ldr	r1, [r7, #8]
 800977a:	69b8      	ldr	r0, [r7, #24]
 800977c:	f7ff fed7 	bl	800952e <put_fat>
 8009780:	4603      	mov	r3, r0
 8009782:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
 8009784:	7ffb      	ldrb	r3, [r7, #31]
 8009786:	2b00      	cmp	r3, #0
 8009788:	d001      	beq.n	800978e <remove_chain+0x88>
 800978a:	7ffb      	ldrb	r3, [r7, #31]
 800978c:	e01c      	b.n	80097c8 <remove_chain+0xc2>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800978e:	69bb      	ldr	r3, [r7, #24]
 8009790:	695a      	ldr	r2, [r3, #20]
 8009792:	69bb      	ldr	r3, [r7, #24]
 8009794:	699b      	ldr	r3, [r3, #24]
 8009796:	3b02      	subs	r3, #2
 8009798:	429a      	cmp	r2, r3
 800979a:	d20b      	bcs.n	80097b4 <remove_chain+0xae>
			fs->free_clst++;
 800979c:	69bb      	ldr	r3, [r7, #24]
 800979e:	695b      	ldr	r3, [r3, #20]
 80097a0:	1c5a      	adds	r2, r3, #1
 80097a2:	69bb      	ldr	r3, [r7, #24]
 80097a4:	615a      	str	r2, [r3, #20]
			fs->fsi_flag |= 1;
 80097a6:	69bb      	ldr	r3, [r7, #24]
 80097a8:	791b      	ldrb	r3, [r3, #4]
 80097aa:	f043 0301 	orr.w	r3, r3, #1
 80097ae:	b2da      	uxtb	r2, r3
 80097b0:	69bb      	ldr	r3, [r7, #24]
 80097b2:	711a      	strb	r2, [r3, #4]
			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
 80097b4:	697b      	ldr	r3, [r7, #20]
 80097b6:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 80097b8:	69bb      	ldr	r3, [r7, #24]
 80097ba:	699b      	ldr	r3, [r3, #24]
 80097bc:	68ba      	ldr	r2, [r7, #8]
 80097be:	429a      	cmp	r2, r3
 80097c0:	d3c6      	bcc.n	8009750 <remove_chain+0x4a>
 80097c2:	e000      	b.n	80097c6 <remove_chain+0xc0>
		if (nxt == 0) break;				/* Empty cluster? */
 80097c4:	bf00      	nop
				obj->stat = 2;	/* Change the object status 'contiguous' */
			}
		}
	}
#endif
	return FR_OK;
 80097c6:	2300      	movs	r3, #0
}
 80097c8:	4618      	mov	r0, r3
 80097ca:	3720      	adds	r7, #32
 80097cc:	46bd      	mov	sp, r7
 80097ce:	bd80      	pop	{r7, pc}

080097d0 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	_FDID* obj,			/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 80097d0:	b580      	push	{r7, lr}
 80097d2:	b088      	sub	sp, #32
 80097d4:	af00      	add	r7, sp, #0
 80097d6:	6078      	str	r0, [r7, #4]
 80097d8:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
 80097da:	687b      	ldr	r3, [r7, #4]
 80097dc:	681b      	ldr	r3, [r3, #0]
 80097de:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
 80097e0:	683b      	ldr	r3, [r7, #0]
 80097e2:	2b00      	cmp	r3, #0
 80097e4:	d10d      	bne.n	8009802 <create_chain+0x32>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 80097e6:	693b      	ldr	r3, [r7, #16]
 80097e8:	691b      	ldr	r3, [r3, #16]
 80097ea:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 80097ec:	69bb      	ldr	r3, [r7, #24]
 80097ee:	2b00      	cmp	r3, #0
 80097f0:	d004      	beq.n	80097fc <create_chain+0x2c>
 80097f2:	693b      	ldr	r3, [r7, #16]
 80097f4:	699b      	ldr	r3, [r3, #24]
 80097f6:	69ba      	ldr	r2, [r7, #24]
 80097f8:	429a      	cmp	r2, r3
 80097fa:	d31b      	bcc.n	8009834 <create_chain+0x64>
 80097fc:	2301      	movs	r3, #1
 80097fe:	61bb      	str	r3, [r7, #24]
 8009800:	e018      	b.n	8009834 <create_chain+0x64>
	}
	else {				/* Stretch current chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8009802:	6839      	ldr	r1, [r7, #0]
 8009804:	6878      	ldr	r0, [r7, #4]
 8009806:	f7ff fdea 	bl	80093de <get_fat>
 800980a:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Invalid FAT value */
 800980c:	68fb      	ldr	r3, [r7, #12]
 800980e:	2b01      	cmp	r3, #1
 8009810:	d801      	bhi.n	8009816 <create_chain+0x46>
 8009812:	2301      	movs	r3, #1
 8009814:	e070      	b.n	80098f8 <create_chain+0x128>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8009816:	68fb      	ldr	r3, [r7, #12]
 8009818:	f1b3 3fff 	cmp.w	r3, #4294967295
 800981c:	d101      	bne.n	8009822 <create_chain+0x52>
 800981e:	68fb      	ldr	r3, [r7, #12]
 8009820:	e06a      	b.n	80098f8 <create_chain+0x128>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8009822:	693b      	ldr	r3, [r7, #16]
 8009824:	699b      	ldr	r3, [r3, #24]
 8009826:	68fa      	ldr	r2, [r7, #12]
 8009828:	429a      	cmp	r2, r3
 800982a:	d201      	bcs.n	8009830 <create_chain+0x60>
 800982c:	68fb      	ldr	r3, [r7, #12]
 800982e:	e063      	b.n	80098f8 <create_chain+0x128>
		scl = clst;
 8009830:	683b      	ldr	r3, [r7, #0]
 8009832:	61bb      	str	r3, [r7, #24]
			}
		}
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		ncl = scl;	/* Start cluster */
 8009834:	69bb      	ldr	r3, [r7, #24]
 8009836:	61fb      	str	r3, [r7, #28]
		for (;;) {
			ncl++;							/* Next cluster */
 8009838:	69fb      	ldr	r3, [r7, #28]
 800983a:	3301      	adds	r3, #1
 800983c:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800983e:	693b      	ldr	r3, [r7, #16]
 8009840:	699b      	ldr	r3, [r3, #24]
 8009842:	69fa      	ldr	r2, [r7, #28]
 8009844:	429a      	cmp	r2, r3
 8009846:	d307      	bcc.n	8009858 <create_chain+0x88>
				ncl = 2;
 8009848:	2302      	movs	r3, #2
 800984a:	61fb      	str	r3, [r7, #28]
				if (ncl > scl) return 0;	/* No free cluster */
 800984c:	69fa      	ldr	r2, [r7, #28]
 800984e:	69bb      	ldr	r3, [r7, #24]
 8009850:	429a      	cmp	r2, r3
 8009852:	d901      	bls.n	8009858 <create_chain+0x88>
 8009854:	2300      	movs	r3, #0
 8009856:	e04f      	b.n	80098f8 <create_chain+0x128>
			}
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 8009858:	69f9      	ldr	r1, [r7, #28]
 800985a:	6878      	ldr	r0, [r7, #4]
 800985c:	f7ff fdbf 	bl	80093de <get_fat>
 8009860:	60f8      	str	r0, [r7, #12]
			if (cs == 0) break;				/* Found a free cluster */
 8009862:	68fb      	ldr	r3, [r7, #12]
 8009864:	2b00      	cmp	r3, #0
 8009866:	d00e      	beq.n	8009886 <create_chain+0xb6>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8009868:	68fb      	ldr	r3, [r7, #12]
 800986a:	2b01      	cmp	r3, #1
 800986c:	d003      	beq.n	8009876 <create_chain+0xa6>
 800986e:	68fb      	ldr	r3, [r7, #12]
 8009870:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009874:	d101      	bne.n	800987a <create_chain+0xaa>
 8009876:	68fb      	ldr	r3, [r7, #12]
 8009878:	e03e      	b.n	80098f8 <create_chain+0x128>
			if (ncl == scl) return 0;		/* No free cluster */
 800987a:	69fa      	ldr	r2, [r7, #28]
 800987c:	69bb      	ldr	r3, [r7, #24]
 800987e:	429a      	cmp	r2, r3
 8009880:	d1da      	bne.n	8009838 <create_chain+0x68>
 8009882:	2300      	movs	r3, #0
 8009884:	e038      	b.n	80098f8 <create_chain+0x128>
			if (cs == 0) break;				/* Found a free cluster */
 8009886:	bf00      	nop
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
 8009888:	f04f 32ff 	mov.w	r2, #4294967295
 800988c:	69f9      	ldr	r1, [r7, #28]
 800988e:	6938      	ldr	r0, [r7, #16]
 8009890:	f7ff fe4d 	bl	800952e <put_fat>
 8009894:	4603      	mov	r3, r0
 8009896:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
 8009898:	7dfb      	ldrb	r3, [r7, #23]
 800989a:	2b00      	cmp	r3, #0
 800989c:	d109      	bne.n	80098b2 <create_chain+0xe2>
 800989e:	683b      	ldr	r3, [r7, #0]
 80098a0:	2b00      	cmp	r3, #0
 80098a2:	d006      	beq.n	80098b2 <create_chain+0xe2>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
 80098a4:	69fa      	ldr	r2, [r7, #28]
 80098a6:	6839      	ldr	r1, [r7, #0]
 80098a8:	6938      	ldr	r0, [r7, #16]
 80098aa:	f7ff fe40 	bl	800952e <put_fat>
 80098ae:	4603      	mov	r3, r0
 80098b0:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 80098b2:	7dfb      	ldrb	r3, [r7, #23]
 80098b4:	2b00      	cmp	r3, #0
 80098b6:	d116      	bne.n	80098e6 <create_chain+0x116>
		fs->last_clst = ncl;
 80098b8:	693b      	ldr	r3, [r7, #16]
 80098ba:	69fa      	ldr	r2, [r7, #28]
 80098bc:	611a      	str	r2, [r3, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 80098be:	693b      	ldr	r3, [r7, #16]
 80098c0:	695a      	ldr	r2, [r3, #20]
 80098c2:	693b      	ldr	r3, [r7, #16]
 80098c4:	699b      	ldr	r3, [r3, #24]
 80098c6:	3b02      	subs	r3, #2
 80098c8:	429a      	cmp	r2, r3
 80098ca:	d804      	bhi.n	80098d6 <create_chain+0x106>
 80098cc:	693b      	ldr	r3, [r7, #16]
 80098ce:	695b      	ldr	r3, [r3, #20]
 80098d0:	1e5a      	subs	r2, r3, #1
 80098d2:	693b      	ldr	r3, [r7, #16]
 80098d4:	615a      	str	r2, [r3, #20]
		fs->fsi_flag |= 1;
 80098d6:	693b      	ldr	r3, [r7, #16]
 80098d8:	791b      	ldrb	r3, [r3, #4]
 80098da:	f043 0301 	orr.w	r3, r3, #1
 80098de:	b2da      	uxtb	r2, r3
 80098e0:	693b      	ldr	r3, [r7, #16]
 80098e2:	711a      	strb	r2, [r3, #4]
 80098e4:	e007      	b.n	80098f6 <create_chain+0x126>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 80098e6:	7dfb      	ldrb	r3, [r7, #23]
 80098e8:	2b01      	cmp	r3, #1
 80098ea:	d102      	bne.n	80098f2 <create_chain+0x122>
 80098ec:	f04f 33ff 	mov.w	r3, #4294967295
 80098f0:	e000      	b.n	80098f4 <create_chain+0x124>
 80098f2:	2301      	movs	r3, #1
 80098f4:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
 80098f6:	69fb      	ldr	r3, [r7, #28]
}
 80098f8:	4618      	mov	r0, r3
 80098fa:	3720      	adds	r7, #32
 80098fc:	46bd      	mov	sp, r7
 80098fe:	bd80      	pop	{r7, pc}

08009900 <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
 8009900:	b480      	push	{r7}
 8009902:	b087      	sub	sp, #28
 8009904:	af00      	add	r7, sp, #0
 8009906:	6078      	str	r0, [r7, #4]
 8009908:	6039      	str	r1, [r7, #0]
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	681b      	ldr	r3, [r3, #0]
 800990e:	60fb      	str	r3, [r7, #12]


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8009910:	687b      	ldr	r3, [r7, #4]
 8009912:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009914:	3304      	adds	r3, #4
 8009916:	613b      	str	r3, [r7, #16]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8009918:	683b      	ldr	r3, [r7, #0]
 800991a:	0a5b      	lsrs	r3, r3, #9
 800991c:	68fa      	ldr	r2, [r7, #12]
 800991e:	8952      	ldrh	r2, [r2, #10]
 8009920:	fbb3 f3f2 	udiv	r3, r3, r2
 8009924:	617b      	str	r3, [r7, #20]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8009926:	693b      	ldr	r3, [r7, #16]
 8009928:	1d1a      	adds	r2, r3, #4
 800992a:	613a      	str	r2, [r7, #16]
 800992c:	681b      	ldr	r3, [r3, #0]
 800992e:	60bb      	str	r3, [r7, #8]
		if (ncl == 0) return 0;	/* End of table? (error) */
 8009930:	68bb      	ldr	r3, [r7, #8]
 8009932:	2b00      	cmp	r3, #0
 8009934:	d101      	bne.n	800993a <clmt_clust+0x3a>
 8009936:	2300      	movs	r3, #0
 8009938:	e010      	b.n	800995c <clmt_clust+0x5c>
		if (cl < ncl) break;	/* In this fragment? */
 800993a:	697a      	ldr	r2, [r7, #20]
 800993c:	68bb      	ldr	r3, [r7, #8]
 800993e:	429a      	cmp	r2, r3
 8009940:	d307      	bcc.n	8009952 <clmt_clust+0x52>
		cl -= ncl; tbl++;		/* Next fragment */
 8009942:	697a      	ldr	r2, [r7, #20]
 8009944:	68bb      	ldr	r3, [r7, #8]
 8009946:	1ad3      	subs	r3, r2, r3
 8009948:	617b      	str	r3, [r7, #20]
 800994a:	693b      	ldr	r3, [r7, #16]
 800994c:	3304      	adds	r3, #4
 800994e:	613b      	str	r3, [r7, #16]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8009950:	e7e9      	b.n	8009926 <clmt_clust+0x26>
		if (cl < ncl) break;	/* In this fragment? */
 8009952:	bf00      	nop
	}
	return cl + *tbl;	/* Return the cluster number */
 8009954:	693b      	ldr	r3, [r7, #16]
 8009956:	681a      	ldr	r2, [r3, #0]
 8009958:	697b      	ldr	r3, [r7, #20]
 800995a:	4413      	add	r3, r2
}
 800995c:	4618      	mov	r0, r3
 800995e:	371c      	adds	r7, #28
 8009960:	46bd      	mov	sp, r7
 8009962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009966:	4770      	bx	lr

08009968 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
 8009968:	b580      	push	{r7, lr}
 800996a:	b086      	sub	sp, #24
 800996c:	af00      	add	r7, sp, #0
 800996e:	6078      	str	r0, [r7, #4]
 8009970:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	681b      	ldr	r3, [r3, #0]
 8009976:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8009978:	683b      	ldr	r3, [r7, #0]
 800997a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800997e:	d204      	bcs.n	800998a <dir_sdi+0x22>
 8009980:	683b      	ldr	r3, [r7, #0]
 8009982:	f003 031f 	and.w	r3, r3, #31
 8009986:	2b00      	cmp	r3, #0
 8009988:	d001      	beq.n	800998e <dir_sdi+0x26>
		return FR_INT_ERR;
 800998a:	2302      	movs	r3, #2
 800998c:	e063      	b.n	8009a56 <dir_sdi+0xee>
	}
	dp->dptr = ofs;				/* Set current offset */
 800998e:	687b      	ldr	r3, [r7, #4]
 8009990:	683a      	ldr	r2, [r7, #0]
 8009992:	615a      	str	r2, [r3, #20]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8009994:	687b      	ldr	r3, [r7, #4]
 8009996:	689b      	ldr	r3, [r3, #8]
 8009998:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800999a:	697b      	ldr	r3, [r7, #20]
 800999c:	2b00      	cmp	r3, #0
 800999e:	d106      	bne.n	80099ae <dir_sdi+0x46>
 80099a0:	693b      	ldr	r3, [r7, #16]
 80099a2:	781b      	ldrb	r3, [r3, #0]
 80099a4:	2b02      	cmp	r3, #2
 80099a6:	d902      	bls.n	80099ae <dir_sdi+0x46>
		clst = fs->dirbase;
 80099a8:	693b      	ldr	r3, [r7, #16]
 80099aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80099ac:	617b      	str	r3, [r7, #20]
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 80099ae:	697b      	ldr	r3, [r7, #20]
 80099b0:	2b00      	cmp	r3, #0
 80099b2:	d10c      	bne.n	80099ce <dir_sdi+0x66>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 80099b4:	683b      	ldr	r3, [r7, #0]
 80099b6:	095b      	lsrs	r3, r3, #5
 80099b8:	693a      	ldr	r2, [r7, #16]
 80099ba:	8912      	ldrh	r2, [r2, #8]
 80099bc:	4293      	cmp	r3, r2
 80099be:	d301      	bcc.n	80099c4 <dir_sdi+0x5c>
 80099c0:	2302      	movs	r3, #2
 80099c2:	e048      	b.n	8009a56 <dir_sdi+0xee>
		dp->sect = fs->dirbase;
 80099c4:	693b      	ldr	r3, [r7, #16]
 80099c6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80099c8:	687b      	ldr	r3, [r7, #4]
 80099ca:	61da      	str	r2, [r3, #28]
 80099cc:	e029      	b.n	8009a22 <dir_sdi+0xba>

	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80099ce:	693b      	ldr	r3, [r7, #16]
 80099d0:	895b      	ldrh	r3, [r3, #10]
 80099d2:	025b      	lsls	r3, r3, #9
 80099d4:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
 80099d6:	e019      	b.n	8009a0c <dir_sdi+0xa4>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80099d8:	687b      	ldr	r3, [r7, #4]
 80099da:	6979      	ldr	r1, [r7, #20]
 80099dc:	4618      	mov	r0, r3
 80099de:	f7ff fcfe 	bl	80093de <get_fat>
 80099e2:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80099e4:	697b      	ldr	r3, [r7, #20]
 80099e6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80099ea:	d101      	bne.n	80099f0 <dir_sdi+0x88>
 80099ec:	2301      	movs	r3, #1
 80099ee:	e032      	b.n	8009a56 <dir_sdi+0xee>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 80099f0:	697b      	ldr	r3, [r7, #20]
 80099f2:	2b01      	cmp	r3, #1
 80099f4:	d904      	bls.n	8009a00 <dir_sdi+0x98>
 80099f6:	693b      	ldr	r3, [r7, #16]
 80099f8:	699b      	ldr	r3, [r3, #24]
 80099fa:	697a      	ldr	r2, [r7, #20]
 80099fc:	429a      	cmp	r2, r3
 80099fe:	d301      	bcc.n	8009a04 <dir_sdi+0x9c>
 8009a00:	2302      	movs	r3, #2
 8009a02:	e028      	b.n	8009a56 <dir_sdi+0xee>
			ofs -= csz;
 8009a04:	683a      	ldr	r2, [r7, #0]
 8009a06:	68fb      	ldr	r3, [r7, #12]
 8009a08:	1ad3      	subs	r3, r2, r3
 8009a0a:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
 8009a0c:	683a      	ldr	r2, [r7, #0]
 8009a0e:	68fb      	ldr	r3, [r7, #12]
 8009a10:	429a      	cmp	r2, r3
 8009a12:	d2e1      	bcs.n	80099d8 <dir_sdi+0x70>
		}
		dp->sect = clust2sect(fs, clst);
 8009a14:	6979      	ldr	r1, [r7, #20]
 8009a16:	6938      	ldr	r0, [r7, #16]
 8009a18:	f7ff fcc2 	bl	80093a0 <clust2sect>
 8009a1c:	4602      	mov	r2, r0
 8009a1e:	687b      	ldr	r3, [r7, #4]
 8009a20:	61da      	str	r2, [r3, #28]
	}
	dp->clust = clst;					/* Current cluster# */
 8009a22:	687b      	ldr	r3, [r7, #4]
 8009a24:	697a      	ldr	r2, [r7, #20]
 8009a26:	619a      	str	r2, [r3, #24]
	if (!dp->sect) return FR_INT_ERR;
 8009a28:	687b      	ldr	r3, [r7, #4]
 8009a2a:	69db      	ldr	r3, [r3, #28]
 8009a2c:	2b00      	cmp	r3, #0
 8009a2e:	d101      	bne.n	8009a34 <dir_sdi+0xcc>
 8009a30:	2302      	movs	r3, #2
 8009a32:	e010      	b.n	8009a56 <dir_sdi+0xee>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8009a34:	687b      	ldr	r3, [r7, #4]
 8009a36:	69da      	ldr	r2, [r3, #28]
 8009a38:	683b      	ldr	r3, [r7, #0]
 8009a3a:	0a5b      	lsrs	r3, r3, #9
 8009a3c:	441a      	add	r2, r3
 8009a3e:	687b      	ldr	r3, [r7, #4]
 8009a40:	61da      	str	r2, [r3, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8009a42:	693b      	ldr	r3, [r7, #16]
 8009a44:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8009a48:	683b      	ldr	r3, [r7, #0]
 8009a4a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009a4e:	441a      	add	r2, r3
 8009a50:	687b      	ldr	r3, [r7, #4]
 8009a52:	621a      	str	r2, [r3, #32]

	return FR_OK;
 8009a54:	2300      	movs	r3, #0
}
 8009a56:	4618      	mov	r0, r3
 8009a58:	3718      	adds	r7, #24
 8009a5a:	46bd      	mov	sp, r7
 8009a5c:	bd80      	pop	{r7, pc}

08009a5e <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8009a5e:	b580      	push	{r7, lr}
 8009a60:	b086      	sub	sp, #24
 8009a62:	af00      	add	r7, sp, #0
 8009a64:	6078      	str	r0, [r7, #4]
 8009a66:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
 8009a68:	687b      	ldr	r3, [r7, #4]
 8009a6a:	681b      	ldr	r3, [r3, #0]
 8009a6c:	60fb      	str	r3, [r7, #12]
#if !_FS_READONLY
	UINT n;
#endif

	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8009a6e:	687b      	ldr	r3, [r7, #4]
 8009a70:	695b      	ldr	r3, [r3, #20]
 8009a72:	3320      	adds	r3, #32
 8009a74:	60bb      	str	r3, [r7, #8]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8009a76:	687b      	ldr	r3, [r7, #4]
 8009a78:	69db      	ldr	r3, [r3, #28]
 8009a7a:	2b00      	cmp	r3, #0
 8009a7c:	d003      	beq.n	8009a86 <dir_next+0x28>
 8009a7e:	68bb      	ldr	r3, [r7, #8]
 8009a80:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8009a84:	d301      	bcc.n	8009a8a <dir_next+0x2c>
 8009a86:	2304      	movs	r3, #4
 8009a88:	e0aa      	b.n	8009be0 <dir_next+0x182>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8009a8a:	68bb      	ldr	r3, [r7, #8]
 8009a8c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009a90:	2b00      	cmp	r3, #0
 8009a92:	f040 8098 	bne.w	8009bc6 <dir_next+0x168>
		dp->sect++;				/* Next sector */
 8009a96:	687b      	ldr	r3, [r7, #4]
 8009a98:	69db      	ldr	r3, [r3, #28]
 8009a9a:	1c5a      	adds	r2, r3, #1
 8009a9c:	687b      	ldr	r3, [r7, #4]
 8009a9e:	61da      	str	r2, [r3, #28]

		if (!dp->clust) {		/* Static table */
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	699b      	ldr	r3, [r3, #24]
 8009aa4:	2b00      	cmp	r3, #0
 8009aa6:	d10b      	bne.n	8009ac0 <dir_next+0x62>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8009aa8:	68bb      	ldr	r3, [r7, #8]
 8009aaa:	095b      	lsrs	r3, r3, #5
 8009aac:	68fa      	ldr	r2, [r7, #12]
 8009aae:	8912      	ldrh	r2, [r2, #8]
 8009ab0:	4293      	cmp	r3, r2
 8009ab2:	f0c0 8088 	bcc.w	8009bc6 <dir_next+0x168>
				dp->sect = 0; return FR_NO_FILE;
 8009ab6:	687b      	ldr	r3, [r7, #4]
 8009ab8:	2200      	movs	r2, #0
 8009aba:	61da      	str	r2, [r3, #28]
 8009abc:	2304      	movs	r3, #4
 8009abe:	e08f      	b.n	8009be0 <dir_next+0x182>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8009ac0:	68bb      	ldr	r3, [r7, #8]
 8009ac2:	0a5b      	lsrs	r3, r3, #9
 8009ac4:	68fa      	ldr	r2, [r7, #12]
 8009ac6:	8952      	ldrh	r2, [r2, #10]
 8009ac8:	3a01      	subs	r2, #1
 8009aca:	4013      	ands	r3, r2
 8009acc:	2b00      	cmp	r3, #0
 8009ace:	d17a      	bne.n	8009bc6 <dir_next+0x168>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8009ad0:	687a      	ldr	r2, [r7, #4]
 8009ad2:	687b      	ldr	r3, [r7, #4]
 8009ad4:	699b      	ldr	r3, [r3, #24]
 8009ad6:	4619      	mov	r1, r3
 8009ad8:	4610      	mov	r0, r2
 8009ada:	f7ff fc80 	bl	80093de <get_fat>
 8009ade:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8009ae0:	697b      	ldr	r3, [r7, #20]
 8009ae2:	2b01      	cmp	r3, #1
 8009ae4:	d801      	bhi.n	8009aea <dir_next+0x8c>
 8009ae6:	2302      	movs	r3, #2
 8009ae8:	e07a      	b.n	8009be0 <dir_next+0x182>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8009aea:	697b      	ldr	r3, [r7, #20]
 8009aec:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009af0:	d101      	bne.n	8009af6 <dir_next+0x98>
 8009af2:	2301      	movs	r3, #1
 8009af4:	e074      	b.n	8009be0 <dir_next+0x182>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 8009af6:	68fb      	ldr	r3, [r7, #12]
 8009af8:	699b      	ldr	r3, [r3, #24]
 8009afa:	697a      	ldr	r2, [r7, #20]
 8009afc:	429a      	cmp	r2, r3
 8009afe:	d358      	bcc.n	8009bb2 <dir_next+0x154>
#if !_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
 8009b00:	683b      	ldr	r3, [r7, #0]
 8009b02:	2b00      	cmp	r3, #0
 8009b04:	d104      	bne.n	8009b10 <dir_next+0xb2>
						dp->sect = 0; return FR_NO_FILE;
 8009b06:	687b      	ldr	r3, [r7, #4]
 8009b08:	2200      	movs	r2, #0
 8009b0a:	61da      	str	r2, [r3, #28]
 8009b0c:	2304      	movs	r3, #4
 8009b0e:	e067      	b.n	8009be0 <dir_next+0x182>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8009b10:	687a      	ldr	r2, [r7, #4]
 8009b12:	687b      	ldr	r3, [r7, #4]
 8009b14:	699b      	ldr	r3, [r3, #24]
 8009b16:	4619      	mov	r1, r3
 8009b18:	4610      	mov	r0, r2
 8009b1a:	f7ff fe59 	bl	80097d0 <create_chain>
 8009b1e:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8009b20:	697b      	ldr	r3, [r7, #20]
 8009b22:	2b00      	cmp	r3, #0
 8009b24:	d101      	bne.n	8009b2a <dir_next+0xcc>
 8009b26:	2307      	movs	r3, #7
 8009b28:	e05a      	b.n	8009be0 <dir_next+0x182>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8009b2a:	697b      	ldr	r3, [r7, #20]
 8009b2c:	2b01      	cmp	r3, #1
 8009b2e:	d101      	bne.n	8009b34 <dir_next+0xd6>
 8009b30:	2302      	movs	r3, #2
 8009b32:	e055      	b.n	8009be0 <dir_next+0x182>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8009b34:	697b      	ldr	r3, [r7, #20]
 8009b36:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009b3a:	d101      	bne.n	8009b40 <dir_next+0xe2>
 8009b3c:	2301      	movs	r3, #1
 8009b3e:	e04f      	b.n	8009be0 <dir_next+0x182>
					/* Clean-up the stretched table */
					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8009b40:	68f8      	ldr	r0, [r7, #12]
 8009b42:	f7ff fb4d 	bl	80091e0 <sync_window>
 8009b46:	4603      	mov	r3, r0
 8009b48:	2b00      	cmp	r3, #0
 8009b4a:	d001      	beq.n	8009b50 <dir_next+0xf2>
 8009b4c:	2301      	movs	r3, #1
 8009b4e:	e047      	b.n	8009be0 <dir_next+0x182>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 8009b50:	68fb      	ldr	r3, [r7, #12]
 8009b52:	3334      	adds	r3, #52	; 0x34
 8009b54:	f44f 7200 	mov.w	r2, #512	; 0x200
 8009b58:	2100      	movs	r1, #0
 8009b5a:	4618      	mov	r0, r3
 8009b5c:	f7ff f977 	bl	8008e4e <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8009b60:	2300      	movs	r3, #0
 8009b62:	613b      	str	r3, [r7, #16]
 8009b64:	6979      	ldr	r1, [r7, #20]
 8009b66:	68f8      	ldr	r0, [r7, #12]
 8009b68:	f7ff fc1a 	bl	80093a0 <clust2sect>
 8009b6c:	4602      	mov	r2, r0
 8009b6e:	68fb      	ldr	r3, [r7, #12]
 8009b70:	631a      	str	r2, [r3, #48]	; 0x30
 8009b72:	e012      	b.n	8009b9a <dir_next+0x13c>
						fs->wflag = 1;
 8009b74:	68fb      	ldr	r3, [r7, #12]
 8009b76:	2201      	movs	r2, #1
 8009b78:	70da      	strb	r2, [r3, #3]
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 8009b7a:	68f8      	ldr	r0, [r7, #12]
 8009b7c:	f7ff fb30 	bl	80091e0 <sync_window>
 8009b80:	4603      	mov	r3, r0
 8009b82:	2b00      	cmp	r3, #0
 8009b84:	d001      	beq.n	8009b8a <dir_next+0x12c>
 8009b86:	2301      	movs	r3, #1
 8009b88:	e02a      	b.n	8009be0 <dir_next+0x182>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8009b8a:	693b      	ldr	r3, [r7, #16]
 8009b8c:	3301      	adds	r3, #1
 8009b8e:	613b      	str	r3, [r7, #16]
 8009b90:	68fb      	ldr	r3, [r7, #12]
 8009b92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009b94:	1c5a      	adds	r2, r3, #1
 8009b96:	68fb      	ldr	r3, [r7, #12]
 8009b98:	631a      	str	r2, [r3, #48]	; 0x30
 8009b9a:	68fb      	ldr	r3, [r7, #12]
 8009b9c:	895b      	ldrh	r3, [r3, #10]
 8009b9e:	461a      	mov	r2, r3
 8009ba0:	693b      	ldr	r3, [r7, #16]
 8009ba2:	4293      	cmp	r3, r2
 8009ba4:	d3e6      	bcc.n	8009b74 <dir_next+0x116>
					}
					fs->winsect -= n;							/* Restore window offset */
 8009ba6:	68fb      	ldr	r3, [r7, #12]
 8009ba8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009baa:	693b      	ldr	r3, [r7, #16]
 8009bac:	1ad2      	subs	r2, r2, r3
 8009bae:	68fb      	ldr	r3, [r7, #12]
 8009bb0:	631a      	str	r2, [r3, #48]	; 0x30
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
 8009bb2:	687b      	ldr	r3, [r7, #4]
 8009bb4:	697a      	ldr	r2, [r7, #20]
 8009bb6:	619a      	str	r2, [r3, #24]
				dp->sect = clust2sect(fs, clst);
 8009bb8:	6979      	ldr	r1, [r7, #20]
 8009bba:	68f8      	ldr	r0, [r7, #12]
 8009bbc:	f7ff fbf0 	bl	80093a0 <clust2sect>
 8009bc0:	4602      	mov	r2, r0
 8009bc2:	687b      	ldr	r3, [r7, #4]
 8009bc4:	61da      	str	r2, [r3, #28]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
 8009bc6:	687b      	ldr	r3, [r7, #4]
 8009bc8:	68ba      	ldr	r2, [r7, #8]
 8009bca:	615a      	str	r2, [r3, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8009bcc:	68fb      	ldr	r3, [r7, #12]
 8009bce:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8009bd2:	68bb      	ldr	r3, [r7, #8]
 8009bd4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009bd8:	441a      	add	r2, r3
 8009bda:	687b      	ldr	r3, [r7, #4]
 8009bdc:	621a      	str	r2, [r3, #32]

	return FR_OK;
 8009bde:	2300      	movs	r3, #0
}
 8009be0:	4618      	mov	r0, r3
 8009be2:	3718      	adds	r7, #24
 8009be4:	46bd      	mov	sp, r7
 8009be6:	bd80      	pop	{r7, pc}

08009be8 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate */
)
{
 8009be8:	b580      	push	{r7, lr}
 8009bea:	b086      	sub	sp, #24
 8009bec:	af00      	add	r7, sp, #0
 8009bee:	6078      	str	r0, [r7, #4]
 8009bf0:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	681b      	ldr	r3, [r3, #0]
 8009bf6:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
 8009bf8:	2100      	movs	r1, #0
 8009bfa:	6878      	ldr	r0, [r7, #4]
 8009bfc:	f7ff feb4 	bl	8009968 <dir_sdi>
 8009c00:	4603      	mov	r3, r0
 8009c02:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8009c04:	7dfb      	ldrb	r3, [r7, #23]
 8009c06:	2b00      	cmp	r3, #0
 8009c08:	d12b      	bne.n	8009c62 <dir_alloc+0x7a>
		n = 0;
 8009c0a:	2300      	movs	r3, #0
 8009c0c:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
 8009c0e:	687b      	ldr	r3, [r7, #4]
 8009c10:	69db      	ldr	r3, [r3, #28]
 8009c12:	4619      	mov	r1, r3
 8009c14:	68f8      	ldr	r0, [r7, #12]
 8009c16:	f7ff fb27 	bl	8009268 <move_window>
 8009c1a:	4603      	mov	r3, r0
 8009c1c:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 8009c1e:	7dfb      	ldrb	r3, [r7, #23]
 8009c20:	2b00      	cmp	r3, #0
 8009c22:	d11d      	bne.n	8009c60 <dir_alloc+0x78>
#if _FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	6a1b      	ldr	r3, [r3, #32]
 8009c28:	781b      	ldrb	r3, [r3, #0]
 8009c2a:	2be5      	cmp	r3, #229	; 0xe5
 8009c2c:	d004      	beq.n	8009c38 <dir_alloc+0x50>
 8009c2e:	687b      	ldr	r3, [r7, #4]
 8009c30:	6a1b      	ldr	r3, [r3, #32]
 8009c32:	781b      	ldrb	r3, [r3, #0]
 8009c34:	2b00      	cmp	r3, #0
 8009c36:	d107      	bne.n	8009c48 <dir_alloc+0x60>
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8009c38:	693b      	ldr	r3, [r7, #16]
 8009c3a:	3301      	adds	r3, #1
 8009c3c:	613b      	str	r3, [r7, #16]
 8009c3e:	693a      	ldr	r2, [r7, #16]
 8009c40:	683b      	ldr	r3, [r7, #0]
 8009c42:	429a      	cmp	r2, r3
 8009c44:	d102      	bne.n	8009c4c <dir_alloc+0x64>
 8009c46:	e00c      	b.n	8009c62 <dir_alloc+0x7a>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 8009c48:	2300      	movs	r3, #0
 8009c4a:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);
 8009c4c:	2101      	movs	r1, #1
 8009c4e:	6878      	ldr	r0, [r7, #4]
 8009c50:	f7ff ff05 	bl	8009a5e <dir_next>
 8009c54:	4603      	mov	r3, r0
 8009c56:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 8009c58:	7dfb      	ldrb	r3, [r7, #23]
 8009c5a:	2b00      	cmp	r3, #0
 8009c5c:	d0d7      	beq.n	8009c0e <dir_alloc+0x26>
 8009c5e:	e000      	b.n	8009c62 <dir_alloc+0x7a>
			if (res != FR_OK) break;
 8009c60:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8009c62:	7dfb      	ldrb	r3, [r7, #23]
 8009c64:	2b04      	cmp	r3, #4
 8009c66:	d101      	bne.n	8009c6c <dir_alloc+0x84>
 8009c68:	2307      	movs	r3, #7
 8009c6a:	75fb      	strb	r3, [r7, #23]
	return res;
 8009c6c:	7dfb      	ldrb	r3, [r7, #23]
}
 8009c6e:	4618      	mov	r0, r3
 8009c70:	3718      	adds	r7, #24
 8009c72:	46bd      	mov	sp, r7
 8009c74:	bd80      	pop	{r7, pc}

08009c76 <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the key entry */
)
{
 8009c76:	b580      	push	{r7, lr}
 8009c78:	b084      	sub	sp, #16
 8009c7a:	af00      	add	r7, sp, #0
 8009c7c:	6078      	str	r0, [r7, #4]
 8009c7e:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
 8009c80:	683b      	ldr	r3, [r7, #0]
 8009c82:	331a      	adds	r3, #26
 8009c84:	4618      	mov	r0, r3
 8009c86:	f7ff f83f 	bl	8008d08 <ld_word>
 8009c8a:	4603      	mov	r3, r0
 8009c8c:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
 8009c8e:	687b      	ldr	r3, [r7, #4]
 8009c90:	781b      	ldrb	r3, [r3, #0]
 8009c92:	2b03      	cmp	r3, #3
 8009c94:	d109      	bne.n	8009caa <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8009c96:	683b      	ldr	r3, [r7, #0]
 8009c98:	3314      	adds	r3, #20
 8009c9a:	4618      	mov	r0, r3
 8009c9c:	f7ff f834 	bl	8008d08 <ld_word>
 8009ca0:	4603      	mov	r3, r0
 8009ca2:	041b      	lsls	r3, r3, #16
 8009ca4:	68fa      	ldr	r2, [r7, #12]
 8009ca6:	4313      	orrs	r3, r2
 8009ca8:	60fb      	str	r3, [r7, #12]
	}

	return cl;
 8009caa:	68fb      	ldr	r3, [r7, #12]
}
 8009cac:	4618      	mov	r0, r3
 8009cae:	3710      	adds	r7, #16
 8009cb0:	46bd      	mov	sp, r7
 8009cb2:	bd80      	pop	{r7, pc}

08009cb4 <st_clust>:
void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
 8009cb4:	b580      	push	{r7, lr}
 8009cb6:	b084      	sub	sp, #16
 8009cb8:	af00      	add	r7, sp, #0
 8009cba:	60f8      	str	r0, [r7, #12]
 8009cbc:	60b9      	str	r1, [r7, #8]
 8009cbe:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 8009cc0:	68bb      	ldr	r3, [r7, #8]
 8009cc2:	331a      	adds	r3, #26
 8009cc4:	687a      	ldr	r2, [r7, #4]
 8009cc6:	b292      	uxth	r2, r2
 8009cc8:	4611      	mov	r1, r2
 8009cca:	4618      	mov	r0, r3
 8009ccc:	f7ff f857 	bl	8008d7e <st_word>
	if (fs->fs_type == FS_FAT32) {
 8009cd0:	68fb      	ldr	r3, [r7, #12]
 8009cd2:	781b      	ldrb	r3, [r3, #0]
 8009cd4:	2b03      	cmp	r3, #3
 8009cd6:	d109      	bne.n	8009cec <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8009cd8:	68bb      	ldr	r3, [r7, #8]
 8009cda:	f103 0214 	add.w	r2, r3, #20
 8009cde:	687b      	ldr	r3, [r7, #4]
 8009ce0:	0c1b      	lsrs	r3, r3, #16
 8009ce2:	b29b      	uxth	r3, r3
 8009ce4:	4619      	mov	r1, r3
 8009ce6:	4610      	mov	r0, r2
 8009ce8:	f7ff f849 	bl	8008d7e <st_word>
	}
}
 8009cec:	bf00      	nop
 8009cee:	3710      	adds	r7, #16
 8009cf0:	46bd      	mov	sp, r7
 8009cf2:	bd80      	pop	{r7, pc}

08009cf4 <cmp_lfn>:
static
int cmp_lfn (				/* 1:matched, 0:not matched */
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
)
{
 8009cf4:	b590      	push	{r4, r7, lr}
 8009cf6:	b087      	sub	sp, #28
 8009cf8:	af00      	add	r7, sp, #0
 8009cfa:	6078      	str	r0, [r7, #4]
 8009cfc:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8009cfe:	683b      	ldr	r3, [r7, #0]
 8009d00:	331a      	adds	r3, #26
 8009d02:	4618      	mov	r0, r3
 8009d04:	f7ff f800 	bl	8008d08 <ld_word>
 8009d08:	4603      	mov	r3, r0
 8009d0a:	2b00      	cmp	r3, #0
 8009d0c:	d001      	beq.n	8009d12 <cmp_lfn+0x1e>
 8009d0e:	2300      	movs	r3, #0
 8009d10:	e059      	b.n	8009dc6 <cmp_lfn+0xd2>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8009d12:	683b      	ldr	r3, [r7, #0]
 8009d14:	781b      	ldrb	r3, [r3, #0]
 8009d16:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009d1a:	1e5a      	subs	r2, r3, #1
 8009d1c:	4613      	mov	r3, r2
 8009d1e:	005b      	lsls	r3, r3, #1
 8009d20:	4413      	add	r3, r2
 8009d22:	009b      	lsls	r3, r3, #2
 8009d24:	4413      	add	r3, r2
 8009d26:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8009d28:	2301      	movs	r3, #1
 8009d2a:	81fb      	strh	r3, [r7, #14]
 8009d2c:	2300      	movs	r3, #0
 8009d2e:	613b      	str	r3, [r7, #16]
 8009d30:	e033      	b.n	8009d9a <cmp_lfn+0xa6>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8009d32:	4a27      	ldr	r2, [pc, #156]	; (8009dd0 <cmp_lfn+0xdc>)
 8009d34:	693b      	ldr	r3, [r7, #16]
 8009d36:	4413      	add	r3, r2
 8009d38:	781b      	ldrb	r3, [r3, #0]
 8009d3a:	461a      	mov	r2, r3
 8009d3c:	683b      	ldr	r3, [r7, #0]
 8009d3e:	4413      	add	r3, r2
 8009d40:	4618      	mov	r0, r3
 8009d42:	f7fe ffe1 	bl	8008d08 <ld_word>
 8009d46:	4603      	mov	r3, r0
 8009d48:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 8009d4a:	89fb      	ldrh	r3, [r7, #14]
 8009d4c:	2b00      	cmp	r3, #0
 8009d4e:	d01a      	beq.n	8009d86 <cmp_lfn+0x92>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8009d50:	697b      	ldr	r3, [r7, #20]
 8009d52:	2bfe      	cmp	r3, #254	; 0xfe
 8009d54:	d812      	bhi.n	8009d7c <cmp_lfn+0x88>
 8009d56:	89bb      	ldrh	r3, [r7, #12]
 8009d58:	4618      	mov	r0, r3
 8009d5a:	f002 f883 	bl	800be64 <ff_wtoupper>
 8009d5e:	4603      	mov	r3, r0
 8009d60:	461c      	mov	r4, r3
 8009d62:	697b      	ldr	r3, [r7, #20]
 8009d64:	1c5a      	adds	r2, r3, #1
 8009d66:	617a      	str	r2, [r7, #20]
 8009d68:	005b      	lsls	r3, r3, #1
 8009d6a:	687a      	ldr	r2, [r7, #4]
 8009d6c:	4413      	add	r3, r2
 8009d6e:	881b      	ldrh	r3, [r3, #0]
 8009d70:	4618      	mov	r0, r3
 8009d72:	f002 f877 	bl	800be64 <ff_wtoupper>
 8009d76:	4603      	mov	r3, r0
 8009d78:	429c      	cmp	r4, r3
 8009d7a:	d001      	beq.n	8009d80 <cmp_lfn+0x8c>
				return 0;					/* Not matched */
 8009d7c:	2300      	movs	r3, #0
 8009d7e:	e022      	b.n	8009dc6 <cmp_lfn+0xd2>
			}
			wc = uc;
 8009d80:	89bb      	ldrh	r3, [r7, #12]
 8009d82:	81fb      	strh	r3, [r7, #14]
 8009d84:	e006      	b.n	8009d94 <cmp_lfn+0xa0>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8009d86:	89bb      	ldrh	r3, [r7, #12]
 8009d88:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009d8c:	4293      	cmp	r3, r2
 8009d8e:	d001      	beq.n	8009d94 <cmp_lfn+0xa0>
 8009d90:	2300      	movs	r3, #0
 8009d92:	e018      	b.n	8009dc6 <cmp_lfn+0xd2>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8009d94:	693b      	ldr	r3, [r7, #16]
 8009d96:	3301      	adds	r3, #1
 8009d98:	613b      	str	r3, [r7, #16]
 8009d9a:	693b      	ldr	r3, [r7, #16]
 8009d9c:	2b0c      	cmp	r3, #12
 8009d9e:	d9c8      	bls.n	8009d32 <cmp_lfn+0x3e>
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8009da0:	683b      	ldr	r3, [r7, #0]
 8009da2:	781b      	ldrb	r3, [r3, #0]
 8009da4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009da8:	2b00      	cmp	r3, #0
 8009daa:	d00b      	beq.n	8009dc4 <cmp_lfn+0xd0>
 8009dac:	89fb      	ldrh	r3, [r7, #14]
 8009dae:	2b00      	cmp	r3, #0
 8009db0:	d008      	beq.n	8009dc4 <cmp_lfn+0xd0>
 8009db2:	697b      	ldr	r3, [r7, #20]
 8009db4:	005b      	lsls	r3, r3, #1
 8009db6:	687a      	ldr	r2, [r7, #4]
 8009db8:	4413      	add	r3, r2
 8009dba:	881b      	ldrh	r3, [r3, #0]
 8009dbc:	2b00      	cmp	r3, #0
 8009dbe:	d001      	beq.n	8009dc4 <cmp_lfn+0xd0>
 8009dc0:	2300      	movs	r3, #0
 8009dc2:	e000      	b.n	8009dc6 <cmp_lfn+0xd2>

	return 1;		/* The part of LFN matched */
 8009dc4:	2301      	movs	r3, #1
}
 8009dc6:	4618      	mov	r0, r3
 8009dc8:	371c      	adds	r7, #28
 8009dca:	46bd      	mov	sp, r7
 8009dcc:	bd90      	pop	{r4, r7, pc}
 8009dce:	bf00      	nop
 8009dd0:	08029f98 	.word	0x08029f98

08009dd4 <pick_lfn>:
static
int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
	BYTE* dir			/* Pointer to the LFN entry */
)
{
 8009dd4:	b580      	push	{r7, lr}
 8009dd6:	b086      	sub	sp, #24
 8009dd8:	af00      	add	r7, sp, #0
 8009dda:	6078      	str	r0, [r7, #4]
 8009ddc:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 8009dde:	683b      	ldr	r3, [r7, #0]
 8009de0:	331a      	adds	r3, #26
 8009de2:	4618      	mov	r0, r3
 8009de4:	f7fe ff90 	bl	8008d08 <ld_word>
 8009de8:	4603      	mov	r3, r0
 8009dea:	2b00      	cmp	r3, #0
 8009dec:	d001      	beq.n	8009df2 <pick_lfn+0x1e>
 8009dee:	2300      	movs	r3, #0
 8009df0:	e04d      	b.n	8009e8e <pick_lfn+0xba>

	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 8009df2:	683b      	ldr	r3, [r7, #0]
 8009df4:	781b      	ldrb	r3, [r3, #0]
 8009df6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009dfa:	1e5a      	subs	r2, r3, #1
 8009dfc:	4613      	mov	r3, r2
 8009dfe:	005b      	lsls	r3, r3, #1
 8009e00:	4413      	add	r3, r2
 8009e02:	009b      	lsls	r3, r3, #2
 8009e04:	4413      	add	r3, r2
 8009e06:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8009e08:	2301      	movs	r3, #1
 8009e0a:	81fb      	strh	r3, [r7, #14]
 8009e0c:	2300      	movs	r3, #0
 8009e0e:	613b      	str	r3, [r7, #16]
 8009e10:	e028      	b.n	8009e64 <pick_lfn+0x90>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8009e12:	4a21      	ldr	r2, [pc, #132]	; (8009e98 <pick_lfn+0xc4>)
 8009e14:	693b      	ldr	r3, [r7, #16]
 8009e16:	4413      	add	r3, r2
 8009e18:	781b      	ldrb	r3, [r3, #0]
 8009e1a:	461a      	mov	r2, r3
 8009e1c:	683b      	ldr	r3, [r7, #0]
 8009e1e:	4413      	add	r3, r2
 8009e20:	4618      	mov	r0, r3
 8009e22:	f7fe ff71 	bl	8008d08 <ld_word>
 8009e26:	4603      	mov	r3, r0
 8009e28:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 8009e2a:	89fb      	ldrh	r3, [r7, #14]
 8009e2c:	2b00      	cmp	r3, #0
 8009e2e:	d00f      	beq.n	8009e50 <pick_lfn+0x7c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 8009e30:	697b      	ldr	r3, [r7, #20]
 8009e32:	2bfe      	cmp	r3, #254	; 0xfe
 8009e34:	d901      	bls.n	8009e3a <pick_lfn+0x66>
 8009e36:	2300      	movs	r3, #0
 8009e38:	e029      	b.n	8009e8e <pick_lfn+0xba>
			lfnbuf[i++] = wc = uc;			/* Store it */
 8009e3a:	89bb      	ldrh	r3, [r7, #12]
 8009e3c:	81fb      	strh	r3, [r7, #14]
 8009e3e:	697b      	ldr	r3, [r7, #20]
 8009e40:	1c5a      	adds	r2, r3, #1
 8009e42:	617a      	str	r2, [r7, #20]
 8009e44:	005b      	lsls	r3, r3, #1
 8009e46:	687a      	ldr	r2, [r7, #4]
 8009e48:	4413      	add	r3, r2
 8009e4a:	89fa      	ldrh	r2, [r7, #14]
 8009e4c:	801a      	strh	r2, [r3, #0]
 8009e4e:	e006      	b.n	8009e5e <pick_lfn+0x8a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8009e50:	89bb      	ldrh	r3, [r7, #12]
 8009e52:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009e56:	4293      	cmp	r3, r2
 8009e58:	d001      	beq.n	8009e5e <pick_lfn+0x8a>
 8009e5a:	2300      	movs	r3, #0
 8009e5c:	e017      	b.n	8009e8e <pick_lfn+0xba>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8009e5e:	693b      	ldr	r3, [r7, #16]
 8009e60:	3301      	adds	r3, #1
 8009e62:	613b      	str	r3, [r7, #16]
 8009e64:	693b      	ldr	r3, [r7, #16]
 8009e66:	2b0c      	cmp	r3, #12
 8009e68:	d9d3      	bls.n	8009e12 <pick_lfn+0x3e>
		}
	}

	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 8009e6a:	683b      	ldr	r3, [r7, #0]
 8009e6c:	781b      	ldrb	r3, [r3, #0]
 8009e6e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009e72:	2b00      	cmp	r3, #0
 8009e74:	d00a      	beq.n	8009e8c <pick_lfn+0xb8>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 8009e76:	697b      	ldr	r3, [r7, #20]
 8009e78:	2bfe      	cmp	r3, #254	; 0xfe
 8009e7a:	d901      	bls.n	8009e80 <pick_lfn+0xac>
 8009e7c:	2300      	movs	r3, #0
 8009e7e:	e006      	b.n	8009e8e <pick_lfn+0xba>
		lfnbuf[i] = 0;
 8009e80:	697b      	ldr	r3, [r7, #20]
 8009e82:	005b      	lsls	r3, r3, #1
 8009e84:	687a      	ldr	r2, [r7, #4]
 8009e86:	4413      	add	r3, r2
 8009e88:	2200      	movs	r2, #0
 8009e8a:	801a      	strh	r2, [r3, #0]
	}

	return 1;		/* The part of LFN is valid */
 8009e8c:	2301      	movs	r3, #1
}
 8009e8e:	4618      	mov	r0, r3
 8009e90:	3718      	adds	r7, #24
 8009e92:	46bd      	mov	sp, r7
 8009e94:	bd80      	pop	{r7, pc}
 8009e96:	bf00      	nop
 8009e98:	08029f98 	.word	0x08029f98

08009e9c <put_lfn>:
	const WCHAR* lfn,	/* Pointer to the LFN */
	BYTE* dir,			/* Pointer to the LFN entry to be created */
	BYTE ord,			/* LFN order (1-20) */
	BYTE sum			/* Checksum of the corresponding SFN */
)
{
 8009e9c:	b580      	push	{r7, lr}
 8009e9e:	b088      	sub	sp, #32
 8009ea0:	af00      	add	r7, sp, #0
 8009ea2:	60f8      	str	r0, [r7, #12]
 8009ea4:	60b9      	str	r1, [r7, #8]
 8009ea6:	4611      	mov	r1, r2
 8009ea8:	461a      	mov	r2, r3
 8009eaa:	460b      	mov	r3, r1
 8009eac:	71fb      	strb	r3, [r7, #7]
 8009eae:	4613      	mov	r3, r2
 8009eb0:	71bb      	strb	r3, [r7, #6]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
 8009eb2:	68bb      	ldr	r3, [r7, #8]
 8009eb4:	330d      	adds	r3, #13
 8009eb6:	79ba      	ldrb	r2, [r7, #6]
 8009eb8:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8009eba:	68bb      	ldr	r3, [r7, #8]
 8009ebc:	330b      	adds	r3, #11
 8009ebe:	220f      	movs	r2, #15
 8009ec0:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
 8009ec2:	68bb      	ldr	r3, [r7, #8]
 8009ec4:	330c      	adds	r3, #12
 8009ec6:	2200      	movs	r2, #0
 8009ec8:	701a      	strb	r2, [r3, #0]
	st_word(dir + LDIR_FstClusLO, 0);
 8009eca:	68bb      	ldr	r3, [r7, #8]
 8009ecc:	331a      	adds	r3, #26
 8009ece:	2100      	movs	r1, #0
 8009ed0:	4618      	mov	r0, r3
 8009ed2:	f7fe ff54 	bl	8008d7e <st_word>

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 8009ed6:	79fb      	ldrb	r3, [r7, #7]
 8009ed8:	1e5a      	subs	r2, r3, #1
 8009eda:	4613      	mov	r3, r2
 8009edc:	005b      	lsls	r3, r3, #1
 8009ede:	4413      	add	r3, r2
 8009ee0:	009b      	lsls	r3, r3, #2
 8009ee2:	4413      	add	r3, r2
 8009ee4:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
 8009ee6:	2300      	movs	r3, #0
 8009ee8:	82fb      	strh	r3, [r7, #22]
 8009eea:	2300      	movs	r3, #0
 8009eec:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 8009eee:	8afb      	ldrh	r3, [r7, #22]
 8009ef0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009ef4:	4293      	cmp	r3, r2
 8009ef6:	d007      	beq.n	8009f08 <put_lfn+0x6c>
 8009ef8:	69fb      	ldr	r3, [r7, #28]
 8009efa:	1c5a      	adds	r2, r3, #1
 8009efc:	61fa      	str	r2, [r7, #28]
 8009efe:	005b      	lsls	r3, r3, #1
 8009f00:	68fa      	ldr	r2, [r7, #12]
 8009f02:	4413      	add	r3, r2
 8009f04:	881b      	ldrh	r3, [r3, #0]
 8009f06:	82fb      	strh	r3, [r7, #22]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8009f08:	4a17      	ldr	r2, [pc, #92]	; (8009f68 <put_lfn+0xcc>)
 8009f0a:	69bb      	ldr	r3, [r7, #24]
 8009f0c:	4413      	add	r3, r2
 8009f0e:	781b      	ldrb	r3, [r3, #0]
 8009f10:	461a      	mov	r2, r3
 8009f12:	68bb      	ldr	r3, [r7, #8]
 8009f14:	4413      	add	r3, r2
 8009f16:	8afa      	ldrh	r2, [r7, #22]
 8009f18:	4611      	mov	r1, r2
 8009f1a:	4618      	mov	r0, r3
 8009f1c:	f7fe ff2f 	bl	8008d7e <st_word>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 8009f20:	8afb      	ldrh	r3, [r7, #22]
 8009f22:	2b00      	cmp	r3, #0
 8009f24:	d102      	bne.n	8009f2c <put_lfn+0x90>
 8009f26:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009f2a:	82fb      	strh	r3, [r7, #22]
	} while (++s < 13);
 8009f2c:	69bb      	ldr	r3, [r7, #24]
 8009f2e:	3301      	adds	r3, #1
 8009f30:	61bb      	str	r3, [r7, #24]
 8009f32:	69bb      	ldr	r3, [r7, #24]
 8009f34:	2b0c      	cmp	r3, #12
 8009f36:	d9da      	bls.n	8009eee <put_lfn+0x52>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 8009f38:	8afb      	ldrh	r3, [r7, #22]
 8009f3a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009f3e:	4293      	cmp	r3, r2
 8009f40:	d006      	beq.n	8009f50 <put_lfn+0xb4>
 8009f42:	69fb      	ldr	r3, [r7, #28]
 8009f44:	005b      	lsls	r3, r3, #1
 8009f46:	68fa      	ldr	r2, [r7, #12]
 8009f48:	4413      	add	r3, r2
 8009f4a:	881b      	ldrh	r3, [r3, #0]
 8009f4c:	2b00      	cmp	r3, #0
 8009f4e:	d103      	bne.n	8009f58 <put_lfn+0xbc>
 8009f50:	79fb      	ldrb	r3, [r7, #7]
 8009f52:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009f56:	71fb      	strb	r3, [r7, #7]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8009f58:	68bb      	ldr	r3, [r7, #8]
 8009f5a:	79fa      	ldrb	r2, [r7, #7]
 8009f5c:	701a      	strb	r2, [r3, #0]
}
 8009f5e:	bf00      	nop
 8009f60:	3720      	adds	r7, #32
 8009f62:	46bd      	mov	sp, r7
 8009f64:	bd80      	pop	{r7, pc}
 8009f66:	bf00      	nop
 8009f68:	08029f98 	.word	0x08029f98

08009f6c <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 8009f6c:	b580      	push	{r7, lr}
 8009f6e:	b08c      	sub	sp, #48	; 0x30
 8009f70:	af00      	add	r7, sp, #0
 8009f72:	60f8      	str	r0, [r7, #12]
 8009f74:	60b9      	str	r1, [r7, #8]
 8009f76:	607a      	str	r2, [r7, #4]
 8009f78:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 8009f7a:	220b      	movs	r2, #11
 8009f7c:	68b9      	ldr	r1, [r7, #8]
 8009f7e:	68f8      	ldr	r0, [r7, #12]
 8009f80:	f7fe ff44 	bl	8008e0c <mem_cpy>

	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8009f84:	683b      	ldr	r3, [r7, #0]
 8009f86:	2b05      	cmp	r3, #5
 8009f88:	d92b      	bls.n	8009fe2 <gen_numname+0x76>
		sr = seq;
 8009f8a:	683b      	ldr	r3, [r7, #0]
 8009f8c:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC */
 8009f8e:	e022      	b.n	8009fd6 <gen_numname+0x6a>
			wc = *lfn++;
 8009f90:	687b      	ldr	r3, [r7, #4]
 8009f92:	1c9a      	adds	r2, r3, #2
 8009f94:	607a      	str	r2, [r7, #4]
 8009f96:	881b      	ldrh	r3, [r3, #0]
 8009f98:	847b      	strh	r3, [r7, #34]	; 0x22
			for (i = 0; i < 16; i++) {
 8009f9a:	2300      	movs	r3, #0
 8009f9c:	62bb      	str	r3, [r7, #40]	; 0x28
 8009f9e:	e017      	b.n	8009fd0 <gen_numname+0x64>
				sr = (sr << 1) + (wc & 1);
 8009fa0:	69fb      	ldr	r3, [r7, #28]
 8009fa2:	005a      	lsls	r2, r3, #1
 8009fa4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8009fa6:	f003 0301 	and.w	r3, r3, #1
 8009faa:	4413      	add	r3, r2
 8009fac:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
 8009fae:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8009fb0:	085b      	lsrs	r3, r3, #1
 8009fb2:	847b      	strh	r3, [r7, #34]	; 0x22
				if (sr & 0x10000) sr ^= 0x11021;
 8009fb4:	69fb      	ldr	r3, [r7, #28]
 8009fb6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009fba:	2b00      	cmp	r3, #0
 8009fbc:	d005      	beq.n	8009fca <gen_numname+0x5e>
 8009fbe:	69fb      	ldr	r3, [r7, #28]
 8009fc0:	f483 3388 	eor.w	r3, r3, #69632	; 0x11000
 8009fc4:	f083 0321 	eor.w	r3, r3, #33	; 0x21
 8009fc8:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < 16; i++) {
 8009fca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009fcc:	3301      	adds	r3, #1
 8009fce:	62bb      	str	r3, [r7, #40]	; 0x28
 8009fd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009fd2:	2b0f      	cmp	r3, #15
 8009fd4:	d9e4      	bls.n	8009fa0 <gen_numname+0x34>
		while (*lfn) {	/* Create a CRC */
 8009fd6:	687b      	ldr	r3, [r7, #4]
 8009fd8:	881b      	ldrh	r3, [r3, #0]
 8009fda:	2b00      	cmp	r3, #0
 8009fdc:	d1d8      	bne.n	8009f90 <gen_numname+0x24>
			}
		}
		seq = (UINT)sr;
 8009fde:	69fb      	ldr	r3, [r7, #28]
 8009fe0:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
 8009fe2:	2307      	movs	r3, #7
 8009fe4:	62bb      	str	r3, [r7, #40]	; 0x28
	do {
		c = (BYTE)((seq % 16) + '0');
 8009fe6:	683b      	ldr	r3, [r7, #0]
 8009fe8:	b2db      	uxtb	r3, r3
 8009fea:	f003 030f 	and.w	r3, r3, #15
 8009fee:	b2db      	uxtb	r3, r3
 8009ff0:	3330      	adds	r3, #48	; 0x30
 8009ff2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (c > '9') c += 7;
 8009ff6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8009ffa:	2b39      	cmp	r3, #57	; 0x39
 8009ffc:	d904      	bls.n	800a008 <gen_numname+0x9c>
 8009ffe:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a002:	3307      	adds	r3, #7
 800a004:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		ns[i--] = c;
 800a008:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a00a:	1e5a      	subs	r2, r3, #1
 800a00c:	62ba      	str	r2, [r7, #40]	; 0x28
 800a00e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800a012:	4413      	add	r3, r2
 800a014:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 800a018:	f803 2c1c 	strb.w	r2, [r3, #-28]
		seq /= 16;
 800a01c:	683b      	ldr	r3, [r7, #0]
 800a01e:	091b      	lsrs	r3, r3, #4
 800a020:	603b      	str	r3, [r7, #0]
	} while (seq);
 800a022:	683b      	ldr	r3, [r7, #0]
 800a024:	2b00      	cmp	r3, #0
 800a026:	d1de      	bne.n	8009fe6 <gen_numname+0x7a>
	ns[i] = '~';
 800a028:	f107 0214 	add.w	r2, r7, #20
 800a02c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a02e:	4413      	add	r3, r2
 800a030:	227e      	movs	r2, #126	; 0x7e
 800a032:	701a      	strb	r2, [r3, #0]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800a034:	2300      	movs	r3, #0
 800a036:	627b      	str	r3, [r7, #36]	; 0x24
 800a038:	e002      	b.n	800a040 <gen_numname+0xd4>
 800a03a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a03c:	3301      	adds	r3, #1
 800a03e:	627b      	str	r3, [r7, #36]	; 0x24
 800a040:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800a042:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a044:	429a      	cmp	r2, r3
 800a046:	d205      	bcs.n	800a054 <gen_numname+0xe8>
 800a048:	68fa      	ldr	r2, [r7, #12]
 800a04a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a04c:	4413      	add	r3, r2
 800a04e:	781b      	ldrb	r3, [r3, #0]
 800a050:	2b20      	cmp	r3, #32
 800a052:	d1f2      	bne.n	800a03a <gen_numname+0xce>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800a054:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a056:	2b07      	cmp	r3, #7
 800a058:	d808      	bhi.n	800a06c <gen_numname+0x100>
 800a05a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a05c:	1c5a      	adds	r2, r3, #1
 800a05e:	62ba      	str	r2, [r7, #40]	; 0x28
 800a060:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800a064:	4413      	add	r3, r2
 800a066:	f813 1c1c 	ldrb.w	r1, [r3, #-28]
 800a06a:	e000      	b.n	800a06e <gen_numname+0x102>
 800a06c:	2120      	movs	r1, #32
 800a06e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a070:	1c5a      	adds	r2, r3, #1
 800a072:	627a      	str	r2, [r7, #36]	; 0x24
 800a074:	68fa      	ldr	r2, [r7, #12]
 800a076:	4413      	add	r3, r2
 800a078:	460a      	mov	r2, r1
 800a07a:	701a      	strb	r2, [r3, #0]
	} while (j < 8);
 800a07c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a07e:	2b07      	cmp	r3, #7
 800a080:	d9e8      	bls.n	800a054 <gen_numname+0xe8>
}
 800a082:	bf00      	nop
 800a084:	bf00      	nop
 800a086:	3730      	adds	r7, #48	; 0x30
 800a088:	46bd      	mov	sp, r7
 800a08a:	bd80      	pop	{r7, pc}

0800a08c <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 800a08c:	b480      	push	{r7}
 800a08e:	b085      	sub	sp, #20
 800a090:	af00      	add	r7, sp, #0
 800a092:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
 800a094:	2300      	movs	r3, #0
 800a096:	73fb      	strb	r3, [r7, #15]
	UINT n = 11;
 800a098:	230b      	movs	r3, #11
 800a09a:	60bb      	str	r3, [r7, #8]

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800a09c:	7bfb      	ldrb	r3, [r7, #15]
 800a09e:	b2da      	uxtb	r2, r3
 800a0a0:	0852      	lsrs	r2, r2, #1
 800a0a2:	01db      	lsls	r3, r3, #7
 800a0a4:	4313      	orrs	r3, r2
 800a0a6:	b2da      	uxtb	r2, r3
 800a0a8:	687b      	ldr	r3, [r7, #4]
 800a0aa:	1c59      	adds	r1, r3, #1
 800a0ac:	6079      	str	r1, [r7, #4]
 800a0ae:	781b      	ldrb	r3, [r3, #0]
 800a0b0:	4413      	add	r3, r2
 800a0b2:	73fb      	strb	r3, [r7, #15]
	} while (--n);
 800a0b4:	68bb      	ldr	r3, [r7, #8]
 800a0b6:	3b01      	subs	r3, #1
 800a0b8:	60bb      	str	r3, [r7, #8]
 800a0ba:	68bb      	ldr	r3, [r7, #8]
 800a0bc:	2b00      	cmp	r3, #0
 800a0be:	d1ed      	bne.n	800a09c <sum_sfn+0x10>
	return sum;
 800a0c0:	7bfb      	ldrb	r3, [r7, #15]
}
 800a0c2:	4618      	mov	r0, r3
 800a0c4:	3714      	adds	r7, #20
 800a0c6:	46bd      	mov	sp, r7
 800a0c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0cc:	4770      	bx	lr

0800a0ce <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
 800a0ce:	b580      	push	{r7, lr}
 800a0d0:	b086      	sub	sp, #24
 800a0d2:	af00      	add	r7, sp, #0
 800a0d4:	6078      	str	r0, [r7, #4]
 800a0d6:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_NO_FILE;
 800a0d8:	2304      	movs	r3, #4
 800a0da:	75fb      	strb	r3, [r7, #23]
	FATFS *fs = dp->obj.fs;
 800a0dc:	687b      	ldr	r3, [r7, #4]
 800a0de:	681b      	ldr	r3, [r3, #0]
 800a0e0:	613b      	str	r3, [r7, #16]
	BYTE a, c;
#if _USE_LFN != 0
	BYTE ord = 0xFF, sum = 0xFF;
 800a0e2:	23ff      	movs	r3, #255	; 0xff
 800a0e4:	757b      	strb	r3, [r7, #21]
 800a0e6:	23ff      	movs	r3, #255	; 0xff
 800a0e8:	753b      	strb	r3, [r7, #20]
#endif

	while (dp->sect) {
 800a0ea:	e081      	b.n	800a1f0 <dir_read+0x122>
		res = move_window(fs, dp->sect);
 800a0ec:	687b      	ldr	r3, [r7, #4]
 800a0ee:	69db      	ldr	r3, [r3, #28]
 800a0f0:	4619      	mov	r1, r3
 800a0f2:	6938      	ldr	r0, [r7, #16]
 800a0f4:	f7ff f8b8 	bl	8009268 <move_window>
 800a0f8:	4603      	mov	r3, r0
 800a0fa:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800a0fc:	7dfb      	ldrb	r3, [r7, #23]
 800a0fe:	2b00      	cmp	r3, #0
 800a100:	d17c      	bne.n	800a1fc <dir_read+0x12e>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800a102:	687b      	ldr	r3, [r7, #4]
 800a104:	6a1b      	ldr	r3, [r3, #32]
 800a106:	781b      	ldrb	r3, [r3, #0]
 800a108:	75bb      	strb	r3, [r7, #22]
		if (c == 0) {
 800a10a:	7dbb      	ldrb	r3, [r7, #22]
 800a10c:	2b00      	cmp	r3, #0
 800a10e:	d102      	bne.n	800a116 <dir_read+0x48>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800a110:	2304      	movs	r3, #4
 800a112:	75fb      	strb	r3, [r7, #23]
 800a114:	e077      	b.n	800a206 <dir_read+0x138>
				}
			}
		} else
#endif
		{	/* On the FAT12/16/32 volume */
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800a116:	687b      	ldr	r3, [r7, #4]
 800a118:	6a1b      	ldr	r3, [r3, #32]
 800a11a:	330b      	adds	r3, #11
 800a11c:	781b      	ldrb	r3, [r3, #0]
 800a11e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a122:	73fb      	strb	r3, [r7, #15]
 800a124:	687b      	ldr	r3, [r7, #4]
 800a126:	7bfa      	ldrb	r2, [r7, #15]
 800a128:	719a      	strb	r2, [r3, #6]
#if _USE_LFN != 0	/* LFN configuration */
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800a12a:	7dbb      	ldrb	r3, [r7, #22]
 800a12c:	2be5      	cmp	r3, #229	; 0xe5
 800a12e:	d00e      	beq.n	800a14e <dir_read+0x80>
 800a130:	7dbb      	ldrb	r3, [r7, #22]
 800a132:	2b2e      	cmp	r3, #46	; 0x2e
 800a134:	d00b      	beq.n	800a14e <dir_read+0x80>
 800a136:	7bfb      	ldrb	r3, [r7, #15]
 800a138:	f023 0320 	bic.w	r3, r3, #32
 800a13c:	2b08      	cmp	r3, #8
 800a13e:	bf0c      	ite	eq
 800a140:	2301      	moveq	r3, #1
 800a142:	2300      	movne	r3, #0
 800a144:	b2db      	uxtb	r3, r3
 800a146:	461a      	mov	r2, r3
 800a148:	683b      	ldr	r3, [r7, #0]
 800a14a:	4293      	cmp	r3, r2
 800a14c:	d002      	beq.n	800a154 <dir_read+0x86>
				ord = 0xFF;
 800a14e:	23ff      	movs	r3, #255	; 0xff
 800a150:	757b      	strb	r3, [r7, #21]
 800a152:	e044      	b.n	800a1de <dir_read+0x110>
			} else {
				if (a == AM_LFN) {			/* An LFN entry is found */
 800a154:	7bfb      	ldrb	r3, [r7, #15]
 800a156:	2b0f      	cmp	r3, #15
 800a158:	d12f      	bne.n	800a1ba <dir_read+0xec>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800a15a:	7dbb      	ldrb	r3, [r7, #22]
 800a15c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a160:	2b00      	cmp	r3, #0
 800a162:	d00d      	beq.n	800a180 <dir_read+0xb2>
						sum = dp->dir[LDIR_Chksum];
 800a164:	687b      	ldr	r3, [r7, #4]
 800a166:	6a1b      	ldr	r3, [r3, #32]
 800a168:	7b5b      	ldrb	r3, [r3, #13]
 800a16a:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;
 800a16c:	7dbb      	ldrb	r3, [r7, #22]
 800a16e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a172:	75bb      	strb	r3, [r7, #22]
 800a174:	7dbb      	ldrb	r3, [r7, #22]
 800a176:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;
 800a178:	687b      	ldr	r3, [r7, #4]
 800a17a:	695a      	ldr	r2, [r3, #20]
 800a17c:	687b      	ldr	r3, [r7, #4]
 800a17e:	631a      	str	r2, [r3, #48]	; 0x30
					}
					/* Check LFN validity and capture it */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800a180:	7dba      	ldrb	r2, [r7, #22]
 800a182:	7d7b      	ldrb	r3, [r7, #21]
 800a184:	429a      	cmp	r2, r3
 800a186:	d115      	bne.n	800a1b4 <dir_read+0xe6>
 800a188:	687b      	ldr	r3, [r7, #4]
 800a18a:	6a1b      	ldr	r3, [r3, #32]
 800a18c:	330d      	adds	r3, #13
 800a18e:	781b      	ldrb	r3, [r3, #0]
 800a190:	7d3a      	ldrb	r2, [r7, #20]
 800a192:	429a      	cmp	r2, r3
 800a194:	d10e      	bne.n	800a1b4 <dir_read+0xe6>
 800a196:	693b      	ldr	r3, [r7, #16]
 800a198:	68da      	ldr	r2, [r3, #12]
 800a19a:	687b      	ldr	r3, [r7, #4]
 800a19c:	6a1b      	ldr	r3, [r3, #32]
 800a19e:	4619      	mov	r1, r3
 800a1a0:	4610      	mov	r0, r2
 800a1a2:	f7ff fe17 	bl	8009dd4 <pick_lfn>
 800a1a6:	4603      	mov	r3, r0
 800a1a8:	2b00      	cmp	r3, #0
 800a1aa:	d003      	beq.n	800a1b4 <dir_read+0xe6>
 800a1ac:	7d7b      	ldrb	r3, [r7, #21]
 800a1ae:	3b01      	subs	r3, #1
 800a1b0:	b2db      	uxtb	r3, r3
 800a1b2:	e000      	b.n	800a1b6 <dir_read+0xe8>
 800a1b4:	23ff      	movs	r3, #255	; 0xff
 800a1b6:	757b      	strb	r3, [r7, #21]
 800a1b8:	e011      	b.n	800a1de <dir_read+0x110>
				} else {					/* An SFN entry is found */
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800a1ba:	7d7b      	ldrb	r3, [r7, #21]
 800a1bc:	2b00      	cmp	r3, #0
 800a1be:	d109      	bne.n	800a1d4 <dir_read+0x106>
 800a1c0:	687b      	ldr	r3, [r7, #4]
 800a1c2:	6a1b      	ldr	r3, [r3, #32]
 800a1c4:	4618      	mov	r0, r3
 800a1c6:	f7ff ff61 	bl	800a08c <sum_sfn>
 800a1ca:	4603      	mov	r3, r0
 800a1cc:	461a      	mov	r2, r3
 800a1ce:	7d3b      	ldrb	r3, [r7, #20]
 800a1d0:	4293      	cmp	r3, r2
 800a1d2:	d015      	beq.n	800a200 <dir_read+0x132>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800a1d4:	687b      	ldr	r3, [r7, #4]
 800a1d6:	f04f 32ff 	mov.w	r2, #4294967295
 800a1da:	631a      	str	r2, [r3, #48]	; 0x30
					}
					break;
 800a1dc:	e010      	b.n	800a200 <dir_read+0x132>
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
 800a1de:	2100      	movs	r1, #0
 800a1e0:	6878      	ldr	r0, [r7, #4]
 800a1e2:	f7ff fc3c 	bl	8009a5e <dir_next>
 800a1e6:	4603      	mov	r3, r0
 800a1e8:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800a1ea:	7dfb      	ldrb	r3, [r7, #23]
 800a1ec:	2b00      	cmp	r3, #0
 800a1ee:	d109      	bne.n	800a204 <dir_read+0x136>
	while (dp->sect) {
 800a1f0:	687b      	ldr	r3, [r7, #4]
 800a1f2:	69db      	ldr	r3, [r3, #28]
 800a1f4:	2b00      	cmp	r3, #0
 800a1f6:	f47f af79 	bne.w	800a0ec <dir_read+0x1e>
 800a1fa:	e004      	b.n	800a206 <dir_read+0x138>
		if (res != FR_OK) break;
 800a1fc:	bf00      	nop
 800a1fe:	e002      	b.n	800a206 <dir_read+0x138>
					break;
 800a200:	bf00      	nop
 800a202:	e000      	b.n	800a206 <dir_read+0x138>
		if (res != FR_OK) break;
 800a204:	bf00      	nop
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800a206:	7dfb      	ldrb	r3, [r7, #23]
 800a208:	2b00      	cmp	r3, #0
 800a20a:	d002      	beq.n	800a212 <dir_read+0x144>
 800a20c:	687b      	ldr	r3, [r7, #4]
 800a20e:	2200      	movs	r2, #0
 800a210:	61da      	str	r2, [r3, #28]
	return res;
 800a212:	7dfb      	ldrb	r3, [r7, #23]
}
 800a214:	4618      	mov	r0, r3
 800a216:	3718      	adds	r7, #24
 800a218:	46bd      	mov	sp, r7
 800a21a:	bd80      	pop	{r7, pc}

0800a21c <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object with the file name */
)
{
 800a21c:	b580      	push	{r7, lr}
 800a21e:	b086      	sub	sp, #24
 800a220:	af00      	add	r7, sp, #0
 800a222:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800a224:	687b      	ldr	r3, [r7, #4]
 800a226:	681b      	ldr	r3, [r3, #0]
 800a228:	613b      	str	r3, [r7, #16]
	BYTE c;
#if _USE_LFN != 0
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800a22a:	2100      	movs	r1, #0
 800a22c:	6878      	ldr	r0, [r7, #4]
 800a22e:	f7ff fb9b 	bl	8009968 <dir_sdi>
 800a232:	4603      	mov	r3, r0
 800a234:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 800a236:	7dfb      	ldrb	r3, [r7, #23]
 800a238:	2b00      	cmp	r3, #0
 800a23a:	d001      	beq.n	800a240 <dir_find+0x24>
 800a23c:	7dfb      	ldrb	r3, [r7, #23]
 800a23e:	e0a9      	b.n	800a394 <dir_find+0x178>
		return res;
	}
#endif
	/* On the FAT12/16/32 volume */
#if _USE_LFN != 0
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800a240:	23ff      	movs	r3, #255	; 0xff
 800a242:	753b      	strb	r3, [r7, #20]
 800a244:	7d3b      	ldrb	r3, [r7, #20]
 800a246:	757b      	strb	r3, [r7, #21]
 800a248:	687b      	ldr	r3, [r7, #4]
 800a24a:	f04f 32ff 	mov.w	r2, #4294967295
 800a24e:	631a      	str	r2, [r3, #48]	; 0x30
#endif
	do {
		res = move_window(fs, dp->sect);
 800a250:	687b      	ldr	r3, [r7, #4]
 800a252:	69db      	ldr	r3, [r3, #28]
 800a254:	4619      	mov	r1, r3
 800a256:	6938      	ldr	r0, [r7, #16]
 800a258:	f7ff f806 	bl	8009268 <move_window>
 800a25c:	4603      	mov	r3, r0
 800a25e:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800a260:	7dfb      	ldrb	r3, [r7, #23]
 800a262:	2b00      	cmp	r3, #0
 800a264:	f040 8090 	bne.w	800a388 <dir_find+0x16c>
		c = dp->dir[DIR_Name];
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	6a1b      	ldr	r3, [r3, #32]
 800a26c:	781b      	ldrb	r3, [r3, #0]
 800a26e:	75bb      	strb	r3, [r7, #22]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800a270:	7dbb      	ldrb	r3, [r7, #22]
 800a272:	2b00      	cmp	r3, #0
 800a274:	d102      	bne.n	800a27c <dir_find+0x60>
 800a276:	2304      	movs	r3, #4
 800a278:	75fb      	strb	r3, [r7, #23]
 800a27a:	e08a      	b.n	800a392 <dir_find+0x176>
#if _USE_LFN != 0	/* LFN configuration */
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800a27c:	687b      	ldr	r3, [r7, #4]
 800a27e:	6a1b      	ldr	r3, [r3, #32]
 800a280:	330b      	adds	r3, #11
 800a282:	781b      	ldrb	r3, [r3, #0]
 800a284:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a288:	73fb      	strb	r3, [r7, #15]
 800a28a:	687b      	ldr	r3, [r7, #4]
 800a28c:	7bfa      	ldrb	r2, [r7, #15]
 800a28e:	719a      	strb	r2, [r3, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800a290:	7dbb      	ldrb	r3, [r7, #22]
 800a292:	2be5      	cmp	r3, #229	; 0xe5
 800a294:	d007      	beq.n	800a2a6 <dir_find+0x8a>
 800a296:	7bfb      	ldrb	r3, [r7, #15]
 800a298:	f003 0308 	and.w	r3, r3, #8
 800a29c:	2b00      	cmp	r3, #0
 800a29e:	d009      	beq.n	800a2b4 <dir_find+0x98>
 800a2a0:	7bfb      	ldrb	r3, [r7, #15]
 800a2a2:	2b0f      	cmp	r3, #15
 800a2a4:	d006      	beq.n	800a2b4 <dir_find+0x98>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800a2a6:	23ff      	movs	r3, #255	; 0xff
 800a2a8:	757b      	strb	r3, [r7, #21]
 800a2aa:	687b      	ldr	r3, [r7, #4]
 800a2ac:	f04f 32ff 	mov.w	r2, #4294967295
 800a2b0:	631a      	str	r2, [r3, #48]	; 0x30
 800a2b2:	e05e      	b.n	800a372 <dir_find+0x156>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 800a2b4:	7bfb      	ldrb	r3, [r7, #15]
 800a2b6:	2b0f      	cmp	r3, #15
 800a2b8:	d136      	bne.n	800a328 <dir_find+0x10c>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800a2ba:	687b      	ldr	r3, [r7, #4]
 800a2bc:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800a2c0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a2c4:	2b00      	cmp	r3, #0
 800a2c6:	d154      	bne.n	800a372 <dir_find+0x156>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800a2c8:	7dbb      	ldrb	r3, [r7, #22]
 800a2ca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a2ce:	2b00      	cmp	r3, #0
 800a2d0:	d00d      	beq.n	800a2ee <dir_find+0xd2>
						sum = dp->dir[LDIR_Chksum];
 800a2d2:	687b      	ldr	r3, [r7, #4]
 800a2d4:	6a1b      	ldr	r3, [r3, #32]
 800a2d6:	7b5b      	ldrb	r3, [r3, #13]
 800a2d8:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800a2da:	7dbb      	ldrb	r3, [r7, #22]
 800a2dc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a2e0:	75bb      	strb	r3, [r7, #22]
 800a2e2:	7dbb      	ldrb	r3, [r7, #22]
 800a2e4:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800a2e6:	687b      	ldr	r3, [r7, #4]
 800a2e8:	695a      	ldr	r2, [r3, #20]
 800a2ea:	687b      	ldr	r3, [r7, #4]
 800a2ec:	631a      	str	r2, [r3, #48]	; 0x30
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800a2ee:	7dba      	ldrb	r2, [r7, #22]
 800a2f0:	7d7b      	ldrb	r3, [r7, #21]
 800a2f2:	429a      	cmp	r2, r3
 800a2f4:	d115      	bne.n	800a322 <dir_find+0x106>
 800a2f6:	687b      	ldr	r3, [r7, #4]
 800a2f8:	6a1b      	ldr	r3, [r3, #32]
 800a2fa:	330d      	adds	r3, #13
 800a2fc:	781b      	ldrb	r3, [r3, #0]
 800a2fe:	7d3a      	ldrb	r2, [r7, #20]
 800a300:	429a      	cmp	r2, r3
 800a302:	d10e      	bne.n	800a322 <dir_find+0x106>
 800a304:	693b      	ldr	r3, [r7, #16]
 800a306:	68da      	ldr	r2, [r3, #12]
 800a308:	687b      	ldr	r3, [r7, #4]
 800a30a:	6a1b      	ldr	r3, [r3, #32]
 800a30c:	4619      	mov	r1, r3
 800a30e:	4610      	mov	r0, r2
 800a310:	f7ff fcf0 	bl	8009cf4 <cmp_lfn>
 800a314:	4603      	mov	r3, r0
 800a316:	2b00      	cmp	r3, #0
 800a318:	d003      	beq.n	800a322 <dir_find+0x106>
 800a31a:	7d7b      	ldrb	r3, [r7, #21]
 800a31c:	3b01      	subs	r3, #1
 800a31e:	b2db      	uxtb	r3, r3
 800a320:	e000      	b.n	800a324 <dir_find+0x108>
 800a322:	23ff      	movs	r3, #255	; 0xff
 800a324:	757b      	strb	r3, [r7, #21]
 800a326:	e024      	b.n	800a372 <dir_find+0x156>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800a328:	7d7b      	ldrb	r3, [r7, #21]
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d109      	bne.n	800a342 <dir_find+0x126>
 800a32e:	687b      	ldr	r3, [r7, #4]
 800a330:	6a1b      	ldr	r3, [r3, #32]
 800a332:	4618      	mov	r0, r3
 800a334:	f7ff feaa 	bl	800a08c <sum_sfn>
 800a338:	4603      	mov	r3, r0
 800a33a:	461a      	mov	r2, r3
 800a33c:	7d3b      	ldrb	r3, [r7, #20]
 800a33e:	4293      	cmp	r3, r2
 800a340:	d024      	beq.n	800a38c <dir_find+0x170>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800a342:	687b      	ldr	r3, [r7, #4]
 800a344:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800a348:	f003 0301 	and.w	r3, r3, #1
 800a34c:	2b00      	cmp	r3, #0
 800a34e:	d10a      	bne.n	800a366 <dir_find+0x14a>
 800a350:	687b      	ldr	r3, [r7, #4]
 800a352:	6a18      	ldr	r0, [r3, #32]
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	3324      	adds	r3, #36	; 0x24
 800a358:	220b      	movs	r2, #11
 800a35a:	4619      	mov	r1, r3
 800a35c:	f7fe fd92 	bl	8008e84 <mem_cmp>
 800a360:	4603      	mov	r3, r0
 800a362:	2b00      	cmp	r3, #0
 800a364:	d014      	beq.n	800a390 <dir_find+0x174>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800a366:	23ff      	movs	r3, #255	; 0xff
 800a368:	757b      	strb	r3, [r7, #21]
 800a36a:	687b      	ldr	r3, [r7, #4]
 800a36c:	f04f 32ff 	mov.w	r2, #4294967295
 800a370:	631a      	str	r2, [r3, #48]	; 0x30
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
		res = dir_next(dp, 0);	/* Next entry */
 800a372:	2100      	movs	r1, #0
 800a374:	6878      	ldr	r0, [r7, #4]
 800a376:	f7ff fb72 	bl	8009a5e <dir_next>
 800a37a:	4603      	mov	r3, r0
 800a37c:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 800a37e:	7dfb      	ldrb	r3, [r7, #23]
 800a380:	2b00      	cmp	r3, #0
 800a382:	f43f af65 	beq.w	800a250 <dir_find+0x34>
 800a386:	e004      	b.n	800a392 <dir_find+0x176>
		if (res != FR_OK) break;
 800a388:	bf00      	nop
 800a38a:	e002      	b.n	800a392 <dir_find+0x176>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800a38c:	bf00      	nop
 800a38e:	e000      	b.n	800a392 <dir_find+0x176>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800a390:	bf00      	nop

	return res;
 800a392:	7dfb      	ldrb	r3, [r7, #23]
}
 800a394:	4618      	mov	r0, r3
 800a396:	3718      	adds	r7, #24
 800a398:	46bd      	mov	sp, r7
 800a39a:	bd80      	pop	{r7, pc}

0800a39c <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 800a39c:	b580      	push	{r7, lr}
 800a39e:	b08c      	sub	sp, #48	; 0x30
 800a3a0:	af00      	add	r7, sp, #0
 800a3a2:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	681b      	ldr	r3, [r3, #0]
 800a3a8:	61fb      	str	r3, [r7, #28]
#if _USE_LFN != 0	/* LFN configuration */
	UINT n, nlen, nent;
	BYTE sn[12], sum;


	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800a3aa:	687b      	ldr	r3, [r7, #4]
 800a3ac:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800a3b0:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
 800a3b4:	2b00      	cmp	r3, #0
 800a3b6:	d001      	beq.n	800a3bc <dir_register+0x20>
 800a3b8:	2306      	movs	r3, #6
 800a3ba:	e0e0      	b.n	800a57e <dir_register+0x1e2>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800a3bc:	2300      	movs	r3, #0
 800a3be:	627b      	str	r3, [r7, #36]	; 0x24
 800a3c0:	e002      	b.n	800a3c8 <dir_register+0x2c>
 800a3c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a3c4:	3301      	adds	r3, #1
 800a3c6:	627b      	str	r3, [r7, #36]	; 0x24
 800a3c8:	69fb      	ldr	r3, [r7, #28]
 800a3ca:	68da      	ldr	r2, [r3, #12]
 800a3cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a3ce:	005b      	lsls	r3, r3, #1
 800a3d0:	4413      	add	r3, r2
 800a3d2:	881b      	ldrh	r3, [r3, #0]
 800a3d4:	2b00      	cmp	r3, #0
 800a3d6:	d1f4      	bne.n	800a3c2 <dir_register+0x26>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
		return FR_OK;
	}
#endif
	/* On the FAT12/16/32 volume */
	mem_cpy(sn, dp->fn, 12);
 800a3d8:	687b      	ldr	r3, [r7, #4]
 800a3da:	f103 0124 	add.w	r1, r3, #36	; 0x24
 800a3de:	f107 030c 	add.w	r3, r7, #12
 800a3e2:	220c      	movs	r2, #12
 800a3e4:	4618      	mov	r0, r3
 800a3e6:	f7fe fd11 	bl	8008e0c <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 800a3ea:	7dfb      	ldrb	r3, [r7, #23]
 800a3ec:	f003 0301 	and.w	r3, r3, #1
 800a3f0:	2b00      	cmp	r3, #0
 800a3f2:	d032      	beq.n	800a45a <dir_register+0xbe>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800a3f4:	687b      	ldr	r3, [r7, #4]
 800a3f6:	2240      	movs	r2, #64	; 0x40
 800a3f8:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		for (n = 1; n < 100; n++) {
 800a3fc:	2301      	movs	r3, #1
 800a3fe:	62bb      	str	r3, [r7, #40]	; 0x28
 800a400:	e016      	b.n	800a430 <dir_register+0x94>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 800a402:	687b      	ldr	r3, [r7, #4]
 800a404:	f103 0024 	add.w	r0, r3, #36	; 0x24
 800a408:	69fb      	ldr	r3, [r7, #28]
 800a40a:	68da      	ldr	r2, [r3, #12]
 800a40c:	f107 010c 	add.w	r1, r7, #12
 800a410:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a412:	f7ff fdab 	bl	8009f6c <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 800a416:	6878      	ldr	r0, [r7, #4]
 800a418:	f7ff ff00 	bl	800a21c <dir_find>
 800a41c:	4603      	mov	r3, r0
 800a41e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) break;
 800a422:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a426:	2b00      	cmp	r3, #0
 800a428:	d106      	bne.n	800a438 <dir_register+0x9c>
		for (n = 1; n < 100; n++) {
 800a42a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a42c:	3301      	adds	r3, #1
 800a42e:	62bb      	str	r3, [r7, #40]	; 0x28
 800a430:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a432:	2b63      	cmp	r3, #99	; 0x63
 800a434:	d9e5      	bls.n	800a402 <dir_register+0x66>
 800a436:	e000      	b.n	800a43a <dir_register+0x9e>
			if (res != FR_OK) break;
 800a438:	bf00      	nop
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 800a43a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a43c:	2b64      	cmp	r3, #100	; 0x64
 800a43e:	d101      	bne.n	800a444 <dir_register+0xa8>
 800a440:	2307      	movs	r3, #7
 800a442:	e09c      	b.n	800a57e <dir_register+0x1e2>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 800a444:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a448:	2b04      	cmp	r3, #4
 800a44a:	d002      	beq.n	800a452 <dir_register+0xb6>
 800a44c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a450:	e095      	b.n	800a57e <dir_register+0x1e2>
		dp->fn[NSFLAG] = sn[NSFLAG];
 800a452:	7dfa      	ldrb	r2, [r7, #23]
 800a454:	687b      	ldr	r3, [r7, #4]
 800a456:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
	}

	/* Create an SFN with/without LFNs. */
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800a45a:	7dfb      	ldrb	r3, [r7, #23]
 800a45c:	f003 0302 	and.w	r3, r3, #2
 800a460:	2b00      	cmp	r3, #0
 800a462:	d007      	beq.n	800a474 <dir_register+0xd8>
 800a464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a466:	330c      	adds	r3, #12
 800a468:	4a47      	ldr	r2, [pc, #284]	; (800a588 <dir_register+0x1ec>)
 800a46a:	fba2 2303 	umull	r2, r3, r2, r3
 800a46e:	089b      	lsrs	r3, r3, #2
 800a470:	3301      	adds	r3, #1
 800a472:	e000      	b.n	800a476 <dir_register+0xda>
 800a474:	2301      	movs	r3, #1
 800a476:	623b      	str	r3, [r7, #32]
	res = dir_alloc(dp, nent);		/* Allocate entries */
 800a478:	6a39      	ldr	r1, [r7, #32]
 800a47a:	6878      	ldr	r0, [r7, #4]
 800a47c:	f7ff fbb4 	bl	8009be8 <dir_alloc>
 800a480:	4603      	mov	r3, r0
 800a482:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 800a486:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a48a:	2b00      	cmp	r3, #0
 800a48c:	d148      	bne.n	800a520 <dir_register+0x184>
 800a48e:	6a3b      	ldr	r3, [r7, #32]
 800a490:	3b01      	subs	r3, #1
 800a492:	623b      	str	r3, [r7, #32]
 800a494:	6a3b      	ldr	r3, [r7, #32]
 800a496:	2b00      	cmp	r3, #0
 800a498:	d042      	beq.n	800a520 <dir_register+0x184>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 800a49a:	687b      	ldr	r3, [r7, #4]
 800a49c:	695a      	ldr	r2, [r3, #20]
 800a49e:	6a3b      	ldr	r3, [r7, #32]
 800a4a0:	015b      	lsls	r3, r3, #5
 800a4a2:	1ad3      	subs	r3, r2, r3
 800a4a4:	4619      	mov	r1, r3
 800a4a6:	6878      	ldr	r0, [r7, #4]
 800a4a8:	f7ff fa5e 	bl	8009968 <dir_sdi>
 800a4ac:	4603      	mov	r3, r0
 800a4ae:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
 800a4b2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a4b6:	2b00      	cmp	r3, #0
 800a4b8:	d132      	bne.n	800a520 <dir_register+0x184>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 800a4ba:	687b      	ldr	r3, [r7, #4]
 800a4bc:	3324      	adds	r3, #36	; 0x24
 800a4be:	4618      	mov	r0, r3
 800a4c0:	f7ff fde4 	bl	800a08c <sum_sfn>
 800a4c4:	4603      	mov	r3, r0
 800a4c6:	76fb      	strb	r3, [r7, #27]
			do {					/* Store LFN entries in bottom first */
				res = move_window(fs, dp->sect);
 800a4c8:	687b      	ldr	r3, [r7, #4]
 800a4ca:	69db      	ldr	r3, [r3, #28]
 800a4cc:	4619      	mov	r1, r3
 800a4ce:	69f8      	ldr	r0, [r7, #28]
 800a4d0:	f7fe feca 	bl	8009268 <move_window>
 800a4d4:	4603      	mov	r3, r0
 800a4d6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
				if (res != FR_OK) break;
 800a4da:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a4de:	2b00      	cmp	r3, #0
 800a4e0:	d11d      	bne.n	800a51e <dir_register+0x182>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 800a4e2:	69fb      	ldr	r3, [r7, #28]
 800a4e4:	68d8      	ldr	r0, [r3, #12]
 800a4e6:	687b      	ldr	r3, [r7, #4]
 800a4e8:	6a19      	ldr	r1, [r3, #32]
 800a4ea:	6a3b      	ldr	r3, [r7, #32]
 800a4ec:	b2da      	uxtb	r2, r3
 800a4ee:	7efb      	ldrb	r3, [r7, #27]
 800a4f0:	f7ff fcd4 	bl	8009e9c <put_lfn>
				fs->wflag = 1;
 800a4f4:	69fb      	ldr	r3, [r7, #28]
 800a4f6:	2201      	movs	r2, #1
 800a4f8:	70da      	strb	r2, [r3, #3]
				res = dir_next(dp, 0);	/* Next entry */
 800a4fa:	2100      	movs	r1, #0
 800a4fc:	6878      	ldr	r0, [r7, #4]
 800a4fe:	f7ff faae 	bl	8009a5e <dir_next>
 800a502:	4603      	mov	r3, r0
 800a504:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			} while (res == FR_OK && --nent);
 800a508:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a50c:	2b00      	cmp	r3, #0
 800a50e:	d107      	bne.n	800a520 <dir_register+0x184>
 800a510:	6a3b      	ldr	r3, [r7, #32]
 800a512:	3b01      	subs	r3, #1
 800a514:	623b      	str	r3, [r7, #32]
 800a516:	6a3b      	ldr	r3, [r7, #32]
 800a518:	2b00      	cmp	r3, #0
 800a51a:	d1d5      	bne.n	800a4c8 <dir_register+0x12c>
 800a51c:	e000      	b.n	800a520 <dir_register+0x184>
				if (res != FR_OK) break;
 800a51e:	bf00      	nop
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
 800a520:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a524:	2b00      	cmp	r3, #0
 800a526:	d128      	bne.n	800a57a <dir_register+0x1de>
		res = move_window(fs, dp->sect);
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	69db      	ldr	r3, [r3, #28]
 800a52c:	4619      	mov	r1, r3
 800a52e:	69f8      	ldr	r0, [r7, #28]
 800a530:	f7fe fe9a 	bl	8009268 <move_window>
 800a534:	4603      	mov	r3, r0
 800a536:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
 800a53a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800a53e:	2b00      	cmp	r3, #0
 800a540:	d11b      	bne.n	800a57a <dir_register+0x1de>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 800a542:	687b      	ldr	r3, [r7, #4]
 800a544:	6a1b      	ldr	r3, [r3, #32]
 800a546:	2220      	movs	r2, #32
 800a548:	2100      	movs	r1, #0
 800a54a:	4618      	mov	r0, r3
 800a54c:	f7fe fc7f 	bl	8008e4e <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800a550:	687b      	ldr	r3, [r7, #4]
 800a552:	6a18      	ldr	r0, [r3, #32]
 800a554:	687b      	ldr	r3, [r7, #4]
 800a556:	3324      	adds	r3, #36	; 0x24
 800a558:	220b      	movs	r2, #11
 800a55a:	4619      	mov	r1, r3
 800a55c:	f7fe fc56 	bl	8008e0c <mem_cpy>
#if _USE_LFN != 0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800a560:	687b      	ldr	r3, [r7, #4]
 800a562:	f893 202f 	ldrb.w	r2, [r3, #47]	; 0x2f
 800a566:	687b      	ldr	r3, [r7, #4]
 800a568:	6a1b      	ldr	r3, [r3, #32]
 800a56a:	330c      	adds	r3, #12
 800a56c:	f002 0218 	and.w	r2, r2, #24
 800a570:	b2d2      	uxtb	r2, r2
 800a572:	701a      	strb	r2, [r3, #0]
#endif
			fs->wflag = 1;
 800a574:	69fb      	ldr	r3, [r7, #28]
 800a576:	2201      	movs	r2, #1
 800a578:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
 800a57a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 800a57e:	4618      	mov	r0, r3
 800a580:	3730      	adds	r7, #48	; 0x30
 800a582:	46bd      	mov	sp, r7
 800a584:	bd80      	pop	{r7, pc}
 800a586:	bf00      	nop
 800a588:	4ec4ec4f 	.word	0x4ec4ec4f

0800a58c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno	 	/* Pointer to the file information to be filled */
)
{
 800a58c:	b580      	push	{r7, lr}
 800a58e:	b088      	sub	sp, #32
 800a590:	af00      	add	r7, sp, #0
 800a592:	6078      	str	r0, [r7, #4]
 800a594:	6039      	str	r1, [r7, #0]
	UINT i, j;
	TCHAR c;
	DWORD tm;
#if _USE_LFN != 0
	WCHAR w, lfv;
	FATFS *fs = dp->obj.fs;
 800a596:	687b      	ldr	r3, [r7, #4]
 800a598:	681b      	ldr	r3, [r3, #0]
 800a59a:	613b      	str	r3, [r7, #16]
#endif


	fno->fname[0] = 0;		/* Invaidate file info */
 800a59c:	683b      	ldr	r3, [r7, #0]
 800a59e:	2200      	movs	r2, #0
 800a5a0:	759a      	strb	r2, [r3, #22]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 800a5a2:	687b      	ldr	r3, [r7, #4]
 800a5a4:	69db      	ldr	r3, [r3, #28]
 800a5a6:	2b00      	cmp	r3, #0
 800a5a8:	f000 80c9 	beq.w	800a73e <get_fileinfo+0x1b2>
		get_xdir_info(fs->dirbuf, fno);
		return;
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 800a5ac:	687b      	ldr	r3, [r7, #4]
 800a5ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a5b0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a5b4:	d032      	beq.n	800a61c <get_fileinfo+0x90>
			i = j = 0;
 800a5b6:	2300      	movs	r3, #0
 800a5b8:	61bb      	str	r3, [r7, #24]
 800a5ba:	69bb      	ldr	r3, [r7, #24]
 800a5bc:	61fb      	str	r3, [r7, #28]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800a5be:	e01b      	b.n	800a5f8 <get_fileinfo+0x6c>
#if !_LFN_UNICODE
				w = ff_convert(w, 0);		/* Unicode -> OEM */
 800a5c0:	89fb      	ldrh	r3, [r7, #14]
 800a5c2:	2100      	movs	r1, #0
 800a5c4:	4618      	mov	r0, r3
 800a5c6:	f001 fc11 	bl	800bdec <ff_convert>
 800a5ca:	4603      	mov	r3, r0
 800a5cc:	81fb      	strh	r3, [r7, #14]
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
 800a5ce:	89fb      	ldrh	r3, [r7, #14]
 800a5d0:	2b00      	cmp	r3, #0
 800a5d2:	d102      	bne.n	800a5da <get_fileinfo+0x4e>
 800a5d4:	2300      	movs	r3, #0
 800a5d6:	61fb      	str	r3, [r7, #28]
 800a5d8:	e01a      	b.n	800a610 <get_fileinfo+0x84>
				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
					fno->fname[i++] = (char)(w >> 8);
				}
#endif
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
 800a5da:	69fb      	ldr	r3, [r7, #28]
 800a5dc:	2bfe      	cmp	r3, #254	; 0xfe
 800a5de:	d902      	bls.n	800a5e6 <get_fileinfo+0x5a>
 800a5e0:	2300      	movs	r3, #0
 800a5e2:	61fb      	str	r3, [r7, #28]
 800a5e4:	e014      	b.n	800a610 <get_fileinfo+0x84>
				fno->fname[i++] = (TCHAR)w;
 800a5e6:	69fb      	ldr	r3, [r7, #28]
 800a5e8:	1c5a      	adds	r2, r3, #1
 800a5ea:	61fa      	str	r2, [r7, #28]
 800a5ec:	89fa      	ldrh	r2, [r7, #14]
 800a5ee:	b2d1      	uxtb	r1, r2
 800a5f0:	683a      	ldr	r2, [r7, #0]
 800a5f2:	4413      	add	r3, r2
 800a5f4:	460a      	mov	r2, r1
 800a5f6:	759a      	strb	r2, [r3, #22]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800a5f8:	693b      	ldr	r3, [r7, #16]
 800a5fa:	68da      	ldr	r2, [r3, #12]
 800a5fc:	69bb      	ldr	r3, [r7, #24]
 800a5fe:	1c59      	adds	r1, r3, #1
 800a600:	61b9      	str	r1, [r7, #24]
 800a602:	005b      	lsls	r3, r3, #1
 800a604:	4413      	add	r3, r2
 800a606:	881b      	ldrh	r3, [r3, #0]
 800a608:	81fb      	strh	r3, [r7, #14]
 800a60a:	89fb      	ldrh	r3, [r7, #14]
 800a60c:	2b00      	cmp	r3, #0
 800a60e:	d1d7      	bne.n	800a5c0 <get_fileinfo+0x34>
			}
			fno->fname[i] = 0;	/* Terminate the LFN */
 800a610:	683a      	ldr	r2, [r7, #0]
 800a612:	69fb      	ldr	r3, [r7, #28]
 800a614:	4413      	add	r3, r2
 800a616:	3316      	adds	r3, #22
 800a618:	2200      	movs	r2, #0
 800a61a:	701a      	strb	r2, [r3, #0]
		}
	}

	i = j = 0;
 800a61c:	2300      	movs	r3, #0
 800a61e:	61bb      	str	r3, [r7, #24]
 800a620:	69bb      	ldr	r3, [r7, #24]
 800a622:	61fb      	str	r3, [r7, #28]
	lfv = fno->fname[i];	/* LFN is exist if non-zero */
 800a624:	683a      	ldr	r2, [r7, #0]
 800a626:	69fb      	ldr	r3, [r7, #28]
 800a628:	4413      	add	r3, r2
 800a62a:	3316      	adds	r3, #22
 800a62c:	781b      	ldrb	r3, [r3, #0]
 800a62e:	81bb      	strh	r3, [r7, #12]
	while (i < 11) {		/* Copy name body and extension */
 800a630:	e04c      	b.n	800a6cc <get_fileinfo+0x140>
		c = (TCHAR)dp->dir[i++];
 800a632:	687b      	ldr	r3, [r7, #4]
 800a634:	6a1a      	ldr	r2, [r3, #32]
 800a636:	69fb      	ldr	r3, [r7, #28]
 800a638:	1c59      	adds	r1, r3, #1
 800a63a:	61f9      	str	r1, [r7, #28]
 800a63c:	4413      	add	r3, r2
 800a63e:	781b      	ldrb	r3, [r3, #0]
 800a640:	75fb      	strb	r3, [r7, #23]
		if (c == ' ') continue;				/* Skip padding spaces */
 800a642:	7dfb      	ldrb	r3, [r7, #23]
 800a644:	2b20      	cmp	r3, #32
 800a646:	d100      	bne.n	800a64a <get_fileinfo+0xbe>
 800a648:	e040      	b.n	800a6cc <get_fileinfo+0x140>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800a64a:	7dfb      	ldrb	r3, [r7, #23]
 800a64c:	2b05      	cmp	r3, #5
 800a64e:	d101      	bne.n	800a654 <get_fileinfo+0xc8>
 800a650:	23e5      	movs	r3, #229	; 0xe5
 800a652:	75fb      	strb	r3, [r7, #23]
		if (i == 9) {						/* Insert a . if extension is exist */
 800a654:	69fb      	ldr	r3, [r7, #28]
 800a656:	2b09      	cmp	r3, #9
 800a658:	d10f      	bne.n	800a67a <get_fileinfo+0xee>
			if (!lfv) fno->fname[j] = '.';
 800a65a:	89bb      	ldrh	r3, [r7, #12]
 800a65c:	2b00      	cmp	r3, #0
 800a65e:	d105      	bne.n	800a66c <get_fileinfo+0xe0>
 800a660:	683a      	ldr	r2, [r7, #0]
 800a662:	69bb      	ldr	r3, [r7, #24]
 800a664:	4413      	add	r3, r2
 800a666:	3316      	adds	r3, #22
 800a668:	222e      	movs	r2, #46	; 0x2e
 800a66a:	701a      	strb	r2, [r3, #0]
			fno->altname[j++] = '.';
 800a66c:	69bb      	ldr	r3, [r7, #24]
 800a66e:	1c5a      	adds	r2, r3, #1
 800a670:	61ba      	str	r2, [r7, #24]
 800a672:	683a      	ldr	r2, [r7, #0]
 800a674:	4413      	add	r3, r2
 800a676:	222e      	movs	r2, #46	; 0x2e
 800a678:	725a      	strb	r2, [r3, #9]
			c = c << 8 | dp->dir[i++];
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
		fno->altname[j] = c;
 800a67a:	683a      	ldr	r2, [r7, #0]
 800a67c:	69bb      	ldr	r3, [r7, #24]
 800a67e:	4413      	add	r3, r2
 800a680:	3309      	adds	r3, #9
 800a682:	7dfa      	ldrb	r2, [r7, #23]
 800a684:	701a      	strb	r2, [r3, #0]
		if (!lfv) {
 800a686:	89bb      	ldrh	r3, [r7, #12]
 800a688:	2b00      	cmp	r3, #0
 800a68a:	d11c      	bne.n	800a6c6 <get_fileinfo+0x13a>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800a68c:	7dfb      	ldrb	r3, [r7, #23]
 800a68e:	2b40      	cmp	r3, #64	; 0x40
 800a690:	d913      	bls.n	800a6ba <get_fileinfo+0x12e>
 800a692:	7dfb      	ldrb	r3, [r7, #23]
 800a694:	2b5a      	cmp	r3, #90	; 0x5a
 800a696:	d810      	bhi.n	800a6ba <get_fileinfo+0x12e>
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	6a1b      	ldr	r3, [r3, #32]
 800a69c:	330c      	adds	r3, #12
 800a69e:	781b      	ldrb	r3, [r3, #0]
 800a6a0:	461a      	mov	r2, r3
 800a6a2:	69fb      	ldr	r3, [r7, #28]
 800a6a4:	2b08      	cmp	r3, #8
 800a6a6:	d901      	bls.n	800a6ac <get_fileinfo+0x120>
 800a6a8:	2310      	movs	r3, #16
 800a6aa:	e000      	b.n	800a6ae <get_fileinfo+0x122>
 800a6ac:	2308      	movs	r3, #8
 800a6ae:	4013      	ands	r3, r2
 800a6b0:	2b00      	cmp	r3, #0
 800a6b2:	d002      	beq.n	800a6ba <get_fileinfo+0x12e>
				c += 0x20;			/* To lower */
 800a6b4:	7dfb      	ldrb	r3, [r7, #23]
 800a6b6:	3320      	adds	r3, #32
 800a6b8:	75fb      	strb	r3, [r7, #23]
			}
			fno->fname[j] = c;
 800a6ba:	683a      	ldr	r2, [r7, #0]
 800a6bc:	69bb      	ldr	r3, [r7, #24]
 800a6be:	4413      	add	r3, r2
 800a6c0:	3316      	adds	r3, #22
 800a6c2:	7dfa      	ldrb	r2, [r7, #23]
 800a6c4:	701a      	strb	r2, [r3, #0]
		}
		j++;
 800a6c6:	69bb      	ldr	r3, [r7, #24]
 800a6c8:	3301      	adds	r3, #1
 800a6ca:	61bb      	str	r3, [r7, #24]
	while (i < 11) {		/* Copy name body and extension */
 800a6cc:	69fb      	ldr	r3, [r7, #28]
 800a6ce:	2b0a      	cmp	r3, #10
 800a6d0:	d9af      	bls.n	800a632 <get_fileinfo+0xa6>
	}
	if (!lfv) {
 800a6d2:	89bb      	ldrh	r3, [r7, #12]
 800a6d4:	2b00      	cmp	r3, #0
 800a6d6:	d10d      	bne.n	800a6f4 <get_fileinfo+0x168>
		fno->fname[j] = 0;
 800a6d8:	683a      	ldr	r2, [r7, #0]
 800a6da:	69bb      	ldr	r3, [r7, #24]
 800a6dc:	4413      	add	r3, r2
 800a6de:	3316      	adds	r3, #22
 800a6e0:	2200      	movs	r2, #0
 800a6e2:	701a      	strb	r2, [r3, #0]
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	6a1b      	ldr	r3, [r3, #32]
 800a6e8:	330c      	adds	r3, #12
 800a6ea:	781b      	ldrb	r3, [r3, #0]
 800a6ec:	2b00      	cmp	r3, #0
 800a6ee:	d101      	bne.n	800a6f4 <get_fileinfo+0x168>
 800a6f0:	2300      	movs	r3, #0
 800a6f2:	61bb      	str	r3, [r7, #24]
	}
	fno->altname[j] = 0;	/* Terminate the SFN */
 800a6f4:	683a      	ldr	r2, [r7, #0]
 800a6f6:	69bb      	ldr	r3, [r7, #24]
 800a6f8:	4413      	add	r3, r2
 800a6fa:	3309      	adds	r3, #9
 800a6fc:	2200      	movs	r2, #0
 800a6fe:	701a      	strb	r2, [r3, #0]
		fno->fname[j++] = c;
	}
	fno->fname[j] = 0;
#endif

	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 800a700:	687b      	ldr	r3, [r7, #4]
 800a702:	6a1b      	ldr	r3, [r3, #32]
 800a704:	7ada      	ldrb	r2, [r3, #11]
 800a706:	683b      	ldr	r3, [r7, #0]
 800a708:	721a      	strb	r2, [r3, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 800a70a:	687b      	ldr	r3, [r7, #4]
 800a70c:	6a1b      	ldr	r3, [r3, #32]
 800a70e:	331c      	adds	r3, #28
 800a710:	4618      	mov	r0, r3
 800a712:	f7fe fb11 	bl	8008d38 <ld_dword>
 800a716:	4602      	mov	r2, r0
 800a718:	683b      	ldr	r3, [r7, #0]
 800a71a:	601a      	str	r2, [r3, #0]
	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
 800a71c:	687b      	ldr	r3, [r7, #4]
 800a71e:	6a1b      	ldr	r3, [r3, #32]
 800a720:	3316      	adds	r3, #22
 800a722:	4618      	mov	r0, r3
 800a724:	f7fe fb08 	bl	8008d38 <ld_dword>
 800a728:	60b8      	str	r0, [r7, #8]
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 800a72a:	68bb      	ldr	r3, [r7, #8]
 800a72c:	b29a      	uxth	r2, r3
 800a72e:	683b      	ldr	r3, [r7, #0]
 800a730:	80da      	strh	r2, [r3, #6]
 800a732:	68bb      	ldr	r3, [r7, #8]
 800a734:	0c1b      	lsrs	r3, r3, #16
 800a736:	b29a      	uxth	r2, r3
 800a738:	683b      	ldr	r3, [r7, #0]
 800a73a:	809a      	strh	r2, [r3, #4]
 800a73c:	e000      	b.n	800a740 <get_fileinfo+0x1b4>
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 800a73e:	bf00      	nop
}
 800a740:	3720      	adds	r7, #32
 800a742:	46bd      	mov	sp, r7
 800a744:	bd80      	pop	{r7, pc}
	...

0800a748 <get_achar>:

static
WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
)
{
 800a748:	b480      	push	{r7}
 800a74a:	b085      	sub	sp, #20
 800a74c:	af00      	add	r7, sp, #0
 800a74e:	6078      	str	r0, [r7, #4]
#if !_LFN_UNICODE
	WCHAR chr;

	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800a750:	687b      	ldr	r3, [r7, #4]
 800a752:	681b      	ldr	r3, [r3, #0]
 800a754:	1c59      	adds	r1, r3, #1
 800a756:	687a      	ldr	r2, [r7, #4]
 800a758:	6011      	str	r1, [r2, #0]
 800a75a:	781b      	ldrb	r3, [r3, #0]
 800a75c:	81fb      	strh	r3, [r7, #14]
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800a75e:	89fb      	ldrh	r3, [r7, #14]
 800a760:	2b60      	cmp	r3, #96	; 0x60
 800a762:	d905      	bls.n	800a770 <get_achar+0x28>
 800a764:	89fb      	ldrh	r3, [r7, #14]
 800a766:	2b7a      	cmp	r3, #122	; 0x7a
 800a768:	d802      	bhi.n	800a770 <get_achar+0x28>
 800a76a:	89fb      	ldrh	r3, [r7, #14]
 800a76c:	3b20      	subs	r3, #32
 800a76e:	81fb      	strh	r3, [r7, #14]
#ifdef _EXCVT
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800a770:	89fb      	ldrh	r3, [r7, #14]
 800a772:	2b7f      	cmp	r3, #127	; 0x7f
 800a774:	d904      	bls.n	800a780 <get_achar+0x38>
 800a776:	89fb      	ldrh	r3, [r7, #14]
 800a778:	3b80      	subs	r3, #128	; 0x80
 800a77a:	4a05      	ldr	r2, [pc, #20]	; (800a790 <get_achar+0x48>)
 800a77c:	5cd3      	ldrb	r3, [r2, r3]
 800a77e:	81fb      	strh	r3, [r7, #14]
#else
	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
		chr = chr << 8 | (BYTE)*(*ptr)++;
	}
#endif
	return chr;
 800a780:	89fb      	ldrh	r3, [r7, #14]
#else
	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
#endif
}
 800a782:	4618      	mov	r0, r3
 800a784:	3714      	adds	r7, #20
 800a786:	46bd      	mov	sp, r7
 800a788:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a78c:	4770      	bx	lr
 800a78e:	bf00      	nop
 800a790:	08029f18 	.word	0x08029f18

0800a794 <pattern_matching>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	int skip,			/* Number of pre-skip chars (number of ?s) */
	int inf				/* Infinite search (* specified) */
)
{
 800a794:	b580      	push	{r7, lr}
 800a796:	b08a      	sub	sp, #40	; 0x28
 800a798:	af00      	add	r7, sp, #0
 800a79a:	60f8      	str	r0, [r7, #12]
 800a79c:	60b9      	str	r1, [r7, #8]
 800a79e:	607a      	str	r2, [r7, #4]
 800a7a0:	603b      	str	r3, [r7, #0]
	const TCHAR *pp, *np;
	WCHAR pc, nc;
	int nm, nx;


	while (skip--) {				/* Pre-skip name chars */
 800a7a2:	e009      	b.n	800a7b8 <pattern_matching+0x24>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 800a7a4:	f107 0308 	add.w	r3, r7, #8
 800a7a8:	4618      	mov	r0, r3
 800a7aa:	f7ff ffcd 	bl	800a748 <get_achar>
 800a7ae:	4603      	mov	r3, r0
 800a7b0:	2b00      	cmp	r3, #0
 800a7b2:	d101      	bne.n	800a7b8 <pattern_matching+0x24>
 800a7b4:	2300      	movs	r3, #0
 800a7b6:	e064      	b.n	800a882 <pattern_matching+0xee>
	while (skip--) {				/* Pre-skip name chars */
 800a7b8:	687b      	ldr	r3, [r7, #4]
 800a7ba:	1e5a      	subs	r2, r3, #1
 800a7bc:	607a      	str	r2, [r7, #4]
 800a7be:	2b00      	cmp	r3, #0
 800a7c0:	d1f0      	bne.n	800a7a4 <pattern_matching+0x10>
	}
	if (!*pat && inf) return 1;		/* (short circuit) */
 800a7c2:	68fb      	ldr	r3, [r7, #12]
 800a7c4:	781b      	ldrb	r3, [r3, #0]
 800a7c6:	2b00      	cmp	r3, #0
 800a7c8:	d104      	bne.n	800a7d4 <pattern_matching+0x40>
 800a7ca:	683b      	ldr	r3, [r7, #0]
 800a7cc:	2b00      	cmp	r3, #0
 800a7ce:	d001      	beq.n	800a7d4 <pattern_matching+0x40>
 800a7d0:	2301      	movs	r3, #1
 800a7d2:	e056      	b.n	800a882 <pattern_matching+0xee>

	do {
		pp = pat; np = nam;			/* Top of pattern and name to match */
 800a7d4:	68fb      	ldr	r3, [r7, #12]
 800a7d6:	617b      	str	r3, [r7, #20]
 800a7d8:	68bb      	ldr	r3, [r7, #8]
 800a7da:	613b      	str	r3, [r7, #16]
		for (;;) {
			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
 800a7dc:	697b      	ldr	r3, [r7, #20]
 800a7de:	781b      	ldrb	r3, [r3, #0]
 800a7e0:	2b3f      	cmp	r3, #63	; 0x3f
 800a7e2:	d003      	beq.n	800a7ec <pattern_matching+0x58>
 800a7e4:	697b      	ldr	r3, [r7, #20]
 800a7e6:	781b      	ldrb	r3, [r3, #0]
 800a7e8:	2b2a      	cmp	r3, #42	; 0x2a
 800a7ea:	d126      	bne.n	800a83a <pattern_matching+0xa6>
				nm = nx = 0;
 800a7ec:	2300      	movs	r3, #0
 800a7ee:	61fb      	str	r3, [r7, #28]
 800a7f0:	69fb      	ldr	r3, [r7, #28]
 800a7f2:	623b      	str	r3, [r7, #32]
				do {				/* Analyze the wildcard chars */
					if (*pp++ == '?') nm++; else nx = 1;
 800a7f4:	697b      	ldr	r3, [r7, #20]
 800a7f6:	1c5a      	adds	r2, r3, #1
 800a7f8:	617a      	str	r2, [r7, #20]
 800a7fa:	781b      	ldrb	r3, [r3, #0]
 800a7fc:	2b3f      	cmp	r3, #63	; 0x3f
 800a7fe:	d103      	bne.n	800a808 <pattern_matching+0x74>
 800a800:	6a3b      	ldr	r3, [r7, #32]
 800a802:	3301      	adds	r3, #1
 800a804:	623b      	str	r3, [r7, #32]
 800a806:	e001      	b.n	800a80c <pattern_matching+0x78>
 800a808:	2301      	movs	r3, #1
 800a80a:	61fb      	str	r3, [r7, #28]
				} while (*pp == '?' || *pp == '*');
 800a80c:	697b      	ldr	r3, [r7, #20]
 800a80e:	781b      	ldrb	r3, [r3, #0]
 800a810:	2b3f      	cmp	r3, #63	; 0x3f
 800a812:	d0ef      	beq.n	800a7f4 <pattern_matching+0x60>
 800a814:	697b      	ldr	r3, [r7, #20]
 800a816:	781b      	ldrb	r3, [r3, #0]
 800a818:	2b2a      	cmp	r3, #42	; 0x2a
 800a81a:	d0eb      	beq.n	800a7f4 <pattern_matching+0x60>
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
 800a81c:	6978      	ldr	r0, [r7, #20]
 800a81e:	6939      	ldr	r1, [r7, #16]
 800a820:	69fb      	ldr	r3, [r7, #28]
 800a822:	6a3a      	ldr	r2, [r7, #32]
 800a824:	f7ff ffb6 	bl	800a794 <pattern_matching>
 800a828:	4603      	mov	r3, r0
 800a82a:	2b00      	cmp	r3, #0
 800a82c:	d001      	beq.n	800a832 <pattern_matching+0x9e>
 800a82e:	2301      	movs	r3, #1
 800a830:	e027      	b.n	800a882 <pattern_matching+0xee>
				nc = *np; break;	/* Branch mismatched */
 800a832:	693b      	ldr	r3, [r7, #16]
 800a834:	781b      	ldrb	r3, [r3, #0]
 800a836:	84fb      	strh	r3, [r7, #38]	; 0x26
 800a838:	e017      	b.n	800a86a <pattern_matching+0xd6>
			}
			pc = get_achar(&pp);	/* Get a pattern char */
 800a83a:	f107 0314 	add.w	r3, r7, #20
 800a83e:	4618      	mov	r0, r3
 800a840:	f7ff ff82 	bl	800a748 <get_achar>
 800a844:	4603      	mov	r3, r0
 800a846:	837b      	strh	r3, [r7, #26]
			nc = get_achar(&np);	/* Get a name char */
 800a848:	f107 0310 	add.w	r3, r7, #16
 800a84c:	4618      	mov	r0, r3
 800a84e:	f7ff ff7b 	bl	800a748 <get_achar>
 800a852:	4603      	mov	r3, r0
 800a854:	84fb      	strh	r3, [r7, #38]	; 0x26
			if (pc != nc) break;	/* Branch mismatched? */
 800a856:	8b7a      	ldrh	r2, [r7, #26]
 800a858:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a85a:	429a      	cmp	r2, r3
 800a85c:	d104      	bne.n	800a868 <pattern_matching+0xd4>
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 800a85e:	8b7b      	ldrh	r3, [r7, #26]
 800a860:	2b00      	cmp	r3, #0
 800a862:	d1bb      	bne.n	800a7dc <pattern_matching+0x48>
 800a864:	2301      	movs	r3, #1
 800a866:	e00c      	b.n	800a882 <pattern_matching+0xee>
			if (pc != nc) break;	/* Branch mismatched? */
 800a868:	bf00      	nop
		}
		get_achar(&nam);			/* nam++ */
 800a86a:	f107 0308 	add.w	r3, r7, #8
 800a86e:	4618      	mov	r0, r3
 800a870:	f7ff ff6a 	bl	800a748 <get_achar>
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
 800a874:	683b      	ldr	r3, [r7, #0]
 800a876:	2b00      	cmp	r3, #0
 800a878:	d002      	beq.n	800a880 <pattern_matching+0xec>
 800a87a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a87c:	2b00      	cmp	r3, #0
 800a87e:	d1a9      	bne.n	800a7d4 <pattern_matching+0x40>

	return 0;
 800a880:	2300      	movs	r3, #0
}
 800a882:	4618      	mov	r0, r3
 800a884:	3728      	adds	r7, #40	; 0x28
 800a886:	46bd      	mov	sp, r7
 800a888:	bd80      	pop	{r7, pc}
	...

0800a88c <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
 800a88c:	b580      	push	{r7, lr}
 800a88e:	b08a      	sub	sp, #40	; 0x28
 800a890:	af00      	add	r7, sp, #0
 800a892:	6078      	str	r0, [r7, #4]
 800a894:	6039      	str	r1, [r7, #0]
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 800a896:	683b      	ldr	r3, [r7, #0]
 800a898:	681b      	ldr	r3, [r3, #0]
 800a89a:	613b      	str	r3, [r7, #16]
 800a89c:	687b      	ldr	r3, [r7, #4]
 800a89e:	681b      	ldr	r3, [r3, #0]
 800a8a0:	68db      	ldr	r3, [r3, #12]
 800a8a2:	60fb      	str	r3, [r7, #12]
 800a8a4:	2300      	movs	r3, #0
 800a8a6:	617b      	str	r3, [r7, #20]
 800a8a8:	697b      	ldr	r3, [r7, #20]
 800a8aa:	61bb      	str	r3, [r7, #24]
	for (;;) {
		w = p[si++];					/* Get a character */
 800a8ac:	69bb      	ldr	r3, [r7, #24]
 800a8ae:	1c5a      	adds	r2, r3, #1
 800a8b0:	61ba      	str	r2, [r7, #24]
 800a8b2:	693a      	ldr	r2, [r7, #16]
 800a8b4:	4413      	add	r3, r2
 800a8b6:	781b      	ldrb	r3, [r3, #0]
 800a8b8:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (w < ' ') break;				/* Break if end of the path name */
 800a8ba:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a8bc:	2b1f      	cmp	r3, #31
 800a8be:	d940      	bls.n	800a942 <create_name+0xb6>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 800a8c0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a8c2:	2b2f      	cmp	r3, #47	; 0x2f
 800a8c4:	d006      	beq.n	800a8d4 <create_name+0x48>
 800a8c6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a8c8:	2b5c      	cmp	r3, #92	; 0x5c
 800a8ca:	d110      	bne.n	800a8ee <create_name+0x62>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800a8cc:	e002      	b.n	800a8d4 <create_name+0x48>
 800a8ce:	69bb      	ldr	r3, [r7, #24]
 800a8d0:	3301      	adds	r3, #1
 800a8d2:	61bb      	str	r3, [r7, #24]
 800a8d4:	693a      	ldr	r2, [r7, #16]
 800a8d6:	69bb      	ldr	r3, [r7, #24]
 800a8d8:	4413      	add	r3, r2
 800a8da:	781b      	ldrb	r3, [r3, #0]
 800a8dc:	2b2f      	cmp	r3, #47	; 0x2f
 800a8de:	d0f6      	beq.n	800a8ce <create_name+0x42>
 800a8e0:	693a      	ldr	r2, [r7, #16]
 800a8e2:	69bb      	ldr	r3, [r7, #24]
 800a8e4:	4413      	add	r3, r2
 800a8e6:	781b      	ldrb	r3, [r3, #0]
 800a8e8:	2b5c      	cmp	r3, #92	; 0x5c
 800a8ea:	d0f0      	beq.n	800a8ce <create_name+0x42>
			break;
 800a8ec:	e02a      	b.n	800a944 <create_name+0xb8>
		}
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 800a8ee:	697b      	ldr	r3, [r7, #20]
 800a8f0:	2bfe      	cmp	r3, #254	; 0xfe
 800a8f2:	d901      	bls.n	800a8f8 <create_name+0x6c>
 800a8f4:	2306      	movs	r3, #6
 800a8f6:	e177      	b.n	800abe8 <create_name+0x35c>
#if !_LFN_UNICODE
		w &= 0xFF;
 800a8f8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a8fa:	b2db      	uxtb	r3, r3
 800a8fc:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 800a8fe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a900:	2101      	movs	r1, #1
 800a902:	4618      	mov	r0, r3
 800a904:	f001 fa72 	bl	800bdec <ff_convert>
 800a908:	4603      	mov	r3, r0
 800a90a:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 800a90c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a90e:	2b00      	cmp	r3, #0
 800a910:	d101      	bne.n	800a916 <create_name+0x8a>
 800a912:	2306      	movs	r3, #6
 800a914:	e168      	b.n	800abe8 <create_name+0x35c>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 800a916:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a918:	2b7f      	cmp	r3, #127	; 0x7f
 800a91a:	d809      	bhi.n	800a930 <create_name+0xa4>
 800a91c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a91e:	4619      	mov	r1, r3
 800a920:	48b3      	ldr	r0, [pc, #716]	; (800abf0 <create_name+0x364>)
 800a922:	f7fe fad6 	bl	8008ed2 <chk_chr>
 800a926:	4603      	mov	r3, r0
 800a928:	2b00      	cmp	r3, #0
 800a92a:	d001      	beq.n	800a930 <create_name+0xa4>
 800a92c:	2306      	movs	r3, #6
 800a92e:	e15b      	b.n	800abe8 <create_name+0x35c>
		lfn[di++] = w;					/* Store the Unicode character */
 800a930:	697b      	ldr	r3, [r7, #20]
 800a932:	1c5a      	adds	r2, r3, #1
 800a934:	617a      	str	r2, [r7, #20]
 800a936:	005b      	lsls	r3, r3, #1
 800a938:	68fa      	ldr	r2, [r7, #12]
 800a93a:	4413      	add	r3, r2
 800a93c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800a93e:	801a      	strh	r2, [r3, #0]
		w = p[si++];					/* Get a character */
 800a940:	e7b4      	b.n	800a8ac <create_name+0x20>
		if (w < ' ') break;				/* Break if end of the path name */
 800a942:	bf00      	nop
	}
	*path = &p[si];						/* Return pointer to the next segment */
 800a944:	693a      	ldr	r2, [r7, #16]
 800a946:	69bb      	ldr	r3, [r7, #24]
 800a948:	441a      	add	r2, r3
 800a94a:	683b      	ldr	r3, [r7, #0]
 800a94c:	601a      	str	r2, [r3, #0]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800a94e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a950:	2b1f      	cmp	r3, #31
 800a952:	d801      	bhi.n	800a958 <create_name+0xcc>
 800a954:	2304      	movs	r3, #4
 800a956:	e000      	b.n	800a95a <create_name+0xce>
 800a958:	2300      	movs	r3, #0
 800a95a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800a95e:	e011      	b.n	800a984 <create_name+0xf8>
		w = lfn[di - 1];
 800a960:	697b      	ldr	r3, [r7, #20]
 800a962:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800a966:	3b01      	subs	r3, #1
 800a968:	005b      	lsls	r3, r3, #1
 800a96a:	68fa      	ldr	r2, [r7, #12]
 800a96c:	4413      	add	r3, r2
 800a96e:	881b      	ldrh	r3, [r3, #0]
 800a970:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (w != ' ' && w != '.') break;
 800a972:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a974:	2b20      	cmp	r3, #32
 800a976:	d002      	beq.n	800a97e <create_name+0xf2>
 800a978:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a97a:	2b2e      	cmp	r3, #46	; 0x2e
 800a97c:	d106      	bne.n	800a98c <create_name+0x100>
		di--;
 800a97e:	697b      	ldr	r3, [r7, #20]
 800a980:	3b01      	subs	r3, #1
 800a982:	617b      	str	r3, [r7, #20]
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800a984:	697b      	ldr	r3, [r7, #20]
 800a986:	2b00      	cmp	r3, #0
 800a988:	d1ea      	bne.n	800a960 <create_name+0xd4>
 800a98a:	e000      	b.n	800a98e <create_name+0x102>
		if (w != ' ' && w != '.') break;
 800a98c:	bf00      	nop
	}
	lfn[di] = 0;						/* LFN is created */
 800a98e:	697b      	ldr	r3, [r7, #20]
 800a990:	005b      	lsls	r3, r3, #1
 800a992:	68fa      	ldr	r2, [r7, #12]
 800a994:	4413      	add	r3, r2
 800a996:	2200      	movs	r2, #0
 800a998:	801a      	strh	r2, [r3, #0]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 800a99a:	697b      	ldr	r3, [r7, #20]
 800a99c:	2b00      	cmp	r3, #0
 800a99e:	d101      	bne.n	800a9a4 <create_name+0x118>
 800a9a0:	2306      	movs	r3, #6
 800a9a2:	e121      	b.n	800abe8 <create_name+0x35c>

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 800a9a4:	687b      	ldr	r3, [r7, #4]
 800a9a6:	3324      	adds	r3, #36	; 0x24
 800a9a8:	220b      	movs	r2, #11
 800a9aa:	2120      	movs	r1, #32
 800a9ac:	4618      	mov	r0, r3
 800a9ae:	f7fe fa4e 	bl	8008e4e <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800a9b2:	2300      	movs	r3, #0
 800a9b4:	61bb      	str	r3, [r7, #24]
 800a9b6:	e002      	b.n	800a9be <create_name+0x132>
 800a9b8:	69bb      	ldr	r3, [r7, #24]
 800a9ba:	3301      	adds	r3, #1
 800a9bc:	61bb      	str	r3, [r7, #24]
 800a9be:	69bb      	ldr	r3, [r7, #24]
 800a9c0:	005b      	lsls	r3, r3, #1
 800a9c2:	68fa      	ldr	r2, [r7, #12]
 800a9c4:	4413      	add	r3, r2
 800a9c6:	881b      	ldrh	r3, [r3, #0]
 800a9c8:	2b20      	cmp	r3, #32
 800a9ca:	d0f5      	beq.n	800a9b8 <create_name+0x12c>
 800a9cc:	69bb      	ldr	r3, [r7, #24]
 800a9ce:	005b      	lsls	r3, r3, #1
 800a9d0:	68fa      	ldr	r2, [r7, #12]
 800a9d2:	4413      	add	r3, r2
 800a9d4:	881b      	ldrh	r3, [r3, #0]
 800a9d6:	2b2e      	cmp	r3, #46	; 0x2e
 800a9d8:	d0ee      	beq.n	800a9b8 <create_name+0x12c>
	if (si) cf |= NS_LOSS | NS_LFN;
 800a9da:	69bb      	ldr	r3, [r7, #24]
 800a9dc:	2b00      	cmp	r3, #0
 800a9de:	d009      	beq.n	800a9f4 <create_name+0x168>
 800a9e0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800a9e4:	f043 0303 	orr.w	r3, r3, #3
 800a9e8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800a9ec:	e002      	b.n	800a9f4 <create_name+0x168>
 800a9ee:	697b      	ldr	r3, [r7, #20]
 800a9f0:	3b01      	subs	r3, #1
 800a9f2:	617b      	str	r3, [r7, #20]
 800a9f4:	697b      	ldr	r3, [r7, #20]
 800a9f6:	2b00      	cmp	r3, #0
 800a9f8:	d009      	beq.n	800aa0e <create_name+0x182>
 800a9fa:	697b      	ldr	r3, [r7, #20]
 800a9fc:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800aa00:	3b01      	subs	r3, #1
 800aa02:	005b      	lsls	r3, r3, #1
 800aa04:	68fa      	ldr	r2, [r7, #12]
 800aa06:	4413      	add	r3, r2
 800aa08:	881b      	ldrh	r3, [r3, #0]
 800aa0a:	2b2e      	cmp	r3, #46	; 0x2e
 800aa0c:	d1ef      	bne.n	800a9ee <create_name+0x162>

	i = b = 0; ni = 8;
 800aa0e:	2300      	movs	r3, #0
 800aa10:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800aa14:	2300      	movs	r3, #0
 800aa16:	623b      	str	r3, [r7, #32]
 800aa18:	2308      	movs	r3, #8
 800aa1a:	61fb      	str	r3, [r7, #28]
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 800aa1c:	69bb      	ldr	r3, [r7, #24]
 800aa1e:	1c5a      	adds	r2, r3, #1
 800aa20:	61ba      	str	r2, [r7, #24]
 800aa22:	005b      	lsls	r3, r3, #1
 800aa24:	68fa      	ldr	r2, [r7, #12]
 800aa26:	4413      	add	r3, r2
 800aa28:	881b      	ldrh	r3, [r3, #0]
 800aa2a:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (!w) break;					/* Break on end of the LFN */
 800aa2c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aa2e:	2b00      	cmp	r3, #0
 800aa30:	f000 8090 	beq.w	800ab54 <create_name+0x2c8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800aa34:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aa36:	2b20      	cmp	r3, #32
 800aa38:	d006      	beq.n	800aa48 <create_name+0x1bc>
 800aa3a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aa3c:	2b2e      	cmp	r3, #46	; 0x2e
 800aa3e:	d10a      	bne.n	800aa56 <create_name+0x1ca>
 800aa40:	69ba      	ldr	r2, [r7, #24]
 800aa42:	697b      	ldr	r3, [r7, #20]
 800aa44:	429a      	cmp	r2, r3
 800aa46:	d006      	beq.n	800aa56 <create_name+0x1ca>
			cf |= NS_LOSS | NS_LFN; continue;
 800aa48:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aa4c:	f043 0303 	orr.w	r3, r3, #3
 800aa50:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800aa54:	e07d      	b.n	800ab52 <create_name+0x2c6>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 800aa56:	6a3a      	ldr	r2, [r7, #32]
 800aa58:	69fb      	ldr	r3, [r7, #28]
 800aa5a:	429a      	cmp	r2, r3
 800aa5c:	d203      	bcs.n	800aa66 <create_name+0x1da>
 800aa5e:	69ba      	ldr	r2, [r7, #24]
 800aa60:	697b      	ldr	r3, [r7, #20]
 800aa62:	429a      	cmp	r2, r3
 800aa64:	d123      	bne.n	800aaae <create_name+0x222>
			if (ni == 11) {				/* Long extension */
 800aa66:	69fb      	ldr	r3, [r7, #28]
 800aa68:	2b0b      	cmp	r3, #11
 800aa6a:	d106      	bne.n	800aa7a <create_name+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
 800aa6c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aa70:	f043 0303 	orr.w	r3, r3, #3
 800aa74:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800aa78:	e06f      	b.n	800ab5a <create_name+0x2ce>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800aa7a:	69ba      	ldr	r2, [r7, #24]
 800aa7c:	697b      	ldr	r3, [r7, #20]
 800aa7e:	429a      	cmp	r2, r3
 800aa80:	d005      	beq.n	800aa8e <create_name+0x202>
 800aa82:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aa86:	f043 0303 	orr.w	r3, r3, #3
 800aa8a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			if (si > di) break;			/* No extension */
 800aa8e:	69ba      	ldr	r2, [r7, #24]
 800aa90:	697b      	ldr	r3, [r7, #20]
 800aa92:	429a      	cmp	r2, r3
 800aa94:	d860      	bhi.n	800ab58 <create_name+0x2cc>
			si = di; i = 8; ni = 11;	/* Enter extension section */
 800aa96:	697b      	ldr	r3, [r7, #20]
 800aa98:	61bb      	str	r3, [r7, #24]
 800aa9a:	2308      	movs	r3, #8
 800aa9c:	623b      	str	r3, [r7, #32]
 800aa9e:	230b      	movs	r3, #11
 800aaa0:	61fb      	str	r3, [r7, #28]
			b <<= 2; continue;
 800aaa2:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800aaa6:	009b      	lsls	r3, r3, #2
 800aaa8:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800aaac:	e051      	b.n	800ab52 <create_name+0x2c6>
		}

		if (w >= 0x80) {				/* Non ASCII character */
 800aaae:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aab0:	2b7f      	cmp	r3, #127	; 0x7f
 800aab2:	d914      	bls.n	800aade <create_name+0x252>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 800aab4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aab6:	2100      	movs	r1, #0
 800aab8:	4618      	mov	r0, r3
 800aaba:	f001 f997 	bl	800bdec <ff_convert>
 800aabe:	4603      	mov	r3, r0
 800aac0:	84bb      	strh	r3, [r7, #36]	; 0x24
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800aac2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	d004      	beq.n	800aad2 <create_name+0x246>
 800aac8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aaca:	3b80      	subs	r3, #128	; 0x80
 800aacc:	4a49      	ldr	r2, [pc, #292]	; (800abf4 <create_name+0x368>)
 800aace:	5cd3      	ldrb	r3, [r2, r3]
 800aad0:	84bb      	strh	r3, [r7, #36]	; 0x24
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 800aad2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aad6:	f043 0302 	orr.w	r3, r3, #2
 800aada:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800aade:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aae0:	2b00      	cmp	r3, #0
 800aae2:	d007      	beq.n	800aaf4 <create_name+0x268>
 800aae4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800aae6:	4619      	mov	r1, r3
 800aae8:	4843      	ldr	r0, [pc, #268]	; (800abf8 <create_name+0x36c>)
 800aaea:	f7fe f9f2 	bl	8008ed2 <chk_chr>
 800aaee:	4603      	mov	r3, r0
 800aaf0:	2b00      	cmp	r3, #0
 800aaf2:	d008      	beq.n	800ab06 <create_name+0x27a>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800aaf4:	235f      	movs	r3, #95	; 0x5f
 800aaf6:	84bb      	strh	r3, [r7, #36]	; 0x24
 800aaf8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aafc:	f043 0303 	orr.w	r3, r3, #3
 800ab00:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800ab04:	e01b      	b.n	800ab3e <create_name+0x2b2>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 800ab06:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ab08:	2b40      	cmp	r3, #64	; 0x40
 800ab0a:	d909      	bls.n	800ab20 <create_name+0x294>
 800ab0c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ab0e:	2b5a      	cmp	r3, #90	; 0x5a
 800ab10:	d806      	bhi.n	800ab20 <create_name+0x294>
					b |= 2;
 800ab12:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800ab16:	f043 0302 	orr.w	r3, r3, #2
 800ab1a:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800ab1e:	e00e      	b.n	800ab3e <create_name+0x2b2>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 800ab20:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ab22:	2b60      	cmp	r3, #96	; 0x60
 800ab24:	d90b      	bls.n	800ab3e <create_name+0x2b2>
 800ab26:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ab28:	2b7a      	cmp	r3, #122	; 0x7a
 800ab2a:	d808      	bhi.n	800ab3e <create_name+0x2b2>
						b |= 1; w -= 0x20;
 800ab2c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800ab30:	f043 0301 	orr.w	r3, r3, #1
 800ab34:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800ab38:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ab3a:	3b20      	subs	r3, #32
 800ab3c:	84bb      	strh	r3, [r7, #36]	; 0x24
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 800ab3e:	6a3b      	ldr	r3, [r7, #32]
 800ab40:	1c5a      	adds	r2, r3, #1
 800ab42:	623a      	str	r2, [r7, #32]
 800ab44:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800ab46:	b2d1      	uxtb	r1, r2
 800ab48:	687a      	ldr	r2, [r7, #4]
 800ab4a:	4413      	add	r3, r2
 800ab4c:	460a      	mov	r2, r1
 800ab4e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
		w = lfn[si++];					/* Get an LFN character */
 800ab52:	e763      	b.n	800aa1c <create_name+0x190>
		if (!w) break;					/* Break on end of the LFN */
 800ab54:	bf00      	nop
 800ab56:	e000      	b.n	800ab5a <create_name+0x2ce>
			if (si > di) break;			/* No extension */
 800ab58:	bf00      	nop
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ab5a:	687b      	ldr	r3, [r7, #4]
 800ab5c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800ab60:	2be5      	cmp	r3, #229	; 0xe5
 800ab62:	d103      	bne.n	800ab6c <create_name+0x2e0>
 800ab64:	687b      	ldr	r3, [r7, #4]
 800ab66:	2205      	movs	r2, #5
 800ab68:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

	if (ni == 8) b <<= 2;
 800ab6c:	69fb      	ldr	r3, [r7, #28]
 800ab6e:	2b08      	cmp	r3, #8
 800ab70:	d104      	bne.n	800ab7c <create_name+0x2f0>
 800ab72:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800ab76:	009b      	lsls	r3, r3, #2
 800ab78:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800ab7c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800ab80:	f003 030c 	and.w	r3, r3, #12
 800ab84:	2b0c      	cmp	r3, #12
 800ab86:	d005      	beq.n	800ab94 <create_name+0x308>
 800ab88:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800ab8c:	f003 0303 	and.w	r3, r3, #3
 800ab90:	2b03      	cmp	r3, #3
 800ab92:	d105      	bne.n	800aba0 <create_name+0x314>
 800ab94:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ab98:	f043 0302 	orr.w	r3, r3, #2
 800ab9c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800aba0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800aba4:	f003 0302 	and.w	r3, r3, #2
 800aba8:	2b00      	cmp	r3, #0
 800abaa:	d117      	bne.n	800abdc <create_name+0x350>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800abac:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800abb0:	f003 0303 	and.w	r3, r3, #3
 800abb4:	2b01      	cmp	r3, #1
 800abb6:	d105      	bne.n	800abc4 <create_name+0x338>
 800abb8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800abbc:	f043 0310 	orr.w	r3, r3, #16
 800abc0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 800abc4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800abc8:	f003 030c 	and.w	r3, r3, #12
 800abcc:	2b04      	cmp	r3, #4
 800abce:	d105      	bne.n	800abdc <create_name+0x350>
 800abd0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800abd4:	f043 0308 	orr.w	r3, r3, #8
 800abd8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800abdc:	687b      	ldr	r3, [r7, #4]
 800abde:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800abe2:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

	return FR_OK;
 800abe6:	2300      	movs	r3, #0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

	return FR_OK;
#endif /* _USE_LFN != 0 */
}
 800abe8:	4618      	mov	r0, r3
 800abea:	3728      	adds	r7, #40	; 0x28
 800abec:	46bd      	mov	sp, r7
 800abee:	bd80      	pop	{r7, pc}
 800abf0:	08028b24 	.word	0x08028b24
 800abf4:	08029f18 	.word	0x08029f18
 800abf8:	08028b30 	.word	0x08028b30

0800abfc <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 800abfc:	b580      	push	{r7, lr}
 800abfe:	b086      	sub	sp, #24
 800ac00:	af00      	add	r7, sp, #0
 800ac02:	6078      	str	r0, [r7, #4]
 800ac04:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
 800ac06:	687b      	ldr	r3, [r7, #4]
 800ac08:	613b      	str	r3, [r7, #16]
	FATFS *fs = obj->fs;
 800ac0a:	693b      	ldr	r3, [r7, #16]
 800ac0c:	681b      	ldr	r3, [r3, #0]
 800ac0e:	60fb      	str	r3, [r7, #12]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800ac10:	e002      	b.n	800ac18 <follow_path+0x1c>
 800ac12:	683b      	ldr	r3, [r7, #0]
 800ac14:	3301      	adds	r3, #1
 800ac16:	603b      	str	r3, [r7, #0]
 800ac18:	683b      	ldr	r3, [r7, #0]
 800ac1a:	781b      	ldrb	r3, [r3, #0]
 800ac1c:	2b2f      	cmp	r3, #47	; 0x2f
 800ac1e:	d0f8      	beq.n	800ac12 <follow_path+0x16>
 800ac20:	683b      	ldr	r3, [r7, #0]
 800ac22:	781b      	ldrb	r3, [r3, #0]
 800ac24:	2b5c      	cmp	r3, #92	; 0x5c
 800ac26:	d0f4      	beq.n	800ac12 <follow_path+0x16>
		obj->sclust = 0;					/* Start from root directory */
 800ac28:	693b      	ldr	r3, [r7, #16]
 800ac2a:	2200      	movs	r2, #0
 800ac2c:	609a      	str	r2, [r3, #8]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800ac2e:	683b      	ldr	r3, [r7, #0]
 800ac30:	781b      	ldrb	r3, [r3, #0]
 800ac32:	2b1f      	cmp	r3, #31
 800ac34:	d80a      	bhi.n	800ac4c <follow_path+0x50>
		dp->fn[NSFLAG] = NS_NONAME;
 800ac36:	687b      	ldr	r3, [r7, #4]
 800ac38:	2280      	movs	r2, #128	; 0x80
 800ac3a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		res = dir_sdi(dp, 0);
 800ac3e:	2100      	movs	r1, #0
 800ac40:	6878      	ldr	r0, [r7, #4]
 800ac42:	f7fe fe91 	bl	8009968 <dir_sdi>
 800ac46:	4603      	mov	r3, r0
 800ac48:	75fb      	strb	r3, [r7, #23]
 800ac4a:	e043      	b.n	800acd4 <follow_path+0xd8>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800ac4c:	463b      	mov	r3, r7
 800ac4e:	4619      	mov	r1, r3
 800ac50:	6878      	ldr	r0, [r7, #4]
 800ac52:	f7ff fe1b 	bl	800a88c <create_name>
 800ac56:	4603      	mov	r3, r0
 800ac58:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800ac5a:	7dfb      	ldrb	r3, [r7, #23]
 800ac5c:	2b00      	cmp	r3, #0
 800ac5e:	d134      	bne.n	800acca <follow_path+0xce>
			res = dir_find(dp);				/* Find an object with the segment name */
 800ac60:	6878      	ldr	r0, [r7, #4]
 800ac62:	f7ff fadb 	bl	800a21c <dir_find>
 800ac66:	4603      	mov	r3, r0
 800ac68:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
 800ac6a:	687b      	ldr	r3, [r7, #4]
 800ac6c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800ac70:	72fb      	strb	r3, [r7, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 800ac72:	7dfb      	ldrb	r3, [r7, #23]
 800ac74:	2b00      	cmp	r3, #0
 800ac76:	d00a      	beq.n	800ac8e <follow_path+0x92>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800ac78:	7dfb      	ldrb	r3, [r7, #23]
 800ac7a:	2b04      	cmp	r3, #4
 800ac7c:	d127      	bne.n	800acce <follow_path+0xd2>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800ac7e:	7afb      	ldrb	r3, [r7, #11]
 800ac80:	f003 0304 	and.w	r3, r3, #4
 800ac84:	2b00      	cmp	r3, #0
 800ac86:	d122      	bne.n	800acce <follow_path+0xd2>
 800ac88:	2305      	movs	r3, #5
 800ac8a:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
 800ac8c:	e01f      	b.n	800acce <follow_path+0xd2>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800ac8e:	7afb      	ldrb	r3, [r7, #11]
 800ac90:	f003 0304 	and.w	r3, r3, #4
 800ac94:	2b00      	cmp	r3, #0
 800ac96:	d11c      	bne.n	800acd2 <follow_path+0xd6>
			/* Get into the sub-directory */
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 800ac98:	693b      	ldr	r3, [r7, #16]
 800ac9a:	799b      	ldrb	r3, [r3, #6]
 800ac9c:	f003 0310 	and.w	r3, r3, #16
 800aca0:	2b00      	cmp	r3, #0
 800aca2:	d102      	bne.n	800acaa <follow_path+0xae>
				res = FR_NO_PATH; break;
 800aca4:	2305      	movs	r3, #5
 800aca6:	75fb      	strb	r3, [r7, #23]
 800aca8:	e014      	b.n	800acd4 <follow_path+0xd8>
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
			} else
#endif
			{
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800acaa:	68fb      	ldr	r3, [r7, #12]
 800acac:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800acb0:	687b      	ldr	r3, [r7, #4]
 800acb2:	695b      	ldr	r3, [r3, #20]
 800acb4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800acb8:	4413      	add	r3, r2
 800acba:	4619      	mov	r1, r3
 800acbc:	68f8      	ldr	r0, [r7, #12]
 800acbe:	f7fe ffda 	bl	8009c76 <ld_clust>
 800acc2:	4602      	mov	r2, r0
 800acc4:	693b      	ldr	r3, [r7, #16]
 800acc6:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800acc8:	e7c0      	b.n	800ac4c <follow_path+0x50>
			if (res != FR_OK) break;
 800acca:	bf00      	nop
 800accc:	e002      	b.n	800acd4 <follow_path+0xd8>
				break;
 800acce:	bf00      	nop
 800acd0:	e000      	b.n	800acd4 <follow_path+0xd8>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800acd2:	bf00      	nop
			}
		}
	}

	return res;
 800acd4:	7dfb      	ldrb	r3, [r7, #23]
}
 800acd6:	4618      	mov	r0, r3
 800acd8:	3718      	adds	r7, #24
 800acda:	46bd      	mov	sp, r7
 800acdc:	bd80      	pop	{r7, pc}

0800acde <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 800acde:	b480      	push	{r7}
 800ace0:	b087      	sub	sp, #28
 800ace2:	af00      	add	r7, sp, #0
 800ace4:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 800ace6:	f04f 33ff 	mov.w	r3, #4294967295
 800acea:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 800acec:	687b      	ldr	r3, [r7, #4]
 800acee:	681b      	ldr	r3, [r3, #0]
 800acf0:	2b00      	cmp	r3, #0
 800acf2:	d031      	beq.n	800ad58 <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800acf4:	687b      	ldr	r3, [r7, #4]
 800acf6:	681b      	ldr	r3, [r3, #0]
 800acf8:	617b      	str	r3, [r7, #20]
 800acfa:	e002      	b.n	800ad02 <get_ldnumber+0x24>
 800acfc:	697b      	ldr	r3, [r7, #20]
 800acfe:	3301      	adds	r3, #1
 800ad00:	617b      	str	r3, [r7, #20]
 800ad02:	697b      	ldr	r3, [r7, #20]
 800ad04:	781b      	ldrb	r3, [r3, #0]
 800ad06:	2b1f      	cmp	r3, #31
 800ad08:	d903      	bls.n	800ad12 <get_ldnumber+0x34>
 800ad0a:	697b      	ldr	r3, [r7, #20]
 800ad0c:	781b      	ldrb	r3, [r3, #0]
 800ad0e:	2b3a      	cmp	r3, #58	; 0x3a
 800ad10:	d1f4      	bne.n	800acfc <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 800ad12:	697b      	ldr	r3, [r7, #20]
 800ad14:	781b      	ldrb	r3, [r3, #0]
 800ad16:	2b3a      	cmp	r3, #58	; 0x3a
 800ad18:	d11c      	bne.n	800ad54 <get_ldnumber+0x76>
			tp = *path;
 800ad1a:	687b      	ldr	r3, [r7, #4]
 800ad1c:	681b      	ldr	r3, [r3, #0]
 800ad1e:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0';
 800ad20:	68fb      	ldr	r3, [r7, #12]
 800ad22:	1c5a      	adds	r2, r3, #1
 800ad24:	60fa      	str	r2, [r7, #12]
 800ad26:	781b      	ldrb	r3, [r3, #0]
 800ad28:	3b30      	subs	r3, #48	; 0x30
 800ad2a:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800ad2c:	68bb      	ldr	r3, [r7, #8]
 800ad2e:	2b09      	cmp	r3, #9
 800ad30:	d80e      	bhi.n	800ad50 <get_ldnumber+0x72>
 800ad32:	68fa      	ldr	r2, [r7, #12]
 800ad34:	697b      	ldr	r3, [r7, #20]
 800ad36:	429a      	cmp	r2, r3
 800ad38:	d10a      	bne.n	800ad50 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800ad3a:	68bb      	ldr	r3, [r7, #8]
 800ad3c:	2b00      	cmp	r3, #0
 800ad3e:	d107      	bne.n	800ad50 <get_ldnumber+0x72>
					vol = (int)i;
 800ad40:	68bb      	ldr	r3, [r7, #8]
 800ad42:	613b      	str	r3, [r7, #16]
					*path = ++tt;
 800ad44:	697b      	ldr	r3, [r7, #20]
 800ad46:	3301      	adds	r3, #1
 800ad48:	617b      	str	r3, [r7, #20]
 800ad4a:	687b      	ldr	r3, [r7, #4]
 800ad4c:	697a      	ldr	r2, [r7, #20]
 800ad4e:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
 800ad50:	693b      	ldr	r3, [r7, #16]
 800ad52:	e002      	b.n	800ad5a <get_ldnumber+0x7c>
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 800ad54:	2300      	movs	r3, #0
 800ad56:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
 800ad58:	693b      	ldr	r3, [r7, #16]
}
 800ad5a:	4618      	mov	r0, r3
 800ad5c:	371c      	adds	r7, #28
 800ad5e:	46bd      	mov	sp, r7
 800ad60:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad64:	4770      	bx	lr
	...

0800ad68 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 800ad68:	b580      	push	{r7, lr}
 800ad6a:	b082      	sub	sp, #8
 800ad6c:	af00      	add	r7, sp, #0
 800ad6e:	6078      	str	r0, [r7, #4]
 800ad70:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	2200      	movs	r2, #0
 800ad76:	70da      	strb	r2, [r3, #3]
 800ad78:	687b      	ldr	r3, [r7, #4]
 800ad7a:	f04f 32ff 	mov.w	r2, #4294967295
 800ad7e:	631a      	str	r2, [r3, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800ad80:	6839      	ldr	r1, [r7, #0]
 800ad82:	6878      	ldr	r0, [r7, #4]
 800ad84:	f7fe fa70 	bl	8009268 <move_window>
 800ad88:	4603      	mov	r3, r0
 800ad8a:	2b00      	cmp	r3, #0
 800ad8c:	d001      	beq.n	800ad92 <check_fs+0x2a>
 800ad8e:	2304      	movs	r3, #4
 800ad90:	e038      	b.n	800ae04 <check_fs+0x9c>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800ad92:	687b      	ldr	r3, [r7, #4]
 800ad94:	3334      	adds	r3, #52	; 0x34
 800ad96:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 800ad9a:	4618      	mov	r0, r3
 800ad9c:	f7fd ffb4 	bl	8008d08 <ld_word>
 800ada0:	4603      	mov	r3, r0
 800ada2:	461a      	mov	r2, r3
 800ada4:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800ada8:	429a      	cmp	r2, r3
 800adaa:	d001      	beq.n	800adb0 <check_fs+0x48>
 800adac:	2303      	movs	r3, #3
 800adae:	e029      	b.n	800ae04 <check_fs+0x9c>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 800adb0:	687b      	ldr	r3, [r7, #4]
 800adb2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800adb6:	2be9      	cmp	r3, #233	; 0xe9
 800adb8:	d009      	beq.n	800adce <check_fs+0x66>
 800adba:	687b      	ldr	r3, [r7, #4]
 800adbc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800adc0:	2beb      	cmp	r3, #235	; 0xeb
 800adc2:	d11e      	bne.n	800ae02 <check_fs+0x9a>
 800adc4:	687b      	ldr	r3, [r7, #4]
 800adc6:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800adca:	2b90      	cmp	r3, #144	; 0x90
 800adcc:	d119      	bne.n	800ae02 <check_fs+0x9a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800adce:	687b      	ldr	r3, [r7, #4]
 800add0:	3334      	adds	r3, #52	; 0x34
 800add2:	3336      	adds	r3, #54	; 0x36
 800add4:	4618      	mov	r0, r3
 800add6:	f7fd ffaf 	bl	8008d38 <ld_dword>
 800adda:	4603      	mov	r3, r0
 800addc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ade0:	4a0a      	ldr	r2, [pc, #40]	; (800ae0c <check_fs+0xa4>)
 800ade2:	4293      	cmp	r3, r2
 800ade4:	d101      	bne.n	800adea <check_fs+0x82>
 800ade6:	2300      	movs	r3, #0
 800ade8:	e00c      	b.n	800ae04 <check_fs+0x9c>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800adea:	687b      	ldr	r3, [r7, #4]
 800adec:	3334      	adds	r3, #52	; 0x34
 800adee:	3352      	adds	r3, #82	; 0x52
 800adf0:	4618      	mov	r0, r3
 800adf2:	f7fd ffa1 	bl	8008d38 <ld_dword>
 800adf6:	4603      	mov	r3, r0
 800adf8:	4a05      	ldr	r2, [pc, #20]	; (800ae10 <check_fs+0xa8>)
 800adfa:	4293      	cmp	r3, r2
 800adfc:	d101      	bne.n	800ae02 <check_fs+0x9a>
 800adfe:	2300      	movs	r3, #0
 800ae00:	e000      	b.n	800ae04 <check_fs+0x9c>
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
 800ae02:	2302      	movs	r3, #2
}
 800ae04:	4618      	mov	r0, r3
 800ae06:	3708      	adds	r7, #8
 800ae08:	46bd      	mov	sp, r7
 800ae0a:	bd80      	pop	{r7, pc}
 800ae0c:	00544146 	.word	0x00544146
 800ae10:	33544146 	.word	0x33544146

0800ae14 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 800ae14:	b580      	push	{r7, lr}
 800ae16:	b096      	sub	sp, #88	; 0x58
 800ae18:	af00      	add	r7, sp, #0
 800ae1a:	60f8      	str	r0, [r7, #12]
 800ae1c:	60b9      	str	r1, [r7, #8]
 800ae1e:	4613      	mov	r3, r2
 800ae20:	71fb      	strb	r3, [r7, #7]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 800ae22:	68bb      	ldr	r3, [r7, #8]
 800ae24:	2200      	movs	r2, #0
 800ae26:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
 800ae28:	68f8      	ldr	r0, [r7, #12]
 800ae2a:	f7ff ff58 	bl	800acde <get_ldnumber>
 800ae2e:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (vol < 0) return FR_INVALID_DRIVE;
 800ae30:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae32:	2b00      	cmp	r3, #0
 800ae34:	da01      	bge.n	800ae3a <find_volume+0x26>
 800ae36:	230b      	movs	r3, #11
 800ae38:	e231      	b.n	800b29e <find_volume+0x48a>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 800ae3a:	4aa8      	ldr	r2, [pc, #672]	; (800b0dc <find_volume+0x2c8>)
 800ae3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ae3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ae42:	63bb      	str	r3, [r7, #56]	; 0x38
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800ae44:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae46:	2b00      	cmp	r3, #0
 800ae48:	d101      	bne.n	800ae4e <find_volume+0x3a>
 800ae4a:	230c      	movs	r3, #12
 800ae4c:	e227      	b.n	800b29e <find_volume+0x48a>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 800ae4e:	68bb      	ldr	r3, [r7, #8]
 800ae50:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ae52:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800ae54:	79fb      	ldrb	r3, [r7, #7]
 800ae56:	f023 0301 	bic.w	r3, r3, #1
 800ae5a:	71fb      	strb	r3, [r7, #7]
	if (fs->fs_type) {					/* If the volume has been mounted */
 800ae5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae5e:	781b      	ldrb	r3, [r3, #0]
 800ae60:	2b00      	cmp	r3, #0
 800ae62:	d01a      	beq.n	800ae9a <find_volume+0x86>
		stat = disk_status(fs->drv);
 800ae64:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae66:	785b      	ldrb	r3, [r3, #1]
 800ae68:	4618      	mov	r0, r3
 800ae6a:	f7fd feaf 	bl	8008bcc <disk_status>
 800ae6e:	4603      	mov	r3, r0
 800ae70:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800ae74:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ae78:	f003 0301 	and.w	r3, r3, #1
 800ae7c:	2b00      	cmp	r3, #0
 800ae7e:	d10c      	bne.n	800ae9a <find_volume+0x86>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800ae80:	79fb      	ldrb	r3, [r7, #7]
 800ae82:	2b00      	cmp	r3, #0
 800ae84:	d007      	beq.n	800ae96 <find_volume+0x82>
 800ae86:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ae8a:	f003 0304 	and.w	r3, r3, #4
 800ae8e:	2b00      	cmp	r3, #0
 800ae90:	d001      	beq.n	800ae96 <find_volume+0x82>
				return FR_WRITE_PROTECTED;
 800ae92:	230a      	movs	r3, #10
 800ae94:	e203      	b.n	800b29e <find_volume+0x48a>
			}
			return FR_OK;				/* The file system object is valid */
 800ae96:	2300      	movs	r3, #0
 800ae98:	e201      	b.n	800b29e <find_volume+0x48a>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800ae9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae9c:	2200      	movs	r2, #0
 800ae9e:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800aea0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aea2:	b2da      	uxtb	r2, r3
 800aea4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aea6:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800aea8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aeaa:	785b      	ldrb	r3, [r3, #1]
 800aeac:	4618      	mov	r0, r3
 800aeae:	f7fd fea7 	bl	8008c00 <disk_initialize>
 800aeb2:	4603      	mov	r3, r0
 800aeb4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800aeb8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800aebc:	f003 0301 	and.w	r3, r3, #1
 800aec0:	2b00      	cmp	r3, #0
 800aec2:	d001      	beq.n	800aec8 <find_volume+0xb4>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800aec4:	2303      	movs	r3, #3
 800aec6:	e1ea      	b.n	800b29e <find_volume+0x48a>
	}
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800aec8:	79fb      	ldrb	r3, [r7, #7]
 800aeca:	2b00      	cmp	r3, #0
 800aecc:	d007      	beq.n	800aede <find_volume+0xca>
 800aece:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800aed2:	f003 0304 	and.w	r3, r3, #4
 800aed6:	2b00      	cmp	r3, #0
 800aed8:	d001      	beq.n	800aede <find_volume+0xca>
		return FR_WRITE_PROTECTED;
 800aeda:	230a      	movs	r3, #10
 800aedc:	e1df      	b.n	800b29e <find_volume+0x48a>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
	bsect = 0;
 800aede:	2300      	movs	r3, #0
 800aee0:	653b      	str	r3, [r7, #80]	; 0x50
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 800aee2:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800aee4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800aee6:	f7ff ff3f 	bl	800ad68 <check_fs>
 800aeea:	4603      	mov	r3, r0
 800aeec:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 800aef0:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800aef4:	2b02      	cmp	r3, #2
 800aef6:	d14b      	bne.n	800af90 <find_volume+0x17c>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800aef8:	2300      	movs	r3, #0
 800aefa:	643b      	str	r3, [r7, #64]	; 0x40
 800aefc:	e01f      	b.n	800af3e <find_volume+0x12a>
			pt = fs->win + (MBR_Table + i * SZ_PTE);
 800aefe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800af00:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800af04:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af06:	011b      	lsls	r3, r3, #4
 800af08:	f503 73df 	add.w	r3, r3, #446	; 0x1be
 800af0c:	4413      	add	r3, r2
 800af0e:	633b      	str	r3, [r7, #48]	; 0x30
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800af10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800af12:	3304      	adds	r3, #4
 800af14:	781b      	ldrb	r3, [r3, #0]
 800af16:	2b00      	cmp	r3, #0
 800af18:	d006      	beq.n	800af28 <find_volume+0x114>
 800af1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800af1c:	3308      	adds	r3, #8
 800af1e:	4618      	mov	r0, r3
 800af20:	f7fd ff0a 	bl	8008d38 <ld_dword>
 800af24:	4602      	mov	r2, r0
 800af26:	e000      	b.n	800af2a <find_volume+0x116>
 800af28:	2200      	movs	r2, #0
 800af2a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af2c:	009b      	lsls	r3, r3, #2
 800af2e:	f107 0158 	add.w	r1, r7, #88	; 0x58
 800af32:	440b      	add	r3, r1
 800af34:	f843 2c44 	str.w	r2, [r3, #-68]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800af38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af3a:	3301      	adds	r3, #1
 800af3c:	643b      	str	r3, [r7, #64]	; 0x40
 800af3e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af40:	2b03      	cmp	r3, #3
 800af42:	d9dc      	bls.n	800aefe <find_volume+0xea>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
 800af44:	2300      	movs	r3, #0
 800af46:	643b      	str	r3, [r7, #64]	; 0x40
		if (i) i--;
 800af48:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d002      	beq.n	800af54 <find_volume+0x140>
 800af4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af50:	3b01      	subs	r3, #1
 800af52:	643b      	str	r3, [r7, #64]	; 0x40
		do {							/* Find an FAT volume */
			bsect = br[i];
 800af54:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af56:	009b      	lsls	r3, r3, #2
 800af58:	f107 0258 	add.w	r2, r7, #88	; 0x58
 800af5c:	4413      	add	r3, r2
 800af5e:	f853 3c44 	ldr.w	r3, [r3, #-68]
 800af62:	653b      	str	r3, [r7, #80]	; 0x50
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800af64:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800af66:	2b00      	cmp	r3, #0
 800af68:	d005      	beq.n	800af76 <find_volume+0x162>
 800af6a:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800af6c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800af6e:	f7ff fefb 	bl	800ad68 <check_fs>
 800af72:	4603      	mov	r3, r0
 800af74:	e000      	b.n	800af78 <find_volume+0x164>
 800af76:	2303      	movs	r3, #3
 800af78:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800af7c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800af80:	2b01      	cmp	r3, #1
 800af82:	d905      	bls.n	800af90 <find_volume+0x17c>
 800af84:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af86:	3301      	adds	r3, #1
 800af88:	643b      	str	r3, [r7, #64]	; 0x40
 800af8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af8c:	2b03      	cmp	r3, #3
 800af8e:	d9e1      	bls.n	800af54 <find_volume+0x140>
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800af90:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800af94:	2b04      	cmp	r3, #4
 800af96:	d101      	bne.n	800af9c <find_volume+0x188>
 800af98:	2301      	movs	r3, #1
 800af9a:	e180      	b.n	800b29e <find_volume+0x48a>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800af9c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800afa0:	2b01      	cmp	r3, #1
 800afa2:	d901      	bls.n	800afa8 <find_volume+0x194>
 800afa4:	230d      	movs	r3, #13
 800afa6:	e17a      	b.n	800b29e <find_volume+0x48a>
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* _FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800afa8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afaa:	3334      	adds	r3, #52	; 0x34
 800afac:	330b      	adds	r3, #11
 800afae:	4618      	mov	r0, r3
 800afb0:	f7fd feaa 	bl	8008d08 <ld_word>
 800afb4:	4603      	mov	r3, r0
 800afb6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800afba:	d001      	beq.n	800afc0 <find_volume+0x1ac>
 800afbc:	230d      	movs	r3, #13
 800afbe:	e16e      	b.n	800b29e <find_volume+0x48a>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800afc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afc2:	3334      	adds	r3, #52	; 0x34
 800afc4:	3316      	adds	r3, #22
 800afc6:	4618      	mov	r0, r3
 800afc8:	f7fd fe9e 	bl	8008d08 <ld_word>
 800afcc:	4603      	mov	r3, r0
 800afce:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800afd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	d106      	bne.n	800afe4 <find_volume+0x1d0>
 800afd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afd8:	3334      	adds	r3, #52	; 0x34
 800afda:	3324      	adds	r3, #36	; 0x24
 800afdc:	4618      	mov	r0, r3
 800afde:	f7fd feab 	bl	8008d38 <ld_dword>
 800afe2:	64f8      	str	r0, [r7, #76]	; 0x4c
		fs->fsize = fasize;
 800afe4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afe6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800afe8:	61da      	str	r2, [r3, #28]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800afea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afec:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
 800aff0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aff2:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800aff4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aff6:	789b      	ldrb	r3, [r3, #2]
 800aff8:	2b01      	cmp	r3, #1
 800affa:	d005      	beq.n	800b008 <find_volume+0x1f4>
 800affc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800affe:	789b      	ldrb	r3, [r3, #2]
 800b000:	2b02      	cmp	r3, #2
 800b002:	d001      	beq.n	800b008 <find_volume+0x1f4>
 800b004:	230d      	movs	r3, #13
 800b006:	e14a      	b.n	800b29e <find_volume+0x48a>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800b008:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b00a:	789b      	ldrb	r3, [r3, #2]
 800b00c:	461a      	mov	r2, r3
 800b00e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b010:	fb02 f303 	mul.w	r3, r2, r3
 800b014:	64fb      	str	r3, [r7, #76]	; 0x4c

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800b016:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b018:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b01c:	b29a      	uxth	r2, r3
 800b01e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b020:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800b022:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b024:	895b      	ldrh	r3, [r3, #10]
 800b026:	2b00      	cmp	r3, #0
 800b028:	d008      	beq.n	800b03c <find_volume+0x228>
 800b02a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b02c:	895b      	ldrh	r3, [r3, #10]
 800b02e:	461a      	mov	r2, r3
 800b030:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b032:	895b      	ldrh	r3, [r3, #10]
 800b034:	3b01      	subs	r3, #1
 800b036:	4013      	ands	r3, r2
 800b038:	2b00      	cmp	r3, #0
 800b03a:	d001      	beq.n	800b040 <find_volume+0x22c>
 800b03c:	230d      	movs	r3, #13
 800b03e:	e12e      	b.n	800b29e <find_volume+0x48a>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800b040:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b042:	3334      	adds	r3, #52	; 0x34
 800b044:	3311      	adds	r3, #17
 800b046:	4618      	mov	r0, r3
 800b048:	f7fd fe5e 	bl	8008d08 <ld_word>
 800b04c:	4603      	mov	r3, r0
 800b04e:	461a      	mov	r2, r3
 800b050:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b052:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800b054:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b056:	891b      	ldrh	r3, [r3, #8]
 800b058:	f003 030f 	and.w	r3, r3, #15
 800b05c:	b29b      	uxth	r3, r3
 800b05e:	2b00      	cmp	r3, #0
 800b060:	d001      	beq.n	800b066 <find_volume+0x252>
 800b062:	230d      	movs	r3, #13
 800b064:	e11b      	b.n	800b29e <find_volume+0x48a>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 800b066:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b068:	3334      	adds	r3, #52	; 0x34
 800b06a:	3313      	adds	r3, #19
 800b06c:	4618      	mov	r0, r3
 800b06e:	f7fd fe4b 	bl	8008d08 <ld_word>
 800b072:	4603      	mov	r3, r0
 800b074:	64bb      	str	r3, [r7, #72]	; 0x48
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800b076:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b078:	2b00      	cmp	r3, #0
 800b07a:	d106      	bne.n	800b08a <find_volume+0x276>
 800b07c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b07e:	3334      	adds	r3, #52	; 0x34
 800b080:	3320      	adds	r3, #32
 800b082:	4618      	mov	r0, r3
 800b084:	f7fd fe58 	bl	8008d38 <ld_dword>
 800b088:	64b8      	str	r0, [r7, #72]	; 0x48

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 800b08a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b08c:	3334      	adds	r3, #52	; 0x34
 800b08e:	330e      	adds	r3, #14
 800b090:	4618      	mov	r0, r3
 800b092:	f7fd fe39 	bl	8008d08 <ld_word>
 800b096:	4603      	mov	r3, r0
 800b098:	85fb      	strh	r3, [r7, #46]	; 0x2e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800b09a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800b09c:	2b00      	cmp	r3, #0
 800b09e:	d101      	bne.n	800b0a4 <find_volume+0x290>
 800b0a0:	230d      	movs	r3, #13
 800b0a2:	e0fc      	b.n	800b29e <find_volume+0x48a>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800b0a4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800b0a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b0a8:	4413      	add	r3, r2
 800b0aa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b0ac:	8912      	ldrh	r2, [r2, #8]
 800b0ae:	0912      	lsrs	r2, r2, #4
 800b0b0:	b292      	uxth	r2, r2
 800b0b2:	4413      	add	r3, r2
 800b0b4:	62bb      	str	r3, [r7, #40]	; 0x28
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800b0b6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b0b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b0ba:	429a      	cmp	r2, r3
 800b0bc:	d201      	bcs.n	800b0c2 <find_volume+0x2ae>
 800b0be:	230d      	movs	r3, #13
 800b0c0:	e0ed      	b.n	800b29e <find_volume+0x48a>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800b0c2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b0c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b0c6:	1ad3      	subs	r3, r2, r3
 800b0c8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b0ca:	8952      	ldrh	r2, [r2, #10]
 800b0cc:	fbb3 f3f2 	udiv	r3, r3, r2
 800b0d0:	627b      	str	r3, [r7, #36]	; 0x24
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800b0d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b0d4:	2b00      	cmp	r3, #0
 800b0d6:	d103      	bne.n	800b0e0 <find_volume+0x2cc>
 800b0d8:	230d      	movs	r3, #13
 800b0da:	e0e0      	b.n	800b29e <find_volume+0x48a>
 800b0dc:	200000b4 	.word	0x200000b4
		fmt = FS_FAT32;
 800b0e0:	2303      	movs	r3, #3
 800b0e2:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800b0e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b0e8:	f64f 72f5 	movw	r2, #65525	; 0xfff5
 800b0ec:	4293      	cmp	r3, r2
 800b0ee:	d802      	bhi.n	800b0f6 <find_volume+0x2e2>
 800b0f0:	2302      	movs	r3, #2
 800b0f2:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800b0f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b0f8:	f640 72f5 	movw	r2, #4085	; 0xff5
 800b0fc:	4293      	cmp	r3, r2
 800b0fe:	d802      	bhi.n	800b106 <find_volume+0x2f2>
 800b100:	2301      	movs	r3, #1
 800b102:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800b106:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b108:	1c9a      	adds	r2, r3, #2
 800b10a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b10c:	619a      	str	r2, [r3, #24]
		fs->volbase = bsect;							/* Volume start sector */
 800b10e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b110:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b112:	621a      	str	r2, [r3, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800b114:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800b116:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b118:	441a      	add	r2, r3
 800b11a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b11c:	625a      	str	r2, [r3, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 800b11e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b120:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b122:	441a      	add	r2, r3
 800b124:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b126:	62da      	str	r2, [r3, #44]	; 0x2c
		if (fmt == FS_FAT32) {
 800b128:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800b12c:	2b03      	cmp	r3, #3
 800b12e:	d11e      	bne.n	800b16e <find_volume+0x35a>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800b130:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b132:	3334      	adds	r3, #52	; 0x34
 800b134:	332a      	adds	r3, #42	; 0x2a
 800b136:	4618      	mov	r0, r3
 800b138:	f7fd fde6 	bl	8008d08 <ld_word>
 800b13c:	4603      	mov	r3, r0
 800b13e:	2b00      	cmp	r3, #0
 800b140:	d001      	beq.n	800b146 <find_volume+0x332>
 800b142:	230d      	movs	r3, #13
 800b144:	e0ab      	b.n	800b29e <find_volume+0x48a>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800b146:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b148:	891b      	ldrh	r3, [r3, #8]
 800b14a:	2b00      	cmp	r3, #0
 800b14c:	d001      	beq.n	800b152 <find_volume+0x33e>
 800b14e:	230d      	movs	r3, #13
 800b150:	e0a5      	b.n	800b29e <find_volume+0x48a>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800b152:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b154:	3334      	adds	r3, #52	; 0x34
 800b156:	332c      	adds	r3, #44	; 0x2c
 800b158:	4618      	mov	r0, r3
 800b15a:	f7fd fded 	bl	8008d38 <ld_dword>
 800b15e:	4602      	mov	r2, r0
 800b160:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b162:	629a      	str	r2, [r3, #40]	; 0x28
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800b164:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b166:	699b      	ldr	r3, [r3, #24]
 800b168:	009b      	lsls	r3, r3, #2
 800b16a:	647b      	str	r3, [r7, #68]	; 0x44
 800b16c:	e01f      	b.n	800b1ae <find_volume+0x39a>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800b16e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b170:	891b      	ldrh	r3, [r3, #8]
 800b172:	2b00      	cmp	r3, #0
 800b174:	d101      	bne.n	800b17a <find_volume+0x366>
 800b176:	230d      	movs	r3, #13
 800b178:	e091      	b.n	800b29e <find_volume+0x48a>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800b17a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b17c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b17e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b180:	441a      	add	r2, r3
 800b182:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b184:	629a      	str	r2, [r3, #40]	; 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800b186:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800b18a:	2b02      	cmp	r3, #2
 800b18c:	d103      	bne.n	800b196 <find_volume+0x382>
 800b18e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b190:	699b      	ldr	r3, [r3, #24]
 800b192:	005b      	lsls	r3, r3, #1
 800b194:	e00a      	b.n	800b1ac <find_volume+0x398>
 800b196:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b198:	699a      	ldr	r2, [r3, #24]
 800b19a:	4613      	mov	r3, r2
 800b19c:	005b      	lsls	r3, r3, #1
 800b19e:	4413      	add	r3, r2
 800b1a0:	085a      	lsrs	r2, r3, #1
 800b1a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1a4:	699b      	ldr	r3, [r3, #24]
 800b1a6:	f003 0301 	and.w	r3, r3, #1
 800b1aa:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800b1ac:	647b      	str	r3, [r7, #68]	; 0x44
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800b1ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1b0:	69da      	ldr	r2, [r3, #28]
 800b1b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1b4:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800b1b8:	0a5b      	lsrs	r3, r3, #9
 800b1ba:	429a      	cmp	r2, r3
 800b1bc:	d201      	bcs.n	800b1c2 <find_volume+0x3ae>
 800b1be:	230d      	movs	r3, #13
 800b1c0:	e06d      	b.n	800b29e <find_volume+0x48a>

#if !_FS_READONLY
		/* Get FSINFO if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800b1c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1c4:	f04f 32ff 	mov.w	r2, #4294967295
 800b1c8:	615a      	str	r2, [r3, #20]
 800b1ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1cc:	695a      	ldr	r2, [r3, #20]
 800b1ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1d0:	611a      	str	r2, [r3, #16]
		fs->fsi_flag = 0x80;
 800b1d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1d4:	2280      	movs	r2, #128	; 0x80
 800b1d6:	711a      	strb	r2, [r3, #4]
#if (_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 800b1d8:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800b1dc:	2b03      	cmp	r3, #3
 800b1de:	d149      	bne.n	800b274 <find_volume+0x460>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800b1e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1e2:	3334      	adds	r3, #52	; 0x34
 800b1e4:	3330      	adds	r3, #48	; 0x30
 800b1e6:	4618      	mov	r0, r3
 800b1e8:	f7fd fd8e 	bl	8008d08 <ld_word>
 800b1ec:	4603      	mov	r3, r0
 800b1ee:	2b01      	cmp	r3, #1
 800b1f0:	d140      	bne.n	800b274 <find_volume+0x460>
			&& move_window(fs, bsect + 1) == FR_OK)
 800b1f2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b1f4:	3301      	adds	r3, #1
 800b1f6:	4619      	mov	r1, r3
 800b1f8:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800b1fa:	f7fe f835 	bl	8009268 <move_window>
 800b1fe:	4603      	mov	r3, r0
 800b200:	2b00      	cmp	r3, #0
 800b202:	d137      	bne.n	800b274 <find_volume+0x460>
		{
			fs->fsi_flag = 0;
 800b204:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b206:	2200      	movs	r2, #0
 800b208:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800b20a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b20c:	3334      	adds	r3, #52	; 0x34
 800b20e:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 800b212:	4618      	mov	r0, r3
 800b214:	f7fd fd78 	bl	8008d08 <ld_word>
 800b218:	4603      	mov	r3, r0
 800b21a:	461a      	mov	r2, r3
 800b21c:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800b220:	429a      	cmp	r2, r3
 800b222:	d127      	bne.n	800b274 <find_volume+0x460>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800b224:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b226:	3334      	adds	r3, #52	; 0x34
 800b228:	4618      	mov	r0, r3
 800b22a:	f7fd fd85 	bl	8008d38 <ld_dword>
 800b22e:	4603      	mov	r3, r0
 800b230:	4a1d      	ldr	r2, [pc, #116]	; (800b2a8 <find_volume+0x494>)
 800b232:	4293      	cmp	r3, r2
 800b234:	d11e      	bne.n	800b274 <find_volume+0x460>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800b236:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b238:	3334      	adds	r3, #52	; 0x34
 800b23a:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 800b23e:	4618      	mov	r0, r3
 800b240:	f7fd fd7a 	bl	8008d38 <ld_dword>
 800b244:	4603      	mov	r3, r0
 800b246:	4a19      	ldr	r2, [pc, #100]	; (800b2ac <find_volume+0x498>)
 800b248:	4293      	cmp	r3, r2
 800b24a:	d113      	bne.n	800b274 <find_volume+0x460>
			{
#if (_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 800b24c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b24e:	3334      	adds	r3, #52	; 0x34
 800b250:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 800b254:	4618      	mov	r0, r3
 800b256:	f7fd fd6f 	bl	8008d38 <ld_dword>
 800b25a:	4602      	mov	r2, r0
 800b25c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b25e:	615a      	str	r2, [r3, #20]
#endif
#if (_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800b260:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b262:	3334      	adds	r3, #52	; 0x34
 800b264:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 800b268:	4618      	mov	r0, r3
 800b26a:	f7fd fd65 	bl	8008d38 <ld_dword>
 800b26e:	4602      	mov	r2, r0
 800b270:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b272:	611a      	str	r2, [r3, #16]
		}
#endif	/* (_FS_NOFSINFO & 3) != 3 */
#endif	/* !_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
 800b274:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b276:	f897 2057 	ldrb.w	r2, [r7, #87]	; 0x57
 800b27a:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 800b27c:	4b0c      	ldr	r3, [pc, #48]	; (800b2b0 <find_volume+0x49c>)
 800b27e:	881b      	ldrh	r3, [r3, #0]
 800b280:	3301      	adds	r3, #1
 800b282:	b29a      	uxth	r2, r3
 800b284:	4b0a      	ldr	r3, [pc, #40]	; (800b2b0 <find_volume+0x49c>)
 800b286:	801a      	strh	r2, [r3, #0]
 800b288:	4b09      	ldr	r3, [pc, #36]	; (800b2b0 <find_volume+0x49c>)
 800b28a:	881a      	ldrh	r2, [r3, #0]
 800b28c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b28e:	80da      	strh	r2, [r3, #6]
#if _USE_LFN == 1
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800b290:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b292:	4a08      	ldr	r2, [pc, #32]	; (800b2b4 <find_volume+0x4a0>)
 800b294:	60da      	str	r2, [r3, #12]
#endif
#if _FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
 800b296:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800b298:	f7fd ff7e 	bl	8009198 <clear_lock>
#endif
	return FR_OK;
 800b29c:	2300      	movs	r3, #0
}
 800b29e:	4618      	mov	r0, r3
 800b2a0:	3758      	adds	r7, #88	; 0x58
 800b2a2:	46bd      	mov	sp, r7
 800b2a4:	bd80      	pop	{r7, pc}
 800b2a6:	bf00      	nop
 800b2a8:	41615252 	.word	0x41615252
 800b2ac:	61417272 	.word	0x61417272
 800b2b0:	200000b8 	.word	0x200000b8
 800b2b4:	200000dc 	.word	0x200000dc

0800b2b8 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 800b2b8:	b580      	push	{r7, lr}
 800b2ba:	b084      	sub	sp, #16
 800b2bc:	af00      	add	r7, sp, #0
 800b2be:	6078      	str	r0, [r7, #4]
 800b2c0:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
 800b2c2:	2309      	movs	r3, #9
 800b2c4:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800b2c6:	687b      	ldr	r3, [r7, #4]
 800b2c8:	2b00      	cmp	r3, #0
 800b2ca:	d01c      	beq.n	800b306 <validate+0x4e>
 800b2cc:	687b      	ldr	r3, [r7, #4]
 800b2ce:	681b      	ldr	r3, [r3, #0]
 800b2d0:	2b00      	cmp	r3, #0
 800b2d2:	d018      	beq.n	800b306 <validate+0x4e>
 800b2d4:	687b      	ldr	r3, [r7, #4]
 800b2d6:	681b      	ldr	r3, [r3, #0]
 800b2d8:	781b      	ldrb	r3, [r3, #0]
 800b2da:	2b00      	cmp	r3, #0
 800b2dc:	d013      	beq.n	800b306 <validate+0x4e>
 800b2de:	687b      	ldr	r3, [r7, #4]
 800b2e0:	889a      	ldrh	r2, [r3, #4]
 800b2e2:	687b      	ldr	r3, [r7, #4]
 800b2e4:	681b      	ldr	r3, [r3, #0]
 800b2e6:	88db      	ldrh	r3, [r3, #6]
 800b2e8:	429a      	cmp	r2, r3
 800b2ea:	d10c      	bne.n	800b306 <validate+0x4e>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800b2ec:	687b      	ldr	r3, [r7, #4]
 800b2ee:	681b      	ldr	r3, [r3, #0]
 800b2f0:	785b      	ldrb	r3, [r3, #1]
 800b2f2:	4618      	mov	r0, r3
 800b2f4:	f7fd fc6a 	bl	8008bcc <disk_status>
 800b2f8:	4603      	mov	r3, r0
 800b2fa:	f003 0301 	and.w	r3, r3, #1
 800b2fe:	2b00      	cmp	r3, #0
 800b300:	d101      	bne.n	800b306 <validate+0x4e>
			res = FR_OK;
 800b302:	2300      	movs	r3, #0
 800b304:	73fb      	strb	r3, [r7, #15]
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800b306:	7bfb      	ldrb	r3, [r7, #15]
 800b308:	2b00      	cmp	r3, #0
 800b30a:	d102      	bne.n	800b312 <validate+0x5a>
 800b30c:	687b      	ldr	r3, [r7, #4]
 800b30e:	681b      	ldr	r3, [r3, #0]
 800b310:	e000      	b.n	800b314 <validate+0x5c>
 800b312:	2300      	movs	r3, #0
 800b314:	683a      	ldr	r2, [r7, #0]
 800b316:	6013      	str	r3, [r2, #0]
	return res;
 800b318:	7bfb      	ldrb	r3, [r7, #15]
}
 800b31a:	4618      	mov	r0, r3
 800b31c:	3710      	adds	r7, #16
 800b31e:	46bd      	mov	sp, r7
 800b320:	bd80      	pop	{r7, pc}
	...

0800b324 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800b324:	b580      	push	{r7, lr}
 800b326:	b088      	sub	sp, #32
 800b328:	af00      	add	r7, sp, #0
 800b32a:	60f8      	str	r0, [r7, #12]
 800b32c:	60b9      	str	r1, [r7, #8]
 800b32e:	4613      	mov	r3, r2
 800b330:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800b332:	68bb      	ldr	r3, [r7, #8]
 800b334:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 800b336:	f107 0310 	add.w	r3, r7, #16
 800b33a:	4618      	mov	r0, r3
 800b33c:	f7ff fccf 	bl	800acde <get_ldnumber>
 800b340:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
 800b342:	69fb      	ldr	r3, [r7, #28]
 800b344:	2b00      	cmp	r3, #0
 800b346:	da01      	bge.n	800b34c <f_mount+0x28>
 800b348:	230b      	movs	r3, #11
 800b34a:	e02b      	b.n	800b3a4 <f_mount+0x80>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800b34c:	4a17      	ldr	r2, [pc, #92]	; (800b3ac <f_mount+0x88>)
 800b34e:	69fb      	ldr	r3, [r7, #28]
 800b350:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b354:	61bb      	str	r3, [r7, #24]

	if (cfs) {
 800b356:	69bb      	ldr	r3, [r7, #24]
 800b358:	2b00      	cmp	r3, #0
 800b35a:	d005      	beq.n	800b368 <f_mount+0x44>
#if _FS_LOCK != 0
		clear_lock(cfs);
 800b35c:	69b8      	ldr	r0, [r7, #24]
 800b35e:	f7fd ff1b 	bl	8009198 <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 800b362:	69bb      	ldr	r3, [r7, #24]
 800b364:	2200      	movs	r2, #0
 800b366:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 800b368:	68fb      	ldr	r3, [r7, #12]
 800b36a:	2b00      	cmp	r3, #0
 800b36c:	d002      	beq.n	800b374 <f_mount+0x50>
		fs->fs_type = 0;				/* Clear new fs object */
 800b36e:	68fb      	ldr	r3, [r7, #12]
 800b370:	2200      	movs	r2, #0
 800b372:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800b374:	68fa      	ldr	r2, [r7, #12]
 800b376:	490d      	ldr	r1, [pc, #52]	; (800b3ac <f_mount+0x88>)
 800b378:	69fb      	ldr	r3, [r7, #28]
 800b37a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800b37e:	68fb      	ldr	r3, [r7, #12]
 800b380:	2b00      	cmp	r3, #0
 800b382:	d002      	beq.n	800b38a <f_mount+0x66>
 800b384:	79fb      	ldrb	r3, [r7, #7]
 800b386:	2b01      	cmp	r3, #1
 800b388:	d001      	beq.n	800b38e <f_mount+0x6a>
 800b38a:	2300      	movs	r3, #0
 800b38c:	e00a      	b.n	800b3a4 <f_mount+0x80>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800b38e:	f107 010c 	add.w	r1, r7, #12
 800b392:	f107 0308 	add.w	r3, r7, #8
 800b396:	2200      	movs	r2, #0
 800b398:	4618      	mov	r0, r3
 800b39a:	f7ff fd3b 	bl	800ae14 <find_volume>
 800b39e:	4603      	mov	r3, r0
 800b3a0:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
 800b3a2:	7dfb      	ldrb	r3, [r7, #23]
}
 800b3a4:	4618      	mov	r0, r3
 800b3a6:	3720      	adds	r7, #32
 800b3a8:	46bd      	mov	sp, r7
 800b3aa:	bd80      	pop	{r7, pc}
 800b3ac:	200000b4 	.word	0x200000b4

0800b3b0 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800b3b0:	b580      	push	{r7, lr}
 800b3b2:	b09a      	sub	sp, #104	; 0x68
 800b3b4:	af00      	add	r7, sp, #0
 800b3b6:	60f8      	str	r0, [r7, #12]
 800b3b8:	60b9      	str	r1, [r7, #8]
 800b3ba:	4613      	mov	r3, r2
 800b3bc:	71fb      	strb	r3, [r7, #7]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800b3be:	68fb      	ldr	r3, [r7, #12]
 800b3c0:	2b00      	cmp	r3, #0
 800b3c2:	d101      	bne.n	800b3c8 <f_open+0x18>
 800b3c4:	2309      	movs	r3, #9
 800b3c6:	e1ad      	b.n	800b724 <f_open+0x374>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800b3c8:	79fb      	ldrb	r3, [r7, #7]
 800b3ca:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b3ce:	71fb      	strb	r3, [r7, #7]
	res = find_volume(&path, &fs, mode);
 800b3d0:	79fa      	ldrb	r2, [r7, #7]
 800b3d2:	f107 0110 	add.w	r1, r7, #16
 800b3d6:	f107 0308 	add.w	r3, r7, #8
 800b3da:	4618      	mov	r0, r3
 800b3dc:	f7ff fd1a 	bl	800ae14 <find_volume>
 800b3e0:	4603      	mov	r3, r0
 800b3e2:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
	if (res == FR_OK) {
 800b3e6:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b3ea:	2b00      	cmp	r3, #0
 800b3ec:	f040 8191 	bne.w	800b712 <f_open+0x362>
		dj.obj.fs = fs;
 800b3f0:	693b      	ldr	r3, [r7, #16]
 800b3f2:	617b      	str	r3, [r7, #20]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 800b3f4:	68ba      	ldr	r2, [r7, #8]
 800b3f6:	f107 0314 	add.w	r3, r7, #20
 800b3fa:	4611      	mov	r1, r2
 800b3fc:	4618      	mov	r0, r3
 800b3fe:	f7ff fbfd 	bl	800abfc <follow_path>
 800b402:	4603      	mov	r3, r0
 800b404:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 800b408:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b40c:	2b00      	cmp	r3, #0
 800b40e:	d11a      	bne.n	800b446 <f_open+0x96>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800b410:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800b414:	b25b      	sxtb	r3, r3
 800b416:	2b00      	cmp	r3, #0
 800b418:	da03      	bge.n	800b422 <f_open+0x72>
				res = FR_INVALID_NAME;
 800b41a:	2306      	movs	r3, #6
 800b41c:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800b420:	e011      	b.n	800b446 <f_open+0x96>
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800b422:	79fb      	ldrb	r3, [r7, #7]
 800b424:	f023 0301 	bic.w	r3, r3, #1
 800b428:	2b00      	cmp	r3, #0
 800b42a:	bf14      	ite	ne
 800b42c:	2301      	movne	r3, #1
 800b42e:	2300      	moveq	r3, #0
 800b430:	b2db      	uxtb	r3, r3
 800b432:	461a      	mov	r2, r3
 800b434:	f107 0314 	add.w	r3, r7, #20
 800b438:	4611      	mov	r1, r2
 800b43a:	4618      	mov	r0, r3
 800b43c:	f7fd fd64 	bl	8008f08 <chk_lock>
 800b440:	4603      	mov	r3, r0
 800b442:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800b446:	79fb      	ldrb	r3, [r7, #7]
 800b448:	f003 031c 	and.w	r3, r3, #28
 800b44c:	2b00      	cmp	r3, #0
 800b44e:	d07f      	beq.n	800b550 <f_open+0x1a0>
			if (res != FR_OK) {					/* No file, create new */
 800b450:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b454:	2b00      	cmp	r3, #0
 800b456:	d017      	beq.n	800b488 <f_open+0xd8>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 800b458:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b45c:	2b04      	cmp	r3, #4
 800b45e:	d10e      	bne.n	800b47e <f_open+0xce>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 800b460:	f7fd fdae 	bl	8008fc0 <enq_lock>
 800b464:	4603      	mov	r3, r0
 800b466:	2b00      	cmp	r3, #0
 800b468:	d006      	beq.n	800b478 <f_open+0xc8>
 800b46a:	f107 0314 	add.w	r3, r7, #20
 800b46e:	4618      	mov	r0, r3
 800b470:	f7fe ff94 	bl	800a39c <dir_register>
 800b474:	4603      	mov	r3, r0
 800b476:	e000      	b.n	800b47a <f_open+0xca>
 800b478:	2312      	movs	r3, #18
 800b47a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800b47e:	79fb      	ldrb	r3, [r7, #7]
 800b480:	f043 0308 	orr.w	r3, r3, #8
 800b484:	71fb      	strb	r3, [r7, #7]
 800b486:	e010      	b.n	800b4aa <f_open+0xfa>
			}
			else {								/* Any object is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800b488:	7ebb      	ldrb	r3, [r7, #26]
 800b48a:	f003 0311 	and.w	r3, r3, #17
 800b48e:	2b00      	cmp	r3, #0
 800b490:	d003      	beq.n	800b49a <f_open+0xea>
					res = FR_DENIED;
 800b492:	2307      	movs	r3, #7
 800b494:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800b498:	e007      	b.n	800b4aa <f_open+0xfa>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800b49a:	79fb      	ldrb	r3, [r7, #7]
 800b49c:	f003 0304 	and.w	r3, r3, #4
 800b4a0:	2b00      	cmp	r3, #0
 800b4a2:	d002      	beq.n	800b4aa <f_open+0xfa>
 800b4a4:	2308      	movs	r3, #8
 800b4a6:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800b4aa:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b4ae:	2b00      	cmp	r3, #0
 800b4b0:	d168      	bne.n	800b584 <f_open+0x1d4>
 800b4b2:	79fb      	ldrb	r3, [r7, #7]
 800b4b4:	f003 0308 	and.w	r3, r3, #8
 800b4b8:	2b00      	cmp	r3, #0
 800b4ba:	d063      	beq.n	800b584 <f_open+0x1d4>
				dw = GET_FATTIME();
 800b4bc:	f7fa fb6e 	bl	8005b9c <get_fattime>
 800b4c0:	65b8      	str	r0, [r7, #88]	; 0x58
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 800b4c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4c4:	330e      	adds	r3, #14
 800b4c6:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800b4c8:	4618      	mov	r0, r3
 800b4ca:	f7fd fc73 	bl	8008db4 <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 800b4ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4d0:	3316      	adds	r3, #22
 800b4d2:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800b4d4:	4618      	mov	r0, r3
 800b4d6:	f7fd fc6d 	bl	8008db4 <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 800b4da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4dc:	330b      	adds	r3, #11
 800b4de:	2220      	movs	r2, #32
 800b4e0:	701a      	strb	r2, [r3, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800b4e2:	693b      	ldr	r3, [r7, #16]
 800b4e4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b4e6:	4611      	mov	r1, r2
 800b4e8:	4618      	mov	r0, r3
 800b4ea:	f7fe fbc4 	bl	8009c76 <ld_clust>
 800b4ee:	6578      	str	r0, [r7, #84]	; 0x54
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 800b4f0:	693b      	ldr	r3, [r7, #16]
 800b4f2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800b4f4:	2200      	movs	r2, #0
 800b4f6:	4618      	mov	r0, r3
 800b4f8:	f7fe fbdc 	bl	8009cb4 <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
 800b4fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4fe:	331c      	adds	r3, #28
 800b500:	2100      	movs	r1, #0
 800b502:	4618      	mov	r0, r3
 800b504:	f7fd fc56 	bl	8008db4 <st_dword>
					fs->wflag = 1;
 800b508:	693b      	ldr	r3, [r7, #16]
 800b50a:	2201      	movs	r2, #1
 800b50c:	70da      	strb	r2, [r3, #3]

					if (cl) {							/* Remove the cluster chain if exist */
 800b50e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b510:	2b00      	cmp	r3, #0
 800b512:	d037      	beq.n	800b584 <f_open+0x1d4>
						dw = fs->winsect;
 800b514:	693b      	ldr	r3, [r7, #16]
 800b516:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b518:	65bb      	str	r3, [r7, #88]	; 0x58
						res = remove_chain(&dj.obj, cl, 0);
 800b51a:	f107 0314 	add.w	r3, r7, #20
 800b51e:	2200      	movs	r2, #0
 800b520:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800b522:	4618      	mov	r0, r3
 800b524:	f7fe f8ef 	bl	8009706 <remove_chain>
 800b528:	4603      	mov	r3, r0
 800b52a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
						if (res == FR_OK) {
 800b52e:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b532:	2b00      	cmp	r3, #0
 800b534:	d126      	bne.n	800b584 <f_open+0x1d4>
							res = move_window(fs, dw);
 800b536:	693b      	ldr	r3, [r7, #16]
 800b538:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800b53a:	4618      	mov	r0, r3
 800b53c:	f7fd fe94 	bl	8009268 <move_window>
 800b540:	4603      	mov	r3, r0
 800b542:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800b546:	693b      	ldr	r3, [r7, #16]
 800b548:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800b54a:	3a01      	subs	r2, #1
 800b54c:	611a      	str	r2, [r3, #16]
 800b54e:	e019      	b.n	800b584 <f_open+0x1d4>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
 800b550:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b554:	2b00      	cmp	r3, #0
 800b556:	d115      	bne.n	800b584 <f_open+0x1d4>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 800b558:	7ebb      	ldrb	r3, [r7, #26]
 800b55a:	f003 0310 	and.w	r3, r3, #16
 800b55e:	2b00      	cmp	r3, #0
 800b560:	d003      	beq.n	800b56a <f_open+0x1ba>
					res = FR_NO_FILE;
 800b562:	2304      	movs	r3, #4
 800b564:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800b568:	e00c      	b.n	800b584 <f_open+0x1d4>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 800b56a:	79fb      	ldrb	r3, [r7, #7]
 800b56c:	f003 0302 	and.w	r3, r3, #2
 800b570:	2b00      	cmp	r3, #0
 800b572:	d007      	beq.n	800b584 <f_open+0x1d4>
 800b574:	7ebb      	ldrb	r3, [r7, #26]
 800b576:	f003 0301 	and.w	r3, r3, #1
 800b57a:	2b00      	cmp	r3, #0
 800b57c:	d002      	beq.n	800b584 <f_open+0x1d4>
						res = FR_DENIED;
 800b57e:	2307      	movs	r3, #7
 800b580:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
					}
				}
			}
		}
		if (res == FR_OK) {
 800b584:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b588:	2b00      	cmp	r3, #0
 800b58a:	d128      	bne.n	800b5de <f_open+0x22e>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 800b58c:	79fb      	ldrb	r3, [r7, #7]
 800b58e:	f003 0308 	and.w	r3, r3, #8
 800b592:	2b00      	cmp	r3, #0
 800b594:	d003      	beq.n	800b59e <f_open+0x1ee>
				mode |= FA_MODIFIED;
 800b596:	79fb      	ldrb	r3, [r7, #7]
 800b598:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b59c:	71fb      	strb	r3, [r7, #7]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800b59e:	693b      	ldr	r3, [r7, #16]
 800b5a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b5a2:	68fb      	ldr	r3, [r7, #12]
 800b5a4:	625a      	str	r2, [r3, #36]	; 0x24
			fp->dir_ptr = dj.dir;
 800b5a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b5a8:	68fb      	ldr	r3, [r7, #12]
 800b5aa:	629a      	str	r2, [r3, #40]	; 0x28
#if _FS_LOCK != 0
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800b5ac:	79fb      	ldrb	r3, [r7, #7]
 800b5ae:	f023 0301 	bic.w	r3, r3, #1
 800b5b2:	2b00      	cmp	r3, #0
 800b5b4:	bf14      	ite	ne
 800b5b6:	2301      	movne	r3, #1
 800b5b8:	2300      	moveq	r3, #0
 800b5ba:	b2db      	uxtb	r3, r3
 800b5bc:	461a      	mov	r2, r3
 800b5be:	f107 0314 	add.w	r3, r7, #20
 800b5c2:	4611      	mov	r1, r2
 800b5c4:	4618      	mov	r0, r3
 800b5c6:	f7fd fd1d 	bl	8009004 <inc_lock>
 800b5ca:	4602      	mov	r2, r0
 800b5cc:	68fb      	ldr	r3, [r7, #12]
 800b5ce:	611a      	str	r2, [r3, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 800b5d0:	68fb      	ldr	r3, [r7, #12]
 800b5d2:	691b      	ldr	r3, [r3, #16]
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d102      	bne.n	800b5de <f_open+0x22e>
 800b5d8:	2302      	movs	r3, #2
 800b5da:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				}
			}
		}
#endif

		if (res == FR_OK) {
 800b5de:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b5e2:	2b00      	cmp	r3, #0
 800b5e4:	f040 8095 	bne.w	800b712 <f_open+0x362>
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800b5e8:	693b      	ldr	r3, [r7, #16]
 800b5ea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b5ec:	4611      	mov	r1, r2
 800b5ee:	4618      	mov	r0, r3
 800b5f0:	f7fe fb41 	bl	8009c76 <ld_clust>
 800b5f4:	4602      	mov	r2, r0
 800b5f6:	68fb      	ldr	r3, [r7, #12]
 800b5f8:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800b5fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5fc:	331c      	adds	r3, #28
 800b5fe:	4618      	mov	r0, r3
 800b600:	f7fd fb9a 	bl	8008d38 <ld_dword>
 800b604:	4602      	mov	r2, r0
 800b606:	68fb      	ldr	r3, [r7, #12]
 800b608:	60da      	str	r2, [r3, #12]
			}
#if _USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
 800b60a:	68fb      	ldr	r3, [r7, #12]
 800b60c:	2200      	movs	r2, #0
 800b60e:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
 800b610:	693a      	ldr	r2, [r7, #16]
 800b612:	68fb      	ldr	r3, [r7, #12]
 800b614:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
 800b616:	693b      	ldr	r3, [r7, #16]
 800b618:	88da      	ldrh	r2, [r3, #6]
 800b61a:	68fb      	ldr	r3, [r7, #12]
 800b61c:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
 800b61e:	68fb      	ldr	r3, [r7, #12]
 800b620:	79fa      	ldrb	r2, [r7, #7]
 800b622:	751a      	strb	r2, [r3, #20]
			fp->err = 0;			/* Clear error flag */
 800b624:	68fb      	ldr	r3, [r7, #12]
 800b626:	2200      	movs	r2, #0
 800b628:	755a      	strb	r2, [r3, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 800b62a:	68fb      	ldr	r3, [r7, #12]
 800b62c:	2200      	movs	r2, #0
 800b62e:	621a      	str	r2, [r3, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800b630:	68fb      	ldr	r3, [r7, #12]
 800b632:	2200      	movs	r2, #0
 800b634:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
#if !_FS_TINY
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 800b636:	68fb      	ldr	r3, [r7, #12]
 800b638:	3330      	adds	r3, #48	; 0x30
 800b63a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b63e:	2100      	movs	r1, #0
 800b640:	4618      	mov	r0, r3
 800b642:	f7fd fc04 	bl	8008e4e <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800b646:	79fb      	ldrb	r3, [r7, #7]
 800b648:	f003 0320 	and.w	r3, r3, #32
 800b64c:	2b00      	cmp	r3, #0
 800b64e:	d060      	beq.n	800b712 <f_open+0x362>
 800b650:	68fb      	ldr	r3, [r7, #12]
 800b652:	68db      	ldr	r3, [r3, #12]
 800b654:	2b00      	cmp	r3, #0
 800b656:	d05c      	beq.n	800b712 <f_open+0x362>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800b658:	68fb      	ldr	r3, [r7, #12]
 800b65a:	68da      	ldr	r2, [r3, #12]
 800b65c:	68fb      	ldr	r3, [r7, #12]
 800b65e:	619a      	str	r2, [r3, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800b660:	693b      	ldr	r3, [r7, #16]
 800b662:	895b      	ldrh	r3, [r3, #10]
 800b664:	025b      	lsls	r3, r3, #9
 800b666:	653b      	str	r3, [r7, #80]	; 0x50
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 800b668:	68fb      	ldr	r3, [r7, #12]
 800b66a:	689b      	ldr	r3, [r3, #8]
 800b66c:	663b      	str	r3, [r7, #96]	; 0x60
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800b66e:	68fb      	ldr	r3, [r7, #12]
 800b670:	68db      	ldr	r3, [r3, #12]
 800b672:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b674:	e016      	b.n	800b6a4 <f_open+0x2f4>
					clst = get_fat(&fp->obj, clst);
 800b676:	68fb      	ldr	r3, [r7, #12]
 800b678:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800b67a:	4618      	mov	r0, r3
 800b67c:	f7fd feaf 	bl	80093de <get_fat>
 800b680:	6638      	str	r0, [r7, #96]	; 0x60
					if (clst <= 1) res = FR_INT_ERR;
 800b682:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b684:	2b01      	cmp	r3, #1
 800b686:	d802      	bhi.n	800b68e <f_open+0x2de>
 800b688:	2302      	movs	r3, #2
 800b68a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800b68e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b690:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b694:	d102      	bne.n	800b69c <f_open+0x2ec>
 800b696:	2301      	movs	r3, #1
 800b698:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800b69c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800b69e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b6a0:	1ad3      	subs	r3, r2, r3
 800b6a2:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b6a4:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b6a8:	2b00      	cmp	r3, #0
 800b6aa:	d103      	bne.n	800b6b4 <f_open+0x304>
 800b6ac:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800b6ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b6b0:	429a      	cmp	r2, r3
 800b6b2:	d8e0      	bhi.n	800b676 <f_open+0x2c6>
				}
				fp->clust = clst;
 800b6b4:	68fb      	ldr	r3, [r7, #12]
 800b6b6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800b6b8:	61da      	str	r2, [r3, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800b6ba:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b6be:	2b00      	cmp	r3, #0
 800b6c0:	d127      	bne.n	800b712 <f_open+0x362>
 800b6c2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b6c4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b6c8:	2b00      	cmp	r3, #0
 800b6ca:	d022      	beq.n	800b712 <f_open+0x362>
					if ((sc = clust2sect(fs, clst)) == 0) {
 800b6cc:	693b      	ldr	r3, [r7, #16]
 800b6ce:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800b6d0:	4618      	mov	r0, r3
 800b6d2:	f7fd fe65 	bl	80093a0 <clust2sect>
 800b6d6:	64f8      	str	r0, [r7, #76]	; 0x4c
 800b6d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b6da:	2b00      	cmp	r3, #0
 800b6dc:	d103      	bne.n	800b6e6 <f_open+0x336>
						res = FR_INT_ERR;
 800b6de:	2302      	movs	r3, #2
 800b6e0:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800b6e4:	e015      	b.n	800b712 <f_open+0x362>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 800b6e6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b6e8:	0a5a      	lsrs	r2, r3, #9
 800b6ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b6ec:	441a      	add	r2, r3
 800b6ee:	68fb      	ldr	r3, [r7, #12]
 800b6f0:	621a      	str	r2, [r3, #32]
#if !_FS_TINY
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 800b6f2:	693b      	ldr	r3, [r7, #16]
 800b6f4:	7858      	ldrb	r0, [r3, #1]
 800b6f6:	68fb      	ldr	r3, [r7, #12]
 800b6f8:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800b6fc:	68fb      	ldr	r3, [r7, #12]
 800b6fe:	6a1a      	ldr	r2, [r3, #32]
 800b700:	2301      	movs	r3, #1
 800b702:	f7fd faa3 	bl	8008c4c <disk_read>
 800b706:	4603      	mov	r3, r0
 800b708:	2b00      	cmp	r3, #0
 800b70a:	d002      	beq.n	800b712 <f_open+0x362>
 800b70c:	2301      	movs	r3, #1
 800b70e:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800b712:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800b716:	2b00      	cmp	r3, #0
 800b718:	d002      	beq.n	800b720 <f_open+0x370>
 800b71a:	68fb      	ldr	r3, [r7, #12]
 800b71c:	2200      	movs	r2, #0
 800b71e:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 800b720:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
}
 800b724:	4618      	mov	r0, r3
 800b726:	3768      	adds	r7, #104	; 0x68
 800b728:	46bd      	mov	sp, r7
 800b72a:	bd80      	pop	{r7, pc}

0800b72c <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 800b72c:	b580      	push	{r7, lr}
 800b72e:	b08e      	sub	sp, #56	; 0x38
 800b730:	af00      	add	r7, sp, #0
 800b732:	60f8      	str	r0, [r7, #12]
 800b734:	60b9      	str	r1, [r7, #8]
 800b736:	607a      	str	r2, [r7, #4]
 800b738:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
 800b73a:	68bb      	ldr	r3, [r7, #8]
 800b73c:	627b      	str	r3, [r7, #36]	; 0x24


	*br = 0;	/* Clear read byte counter */
 800b73e:	683b      	ldr	r3, [r7, #0]
 800b740:	2200      	movs	r2, #0
 800b742:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 800b744:	68fb      	ldr	r3, [r7, #12]
 800b746:	f107 0214 	add.w	r2, r7, #20
 800b74a:	4611      	mov	r1, r2
 800b74c:	4618      	mov	r0, r3
 800b74e:	f7ff fdb3 	bl	800b2b8 <validate>
 800b752:	4603      	mov	r3, r0
 800b754:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800b758:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800b75c:	2b00      	cmp	r3, #0
 800b75e:	d107      	bne.n	800b770 <f_read+0x44>
 800b760:	68fb      	ldr	r3, [r7, #12]
 800b762:	7d5b      	ldrb	r3, [r3, #21]
 800b764:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 800b768:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800b76c:	2b00      	cmp	r3, #0
 800b76e:	d002      	beq.n	800b776 <f_read+0x4a>
 800b770:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800b774:	e115      	b.n	800b9a2 <f_read+0x276>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800b776:	68fb      	ldr	r3, [r7, #12]
 800b778:	7d1b      	ldrb	r3, [r3, #20]
 800b77a:	f003 0301 	and.w	r3, r3, #1
 800b77e:	2b00      	cmp	r3, #0
 800b780:	d101      	bne.n	800b786 <f_read+0x5a>
 800b782:	2307      	movs	r3, #7
 800b784:	e10d      	b.n	800b9a2 <f_read+0x276>
	remain = fp->obj.objsize - fp->fptr;
 800b786:	68fb      	ldr	r3, [r7, #12]
 800b788:	68da      	ldr	r2, [r3, #12]
 800b78a:	68fb      	ldr	r3, [r7, #12]
 800b78c:	699b      	ldr	r3, [r3, #24]
 800b78e:	1ad3      	subs	r3, r2, r3
 800b790:	623b      	str	r3, [r7, #32]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 800b792:	687a      	ldr	r2, [r7, #4]
 800b794:	6a3b      	ldr	r3, [r7, #32]
 800b796:	429a      	cmp	r2, r3
 800b798:	f240 80fe 	bls.w	800b998 <f_read+0x26c>
 800b79c:	6a3b      	ldr	r3, [r7, #32]
 800b79e:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
 800b7a0:	e0fa      	b.n	800b998 <f_read+0x26c>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800b7a2:	68fb      	ldr	r3, [r7, #12]
 800b7a4:	699b      	ldr	r3, [r3, #24]
 800b7a6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b7aa:	2b00      	cmp	r3, #0
 800b7ac:	f040 80c6 	bne.w	800b93c <f_read+0x210>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800b7b0:	68fb      	ldr	r3, [r7, #12]
 800b7b2:	699b      	ldr	r3, [r3, #24]
 800b7b4:	0a5b      	lsrs	r3, r3, #9
 800b7b6:	697a      	ldr	r2, [r7, #20]
 800b7b8:	8952      	ldrh	r2, [r2, #10]
 800b7ba:	3a01      	subs	r2, #1
 800b7bc:	4013      	ands	r3, r2
 800b7be:	61fb      	str	r3, [r7, #28]
			if (csect == 0) {					/* On the cluster boundary? */
 800b7c0:	69fb      	ldr	r3, [r7, #28]
 800b7c2:	2b00      	cmp	r3, #0
 800b7c4:	d12f      	bne.n	800b826 <f_read+0xfa>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800b7c6:	68fb      	ldr	r3, [r7, #12]
 800b7c8:	699b      	ldr	r3, [r3, #24]
 800b7ca:	2b00      	cmp	r3, #0
 800b7cc:	d103      	bne.n	800b7d6 <f_read+0xaa>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800b7ce:	68fb      	ldr	r3, [r7, #12]
 800b7d0:	689b      	ldr	r3, [r3, #8]
 800b7d2:	633b      	str	r3, [r7, #48]	; 0x30
 800b7d4:	e013      	b.n	800b7fe <f_read+0xd2>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 800b7d6:	68fb      	ldr	r3, [r7, #12]
 800b7d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b7da:	2b00      	cmp	r3, #0
 800b7dc:	d007      	beq.n	800b7ee <f_read+0xc2>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 800b7de:	68fb      	ldr	r3, [r7, #12]
 800b7e0:	699b      	ldr	r3, [r3, #24]
 800b7e2:	4619      	mov	r1, r3
 800b7e4:	68f8      	ldr	r0, [r7, #12]
 800b7e6:	f7fe f88b 	bl	8009900 <clmt_clust>
 800b7ea:	6338      	str	r0, [r7, #48]	; 0x30
 800b7ec:	e007      	b.n	800b7fe <f_read+0xd2>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800b7ee:	68fa      	ldr	r2, [r7, #12]
 800b7f0:	68fb      	ldr	r3, [r7, #12]
 800b7f2:	69db      	ldr	r3, [r3, #28]
 800b7f4:	4619      	mov	r1, r3
 800b7f6:	4610      	mov	r0, r2
 800b7f8:	f7fd fdf1 	bl	80093de <get_fat>
 800b7fc:	6338      	str	r0, [r7, #48]	; 0x30
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800b7fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b800:	2b01      	cmp	r3, #1
 800b802:	d804      	bhi.n	800b80e <f_read+0xe2>
 800b804:	68fb      	ldr	r3, [r7, #12]
 800b806:	2202      	movs	r2, #2
 800b808:	755a      	strb	r2, [r3, #21]
 800b80a:	2302      	movs	r3, #2
 800b80c:	e0c9      	b.n	800b9a2 <f_read+0x276>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800b80e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b810:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b814:	d104      	bne.n	800b820 <f_read+0xf4>
 800b816:	68fb      	ldr	r3, [r7, #12]
 800b818:	2201      	movs	r2, #1
 800b81a:	755a      	strb	r2, [r3, #21]
 800b81c:	2301      	movs	r3, #1
 800b81e:	e0c0      	b.n	800b9a2 <f_read+0x276>
				fp->clust = clst;				/* Update current cluster */
 800b820:	68fb      	ldr	r3, [r7, #12]
 800b822:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b824:	61da      	str	r2, [r3, #28]
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 800b826:	697a      	ldr	r2, [r7, #20]
 800b828:	68fb      	ldr	r3, [r7, #12]
 800b82a:	69db      	ldr	r3, [r3, #28]
 800b82c:	4619      	mov	r1, r3
 800b82e:	4610      	mov	r0, r2
 800b830:	f7fd fdb6 	bl	80093a0 <clust2sect>
 800b834:	61b8      	str	r0, [r7, #24]
			if (!sect) ABORT(fs, FR_INT_ERR);
 800b836:	69bb      	ldr	r3, [r7, #24]
 800b838:	2b00      	cmp	r3, #0
 800b83a:	d104      	bne.n	800b846 <f_read+0x11a>
 800b83c:	68fb      	ldr	r3, [r7, #12]
 800b83e:	2202      	movs	r2, #2
 800b840:	755a      	strb	r2, [r3, #21]
 800b842:	2302      	movs	r3, #2
 800b844:	e0ad      	b.n	800b9a2 <f_read+0x276>
			sect += csect;
 800b846:	69ba      	ldr	r2, [r7, #24]
 800b848:	69fb      	ldr	r3, [r7, #28]
 800b84a:	4413      	add	r3, r2
 800b84c:	61bb      	str	r3, [r7, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800b84e:	687b      	ldr	r3, [r7, #4]
 800b850:	0a5b      	lsrs	r3, r3, #9
 800b852:	62bb      	str	r3, [r7, #40]	; 0x28
			if (cc) {							/* Read maximum contiguous sectors directly */
 800b854:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b856:	2b00      	cmp	r3, #0
 800b858:	d039      	beq.n	800b8ce <f_read+0x1a2>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800b85a:	69fa      	ldr	r2, [r7, #28]
 800b85c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b85e:	4413      	add	r3, r2
 800b860:	697a      	ldr	r2, [r7, #20]
 800b862:	8952      	ldrh	r2, [r2, #10]
 800b864:	4293      	cmp	r3, r2
 800b866:	d905      	bls.n	800b874 <f_read+0x148>
					cc = fs->csize - csect;
 800b868:	697b      	ldr	r3, [r7, #20]
 800b86a:	895b      	ldrh	r3, [r3, #10]
 800b86c:	461a      	mov	r2, r3
 800b86e:	69fb      	ldr	r3, [r7, #28]
 800b870:	1ad3      	subs	r3, r2, r3
 800b872:	62bb      	str	r3, [r7, #40]	; 0x28
				}
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b874:	697b      	ldr	r3, [r7, #20]
 800b876:	7858      	ldrb	r0, [r3, #1]
 800b878:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b87a:	69ba      	ldr	r2, [r7, #24]
 800b87c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b87e:	f7fd f9e5 	bl	8008c4c <disk_read>
 800b882:	4603      	mov	r3, r0
 800b884:	2b00      	cmp	r3, #0
 800b886:	d004      	beq.n	800b892 <f_read+0x166>
 800b888:	68fb      	ldr	r3, [r7, #12]
 800b88a:	2201      	movs	r2, #1
 800b88c:	755a      	strb	r2, [r3, #21]
 800b88e:	2301      	movs	r3, #1
 800b890:	e087      	b.n	800b9a2 <f_read+0x276>
#if _FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800b892:	68fb      	ldr	r3, [r7, #12]
 800b894:	7d1b      	ldrb	r3, [r3, #20]
 800b896:	b25b      	sxtb	r3, r3
 800b898:	2b00      	cmp	r3, #0
 800b89a:	da14      	bge.n	800b8c6 <f_read+0x19a>
 800b89c:	68fb      	ldr	r3, [r7, #12]
 800b89e:	6a1a      	ldr	r2, [r3, #32]
 800b8a0:	69bb      	ldr	r3, [r7, #24]
 800b8a2:	1ad3      	subs	r3, r2, r3
 800b8a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b8a6:	429a      	cmp	r2, r3
 800b8a8:	d90d      	bls.n	800b8c6 <f_read+0x19a>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 800b8aa:	68fb      	ldr	r3, [r7, #12]
 800b8ac:	6a1a      	ldr	r2, [r3, #32]
 800b8ae:	69bb      	ldr	r3, [r7, #24]
 800b8b0:	1ad3      	subs	r3, r2, r3
 800b8b2:	025b      	lsls	r3, r3, #9
 800b8b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b8b6:	18d0      	adds	r0, r2, r3
 800b8b8:	68fb      	ldr	r3, [r7, #12]
 800b8ba:	3330      	adds	r3, #48	; 0x30
 800b8bc:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b8c0:	4619      	mov	r1, r3
 800b8c2:	f7fd faa3 	bl	8008e0c <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800b8c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b8c8:	025b      	lsls	r3, r3, #9
 800b8ca:	62fb      	str	r3, [r7, #44]	; 0x2c
				continue;
 800b8cc:	e050      	b.n	800b970 <f_read+0x244>
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 800b8ce:	68fb      	ldr	r3, [r7, #12]
 800b8d0:	6a1b      	ldr	r3, [r3, #32]
 800b8d2:	69ba      	ldr	r2, [r7, #24]
 800b8d4:	429a      	cmp	r2, r3
 800b8d6:	d02e      	beq.n	800b936 <f_read+0x20a>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 800b8d8:	68fb      	ldr	r3, [r7, #12]
 800b8da:	7d1b      	ldrb	r3, [r3, #20]
 800b8dc:	b25b      	sxtb	r3, r3
 800b8de:	2b00      	cmp	r3, #0
 800b8e0:	da18      	bge.n	800b914 <f_read+0x1e8>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800b8e2:	697b      	ldr	r3, [r7, #20]
 800b8e4:	7858      	ldrb	r0, [r3, #1]
 800b8e6:	68fb      	ldr	r3, [r7, #12]
 800b8e8:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800b8ec:	68fb      	ldr	r3, [r7, #12]
 800b8ee:	6a1a      	ldr	r2, [r3, #32]
 800b8f0:	2301      	movs	r3, #1
 800b8f2:	f7fd f9cb 	bl	8008c8c <disk_write>
 800b8f6:	4603      	mov	r3, r0
 800b8f8:	2b00      	cmp	r3, #0
 800b8fa:	d004      	beq.n	800b906 <f_read+0x1da>
 800b8fc:	68fb      	ldr	r3, [r7, #12]
 800b8fe:	2201      	movs	r2, #1
 800b900:	755a      	strb	r2, [r3, #21]
 800b902:	2301      	movs	r3, #1
 800b904:	e04d      	b.n	800b9a2 <f_read+0x276>
					fp->flag &= (BYTE)~FA_DIRTY;
 800b906:	68fb      	ldr	r3, [r7, #12]
 800b908:	7d1b      	ldrb	r3, [r3, #20]
 800b90a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800b90e:	b2da      	uxtb	r2, r3
 800b910:	68fb      	ldr	r3, [r7, #12]
 800b912:	751a      	strb	r2, [r3, #20]
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800b914:	697b      	ldr	r3, [r7, #20]
 800b916:	7858      	ldrb	r0, [r3, #1]
 800b918:	68fb      	ldr	r3, [r7, #12]
 800b91a:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800b91e:	2301      	movs	r3, #1
 800b920:	69ba      	ldr	r2, [r7, #24]
 800b922:	f7fd f993 	bl	8008c4c <disk_read>
 800b926:	4603      	mov	r3, r0
 800b928:	2b00      	cmp	r3, #0
 800b92a:	d004      	beq.n	800b936 <f_read+0x20a>
 800b92c:	68fb      	ldr	r3, [r7, #12]
 800b92e:	2201      	movs	r2, #1
 800b930:	755a      	strb	r2, [r3, #21]
 800b932:	2301      	movs	r3, #1
 800b934:	e035      	b.n	800b9a2 <f_read+0x276>
			}
#endif
			fp->sect = sect;
 800b936:	68fb      	ldr	r3, [r7, #12]
 800b938:	69ba      	ldr	r2, [r7, #24]
 800b93a:	621a      	str	r2, [r3, #32]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800b93c:	68fb      	ldr	r3, [r7, #12]
 800b93e:	699b      	ldr	r3, [r3, #24]
 800b940:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b944:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 800b948:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 800b94a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b94c:	687b      	ldr	r3, [r7, #4]
 800b94e:	429a      	cmp	r2, r3
 800b950:	d901      	bls.n	800b956 <f_read+0x22a>
 800b952:	687b      	ldr	r3, [r7, #4]
 800b954:	62fb      	str	r3, [r7, #44]	; 0x2c
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800b956:	68fb      	ldr	r3, [r7, #12]
 800b958:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800b95c:	68fb      	ldr	r3, [r7, #12]
 800b95e:	699b      	ldr	r3, [r3, #24]
 800b960:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b964:	4413      	add	r3, r2
 800b966:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b968:	4619      	mov	r1, r3
 800b96a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800b96c:	f7fd fa4e 	bl	8008e0c <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800b970:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b972:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b974:	4413      	add	r3, r2
 800b976:	627b      	str	r3, [r7, #36]	; 0x24
 800b978:	68fb      	ldr	r3, [r7, #12]
 800b97a:	699a      	ldr	r2, [r3, #24]
 800b97c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b97e:	441a      	add	r2, r3
 800b980:	68fb      	ldr	r3, [r7, #12]
 800b982:	619a      	str	r2, [r3, #24]
 800b984:	683b      	ldr	r3, [r7, #0]
 800b986:	681a      	ldr	r2, [r3, #0]
 800b988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b98a:	441a      	add	r2, r3
 800b98c:	683b      	ldr	r3, [r7, #0]
 800b98e:	601a      	str	r2, [r3, #0]
 800b990:	687a      	ldr	r2, [r7, #4]
 800b992:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b994:	1ad3      	subs	r3, r2, r3
 800b996:	607b      	str	r3, [r7, #4]
	for ( ;  btr;								/* Repeat until all data read */
 800b998:	687b      	ldr	r3, [r7, #4]
 800b99a:	2b00      	cmp	r3, #0
 800b99c:	f47f af01 	bne.w	800b7a2 <f_read+0x76>
#endif
	}

	LEAVE_FF(fs, FR_OK);
 800b9a0:	2300      	movs	r3, #0
}
 800b9a2:	4618      	mov	r0, r3
 800b9a4:	3738      	adds	r7, #56	; 0x38
 800b9a6:	46bd      	mov	sp, r7
 800b9a8:	bd80      	pop	{r7, pc}

0800b9aa <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 800b9aa:	b580      	push	{r7, lr}
 800b9ac:	b086      	sub	sp, #24
 800b9ae:	af00      	add	r7, sp, #0
 800b9b0:	6078      	str	r0, [r7, #4]
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 800b9b2:	687b      	ldr	r3, [r7, #4]
 800b9b4:	f107 0208 	add.w	r2, r7, #8
 800b9b8:	4611      	mov	r1, r2
 800b9ba:	4618      	mov	r0, r3
 800b9bc:	f7ff fc7c 	bl	800b2b8 <validate>
 800b9c0:	4603      	mov	r3, r0
 800b9c2:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800b9c4:	7dfb      	ldrb	r3, [r7, #23]
 800b9c6:	2b00      	cmp	r3, #0
 800b9c8:	d168      	bne.n	800ba9c <f_sync+0xf2>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 800b9ca:	687b      	ldr	r3, [r7, #4]
 800b9cc:	7d1b      	ldrb	r3, [r3, #20]
 800b9ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b9d2:	2b00      	cmp	r3, #0
 800b9d4:	d062      	beq.n	800ba9c <f_sync+0xf2>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 800b9d6:	687b      	ldr	r3, [r7, #4]
 800b9d8:	7d1b      	ldrb	r3, [r3, #20]
 800b9da:	b25b      	sxtb	r3, r3
 800b9dc:	2b00      	cmp	r3, #0
 800b9de:	da15      	bge.n	800ba0c <f_sync+0x62>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 800b9e0:	68bb      	ldr	r3, [r7, #8]
 800b9e2:	7858      	ldrb	r0, [r3, #1]
 800b9e4:	687b      	ldr	r3, [r7, #4]
 800b9e6:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800b9ea:	687b      	ldr	r3, [r7, #4]
 800b9ec:	6a1a      	ldr	r2, [r3, #32]
 800b9ee:	2301      	movs	r3, #1
 800b9f0:	f7fd f94c 	bl	8008c8c <disk_write>
 800b9f4:	4603      	mov	r3, r0
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d001      	beq.n	800b9fe <f_sync+0x54>
 800b9fa:	2301      	movs	r3, #1
 800b9fc:	e04f      	b.n	800ba9e <f_sync+0xf4>
				fp->flag &= (BYTE)~FA_DIRTY;
 800b9fe:	687b      	ldr	r3, [r7, #4]
 800ba00:	7d1b      	ldrb	r3, [r3, #20]
 800ba02:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ba06:	b2da      	uxtb	r2, r3
 800ba08:	687b      	ldr	r3, [r7, #4]
 800ba0a:	751a      	strb	r2, [r3, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 800ba0c:	f7fa f8c6 	bl	8005b9c <get_fattime>
 800ba10:	6138      	str	r0, [r7, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 800ba12:	68ba      	ldr	r2, [r7, #8]
 800ba14:	687b      	ldr	r3, [r7, #4]
 800ba16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba18:	4619      	mov	r1, r3
 800ba1a:	4610      	mov	r0, r2
 800ba1c:	f7fd fc24 	bl	8009268 <move_window>
 800ba20:	4603      	mov	r3, r0
 800ba22:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) {
 800ba24:	7dfb      	ldrb	r3, [r7, #23]
 800ba26:	2b00      	cmp	r3, #0
 800ba28:	d138      	bne.n	800ba9c <f_sync+0xf2>
					dir = fp->dir_ptr;
 800ba2a:	687b      	ldr	r3, [r7, #4]
 800ba2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ba2e:	60fb      	str	r3, [r7, #12]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 800ba30:	68fb      	ldr	r3, [r7, #12]
 800ba32:	330b      	adds	r3, #11
 800ba34:	781a      	ldrb	r2, [r3, #0]
 800ba36:	68fb      	ldr	r3, [r7, #12]
 800ba38:	330b      	adds	r3, #11
 800ba3a:	f042 0220 	orr.w	r2, r2, #32
 800ba3e:	b2d2      	uxtb	r2, r2
 800ba40:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 800ba42:	687b      	ldr	r3, [r7, #4]
 800ba44:	6818      	ldr	r0, [r3, #0]
 800ba46:	687b      	ldr	r3, [r7, #4]
 800ba48:	689b      	ldr	r3, [r3, #8]
 800ba4a:	461a      	mov	r2, r3
 800ba4c:	68f9      	ldr	r1, [r7, #12]
 800ba4e:	f7fe f931 	bl	8009cb4 <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 800ba52:	68fb      	ldr	r3, [r7, #12]
 800ba54:	f103 021c 	add.w	r2, r3, #28
 800ba58:	687b      	ldr	r3, [r7, #4]
 800ba5a:	68db      	ldr	r3, [r3, #12]
 800ba5c:	4619      	mov	r1, r3
 800ba5e:	4610      	mov	r0, r2
 800ba60:	f7fd f9a8 	bl	8008db4 <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 800ba64:	68fb      	ldr	r3, [r7, #12]
 800ba66:	3316      	adds	r3, #22
 800ba68:	6939      	ldr	r1, [r7, #16]
 800ba6a:	4618      	mov	r0, r3
 800ba6c:	f7fd f9a2 	bl	8008db4 <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
 800ba70:	68fb      	ldr	r3, [r7, #12]
 800ba72:	3312      	adds	r3, #18
 800ba74:	2100      	movs	r1, #0
 800ba76:	4618      	mov	r0, r3
 800ba78:	f7fd f981 	bl	8008d7e <st_word>
					fs->wflag = 1;
 800ba7c:	68bb      	ldr	r3, [r7, #8]
 800ba7e:	2201      	movs	r2, #1
 800ba80:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 800ba82:	68bb      	ldr	r3, [r7, #8]
 800ba84:	4618      	mov	r0, r3
 800ba86:	f7fd fc1d 	bl	80092c4 <sync_fs>
 800ba8a:	4603      	mov	r3, r0
 800ba8c:	75fb      	strb	r3, [r7, #23]
					fp->flag &= (BYTE)~FA_MODIFIED;
 800ba8e:	687b      	ldr	r3, [r7, #4]
 800ba90:	7d1b      	ldrb	r3, [r3, #20]
 800ba92:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800ba96:	b2da      	uxtb	r2, r3
 800ba98:	687b      	ldr	r3, [r7, #4]
 800ba9a:	751a      	strb	r2, [r3, #20]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 800ba9c:	7dfb      	ldrb	r3, [r7, #23]
}
 800ba9e:	4618      	mov	r0, r3
 800baa0:	3718      	adds	r7, #24
 800baa2:	46bd      	mov	sp, r7
 800baa4:	bd80      	pop	{r7, pc}

0800baa6 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 800baa6:	b580      	push	{r7, lr}
 800baa8:	b084      	sub	sp, #16
 800baaa:	af00      	add	r7, sp, #0
 800baac:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 800baae:	6878      	ldr	r0, [r7, #4]
 800bab0:	f7ff ff7b 	bl	800b9aa <f_sync>
 800bab4:	4603      	mov	r3, r0
 800bab6:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
 800bab8:	7bfb      	ldrb	r3, [r7, #15]
 800baba:	2b00      	cmp	r3, #0
 800babc:	d118      	bne.n	800baf0 <f_close+0x4a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 800babe:	687b      	ldr	r3, [r7, #4]
 800bac0:	f107 0208 	add.w	r2, r7, #8
 800bac4:	4611      	mov	r1, r2
 800bac6:	4618      	mov	r0, r3
 800bac8:	f7ff fbf6 	bl	800b2b8 <validate>
 800bacc:	4603      	mov	r3, r0
 800bace:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 800bad0:	7bfb      	ldrb	r3, [r7, #15]
 800bad2:	2b00      	cmp	r3, #0
 800bad4:	d10c      	bne.n	800baf0 <f_close+0x4a>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 800bad6:	687b      	ldr	r3, [r7, #4]
 800bad8:	691b      	ldr	r3, [r3, #16]
 800bada:	4618      	mov	r0, r3
 800badc:	f7fd fb20 	bl	8009120 <dec_lock>
 800bae0:	4603      	mov	r3, r0
 800bae2:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK)
 800bae4:	7bfb      	ldrb	r3, [r7, #15]
 800bae6:	2b00      	cmp	r3, #0
 800bae8:	d102      	bne.n	800baf0 <f_close+0x4a>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
 800baea:	687b      	ldr	r3, [r7, #4]
 800baec:	2200      	movs	r2, #0
 800baee:	601a      	str	r2, [r3, #0]
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
 800baf0:	7bfb      	ldrb	r3, [r7, #15]
}
 800baf2:	4618      	mov	r0, r3
 800baf4:	3710      	adds	r7, #16
 800baf6:	46bd      	mov	sp, r7
 800baf8:	bd80      	pop	{r7, pc}

0800bafa <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 800bafa:	b580      	push	{r7, lr}
 800bafc:	b086      	sub	sp, #24
 800bafe:	af00      	add	r7, sp, #0
 800bb00:	6078      	str	r0, [r7, #4]
 800bb02:	6039      	str	r1, [r7, #0]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	2b00      	cmp	r3, #0
 800bb08:	d101      	bne.n	800bb0e <f_opendir+0x14>
 800bb0a:	2309      	movs	r3, #9
 800bb0c:	e064      	b.n	800bbd8 <f_opendir+0xde>

	/* Get logical drive */
	obj = &dp->obj;
 800bb0e:	687b      	ldr	r3, [r7, #4]
 800bb10:	613b      	str	r3, [r7, #16]
	res = find_volume(&path, &fs, 0);
 800bb12:	f107 010c 	add.w	r1, r7, #12
 800bb16:	463b      	mov	r3, r7
 800bb18:	2200      	movs	r2, #0
 800bb1a:	4618      	mov	r0, r3
 800bb1c:	f7ff f97a 	bl	800ae14 <find_volume>
 800bb20:	4603      	mov	r3, r0
 800bb22:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800bb24:	7dfb      	ldrb	r3, [r7, #23]
 800bb26:	2b00      	cmp	r3, #0
 800bb28:	d14f      	bne.n	800bbca <f_opendir+0xd0>
		obj->fs = fs;
 800bb2a:	68fa      	ldr	r2, [r7, #12]
 800bb2c:	693b      	ldr	r3, [r7, #16]
 800bb2e:	601a      	str	r2, [r3, #0]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800bb30:	683b      	ldr	r3, [r7, #0]
 800bb32:	4619      	mov	r1, r3
 800bb34:	6878      	ldr	r0, [r7, #4]
 800bb36:	f7ff f861 	bl	800abfc <follow_path>
 800bb3a:	4603      	mov	r3, r0
 800bb3c:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK) {						/* Follow completed */
 800bb3e:	7dfb      	ldrb	r3, [r7, #23]
 800bb40:	2b00      	cmp	r3, #0
 800bb42:	d13d      	bne.n	800bbc0 <f_opendir+0xc6>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 800bb44:	687b      	ldr	r3, [r7, #4]
 800bb46:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800bb4a:	b25b      	sxtb	r3, r3
 800bb4c:	2b00      	cmp	r3, #0
 800bb4e:	db12      	blt.n	800bb76 <f_opendir+0x7c>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 800bb50:	693b      	ldr	r3, [r7, #16]
 800bb52:	799b      	ldrb	r3, [r3, #6]
 800bb54:	f003 0310 	and.w	r3, r3, #16
 800bb58:	2b00      	cmp	r3, #0
 800bb5a:	d00a      	beq.n	800bb72 <f_opendir+0x78>
						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
					} else
#endif
					{
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800bb5c:	68fa      	ldr	r2, [r7, #12]
 800bb5e:	687b      	ldr	r3, [r7, #4]
 800bb60:	6a1b      	ldr	r3, [r3, #32]
 800bb62:	4619      	mov	r1, r3
 800bb64:	4610      	mov	r0, r2
 800bb66:	f7fe f886 	bl	8009c76 <ld_clust>
 800bb6a:	4602      	mov	r2, r0
 800bb6c:	693b      	ldr	r3, [r7, #16]
 800bb6e:	609a      	str	r2, [r3, #8]
 800bb70:	e001      	b.n	800bb76 <f_opendir+0x7c>
					}
				} else {						/* This object is a file */
					res = FR_NO_PATH;
 800bb72:	2305      	movs	r3, #5
 800bb74:	75fb      	strb	r3, [r7, #23]
				}
			}
			if (res == FR_OK) {
 800bb76:	7dfb      	ldrb	r3, [r7, #23]
 800bb78:	2b00      	cmp	r3, #0
 800bb7a:	d121      	bne.n	800bbc0 <f_opendir+0xc6>
				obj->id = fs->id;
 800bb7c:	68fb      	ldr	r3, [r7, #12]
 800bb7e:	88da      	ldrh	r2, [r3, #6]
 800bb80:	693b      	ldr	r3, [r7, #16]
 800bb82:	809a      	strh	r2, [r3, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 800bb84:	2100      	movs	r1, #0
 800bb86:	6878      	ldr	r0, [r7, #4]
 800bb88:	f7fd feee 	bl	8009968 <dir_sdi>
 800bb8c:	4603      	mov	r3, r0
 800bb8e:	75fb      	strb	r3, [r7, #23]
#if _FS_LOCK != 0
				if (res == FR_OK) {
 800bb90:	7dfb      	ldrb	r3, [r7, #23]
 800bb92:	2b00      	cmp	r3, #0
 800bb94:	d114      	bne.n	800bbc0 <f_opendir+0xc6>
					if (obj->sclust) {
 800bb96:	693b      	ldr	r3, [r7, #16]
 800bb98:	689b      	ldr	r3, [r3, #8]
 800bb9a:	2b00      	cmp	r3, #0
 800bb9c:	d00d      	beq.n	800bbba <f_opendir+0xc0>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 800bb9e:	2100      	movs	r1, #0
 800bba0:	6878      	ldr	r0, [r7, #4]
 800bba2:	f7fd fa2f 	bl	8009004 <inc_lock>
 800bba6:	4602      	mov	r2, r0
 800bba8:	693b      	ldr	r3, [r7, #16]
 800bbaa:	611a      	str	r2, [r3, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 800bbac:	693b      	ldr	r3, [r7, #16]
 800bbae:	691b      	ldr	r3, [r3, #16]
 800bbb0:	2b00      	cmp	r3, #0
 800bbb2:	d105      	bne.n	800bbc0 <f_opendir+0xc6>
 800bbb4:	2312      	movs	r3, #18
 800bbb6:	75fb      	strb	r3, [r7, #23]
 800bbb8:	e002      	b.n	800bbc0 <f_opendir+0xc6>
					} else {
						obj->lockid = 0;	/* Root directory need not to be locked */
 800bbba:	693b      	ldr	r3, [r7, #16]
 800bbbc:	2200      	movs	r2, #0
 800bbbe:	611a      	str	r2, [r3, #16]
				}
#endif
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800bbc0:	7dfb      	ldrb	r3, [r7, #23]
 800bbc2:	2b04      	cmp	r3, #4
 800bbc4:	d101      	bne.n	800bbca <f_opendir+0xd0>
 800bbc6:	2305      	movs	r3, #5
 800bbc8:	75fb      	strb	r3, [r7, #23]
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 800bbca:	7dfb      	ldrb	r3, [r7, #23]
 800bbcc:	2b00      	cmp	r3, #0
 800bbce:	d002      	beq.n	800bbd6 <f_opendir+0xdc>
 800bbd0:	693b      	ldr	r3, [r7, #16]
 800bbd2:	2200      	movs	r2, #0
 800bbd4:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 800bbd6:	7dfb      	ldrb	r3, [r7, #23]
}
 800bbd8:	4618      	mov	r0, r3
 800bbda:	3718      	adds	r7, #24
 800bbdc:	46bd      	mov	sp, r7
 800bbde:	bd80      	pop	{r7, pc}

0800bbe0 <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 800bbe0:	b580      	push	{r7, lr}
 800bbe2:	b084      	sub	sp, #16
 800bbe4:	af00      	add	r7, sp, #0
 800bbe6:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
 800bbe8:	687b      	ldr	r3, [r7, #4]
 800bbea:	f107 0208 	add.w	r2, r7, #8
 800bbee:	4611      	mov	r1, r2
 800bbf0:	4618      	mov	r0, r3
 800bbf2:	f7ff fb61 	bl	800b2b8 <validate>
 800bbf6:	4603      	mov	r3, r0
 800bbf8:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800bbfa:	7bfb      	ldrb	r3, [r7, #15]
 800bbfc:	2b00      	cmp	r3, #0
 800bbfe:	d110      	bne.n	800bc22 <f_closedir+0x42>
#if _FS_LOCK != 0
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 800bc00:	687b      	ldr	r3, [r7, #4]
 800bc02:	691b      	ldr	r3, [r3, #16]
 800bc04:	2b00      	cmp	r3, #0
 800bc06:	d006      	beq.n	800bc16 <f_closedir+0x36>
			res = dec_lock(dp->obj.lockid);
 800bc08:	687b      	ldr	r3, [r7, #4]
 800bc0a:	691b      	ldr	r3, [r3, #16]
 800bc0c:	4618      	mov	r0, r3
 800bc0e:	f7fd fa87 	bl	8009120 <dec_lock>
 800bc12:	4603      	mov	r3, r0
 800bc14:	73fb      	strb	r3, [r7, #15]
		}
		if (res == FR_OK)
 800bc16:	7bfb      	ldrb	r3, [r7, #15]
 800bc18:	2b00      	cmp	r3, #0
 800bc1a:	d102      	bne.n	800bc22 <f_closedir+0x42>
#endif
		{
			dp->obj.fs = 0;			/* Invalidate directory object */
 800bc1c:	687b      	ldr	r3, [r7, #4]
 800bc1e:	2200      	movs	r2, #0
 800bc20:	601a      	str	r2, [r3, #0]
		}
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
 800bc22:	7bfb      	ldrb	r3, [r7, #15]
}
 800bc24:	4618      	mov	r0, r3
 800bc26:	3710      	adds	r7, #16
 800bc28:	46bd      	mov	sp, r7
 800bc2a:	bd80      	pop	{r7, pc}

0800bc2c <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800bc2c:	b580      	push	{r7, lr}
 800bc2e:	b084      	sub	sp, #16
 800bc30:	af00      	add	r7, sp, #0
 800bc32:	6078      	str	r0, [r7, #4]
 800bc34:	6039      	str	r1, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 800bc36:	687b      	ldr	r3, [r7, #4]
 800bc38:	f107 0208 	add.w	r2, r7, #8
 800bc3c:	4611      	mov	r1, r2
 800bc3e:	4618      	mov	r0, r3
 800bc40:	f7ff fb3a 	bl	800b2b8 <validate>
 800bc44:	4603      	mov	r3, r0
 800bc46:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800bc48:	7bfb      	ldrb	r3, [r7, #15]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d126      	bne.n	800bc9c <f_readdir+0x70>
		if (!fno) {
 800bc4e:	683b      	ldr	r3, [r7, #0]
 800bc50:	2b00      	cmp	r3, #0
 800bc52:	d106      	bne.n	800bc62 <f_readdir+0x36>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 800bc54:	2100      	movs	r1, #0
 800bc56:	6878      	ldr	r0, [r7, #4]
 800bc58:	f7fd fe86 	bl	8009968 <dir_sdi>
 800bc5c:	4603      	mov	r3, r0
 800bc5e:	73fb      	strb	r3, [r7, #15]
 800bc60:	e01c      	b.n	800bc9c <f_readdir+0x70>
		} else {
			INIT_NAMBUF(fs);
			res = dir_read(dp, 0);			/* Read an item */
 800bc62:	2100      	movs	r1, #0
 800bc64:	6878      	ldr	r0, [r7, #4]
 800bc66:	f7fe fa32 	bl	800a0ce <dir_read>
 800bc6a:	4603      	mov	r3, r0
 800bc6c:	73fb      	strb	r3, [r7, #15]
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 800bc6e:	7bfb      	ldrb	r3, [r7, #15]
 800bc70:	2b04      	cmp	r3, #4
 800bc72:	d101      	bne.n	800bc78 <f_readdir+0x4c>
 800bc74:	2300      	movs	r3, #0
 800bc76:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK) {				/* A valid entry is found */
 800bc78:	7bfb      	ldrb	r3, [r7, #15]
 800bc7a:	2b00      	cmp	r3, #0
 800bc7c:	d10e      	bne.n	800bc9c <f_readdir+0x70>
				get_fileinfo(dp, fno);		/* Get the object information */
 800bc7e:	6839      	ldr	r1, [r7, #0]
 800bc80:	6878      	ldr	r0, [r7, #4]
 800bc82:	f7fe fc83 	bl	800a58c <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 800bc86:	2100      	movs	r1, #0
 800bc88:	6878      	ldr	r0, [r7, #4]
 800bc8a:	f7fd fee8 	bl	8009a5e <dir_next>
 800bc8e:	4603      	mov	r3, r0
 800bc90:	73fb      	strb	r3, [r7, #15]
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 800bc92:	7bfb      	ldrb	r3, [r7, #15]
 800bc94:	2b04      	cmp	r3, #4
 800bc96:	d101      	bne.n	800bc9c <f_readdir+0x70>
 800bc98:	2300      	movs	r3, #0
 800bc9a:	73fb      	strb	r3, [r7, #15]
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
 800bc9c:	7bfb      	ldrb	r3, [r7, #15]
}
 800bc9e:	4618      	mov	r0, r3
 800bca0:	3710      	adds	r7, #16
 800bca2:	46bd      	mov	sp, r7
 800bca4:	bd80      	pop	{r7, pc}

0800bca6 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 800bca6:	b580      	push	{r7, lr}
 800bca8:	b084      	sub	sp, #16
 800bcaa:	af00      	add	r7, sp, #0
 800bcac:	6078      	str	r0, [r7, #4]
 800bcae:	6039      	str	r1, [r7, #0]
	FRESULT res;


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
 800bcb0:	6839      	ldr	r1, [r7, #0]
 800bcb2:	6878      	ldr	r0, [r7, #4]
 800bcb4:	f7ff ffba 	bl	800bc2c <f_readdir>
 800bcb8:	4603      	mov	r3, r0
 800bcba:	73fb      	strb	r3, [r7, #15]
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 800bcbc:	7bfb      	ldrb	r3, [r7, #15]
 800bcbe:	2b00      	cmp	r3, #0
 800bcc0:	d114      	bne.n	800bcec <f_findnext+0x46>
 800bcc2:	683b      	ldr	r3, [r7, #0]
 800bcc4:	2b00      	cmp	r3, #0
 800bcc6:	d011      	beq.n	800bcec <f_findnext+0x46>
 800bcc8:	683b      	ldr	r3, [r7, #0]
 800bcca:	7d9b      	ldrb	r3, [r3, #22]
 800bccc:	2b00      	cmp	r3, #0
 800bcce:	d00d      	beq.n	800bcec <f_findnext+0x46>
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 800bcd0:	687b      	ldr	r3, [r7, #4]
 800bcd2:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800bcd4:	683b      	ldr	r3, [r7, #0]
 800bcd6:	f103 0116 	add.w	r1, r3, #22
 800bcda:	2300      	movs	r3, #0
 800bcdc:	2200      	movs	r2, #0
 800bcde:	f7fe fd59 	bl	800a794 <pattern_matching>
 800bce2:	4603      	mov	r3, r0
 800bce4:	2b00      	cmp	r3, #0
 800bce6:	d100      	bne.n	800bcea <f_findnext+0x44>
		res = f_readdir(dp, fno);		/* Get a directory item */
 800bce8:	e7e2      	b.n	800bcb0 <f_findnext+0xa>
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 800bcea:	bf00      	nop
#if _USE_LFN != 0 && _USE_FIND == 2
		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
 800bcec:	7bfb      	ldrb	r3, [r7, #15]
}
 800bcee:	4618      	mov	r0, r3
 800bcf0:	3710      	adds	r7, #16
 800bcf2:	46bd      	mov	sp, r7
 800bcf4:	bd80      	pop	{r7, pc}

0800bcf6 <f_findfirst>:
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
 800bcf6:	b580      	push	{r7, lr}
 800bcf8:	b086      	sub	sp, #24
 800bcfa:	af00      	add	r7, sp, #0
 800bcfc:	60f8      	str	r0, [r7, #12]
 800bcfe:	60b9      	str	r1, [r7, #8]
 800bd00:	607a      	str	r2, [r7, #4]
 800bd02:	603b      	str	r3, [r7, #0]
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
 800bd04:	68fb      	ldr	r3, [r7, #12]
 800bd06:	683a      	ldr	r2, [r7, #0]
 800bd08:	635a      	str	r2, [r3, #52]	; 0x34
	res = f_opendir(dp, path);		/* Open the target directory */
 800bd0a:	6879      	ldr	r1, [r7, #4]
 800bd0c:	68f8      	ldr	r0, [r7, #12]
 800bd0e:	f7ff fef4 	bl	800bafa <f_opendir>
 800bd12:	4603      	mov	r3, r0
 800bd14:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800bd16:	7dfb      	ldrb	r3, [r7, #23]
 800bd18:	2b00      	cmp	r3, #0
 800bd1a:	d105      	bne.n	800bd28 <f_findfirst+0x32>
		res = f_findnext(dp, fno);	/* Find the first item */
 800bd1c:	68b9      	ldr	r1, [r7, #8]
 800bd1e:	68f8      	ldr	r0, [r7, #12]
 800bd20:	f7ff ffc1 	bl	800bca6 <f_findnext>
 800bd24:	4603      	mov	r3, r0
 800bd26:	75fb      	strb	r3, [r7, #23]
	}
	return res;
 800bd28:	7dfb      	ldrb	r3, [r7, #23]
}
 800bd2a:	4618      	mov	r0, r3
 800bd2c:	3718      	adds	r7, #24
 800bd2e:	46bd      	mov	sp, r7
 800bd30:	bd80      	pop	{r7, pc}
	...

0800bd34 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 800bd34:	b480      	push	{r7}
 800bd36:	b087      	sub	sp, #28
 800bd38:	af00      	add	r7, sp, #0
 800bd3a:	60f8      	str	r0, [r7, #12]
 800bd3c:	60b9      	str	r1, [r7, #8]
 800bd3e:	4613      	mov	r3, r2
 800bd40:	71fb      	strb	r3, [r7, #7]
  uint8_t ret = 1;
 800bd42:	2301      	movs	r3, #1
 800bd44:	75fb      	strb	r3, [r7, #23]
  uint8_t DiskNum = 0;
 800bd46:	2300      	movs	r3, #0
 800bd48:	75bb      	strb	r3, [r7, #22]

  if(disk.nbr < _VOLUMES)
 800bd4a:	4b1f      	ldr	r3, [pc, #124]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd4c:	7a5b      	ldrb	r3, [r3, #9]
 800bd4e:	b2db      	uxtb	r3, r3
 800bd50:	2b00      	cmp	r3, #0
 800bd52:	d131      	bne.n	800bdb8 <FATFS_LinkDriverEx+0x84>
  {
    disk.is_initialized[disk.nbr] = 0;
 800bd54:	4b1c      	ldr	r3, [pc, #112]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd56:	7a5b      	ldrb	r3, [r3, #9]
 800bd58:	b2db      	uxtb	r3, r3
 800bd5a:	461a      	mov	r2, r3
 800bd5c:	4b1a      	ldr	r3, [pc, #104]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd5e:	2100      	movs	r1, #0
 800bd60:	5499      	strb	r1, [r3, r2]
    disk.drv[disk.nbr] = drv;
 800bd62:	4b19      	ldr	r3, [pc, #100]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd64:	7a5b      	ldrb	r3, [r3, #9]
 800bd66:	b2db      	uxtb	r3, r3
 800bd68:	4a17      	ldr	r2, [pc, #92]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd6a:	009b      	lsls	r3, r3, #2
 800bd6c:	4413      	add	r3, r2
 800bd6e:	68fa      	ldr	r2, [r7, #12]
 800bd70:	605a      	str	r2, [r3, #4]
    disk.lun[disk.nbr] = lun;
 800bd72:	4b15      	ldr	r3, [pc, #84]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd74:	7a5b      	ldrb	r3, [r3, #9]
 800bd76:	b2db      	uxtb	r3, r3
 800bd78:	461a      	mov	r2, r3
 800bd7a:	4b13      	ldr	r3, [pc, #76]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd7c:	4413      	add	r3, r2
 800bd7e:	79fa      	ldrb	r2, [r7, #7]
 800bd80:	721a      	strb	r2, [r3, #8]
    DiskNum = disk.nbr++;
 800bd82:	4b11      	ldr	r3, [pc, #68]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd84:	7a5b      	ldrb	r3, [r3, #9]
 800bd86:	b2db      	uxtb	r3, r3
 800bd88:	1c5a      	adds	r2, r3, #1
 800bd8a:	b2d1      	uxtb	r1, r2
 800bd8c:	4a0e      	ldr	r2, [pc, #56]	; (800bdc8 <FATFS_LinkDriverEx+0x94>)
 800bd8e:	7251      	strb	r1, [r2, #9]
 800bd90:	75bb      	strb	r3, [r7, #22]
    path[0] = DiskNum + '0';
 800bd92:	7dbb      	ldrb	r3, [r7, #22]
 800bd94:	3330      	adds	r3, #48	; 0x30
 800bd96:	b2da      	uxtb	r2, r3
 800bd98:	68bb      	ldr	r3, [r7, #8]
 800bd9a:	701a      	strb	r2, [r3, #0]
    path[1] = ':';
 800bd9c:	68bb      	ldr	r3, [r7, #8]
 800bd9e:	3301      	adds	r3, #1
 800bda0:	223a      	movs	r2, #58	; 0x3a
 800bda2:	701a      	strb	r2, [r3, #0]
    path[2] = '/';
 800bda4:	68bb      	ldr	r3, [r7, #8]
 800bda6:	3302      	adds	r3, #2
 800bda8:	222f      	movs	r2, #47	; 0x2f
 800bdaa:	701a      	strb	r2, [r3, #0]
    path[3] = 0;
 800bdac:	68bb      	ldr	r3, [r7, #8]
 800bdae:	3303      	adds	r3, #3
 800bdb0:	2200      	movs	r2, #0
 800bdb2:	701a      	strb	r2, [r3, #0]
    ret = 0;
 800bdb4:	2300      	movs	r3, #0
 800bdb6:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 800bdb8:	7dfb      	ldrb	r3, [r7, #23]
}
 800bdba:	4618      	mov	r0, r3
 800bdbc:	371c      	adds	r7, #28
 800bdbe:	46bd      	mov	sp, r7
 800bdc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdc4:	4770      	bx	lr
 800bdc6:	bf00      	nop
 800bdc8:	200002dc 	.word	0x200002dc

0800bdcc <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 800bdcc:	b580      	push	{r7, lr}
 800bdce:	b082      	sub	sp, #8
 800bdd0:	af00      	add	r7, sp, #0
 800bdd2:	6078      	str	r0, [r7, #4]
 800bdd4:	6039      	str	r1, [r7, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
 800bdd6:	2200      	movs	r2, #0
 800bdd8:	6839      	ldr	r1, [r7, #0]
 800bdda:	6878      	ldr	r0, [r7, #4]
 800bddc:	f7ff ffaa 	bl	800bd34 <FATFS_LinkDriverEx>
 800bde0:	4603      	mov	r3, r0
}
 800bde2:	4618      	mov	r0, r3
 800bde4:	3708      	adds	r7, #8
 800bde6:	46bd      	mov	sp, r7
 800bde8:	bd80      	pop	{r7, pc}
	...

0800bdec <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
)
{
 800bdec:	b480      	push	{r7}
 800bdee:	b085      	sub	sp, #20
 800bdf0:	af00      	add	r7, sp, #0
 800bdf2:	4603      	mov	r3, r0
 800bdf4:	6039      	str	r1, [r7, #0]
 800bdf6:	80fb      	strh	r3, [r7, #6]
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 800bdf8:	88fb      	ldrh	r3, [r7, #6]
 800bdfa:	2b7f      	cmp	r3, #127	; 0x7f
 800bdfc:	d802      	bhi.n	800be04 <ff_convert+0x18>
		c = chr;
 800bdfe:	88fb      	ldrh	r3, [r7, #6]
 800be00:	81fb      	strh	r3, [r7, #14]
 800be02:	e025      	b.n	800be50 <ff_convert+0x64>

	} else {
		if (dir) {		/* OEM code to Unicode */
 800be04:	683b      	ldr	r3, [r7, #0]
 800be06:	2b00      	cmp	r3, #0
 800be08:	d00b      	beq.n	800be22 <ff_convert+0x36>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 800be0a:	88fb      	ldrh	r3, [r7, #6]
 800be0c:	2bff      	cmp	r3, #255	; 0xff
 800be0e:	d805      	bhi.n	800be1c <ff_convert+0x30>
 800be10:	88fb      	ldrh	r3, [r7, #6]
 800be12:	3b80      	subs	r3, #128	; 0x80
 800be14:	4a12      	ldr	r2, [pc, #72]	; (800be60 <ff_convert+0x74>)
 800be16:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800be1a:	e000      	b.n	800be1e <ff_convert+0x32>
 800be1c:	2300      	movs	r3, #0
 800be1e:	81fb      	strh	r3, [r7, #14]
 800be20:	e016      	b.n	800be50 <ff_convert+0x64>

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 800be22:	2300      	movs	r3, #0
 800be24:	81fb      	strh	r3, [r7, #14]
 800be26:	e009      	b.n	800be3c <ff_convert+0x50>
				if (chr == Tbl[c]) break;
 800be28:	89fb      	ldrh	r3, [r7, #14]
 800be2a:	4a0d      	ldr	r2, [pc, #52]	; (800be60 <ff_convert+0x74>)
 800be2c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800be30:	88fa      	ldrh	r2, [r7, #6]
 800be32:	429a      	cmp	r2, r3
 800be34:	d006      	beq.n	800be44 <ff_convert+0x58>
			for (c = 0; c < 0x80; c++) {
 800be36:	89fb      	ldrh	r3, [r7, #14]
 800be38:	3301      	adds	r3, #1
 800be3a:	81fb      	strh	r3, [r7, #14]
 800be3c:	89fb      	ldrh	r3, [r7, #14]
 800be3e:	2b7f      	cmp	r3, #127	; 0x7f
 800be40:	d9f2      	bls.n	800be28 <ff_convert+0x3c>
 800be42:	e000      	b.n	800be46 <ff_convert+0x5a>
				if (chr == Tbl[c]) break;
 800be44:	bf00      	nop
			}
			c = (c + 0x80) & 0xFF;
 800be46:	89fb      	ldrh	r3, [r7, #14]
 800be48:	3380      	adds	r3, #128	; 0x80
 800be4a:	b29b      	uxth	r3, r3
 800be4c:	b2db      	uxtb	r3, r3
 800be4e:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
 800be50:	89fb      	ldrh	r3, [r7, #14]
}
 800be52:	4618      	mov	r0, r3
 800be54:	3714      	adds	r7, #20
 800be56:	46bd      	mov	sp, r7
 800be58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be5c:	4770      	bx	lr
 800be5e:	bf00      	nop
 800be60:	08029fa8 	.word	0x08029fa8

0800be64 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 800be64:	b480      	push	{r7}
 800be66:	b087      	sub	sp, #28
 800be68:	af00      	add	r7, sp, #0
 800be6a:	4603      	mov	r3, r0
 800be6c:	80fb      	strh	r3, [r7, #6]
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 800be6e:	88fb      	ldrh	r3, [r7, #6]
 800be70:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800be74:	d201      	bcs.n	800be7a <ff_wtoupper+0x16>
 800be76:	4b3e      	ldr	r3, [pc, #248]	; (800bf70 <ff_wtoupper+0x10c>)
 800be78:	e000      	b.n	800be7c <ff_wtoupper+0x18>
 800be7a:	4b3e      	ldr	r3, [pc, #248]	; (800bf74 <ff_wtoupper+0x110>)
 800be7c:	617b      	str	r3, [r7, #20]
	for (;;) {
		bc = *p++;								/* Get block base */
 800be7e:	697b      	ldr	r3, [r7, #20]
 800be80:	1c9a      	adds	r2, r3, #2
 800be82:	617a      	str	r2, [r7, #20]
 800be84:	881b      	ldrh	r3, [r3, #0]
 800be86:	827b      	strh	r3, [r7, #18]
		if (!bc || chr < bc) break;
 800be88:	8a7b      	ldrh	r3, [r7, #18]
 800be8a:	2b00      	cmp	r3, #0
 800be8c:	d068      	beq.n	800bf60 <ff_wtoupper+0xfc>
 800be8e:	88fa      	ldrh	r2, [r7, #6]
 800be90:	8a7b      	ldrh	r3, [r7, #18]
 800be92:	429a      	cmp	r2, r3
 800be94:	d364      	bcc.n	800bf60 <ff_wtoupper+0xfc>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 800be96:	697b      	ldr	r3, [r7, #20]
 800be98:	1c9a      	adds	r2, r3, #2
 800be9a:	617a      	str	r2, [r7, #20]
 800be9c:	881b      	ldrh	r3, [r3, #0]
 800be9e:	823b      	strh	r3, [r7, #16]
 800bea0:	8a3b      	ldrh	r3, [r7, #16]
 800bea2:	0a1b      	lsrs	r3, r3, #8
 800bea4:	81fb      	strh	r3, [r7, #14]
 800bea6:	8a3b      	ldrh	r3, [r7, #16]
 800bea8:	b2db      	uxtb	r3, r3
 800beaa:	823b      	strh	r3, [r7, #16]
		if (chr < bc + nc) {	/* In the block? */
 800beac:	88fa      	ldrh	r2, [r7, #6]
 800beae:	8a79      	ldrh	r1, [r7, #18]
 800beb0:	8a3b      	ldrh	r3, [r7, #16]
 800beb2:	440b      	add	r3, r1
 800beb4:	429a      	cmp	r2, r3
 800beb6:	da49      	bge.n	800bf4c <ff_wtoupper+0xe8>
			switch (cmd) {
 800beb8:	89fb      	ldrh	r3, [r7, #14]
 800beba:	2b08      	cmp	r3, #8
 800bebc:	d84f      	bhi.n	800bf5e <ff_wtoupper+0xfa>
 800bebe:	a201      	add	r2, pc, #4	; (adr r2, 800bec4 <ff_wtoupper+0x60>)
 800bec0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bec4:	0800bee9 	.word	0x0800bee9
 800bec8:	0800befb 	.word	0x0800befb
 800becc:	0800bf11 	.word	0x0800bf11
 800bed0:	0800bf19 	.word	0x0800bf19
 800bed4:	0800bf21 	.word	0x0800bf21
 800bed8:	0800bf29 	.word	0x0800bf29
 800bedc:	0800bf31 	.word	0x0800bf31
 800bee0:	0800bf39 	.word	0x0800bf39
 800bee4:	0800bf41 	.word	0x0800bf41
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 800bee8:	88fa      	ldrh	r2, [r7, #6]
 800beea:	8a7b      	ldrh	r3, [r7, #18]
 800beec:	1ad3      	subs	r3, r2, r3
 800beee:	005b      	lsls	r3, r3, #1
 800bef0:	697a      	ldr	r2, [r7, #20]
 800bef2:	4413      	add	r3, r2
 800bef4:	881b      	ldrh	r3, [r3, #0]
 800bef6:	80fb      	strh	r3, [r7, #6]
 800bef8:	e027      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 800befa:	88fa      	ldrh	r2, [r7, #6]
 800befc:	8a7b      	ldrh	r3, [r7, #18]
 800befe:	1ad3      	subs	r3, r2, r3
 800bf00:	b29b      	uxth	r3, r3
 800bf02:	f003 0301 	and.w	r3, r3, #1
 800bf06:	b29b      	uxth	r3, r3
 800bf08:	88fa      	ldrh	r2, [r7, #6]
 800bf0a:	1ad3      	subs	r3, r2, r3
 800bf0c:	80fb      	strh	r3, [r7, #6]
 800bf0e:	e01c      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 2: chr -= 16; break;				/* Shift -16 */
 800bf10:	88fb      	ldrh	r3, [r7, #6]
 800bf12:	3b10      	subs	r3, #16
 800bf14:	80fb      	strh	r3, [r7, #6]
 800bf16:	e018      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 3:	chr -= 32; break;				/* Shift -32 */
 800bf18:	88fb      	ldrh	r3, [r7, #6]
 800bf1a:	3b20      	subs	r3, #32
 800bf1c:	80fb      	strh	r3, [r7, #6]
 800bf1e:	e014      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 4:	chr -= 48; break;				/* Shift -48 */
 800bf20:	88fb      	ldrh	r3, [r7, #6]
 800bf22:	3b30      	subs	r3, #48	; 0x30
 800bf24:	80fb      	strh	r3, [r7, #6]
 800bf26:	e010      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 5:	chr -= 26; break;				/* Shift -26 */
 800bf28:	88fb      	ldrh	r3, [r7, #6]
 800bf2a:	3b1a      	subs	r3, #26
 800bf2c:	80fb      	strh	r3, [r7, #6]
 800bf2e:	e00c      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 6:	chr += 8; break;				/* Shift +8 */
 800bf30:	88fb      	ldrh	r3, [r7, #6]
 800bf32:	3308      	adds	r3, #8
 800bf34:	80fb      	strh	r3, [r7, #6]
 800bf36:	e008      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 7: chr -= 80; break;				/* Shift -80 */
 800bf38:	88fb      	ldrh	r3, [r7, #6]
 800bf3a:	3b50      	subs	r3, #80	; 0x50
 800bf3c:	80fb      	strh	r3, [r7, #6]
 800bf3e:	e004      	b.n	800bf4a <ff_wtoupper+0xe6>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 800bf40:	88fb      	ldrh	r3, [r7, #6]
 800bf42:	f5a3 53e3 	sub.w	r3, r3, #7264	; 0x1c60
 800bf46:	80fb      	strh	r3, [r7, #6]
 800bf48:	bf00      	nop
			}
			break;
 800bf4a:	e008      	b.n	800bf5e <ff_wtoupper+0xfa>
		}
		if (!cmd) p += nc;
 800bf4c:	89fb      	ldrh	r3, [r7, #14]
 800bf4e:	2b00      	cmp	r3, #0
 800bf50:	d195      	bne.n	800be7e <ff_wtoupper+0x1a>
 800bf52:	8a3b      	ldrh	r3, [r7, #16]
 800bf54:	005b      	lsls	r3, r3, #1
 800bf56:	697a      	ldr	r2, [r7, #20]
 800bf58:	4413      	add	r3, r2
 800bf5a:	617b      	str	r3, [r7, #20]
		bc = *p++;								/* Get block base */
 800bf5c:	e78f      	b.n	800be7e <ff_wtoupper+0x1a>
			break;
 800bf5e:	bf00      	nop
	}

	return chr;
 800bf60:	88fb      	ldrh	r3, [r7, #6]
}
 800bf62:	4618      	mov	r0, r3
 800bf64:	371c      	adds	r7, #28
 800bf66:	46bd      	mov	sp, r7
 800bf68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf6c:	4770      	bx	lr
 800bf6e:	bf00      	nop
 800bf70:	0802a0a8 	.word	0x0802a0a8
 800bf74:	0802a29c 	.word	0x0802a29c

0800bf78 <jpeg_abort>:
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
 800bf78:	b580      	push	{r7, lr}
 800bf7a:	b084      	sub	sp, #16
 800bf7c:	af00      	add	r7, sp, #0
 800bf7e:	6078      	str	r0, [r7, #4]
  int pool;

  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
  if (cinfo->mem == NULL)
 800bf80:	687b      	ldr	r3, [r7, #4]
 800bf82:	685b      	ldr	r3, [r3, #4]
 800bf84:	2b00      	cmp	r3, #0
 800bf86:	d01e      	beq.n	800bfc6 <jpeg_abort+0x4e>
    return;

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 800bf88:	2301      	movs	r3, #1
 800bf8a:	60fb      	str	r3, [r7, #12]
 800bf8c:	e008      	b.n	800bfa0 <jpeg_abort+0x28>
    (*cinfo->mem->free_pool) (cinfo, pool);
 800bf8e:	687b      	ldr	r3, [r7, #4]
 800bf90:	685b      	ldr	r3, [r3, #4]
 800bf92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf94:	68f9      	ldr	r1, [r7, #12]
 800bf96:	6878      	ldr	r0, [r7, #4]
 800bf98:	4798      	blx	r3
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
 800bf9a:	68fb      	ldr	r3, [r7, #12]
 800bf9c:	3b01      	subs	r3, #1
 800bf9e:	60fb      	str	r3, [r7, #12]
 800bfa0:	68fb      	ldr	r3, [r7, #12]
 800bfa2:	2b00      	cmp	r3, #0
 800bfa4:	dcf3      	bgt.n	800bf8e <jpeg_abort+0x16>
  }

  /* Reset overall state for possible reuse of object */
  if (cinfo->is_decompressor) {
 800bfa6:	687b      	ldr	r3, [r7, #4]
 800bfa8:	691b      	ldr	r3, [r3, #16]
 800bfaa:	2b00      	cmp	r3, #0
 800bfac:	d007      	beq.n	800bfbe <jpeg_abort+0x46>
    cinfo->global_state = DSTATE_START;
 800bfae:	687b      	ldr	r3, [r7, #4]
 800bfb0:	22c8      	movs	r2, #200	; 0xc8
 800bfb2:	615a      	str	r2, [r3, #20]
    /* Try to keep application from accessing now-deleted marker list.
     * A bit kludgy to do it here, but this is the most central place.
     */
    ((j_decompress_ptr) cinfo)->marker_list = NULL;
 800bfb4:	687b      	ldr	r3, [r7, #4]
 800bfb6:	2200      	movs	r2, #0
 800bfb8:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
 800bfbc:	e004      	b.n	800bfc8 <jpeg_abort+0x50>
  } else {
    cinfo->global_state = CSTATE_START;
 800bfbe:	687b      	ldr	r3, [r7, #4]
 800bfc0:	2264      	movs	r2, #100	; 0x64
 800bfc2:	615a      	str	r2, [r3, #20]
 800bfc4:	e000      	b.n	800bfc8 <jpeg_abort+0x50>
    return;
 800bfc6:	bf00      	nop
  }
}
 800bfc8:	3710      	adds	r7, #16
 800bfca:	46bd      	mov	sp, r7
 800bfcc:	bd80      	pop	{r7, pc}

0800bfce <jpeg_destroy>:
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
 800bfce:	b580      	push	{r7, lr}
 800bfd0:	b082      	sub	sp, #8
 800bfd2:	af00      	add	r7, sp, #0
 800bfd4:	6078      	str	r0, [r7, #4]
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
 800bfd6:	687b      	ldr	r3, [r7, #4]
 800bfd8:	685b      	ldr	r3, [r3, #4]
 800bfda:	2b00      	cmp	r3, #0
 800bfdc:	d004      	beq.n	800bfe8 <jpeg_destroy+0x1a>
    (*cinfo->mem->self_destruct) (cinfo);
 800bfde:	687b      	ldr	r3, [r7, #4]
 800bfe0:	685b      	ldr	r3, [r3, #4]
 800bfe2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bfe4:	6878      	ldr	r0, [r7, #4]
 800bfe6:	4798      	blx	r3
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
 800bfe8:	687b      	ldr	r3, [r7, #4]
 800bfea:	2200      	movs	r2, #0
 800bfec:	605a      	str	r2, [r3, #4]
  cinfo->global_state = 0;	/* mark it destroyed */
 800bfee:	687b      	ldr	r3, [r7, #4]
 800bff0:	2200      	movs	r2, #0
 800bff2:	615a      	str	r2, [r3, #20]
}
 800bff4:	bf00      	nop
 800bff6:	3708      	adds	r7, #8
 800bff8:	46bd      	mov	sp, r7
 800bffa:	bd80      	pop	{r7, pc}

0800bffc <jpeg_alloc_quant_table>:
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
 800bffc:	b580      	push	{r7, lr}
 800bffe:	b084      	sub	sp, #16
 800c000:	af00      	add	r7, sp, #0
 800c002:	6078      	str	r0, [r7, #4]
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	685b      	ldr	r3, [r3, #4]
 800c008:	681b      	ldr	r3, [r3, #0]
 800c00a:	2284      	movs	r2, #132	; 0x84
 800c00c:	2100      	movs	r1, #0
 800c00e:	6878      	ldr	r0, [r7, #4]
 800c010:	4798      	blx	r3
 800c012:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 800c014:	68fb      	ldr	r3, [r7, #12]
 800c016:	2200      	movs	r2, #0
 800c018:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  return tbl;
 800c01c:	68fb      	ldr	r3, [r7, #12]
}
 800c01e:	4618      	mov	r0, r3
 800c020:	3710      	adds	r7, #16
 800c022:	46bd      	mov	sp, r7
 800c024:	bd80      	pop	{r7, pc}

0800c026 <jpeg_alloc_huff_table>:


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
 800c026:	b580      	push	{r7, lr}
 800c028:	b084      	sub	sp, #16
 800c02a:	af00      	add	r7, sp, #0
 800c02c:	6078      	str	r0, [r7, #4]
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
 800c02e:	687b      	ldr	r3, [r7, #4]
 800c030:	685b      	ldr	r3, [r3, #4]
 800c032:	681b      	ldr	r3, [r3, #0]
 800c034:	f44f 728c 	mov.w	r2, #280	; 0x118
 800c038:	2100      	movs	r1, #0
 800c03a:	6878      	ldr	r0, [r7, #4]
 800c03c:	4798      	blx	r3
 800c03e:	60f8      	str	r0, [r7, #12]
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
 800c040:	68fb      	ldr	r3, [r7, #12]
 800c042:	2200      	movs	r2, #0
 800c044:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  return tbl;
 800c048:	68fb      	ldr	r3, [r7, #12]
}
 800c04a:	4618      	mov	r0, r3
 800c04c:	3710      	adds	r7, #16
 800c04e:	46bd      	mov	sp, r7
 800c050:	bd80      	pop	{r7, pc}

0800c052 <jpeg_CreateDecompress>:
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
 800c052:	b580      	push	{r7, lr}
 800c054:	b088      	sub	sp, #32
 800c056:	af00      	add	r7, sp, #0
 800c058:	60f8      	str	r0, [r7, #12]
 800c05a:	60b9      	str	r1, [r7, #8]
 800c05c:	607a      	str	r2, [r7, #4]
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
 800c05e:	68fb      	ldr	r3, [r7, #12]
 800c060:	2200      	movs	r2, #0
 800c062:	605a      	str	r2, [r3, #4]
  if (version != JPEG_LIB_VERSION)
 800c064:	68bb      	ldr	r3, [r7, #8]
 800c066:	2b50      	cmp	r3, #80	; 0x50
 800c068:	d010      	beq.n	800c08c <jpeg_CreateDecompress+0x3a>
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
 800c06a:	68fb      	ldr	r3, [r7, #12]
 800c06c:	681b      	ldr	r3, [r3, #0]
 800c06e:	220d      	movs	r2, #13
 800c070:	615a      	str	r2, [r3, #20]
 800c072:	68fb      	ldr	r3, [r7, #12]
 800c074:	681b      	ldr	r3, [r3, #0]
 800c076:	2250      	movs	r2, #80	; 0x50
 800c078:	619a      	str	r2, [r3, #24]
 800c07a:	68fb      	ldr	r3, [r7, #12]
 800c07c:	681b      	ldr	r3, [r3, #0]
 800c07e:	68ba      	ldr	r2, [r7, #8]
 800c080:	61da      	str	r2, [r3, #28]
 800c082:	68fb      	ldr	r3, [r7, #12]
 800c084:	681b      	ldr	r3, [r3, #0]
 800c086:	681b      	ldr	r3, [r3, #0]
 800c088:	68f8      	ldr	r0, [r7, #12]
 800c08a:	4798      	blx	r3
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
 800c08c:	687b      	ldr	r3, [r7, #4]
 800c08e:	f5b3 7ff4 	cmp.w	r3, #488	; 0x1e8
 800c092:	d011      	beq.n	800c0b8 <jpeg_CreateDecompress+0x66>
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
 800c094:	68fb      	ldr	r3, [r7, #12]
 800c096:	681b      	ldr	r3, [r3, #0]
 800c098:	2216      	movs	r2, #22
 800c09a:	615a      	str	r2, [r3, #20]
 800c09c:	68fb      	ldr	r3, [r7, #12]
 800c09e:	681b      	ldr	r3, [r3, #0]
 800c0a0:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 800c0a4:	619a      	str	r2, [r3, #24]
 800c0a6:	68fb      	ldr	r3, [r7, #12]
 800c0a8:	681b      	ldr	r3, [r3, #0]
 800c0aa:	687a      	ldr	r2, [r7, #4]
 800c0ac:	61da      	str	r2, [r3, #28]
 800c0ae:	68fb      	ldr	r3, [r7, #12]
 800c0b0:	681b      	ldr	r3, [r3, #0]
 800c0b2:	681b      	ldr	r3, [r3, #0]
 800c0b4:	68f8      	ldr	r0, [r7, #12]
 800c0b6:	4798      	blx	r3
   * client_data, so we have to save and restore those fields.
   * Note: if application hasn't set client_data, tools like Purify may
   * complain here.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
 800c0b8:	68fb      	ldr	r3, [r7, #12]
 800c0ba:	681b      	ldr	r3, [r3, #0]
 800c0bc:	61bb      	str	r3, [r7, #24]
    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
 800c0be:	68fb      	ldr	r3, [r7, #12]
 800c0c0:	68db      	ldr	r3, [r3, #12]
 800c0c2:	617b      	str	r3, [r7, #20]
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
 800c0c4:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 800c0c8:	2100      	movs	r1, #0
 800c0ca:	68f8      	ldr	r0, [r7, #12]
 800c0cc:	f01c f8d8 	bl	8028280 <memset>
    cinfo->err = err;
 800c0d0:	68fb      	ldr	r3, [r7, #12]
 800c0d2:	69ba      	ldr	r2, [r7, #24]
 800c0d4:	601a      	str	r2, [r3, #0]
    cinfo->client_data = client_data;
 800c0d6:	68fb      	ldr	r3, [r7, #12]
 800c0d8:	697a      	ldr	r2, [r7, #20]
 800c0da:	60da      	str	r2, [r3, #12]
  }
  cinfo->is_decompressor = TRUE;
 800c0dc:	68fb      	ldr	r3, [r7, #12]
 800c0de:	2201      	movs	r2, #1
 800c0e0:	611a      	str	r2, [r3, #16]

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);
 800c0e2:	68f8      	ldr	r0, [r7, #12]
 800c0e4:	f019 f9f6 	bl	80254d4 <jinit_memory_mgr>

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
 800c0e8:	68fb      	ldr	r3, [r7, #12]
 800c0ea:	2200      	movs	r2, #0
 800c0ec:	609a      	str	r2, [r3, #8]
  cinfo->src = NULL;
 800c0ee:	68fb      	ldr	r3, [r7, #12]
 800c0f0:	2200      	movs	r2, #0
 800c0f2:	619a      	str	r2, [r3, #24]

  for (i = 0; i < NUM_QUANT_TBLS; i++)
 800c0f4:	2300      	movs	r3, #0
 800c0f6:	61fb      	str	r3, [r7, #28]
 800c0f8:	e009      	b.n	800c10e <jpeg_CreateDecompress+0xbc>
    cinfo->quant_tbl_ptrs[i] = NULL;
 800c0fa:	68fa      	ldr	r2, [r7, #12]
 800c0fc:	69fb      	ldr	r3, [r7, #28]
 800c0fe:	3328      	adds	r3, #40	; 0x28
 800c100:	009b      	lsls	r3, r3, #2
 800c102:	4413      	add	r3, r2
 800c104:	2200      	movs	r2, #0
 800c106:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_QUANT_TBLS; i++)
 800c108:	69fb      	ldr	r3, [r7, #28]
 800c10a:	3301      	adds	r3, #1
 800c10c:	61fb      	str	r3, [r7, #28]
 800c10e:	69fb      	ldr	r3, [r7, #28]
 800c110:	2b03      	cmp	r3, #3
 800c112:	ddf2      	ble.n	800c0fa <jpeg_CreateDecompress+0xa8>

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 800c114:	2300      	movs	r3, #0
 800c116:	61fb      	str	r3, [r7, #28]
 800c118:	e010      	b.n	800c13c <jpeg_CreateDecompress+0xea>
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
 800c11a:	68fa      	ldr	r2, [r7, #12]
 800c11c:	69fb      	ldr	r3, [r7, #28]
 800c11e:	332c      	adds	r3, #44	; 0x2c
 800c120:	009b      	lsls	r3, r3, #2
 800c122:	4413      	add	r3, r2
 800c124:	2200      	movs	r2, #0
 800c126:	605a      	str	r2, [r3, #4]
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
 800c128:	68fa      	ldr	r2, [r7, #12]
 800c12a:	69fb      	ldr	r3, [r7, #28]
 800c12c:	3330      	adds	r3, #48	; 0x30
 800c12e:	009b      	lsls	r3, r3, #2
 800c130:	4413      	add	r3, r2
 800c132:	2200      	movs	r2, #0
 800c134:	605a      	str	r2, [r3, #4]
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
 800c136:	69fb      	ldr	r3, [r7, #28]
 800c138:	3301      	adds	r3, #1
 800c13a:	61fb      	str	r3, [r7, #28]
 800c13c:	69fb      	ldr	r3, [r7, #28]
 800c13e:	2b03      	cmp	r3, #3
 800c140:	ddeb      	ble.n	800c11a <jpeg_CreateDecompress+0xc8>
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  cinfo->marker_list = NULL;
 800c142:	68fb      	ldr	r3, [r7, #12]
 800c144:	2200      	movs	r2, #0
 800c146:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
  jinit_marker_reader(cinfo);
 800c14a:	68f8      	ldr	r0, [r7, #12]
 800c14c:	f009 fcbe 	bl	8015acc <jinit_marker_reader>

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);
 800c150:	68f8      	ldr	r0, [r7, #12]
 800c152:	f006 ff23 	bl	8012f9c <jinit_input_controller>

  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
 800c156:	68fb      	ldr	r3, [r7, #12]
 800c158:	22c8      	movs	r2, #200	; 0xc8
 800c15a:	615a      	str	r2, [r3, #20]
}
 800c15c:	bf00      	nop
 800c15e:	3720      	adds	r7, #32
 800c160:	46bd      	mov	sp, r7
 800c162:	bd80      	pop	{r7, pc}

0800c164 <jpeg_destroy_decompress>:
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
 800c164:	b580      	push	{r7, lr}
 800c166:	b082      	sub	sp, #8
 800c168:	af00      	add	r7, sp, #0
 800c16a:	6078      	str	r0, [r7, #4]
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
 800c16c:	6878      	ldr	r0, [r7, #4]
 800c16e:	f7ff ff2e 	bl	800bfce <jpeg_destroy>
}
 800c172:	bf00      	nop
 800c174:	3708      	adds	r7, #8
 800c176:	46bd      	mov	sp, r7
 800c178:	bd80      	pop	{r7, pc}
	...

0800c17c <default_decompress_parms>:
 * Set default decompression parameters.
 */

LOCAL(void)
default_decompress_parms (j_decompress_ptr cinfo)
{
 800c17c:	b580      	push	{r7, lr}
 800c17e:	b086      	sub	sp, #24
 800c180:	af00      	add	r7, sp, #0
 800c182:	6078      	str	r0, [r7, #4]
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c188:	2b04      	cmp	r3, #4
 800c18a:	f000 8097 	beq.w	800c2bc <default_decompress_parms+0x140>
 800c18e:	2b04      	cmp	r3, #4
 800c190:	f300 80ca 	bgt.w	800c328 <default_decompress_parms+0x1ac>
 800c194:	2b01      	cmp	r3, #1
 800c196:	d002      	beq.n	800c19e <default_decompress_parms+0x22>
 800c198:	2b03      	cmp	r3, #3
 800c19a:	d009      	beq.n	800c1b0 <default_decompress_parms+0x34>
 800c19c:	e0c4      	b.n	800c328 <default_decompress_parms+0x1ac>
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
 800c19e:	687b      	ldr	r3, [r7, #4]
 800c1a0:	2201      	movs	r2, #1
 800c1a2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    cinfo->out_color_space = JCS_GRAYSCALE;
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	2201      	movs	r2, #1
 800c1aa:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    break;
 800c1ae:	e0c4      	b.n	800c33a <default_decompress_parms+0x1be>
    
  case 3:
    if (cinfo->saw_JFIF_marker) {
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800c1b6:	2b00      	cmp	r3, #0
 800c1b8:	d004      	beq.n	800c1c4 <default_decompress_parms+0x48>
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	2203      	movs	r2, #3
 800c1be:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 800c1c2:	e076      	b.n	800c2b2 <default_decompress_parms+0x136>
    } else if (cinfo->saw_Adobe_marker) {
 800c1c4:	687b      	ldr	r3, [r7, #4]
 800c1c6:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 800c1ca:	2b00      	cmp	r3, #0
 800c1cc:	d027      	beq.n	800c21e <default_decompress_parms+0xa2>
      switch (cinfo->Adobe_transform) {
 800c1ce:	687b      	ldr	r3, [r7, #4]
 800c1d0:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
 800c1d4:	2b00      	cmp	r3, #0
 800c1d6:	d002      	beq.n	800c1de <default_decompress_parms+0x62>
 800c1d8:	2b01      	cmp	r3, #1
 800c1da:	d005      	beq.n	800c1e8 <default_decompress_parms+0x6c>
 800c1dc:	e009      	b.n	800c1f2 <default_decompress_parms+0x76>
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
 800c1de:	687b      	ldr	r3, [r7, #4]
 800c1e0:	2202      	movs	r2, #2
 800c1e2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c1e6:	e064      	b.n	800c2b2 <default_decompress_parms+0x136>
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	2203      	movs	r2, #3
 800c1ec:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c1f0:	e05f      	b.n	800c2b2 <default_decompress_parms+0x136>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 800c1f2:	687b      	ldr	r3, [r7, #4]
 800c1f4:	681b      	ldr	r3, [r3, #0]
 800c1f6:	2274      	movs	r2, #116	; 0x74
 800c1f8:	615a      	str	r2, [r3, #20]
 800c1fa:	687b      	ldr	r3, [r7, #4]
 800c1fc:	f893 212c 	ldrb.w	r2, [r3, #300]	; 0x12c
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	681b      	ldr	r3, [r3, #0]
 800c204:	619a      	str	r2, [r3, #24]
 800c206:	687b      	ldr	r3, [r7, #4]
 800c208:	681b      	ldr	r3, [r3, #0]
 800c20a:	685b      	ldr	r3, [r3, #4]
 800c20c:	f04f 31ff 	mov.w	r1, #4294967295
 800c210:	6878      	ldr	r0, [r7, #4]
 800c212:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 800c214:	687b      	ldr	r3, [r7, #4]
 800c216:	2203      	movs	r2, #3
 800c218:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c21c:	e049      	b.n	800c2b2 <default_decompress_parms+0x136>
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
 800c21e:	687b      	ldr	r3, [r7, #4]
 800c220:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800c224:	681b      	ldr	r3, [r3, #0]
 800c226:	617b      	str	r3, [r7, #20]
      int cid1 = cinfo->comp_info[1].component_id;
 800c228:	687b      	ldr	r3, [r7, #4]
 800c22a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800c22e:	3358      	adds	r3, #88	; 0x58
 800c230:	681b      	ldr	r3, [r3, #0]
 800c232:	613b      	str	r3, [r7, #16]
      int cid2 = cinfo->comp_info[2].component_id;
 800c234:	687b      	ldr	r3, [r7, #4]
 800c236:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800c23a:	33b0      	adds	r3, #176	; 0xb0
 800c23c:	681b      	ldr	r3, [r3, #0]
 800c23e:	60fb      	str	r3, [r7, #12]

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
 800c240:	697b      	ldr	r3, [r7, #20]
 800c242:	2b01      	cmp	r3, #1
 800c244:	d10a      	bne.n	800c25c <default_decompress_parms+0xe0>
 800c246:	693b      	ldr	r3, [r7, #16]
 800c248:	2b02      	cmp	r3, #2
 800c24a:	d107      	bne.n	800c25c <default_decompress_parms+0xe0>
 800c24c:	68fb      	ldr	r3, [r7, #12]
 800c24e:	2b03      	cmp	r3, #3
 800c250:	d104      	bne.n	800c25c <default_decompress_parms+0xe0>
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
 800c252:	687b      	ldr	r3, [r7, #4]
 800c254:	2203      	movs	r2, #3
 800c256:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 800c25a:	e02a      	b.n	800c2b2 <default_decompress_parms+0x136>
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
 800c25c:	697b      	ldr	r3, [r7, #20]
 800c25e:	2b52      	cmp	r3, #82	; 0x52
 800c260:	d10a      	bne.n	800c278 <default_decompress_parms+0xfc>
 800c262:	693b      	ldr	r3, [r7, #16]
 800c264:	2b47      	cmp	r3, #71	; 0x47
 800c266:	d107      	bne.n	800c278 <default_decompress_parms+0xfc>
 800c268:	68fb      	ldr	r3, [r7, #12]
 800c26a:	2b42      	cmp	r3, #66	; 0x42
 800c26c:	d104      	bne.n	800c278 <default_decompress_parms+0xfc>
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
 800c26e:	687b      	ldr	r3, [r7, #4]
 800c270:	2202      	movs	r2, #2
 800c272:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 800c276:	e01c      	b.n	800c2b2 <default_decompress_parms+0x136>
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
 800c278:	687b      	ldr	r3, [r7, #4]
 800c27a:	681b      	ldr	r3, [r3, #0]
 800c27c:	3318      	adds	r3, #24
 800c27e:	60bb      	str	r3, [r7, #8]
 800c280:	68bb      	ldr	r3, [r7, #8]
 800c282:	697a      	ldr	r2, [r7, #20]
 800c284:	601a      	str	r2, [r3, #0]
 800c286:	68bb      	ldr	r3, [r7, #8]
 800c288:	3304      	adds	r3, #4
 800c28a:	693a      	ldr	r2, [r7, #16]
 800c28c:	601a      	str	r2, [r3, #0]
 800c28e:	68bb      	ldr	r3, [r7, #8]
 800c290:	3308      	adds	r3, #8
 800c292:	68fa      	ldr	r2, [r7, #12]
 800c294:	601a      	str	r2, [r3, #0]
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	681b      	ldr	r3, [r3, #0]
 800c29a:	2271      	movs	r2, #113	; 0x71
 800c29c:	615a      	str	r2, [r3, #20]
 800c29e:	687b      	ldr	r3, [r7, #4]
 800c2a0:	681b      	ldr	r3, [r3, #0]
 800c2a2:	685b      	ldr	r3, [r3, #4]
 800c2a4:	2101      	movs	r1, #1
 800c2a6:	6878      	ldr	r0, [r7, #4]
 800c2a8:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
 800c2aa:	687b      	ldr	r3, [r7, #4]
 800c2ac:	2203      	movs	r2, #3
 800c2ae:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	2202      	movs	r2, #2
 800c2b6:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    break;
 800c2ba:	e03e      	b.n	800c33a <default_decompress_parms+0x1be>
    
  case 4:
    if (cinfo->saw_Adobe_marker) {
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 800c2c2:	2b00      	cmp	r3, #0
 800c2c4:	d027      	beq.n	800c316 <default_decompress_parms+0x19a>
      switch (cinfo->Adobe_transform) {
 800c2c6:	687b      	ldr	r3, [r7, #4]
 800c2c8:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
 800c2cc:	2b00      	cmp	r3, #0
 800c2ce:	d002      	beq.n	800c2d6 <default_decompress_parms+0x15a>
 800c2d0:	2b02      	cmp	r3, #2
 800c2d2:	d005      	beq.n	800c2e0 <default_decompress_parms+0x164>
 800c2d4:	e009      	b.n	800c2ea <default_decompress_parms+0x16e>
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
 800c2d6:	687b      	ldr	r3, [r7, #4]
 800c2d8:	2204      	movs	r2, #4
 800c2da:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c2de:	e01e      	b.n	800c31e <default_decompress_parms+0x1a2>
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
 800c2e0:	687b      	ldr	r3, [r7, #4]
 800c2e2:	2205      	movs	r2, #5
 800c2e4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c2e8:	e019      	b.n	800c31e <default_decompress_parms+0x1a2>
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
 800c2ea:	687b      	ldr	r3, [r7, #4]
 800c2ec:	681b      	ldr	r3, [r3, #0]
 800c2ee:	2274      	movs	r2, #116	; 0x74
 800c2f0:	615a      	str	r2, [r3, #20]
 800c2f2:	687b      	ldr	r3, [r7, #4]
 800c2f4:	f893 212c 	ldrb.w	r2, [r3, #300]	; 0x12c
 800c2f8:	687b      	ldr	r3, [r7, #4]
 800c2fa:	681b      	ldr	r3, [r3, #0]
 800c2fc:	619a      	str	r2, [r3, #24]
 800c2fe:	687b      	ldr	r3, [r7, #4]
 800c300:	681b      	ldr	r3, [r3, #0]
 800c302:	685b      	ldr	r3, [r3, #4]
 800c304:	f04f 31ff 	mov.w	r1, #4294967295
 800c308:	6878      	ldr	r0, [r7, #4]
 800c30a:	4798      	blx	r3
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
 800c30c:	687b      	ldr	r3, [r7, #4]
 800c30e:	2205      	movs	r2, #5
 800c310:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	break;
 800c314:	e003      	b.n	800c31e <default_decompress_parms+0x1a2>
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
 800c316:	687b      	ldr	r3, [r7, #4]
 800c318:	2204      	movs	r2, #4
 800c31a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    }
    cinfo->out_color_space = JCS_CMYK;
 800c31e:	687b      	ldr	r3, [r7, #4]
 800c320:	2204      	movs	r2, #4
 800c322:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    break;
 800c326:	e008      	b.n	800c33a <default_decompress_parms+0x1be>
    
  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
 800c328:	687b      	ldr	r3, [r7, #4]
 800c32a:	2200      	movs	r2, #0
 800c32c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    cinfo->out_color_space = JCS_UNKNOWN;
 800c330:	687b      	ldr	r3, [r7, #4]
 800c332:	2200      	movs	r2, #0
 800c334:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    break;
 800c338:	bf00      	nop
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = cinfo->block_size;		/* 1:1 scaling */
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 800c340:	461a      	mov	r2, r3
 800c342:	687b      	ldr	r3, [r7, #4]
 800c344:	62da      	str	r2, [r3, #44]	; 0x2c
  cinfo->scale_denom = cinfo->block_size;
 800c346:	687b      	ldr	r3, [r7, #4]
 800c348:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 800c34c:	461a      	mov	r2, r3
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	631a      	str	r2, [r3, #48]	; 0x30
  cinfo->output_gamma = 1.0;
 800c352:	6879      	ldr	r1, [r7, #4]
 800c354:	f04f 0200 	mov.w	r2, #0
 800c358:	4b18      	ldr	r3, [pc, #96]	; (800c3bc <default_decompress_parms+0x240>)
 800c35a:	e9c1 230e 	strd	r2, r3, [r1, #56]	; 0x38
  cinfo->buffered_image = FALSE;
 800c35e:	687b      	ldr	r3, [r7, #4]
 800c360:	2200      	movs	r2, #0
 800c362:	641a      	str	r2, [r3, #64]	; 0x40
  cinfo->raw_data_out = FALSE;
 800c364:	687b      	ldr	r3, [r7, #4]
 800c366:	2200      	movs	r2, #0
 800c368:	645a      	str	r2, [r3, #68]	; 0x44
  cinfo->dct_method = JDCT_DEFAULT;
 800c36a:	687b      	ldr	r3, [r7, #4]
 800c36c:	2200      	movs	r2, #0
 800c36e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
  cinfo->do_fancy_upsampling = TRUE;
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	2201      	movs	r2, #1
 800c376:	64da      	str	r2, [r3, #76]	; 0x4c
  cinfo->do_block_smoothing = TRUE;
 800c378:	687b      	ldr	r3, [r7, #4]
 800c37a:	2201      	movs	r2, #1
 800c37c:	651a      	str	r2, [r3, #80]	; 0x50
  cinfo->quantize_colors = FALSE;
 800c37e:	687b      	ldr	r3, [r7, #4]
 800c380:	2200      	movs	r2, #0
 800c382:	655a      	str	r2, [r3, #84]	; 0x54
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
 800c384:	687b      	ldr	r3, [r7, #4]
 800c386:	2202      	movs	r2, #2
 800c388:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
 800c38c:	687b      	ldr	r3, [r7, #4]
 800c38e:	2201      	movs	r2, #1
 800c390:	65da      	str	r2, [r3, #92]	; 0x5c
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	f44f 7280 	mov.w	r2, #256	; 0x100
 800c398:	661a      	str	r2, [r3, #96]	; 0x60
  cinfo->colormap = NULL;
 800c39a:	687b      	ldr	r3, [r7, #4]
 800c39c:	2200      	movs	r2, #0
 800c39e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
 800c3a2:	687b      	ldr	r3, [r7, #4]
 800c3a4:	2200      	movs	r2, #0
 800c3a6:	665a      	str	r2, [r3, #100]	; 0x64
  cinfo->enable_external_quant = FALSE;
 800c3a8:	687b      	ldr	r3, [r7, #4]
 800c3aa:	2200      	movs	r2, #0
 800c3ac:	669a      	str	r2, [r3, #104]	; 0x68
  cinfo->enable_2pass_quant = FALSE;
 800c3ae:	687b      	ldr	r3, [r7, #4]
 800c3b0:	2200      	movs	r2, #0
 800c3b2:	66da      	str	r2, [r3, #108]	; 0x6c
}
 800c3b4:	bf00      	nop
 800c3b6:	3718      	adds	r7, #24
 800c3b8:	46bd      	mov	sp, r7
 800c3ba:	bd80      	pop	{r7, pc}
 800c3bc:	3ff00000 	.word	0x3ff00000

0800c3c0 <jpeg_read_header>:
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
 800c3c0:	b580      	push	{r7, lr}
 800c3c2:	b084      	sub	sp, #16
 800c3c4:	af00      	add	r7, sp, #0
 800c3c6:	6078      	str	r0, [r7, #4]
 800c3c8:	6039      	str	r1, [r7, #0]
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	695b      	ldr	r3, [r3, #20]
 800c3ce:	2bc8      	cmp	r3, #200	; 0xc8
 800c3d0:	d011      	beq.n	800c3f6 <jpeg_read_header+0x36>
      cinfo->global_state != DSTATE_INHEADER)
 800c3d2:	687b      	ldr	r3, [r7, #4]
 800c3d4:	695b      	ldr	r3, [r3, #20]
  if (cinfo->global_state != DSTATE_START &&
 800c3d6:	2bc9      	cmp	r3, #201	; 0xc9
 800c3d8:	d00d      	beq.n	800c3f6 <jpeg_read_header+0x36>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 800c3da:	687b      	ldr	r3, [r7, #4]
 800c3dc:	681b      	ldr	r3, [r3, #0]
 800c3de:	2215      	movs	r2, #21
 800c3e0:	615a      	str	r2, [r3, #20]
 800c3e2:	687b      	ldr	r3, [r7, #4]
 800c3e4:	681b      	ldr	r3, [r3, #0]
 800c3e6:	687a      	ldr	r2, [r7, #4]
 800c3e8:	6952      	ldr	r2, [r2, #20]
 800c3ea:	619a      	str	r2, [r3, #24]
 800c3ec:	687b      	ldr	r3, [r7, #4]
 800c3ee:	681b      	ldr	r3, [r3, #0]
 800c3f0:	681b      	ldr	r3, [r3, #0]
 800c3f2:	6878      	ldr	r0, [r7, #4]
 800c3f4:	4798      	blx	r3

  retcode = jpeg_consume_input(cinfo);
 800c3f6:	6878      	ldr	r0, [r7, #4]
 800c3f8:	f000 f828 	bl	800c44c <jpeg_consume_input>
 800c3fc:	60f8      	str	r0, [r7, #12]

  switch (retcode) {
 800c3fe:	68fb      	ldr	r3, [r7, #12]
 800c400:	2b02      	cmp	r3, #2
 800c402:	d00b      	beq.n	800c41c <jpeg_read_header+0x5c>
 800c404:	68fb      	ldr	r3, [r7, #12]
 800c406:	2b02      	cmp	r3, #2
 800c408:	dc1b      	bgt.n	800c442 <jpeg_read_header+0x82>
 800c40a:	68fb      	ldr	r3, [r7, #12]
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	d017      	beq.n	800c440 <jpeg_read_header+0x80>
 800c410:	68fb      	ldr	r3, [r7, #12]
 800c412:	2b01      	cmp	r3, #1
 800c414:	d115      	bne.n	800c442 <jpeg_read_header+0x82>
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
 800c416:	2301      	movs	r3, #1
 800c418:	60fb      	str	r3, [r7, #12]
    break;
 800c41a:	e012      	b.n	800c442 <jpeg_read_header+0x82>
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
 800c41c:	683b      	ldr	r3, [r7, #0]
 800c41e:	2b00      	cmp	r3, #0
 800c420:	d008      	beq.n	800c434 <jpeg_read_header+0x74>
      ERREXIT(cinfo, JERR_NO_IMAGE);
 800c422:	687b      	ldr	r3, [r7, #4]
 800c424:	681b      	ldr	r3, [r3, #0]
 800c426:	2235      	movs	r2, #53	; 0x35
 800c428:	615a      	str	r2, [r3, #20]
 800c42a:	687b      	ldr	r3, [r7, #4]
 800c42c:	681b      	ldr	r3, [r3, #0]
 800c42e:	681b      	ldr	r3, [r3, #0]
 800c430:	6878      	ldr	r0, [r7, #4]
 800c432:	4798      	blx	r3
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
 800c434:	6878      	ldr	r0, [r7, #4]
 800c436:	f7ff fd9f 	bl	800bf78 <jpeg_abort>
    retcode = JPEG_HEADER_TABLES_ONLY;
 800c43a:	2302      	movs	r3, #2
 800c43c:	60fb      	str	r3, [r7, #12]
    break;
 800c43e:	e000      	b.n	800c442 <jpeg_read_header+0x82>
  case JPEG_SUSPENDED:
    /* no work */
    break;
 800c440:	bf00      	nop
  }

  return retcode;
 800c442:	68fb      	ldr	r3, [r7, #12]
}
 800c444:	4618      	mov	r0, r3
 800c446:	3710      	adds	r7, #16
 800c448:	46bd      	mov	sp, r7
 800c44a:	bd80      	pop	{r7, pc}

0800c44c <jpeg_consume_input>:
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
 800c44c:	b580      	push	{r7, lr}
 800c44e:	b084      	sub	sp, #16
 800c450:	af00      	add	r7, sp, #0
 800c452:	6078      	str	r0, [r7, #4]
  int retcode = JPEG_SUSPENDED;
 800c454:	2300      	movs	r3, #0
 800c456:	60fb      	str	r3, [r7, #12]

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
 800c458:	687b      	ldr	r3, [r7, #4]
 800c45a:	695b      	ldr	r3, [r3, #20]
 800c45c:	3bc8      	subs	r3, #200	; 0xc8
 800c45e:	2b0a      	cmp	r3, #10
 800c460:	d842      	bhi.n	800c4e8 <jpeg_consume_input+0x9c>
 800c462:	a201      	add	r2, pc, #4	; (adr r2, 800c468 <jpeg_consume_input+0x1c>)
 800c464:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c468:	0800c495 	.word	0x0800c495
 800c46c:	0800c4b1 	.word	0x0800c4b1
 800c470:	0800c4d3 	.word	0x0800c4d3
 800c474:	0800c4d9 	.word	0x0800c4d9
 800c478:	0800c4d9 	.word	0x0800c4d9
 800c47c:	0800c4d9 	.word	0x0800c4d9
 800c480:	0800c4d9 	.word	0x0800c4d9
 800c484:	0800c4d9 	.word	0x0800c4d9
 800c488:	0800c4d9 	.word	0x0800c4d9
 800c48c:	0800c4e9 	.word	0x0800c4e9
 800c490:	0800c4d9 	.word	0x0800c4d9
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
 800c494:	687b      	ldr	r3, [r7, #4]
 800c496:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c49a:	685b      	ldr	r3, [r3, #4]
 800c49c:	6878      	ldr	r0, [r7, #4]
 800c49e:	4798      	blx	r3
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
 800c4a0:	687b      	ldr	r3, [r7, #4]
 800c4a2:	699b      	ldr	r3, [r3, #24]
 800c4a4:	689b      	ldr	r3, [r3, #8]
 800c4a6:	6878      	ldr	r0, [r7, #4]
 800c4a8:	4798      	blx	r3
    cinfo->global_state = DSTATE_INHEADER;
 800c4aa:	687b      	ldr	r3, [r7, #4]
 800c4ac:	22c9      	movs	r2, #201	; 0xc9
 800c4ae:	615a      	str	r2, [r3, #20]
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 800c4b0:	687b      	ldr	r3, [r7, #4]
 800c4b2:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c4b6:	681b      	ldr	r3, [r3, #0]
 800c4b8:	6878      	ldr	r0, [r7, #4]
 800c4ba:	4798      	blx	r3
 800c4bc:	60f8      	str	r0, [r7, #12]
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
 800c4be:	68fb      	ldr	r3, [r7, #12]
 800c4c0:	2b01      	cmp	r3, #1
 800c4c2:	d120      	bne.n	800c506 <jpeg_consume_input+0xba>
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
 800c4c4:	6878      	ldr	r0, [r7, #4]
 800c4c6:	f7ff fe59 	bl	800c17c <default_decompress_parms>
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
 800c4ca:	687b      	ldr	r3, [r7, #4]
 800c4cc:	22ca      	movs	r2, #202	; 0xca
 800c4ce:	615a      	str	r2, [r3, #20]
    }
    break;
 800c4d0:	e019      	b.n	800c506 <jpeg_consume_input+0xba>
  case DSTATE_READY:
    /* Can't advance past first SOS until start_decompress is called */
    retcode = JPEG_REACHED_SOS;
 800c4d2:	2301      	movs	r3, #1
 800c4d4:	60fb      	str	r3, [r7, #12]
    break;
 800c4d6:	e017      	b.n	800c508 <jpeg_consume_input+0xbc>
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
 800c4d8:	687b      	ldr	r3, [r7, #4]
 800c4da:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c4de:	681b      	ldr	r3, [r3, #0]
 800c4e0:	6878      	ldr	r0, [r7, #4]
 800c4e2:	4798      	blx	r3
 800c4e4:	60f8      	str	r0, [r7, #12]
    break;
 800c4e6:	e00f      	b.n	800c508 <jpeg_consume_input+0xbc>
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 800c4e8:	687b      	ldr	r3, [r7, #4]
 800c4ea:	681b      	ldr	r3, [r3, #0]
 800c4ec:	2215      	movs	r2, #21
 800c4ee:	615a      	str	r2, [r3, #20]
 800c4f0:	687b      	ldr	r3, [r7, #4]
 800c4f2:	681b      	ldr	r3, [r3, #0]
 800c4f4:	687a      	ldr	r2, [r7, #4]
 800c4f6:	6952      	ldr	r2, [r2, #20]
 800c4f8:	619a      	str	r2, [r3, #24]
 800c4fa:	687b      	ldr	r3, [r7, #4]
 800c4fc:	681b      	ldr	r3, [r3, #0]
 800c4fe:	681b      	ldr	r3, [r3, #0]
 800c500:	6878      	ldr	r0, [r7, #4]
 800c502:	4798      	blx	r3
 800c504:	e000      	b.n	800c508 <jpeg_consume_input+0xbc>
    break;
 800c506:	bf00      	nop
  }
  return retcode;
 800c508:	68fb      	ldr	r3, [r7, #12]
}
 800c50a:	4618      	mov	r0, r3
 800c50c:	3710      	adds	r7, #16
 800c50e:	46bd      	mov	sp, r7
 800c510:	bd80      	pop	{r7, pc}
 800c512:	bf00      	nop

0800c514 <jpeg_finish_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
 800c514:	b580      	push	{r7, lr}
 800c516:	b082      	sub	sp, #8
 800c518:	af00      	add	r7, sp, #0
 800c51a:	6078      	str	r0, [r7, #4]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 800c51c:	687b      	ldr	r3, [r7, #4]
 800c51e:	695b      	ldr	r3, [r3, #20]
 800c520:	2bcd      	cmp	r3, #205	; 0xcd
 800c522:	d003      	beq.n	800c52c <jpeg_finish_decompress+0x18>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	695b      	ldr	r3, [r3, #20]
  if ((cinfo->global_state == DSTATE_SCANNING ||
 800c528:	2bce      	cmp	r3, #206	; 0xce
 800c52a:	d11d      	bne.n	800c568 <jpeg_finish_decompress+0x54>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
 800c52c:	687b      	ldr	r3, [r7, #4]
 800c52e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c530:	2b00      	cmp	r3, #0
 800c532:	d119      	bne.n	800c568 <jpeg_finish_decompress+0x54>
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c53a:	687b      	ldr	r3, [r7, #4]
 800c53c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c53e:	429a      	cmp	r2, r3
 800c540:	d208      	bcs.n	800c554 <jpeg_finish_decompress+0x40>
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
 800c542:	687b      	ldr	r3, [r7, #4]
 800c544:	681b      	ldr	r3, [r3, #0]
 800c546:	2245      	movs	r2, #69	; 0x45
 800c548:	615a      	str	r2, [r3, #20]
 800c54a:	687b      	ldr	r3, [r7, #4]
 800c54c:	681b      	ldr	r3, [r3, #0]
 800c54e:	681b      	ldr	r3, [r3, #0]
 800c550:	6878      	ldr	r0, [r7, #4]
 800c552:	4798      	blx	r3
    (*cinfo->master->finish_output_pass) (cinfo);
 800c554:	687b      	ldr	r3, [r7, #4]
 800c556:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800c55a:	685b      	ldr	r3, [r3, #4]
 800c55c:	6878      	ldr	r0, [r7, #4]
 800c55e:	4798      	blx	r3
    cinfo->global_state = DSTATE_STOPPING;
 800c560:	687b      	ldr	r3, [r7, #4]
 800c562:	22d2      	movs	r2, #210	; 0xd2
 800c564:	615a      	str	r2, [r3, #20]
 800c566:	e019      	b.n	800c59c <jpeg_finish_decompress+0x88>
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
 800c568:	687b      	ldr	r3, [r7, #4]
 800c56a:	695b      	ldr	r3, [r3, #20]
 800c56c:	2bcf      	cmp	r3, #207	; 0xcf
 800c56e:	d103      	bne.n	800c578 <jpeg_finish_decompress+0x64>
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
 800c570:	687b      	ldr	r3, [r7, #4]
 800c572:	22d2      	movs	r2, #210	; 0xd2
 800c574:	615a      	str	r2, [r3, #20]
 800c576:	e01d      	b.n	800c5b4 <jpeg_finish_decompress+0xa0>
  } else if (cinfo->global_state != DSTATE_STOPPING) {
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	695b      	ldr	r3, [r3, #20]
 800c57c:	2bd2      	cmp	r3, #210	; 0xd2
 800c57e:	d019      	beq.n	800c5b4 <jpeg_finish_decompress+0xa0>
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 800c580:	687b      	ldr	r3, [r7, #4]
 800c582:	681b      	ldr	r3, [r3, #0]
 800c584:	2215      	movs	r2, #21
 800c586:	615a      	str	r2, [r3, #20]
 800c588:	687b      	ldr	r3, [r7, #4]
 800c58a:	681b      	ldr	r3, [r3, #0]
 800c58c:	687a      	ldr	r2, [r7, #4]
 800c58e:	6952      	ldr	r2, [r2, #20]
 800c590:	619a      	str	r2, [r3, #24]
 800c592:	687b      	ldr	r3, [r7, #4]
 800c594:	681b      	ldr	r3, [r3, #0]
 800c596:	681b      	ldr	r3, [r3, #0]
 800c598:	6878      	ldr	r0, [r7, #4]
 800c59a:	4798      	blx	r3
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
 800c59c:	e00a      	b.n	800c5b4 <jpeg_finish_decompress+0xa0>
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c5a4:	681b      	ldr	r3, [r3, #0]
 800c5a6:	6878      	ldr	r0, [r7, #4]
 800c5a8:	4798      	blx	r3
 800c5aa:	4603      	mov	r3, r0
 800c5ac:	2b00      	cmp	r3, #0
 800c5ae:	d101      	bne.n	800c5b4 <jpeg_finish_decompress+0xa0>
      return FALSE;		/* Suspend, come back later */
 800c5b0:	2300      	movs	r3, #0
 800c5b2:	e00e      	b.n	800c5d2 <jpeg_finish_decompress+0xbe>
  while (! cinfo->inputctl->eoi_reached) {
 800c5b4:	687b      	ldr	r3, [r7, #4]
 800c5b6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c5ba:	695b      	ldr	r3, [r3, #20]
 800c5bc:	2b00      	cmp	r3, #0
 800c5be:	d0ee      	beq.n	800c59e <jpeg_finish_decompress+0x8a>
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
 800c5c0:	687b      	ldr	r3, [r7, #4]
 800c5c2:	699b      	ldr	r3, [r3, #24]
 800c5c4:	699b      	ldr	r3, [r3, #24]
 800c5c6:	6878      	ldr	r0, [r7, #4]
 800c5c8:	4798      	blx	r3
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
 800c5ca:	6878      	ldr	r0, [r7, #4]
 800c5cc:	f7ff fcd4 	bl	800bf78 <jpeg_abort>
  return TRUE;
 800c5d0:	2301      	movs	r3, #1
}
 800c5d2:	4618      	mov	r0, r3
 800c5d4:	3708      	adds	r7, #8
 800c5d6:	46bd      	mov	sp, r7
 800c5d8:	bd80      	pop	{r7, pc}

0800c5da <jpeg_start_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
 800c5da:	b580      	push	{r7, lr}
 800c5dc:	b084      	sub	sp, #16
 800c5de:	af00      	add	r7, sp, #0
 800c5e0:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state == DSTATE_READY) {
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	695b      	ldr	r3, [r3, #20]
 800c5e6:	2bca      	cmp	r3, #202	; 0xca
 800c5e8:	d10e      	bne.n	800c608 <jpeg_start_decompress+0x2e>
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
 800c5ea:	6878      	ldr	r0, [r7, #4]
 800c5ec:	f009 fed4 	bl	8016398 <jinit_master_decompress>
    if (cinfo->buffered_image) {
 800c5f0:	687b      	ldr	r3, [r7, #4]
 800c5f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c5f4:	2b00      	cmp	r3, #0
 800c5f6:	d004      	beq.n	800c602 <jpeg_start_decompress+0x28>
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
 800c5f8:	687b      	ldr	r3, [r7, #4]
 800c5fa:	22cf      	movs	r2, #207	; 0xcf
 800c5fc:	615a      	str	r2, [r3, #20]
      return TRUE;
 800c5fe:	2301      	movs	r3, #1
 800c600:	e063      	b.n	800c6ca <jpeg_start_decompress+0xf0>
    }
    cinfo->global_state = DSTATE_PRELOAD;
 800c602:	687b      	ldr	r3, [r7, #4]
 800c604:	22cb      	movs	r2, #203	; 0xcb
 800c606:	615a      	str	r2, [r3, #20]
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
 800c608:	687b      	ldr	r3, [r7, #4]
 800c60a:	695b      	ldr	r3, [r3, #20]
 800c60c:	2bcb      	cmp	r3, #203	; 0xcb
 800c60e:	d146      	bne.n	800c69e <jpeg_start_decompress+0xc4>
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
 800c610:	687b      	ldr	r3, [r7, #4]
 800c612:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c616:	691b      	ldr	r3, [r3, #16]
 800c618:	2b00      	cmp	r3, #0
 800c61a:	d039      	beq.n	800c690 <jpeg_start_decompress+0xb6>
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
 800c61c:	687b      	ldr	r3, [r7, #4]
 800c61e:	689b      	ldr	r3, [r3, #8]
 800c620:	2b00      	cmp	r3, #0
 800c622:	d004      	beq.n	800c62e <jpeg_start_decompress+0x54>
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	689b      	ldr	r3, [r3, #8]
 800c628:	681b      	ldr	r3, [r3, #0]
 800c62a:	6878      	ldr	r0, [r7, #4]
 800c62c:	4798      	blx	r3
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
 800c62e:	687b      	ldr	r3, [r7, #4]
 800c630:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800c634:	681b      	ldr	r3, [r3, #0]
 800c636:	6878      	ldr	r0, [r7, #4]
 800c638:	4798      	blx	r3
 800c63a:	60f8      	str	r0, [r7, #12]
	if (retcode == JPEG_SUSPENDED)
 800c63c:	68fb      	ldr	r3, [r7, #12]
 800c63e:	2b00      	cmp	r3, #0
 800c640:	d101      	bne.n	800c646 <jpeg_start_decompress+0x6c>
	  return FALSE;
 800c642:	2300      	movs	r3, #0
 800c644:	e041      	b.n	800c6ca <jpeg_start_decompress+0xf0>
	if (retcode == JPEG_REACHED_EOI)
 800c646:	68fb      	ldr	r3, [r7, #12]
 800c648:	2b02      	cmp	r3, #2
 800c64a:	d020      	beq.n	800c68e <jpeg_start_decompress+0xb4>
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
 800c64c:	687b      	ldr	r3, [r7, #4]
 800c64e:	689b      	ldr	r3, [r3, #8]
 800c650:	2b00      	cmp	r3, #0
 800c652:	d0e3      	beq.n	800c61c <jpeg_start_decompress+0x42>
 800c654:	68fb      	ldr	r3, [r7, #12]
 800c656:	2b03      	cmp	r3, #3
 800c658:	d002      	beq.n	800c660 <jpeg_start_decompress+0x86>
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
 800c65a:	68fb      	ldr	r3, [r7, #12]
 800c65c:	2b01      	cmp	r3, #1
 800c65e:	d1dd      	bne.n	800c61c <jpeg_start_decompress+0x42>
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	689b      	ldr	r3, [r3, #8]
 800c664:	685a      	ldr	r2, [r3, #4]
 800c666:	3201      	adds	r2, #1
 800c668:	605a      	str	r2, [r3, #4]
 800c66a:	685a      	ldr	r2, [r3, #4]
 800c66c:	687b      	ldr	r3, [r7, #4]
 800c66e:	689b      	ldr	r3, [r3, #8]
 800c670:	689b      	ldr	r3, [r3, #8]
 800c672:	429a      	cmp	r2, r3
 800c674:	dbd2      	blt.n	800c61c <jpeg_start_decompress+0x42>
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
 800c676:	687b      	ldr	r3, [r7, #4]
 800c678:	689b      	ldr	r3, [r3, #8]
 800c67a:	689a      	ldr	r2, [r3, #8]
 800c67c:	687b      	ldr	r3, [r7, #4]
 800c67e:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800c682:	4619      	mov	r1, r3
 800c684:	687b      	ldr	r3, [r7, #4]
 800c686:	689b      	ldr	r3, [r3, #8]
 800c688:	440a      	add	r2, r1
 800c68a:	609a      	str	r2, [r3, #8]
      for (;;) {
 800c68c:	e7c6      	b.n	800c61c <jpeg_start_decompress+0x42>
	  break;
 800c68e:	bf00      	nop
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
 800c690:	687b      	ldr	r3, [r7, #4]
 800c692:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800c696:	687b      	ldr	r3, [r7, #4]
 800c698:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
 800c69c:	e011      	b.n	800c6c2 <jpeg_start_decompress+0xe8>
  } else if (cinfo->global_state != DSTATE_PRESCAN)
 800c69e:	687b      	ldr	r3, [r7, #4]
 800c6a0:	695b      	ldr	r3, [r3, #20]
 800c6a2:	2bcc      	cmp	r3, #204	; 0xcc
 800c6a4:	d00d      	beq.n	800c6c2 <jpeg_start_decompress+0xe8>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 800c6a6:	687b      	ldr	r3, [r7, #4]
 800c6a8:	681b      	ldr	r3, [r3, #0]
 800c6aa:	2215      	movs	r2, #21
 800c6ac:	615a      	str	r2, [r3, #20]
 800c6ae:	687b      	ldr	r3, [r7, #4]
 800c6b0:	681b      	ldr	r3, [r3, #0]
 800c6b2:	687a      	ldr	r2, [r7, #4]
 800c6b4:	6952      	ldr	r2, [r2, #20]
 800c6b6:	619a      	str	r2, [r3, #24]
 800c6b8:	687b      	ldr	r3, [r7, #4]
 800c6ba:	681b      	ldr	r3, [r3, #0]
 800c6bc:	681b      	ldr	r3, [r3, #0]
 800c6be:	6878      	ldr	r0, [r7, #4]
 800c6c0:	4798      	blx	r3
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
 800c6c2:	6878      	ldr	r0, [r7, #4]
 800c6c4:	f000 f805 	bl	800c6d2 <output_pass_setup>
 800c6c8:	4603      	mov	r3, r0
}
 800c6ca:	4618      	mov	r0, r3
 800c6cc:	3710      	adds	r7, #16
 800c6ce:	46bd      	mov	sp, r7
 800c6d0:	bd80      	pop	{r7, pc}

0800c6d2 <output_pass_setup>:
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
 800c6d2:	b590      	push	{r4, r7, lr}
 800c6d4:	b085      	sub	sp, #20
 800c6d6:	af00      	add	r7, sp, #0
 800c6d8:	6078      	str	r0, [r7, #4]
  if (cinfo->global_state != DSTATE_PRESCAN) {
 800c6da:	687b      	ldr	r3, [r7, #4]
 800c6dc:	695b      	ldr	r3, [r3, #20]
 800c6de:	2bcc      	cmp	r3, #204	; 0xcc
 800c6e0:	d04f      	beq.n	800c782 <output_pass_setup+0xb0>
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 800c6e2:	687b      	ldr	r3, [r7, #4]
 800c6e4:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800c6e8:	681b      	ldr	r3, [r3, #0]
 800c6ea:	6878      	ldr	r0, [r7, #4]
 800c6ec:	4798      	blx	r3
    cinfo->output_scanline = 0;
 800c6ee:	687b      	ldr	r3, [r7, #4]
 800c6f0:	2200      	movs	r2, #0
 800c6f2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    cinfo->global_state = DSTATE_PRESCAN;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	22cc      	movs	r2, #204	; 0xcc
 800c6fa:	615a      	str	r2, [r3, #20]
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
 800c6fc:	e041      	b.n	800c782 <output_pass_setup+0xb0>
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	689b      	ldr	r3, [r3, #8]
 800c702:	2b00      	cmp	r3, #0
 800c704:	d00f      	beq.n	800c726 <output_pass_setup+0x54>
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c70c:	687b      	ldr	r3, [r7, #4]
 800c70e:	689b      	ldr	r3, [r3, #8]
 800c710:	605a      	str	r2, [r3, #4]
	cinfo->progress->pass_limit = (long) cinfo->output_height;
 800c712:	687b      	ldr	r3, [r7, #4]
 800c714:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c716:	687b      	ldr	r3, [r7, #4]
 800c718:	689b      	ldr	r3, [r3, #8]
 800c71a:	609a      	str	r2, [r3, #8]
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 800c71c:	687b      	ldr	r3, [r7, #4]
 800c71e:	689b      	ldr	r3, [r3, #8]
 800c720:	681b      	ldr	r3, [r3, #0]
 800c722:	6878      	ldr	r0, [r7, #4]
 800c724:	4798      	blx	r3
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
 800c726:	687b      	ldr	r3, [r7, #4]
 800c728:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c72c:	60fb      	str	r3, [r7, #12]
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
 800c72e:	687b      	ldr	r3, [r7, #4]
 800c730:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 800c734:	685c      	ldr	r4, [r3, #4]
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	f103 028c 	add.w	r2, r3, #140	; 0x8c
 800c73c:	2300      	movs	r3, #0
 800c73e:	2100      	movs	r1, #0
 800c740:	6878      	ldr	r0, [r7, #4]
 800c742:	47a0      	blx	r4
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
 800c744:	687b      	ldr	r3, [r7, #4]
 800c746:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c74a:	68fa      	ldr	r2, [r7, #12]
 800c74c:	429a      	cmp	r2, r3
 800c74e:	d101      	bne.n	800c754 <output_pass_setup+0x82>
	return FALSE;		/* No progress made, must suspend */
 800c750:	2300      	movs	r3, #0
 800c752:	e026      	b.n	800c7a2 <output_pass_setup+0xd0>
    while (cinfo->output_scanline < cinfo->output_height) {
 800c754:	687b      	ldr	r3, [r7, #4]
 800c756:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c75a:	687b      	ldr	r3, [r7, #4]
 800c75c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c75e:	429a      	cmp	r2, r3
 800c760:	d3cd      	bcc.n	800c6fe <output_pass_setup+0x2c>
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
 800c762:	687b      	ldr	r3, [r7, #4]
 800c764:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800c768:	685b      	ldr	r3, [r3, #4]
 800c76a:	6878      	ldr	r0, [r7, #4]
 800c76c:	4798      	blx	r3
    (*cinfo->master->prepare_for_output_pass) (cinfo);
 800c76e:	687b      	ldr	r3, [r7, #4]
 800c770:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800c774:	681b      	ldr	r3, [r3, #0]
 800c776:	6878      	ldr	r0, [r7, #4]
 800c778:	4798      	blx	r3
    cinfo->output_scanline = 0;
 800c77a:	687b      	ldr	r3, [r7, #4]
 800c77c:	2200      	movs	r2, #0
 800c77e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (cinfo->master->is_dummy_pass) {
 800c782:	687b      	ldr	r3, [r7, #4]
 800c784:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 800c788:	689b      	ldr	r3, [r3, #8]
 800c78a:	2b00      	cmp	r3, #0
 800c78c:	d1e2      	bne.n	800c754 <output_pass_setup+0x82>
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
 800c78e:	687b      	ldr	r3, [r7, #4]
 800c790:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c792:	2b00      	cmp	r3, #0
 800c794:	d001      	beq.n	800c79a <output_pass_setup+0xc8>
 800c796:	22ce      	movs	r2, #206	; 0xce
 800c798:	e000      	b.n	800c79c <output_pass_setup+0xca>
 800c79a:	22cd      	movs	r2, #205	; 0xcd
 800c79c:	687b      	ldr	r3, [r7, #4]
 800c79e:	615a      	str	r2, [r3, #20]
  return TRUE;
 800c7a0:	2301      	movs	r3, #1
}
 800c7a2:	4618      	mov	r0, r3
 800c7a4:	3714      	adds	r7, #20
 800c7a6:	46bd      	mov	sp, r7
 800c7a8:	bd90      	pop	{r4, r7, pc}

0800c7aa <jpeg_read_scanlines>:
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
 800c7aa:	b590      	push	{r4, r7, lr}
 800c7ac:	b087      	sub	sp, #28
 800c7ae:	af00      	add	r7, sp, #0
 800c7b0:	60f8      	str	r0, [r7, #12]
 800c7b2:	60b9      	str	r1, [r7, #8]
 800c7b4:	607a      	str	r2, [r7, #4]
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
 800c7b6:	68fb      	ldr	r3, [r7, #12]
 800c7b8:	695b      	ldr	r3, [r3, #20]
 800c7ba:	2bcd      	cmp	r3, #205	; 0xcd
 800c7bc:	d00d      	beq.n	800c7da <jpeg_read_scanlines+0x30>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 800c7be:	68fb      	ldr	r3, [r7, #12]
 800c7c0:	681b      	ldr	r3, [r3, #0]
 800c7c2:	2215      	movs	r2, #21
 800c7c4:	615a      	str	r2, [r3, #20]
 800c7c6:	68fb      	ldr	r3, [r7, #12]
 800c7c8:	681b      	ldr	r3, [r3, #0]
 800c7ca:	68fa      	ldr	r2, [r7, #12]
 800c7cc:	6952      	ldr	r2, [r2, #20]
 800c7ce:	619a      	str	r2, [r3, #24]
 800c7d0:	68fb      	ldr	r3, [r7, #12]
 800c7d2:	681b      	ldr	r3, [r3, #0]
 800c7d4:	681b      	ldr	r3, [r3, #0]
 800c7d6:	68f8      	ldr	r0, [r7, #12]
 800c7d8:	4798      	blx	r3
  if (cinfo->output_scanline >= cinfo->output_height) {
 800c7da:	68fb      	ldr	r3, [r7, #12]
 800c7dc:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c7e0:	68fb      	ldr	r3, [r7, #12]
 800c7e2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c7e4:	429a      	cmp	r2, r3
 800c7e6:	d30c      	bcc.n	800c802 <jpeg_read_scanlines+0x58>
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
 800c7e8:	68fb      	ldr	r3, [r7, #12]
 800c7ea:	681b      	ldr	r3, [r3, #0]
 800c7ec:	227e      	movs	r2, #126	; 0x7e
 800c7ee:	615a      	str	r2, [r3, #20]
 800c7f0:	68fb      	ldr	r3, [r7, #12]
 800c7f2:	681b      	ldr	r3, [r3, #0]
 800c7f4:	685b      	ldr	r3, [r3, #4]
 800c7f6:	f04f 31ff 	mov.w	r1, #4294967295
 800c7fa:	68f8      	ldr	r0, [r7, #12]
 800c7fc:	4798      	blx	r3
    return 0;
 800c7fe:	2300      	movs	r3, #0
 800c800:	e028      	b.n	800c854 <jpeg_read_scanlines+0xaa>
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
 800c802:	68fb      	ldr	r3, [r7, #12]
 800c804:	689b      	ldr	r3, [r3, #8]
 800c806:	2b00      	cmp	r3, #0
 800c808:	d00f      	beq.n	800c82a <jpeg_read_scanlines+0x80>
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
 800c80a:	68fb      	ldr	r3, [r7, #12]
 800c80c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c810:	68fb      	ldr	r3, [r7, #12]
 800c812:	689b      	ldr	r3, [r3, #8]
 800c814:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->output_height;
 800c816:	68fb      	ldr	r3, [r7, #12]
 800c818:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c81a:	68fb      	ldr	r3, [r7, #12]
 800c81c:	689b      	ldr	r3, [r3, #8]
 800c81e:	609a      	str	r2, [r3, #8]
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 800c820:	68fb      	ldr	r3, [r7, #12]
 800c822:	689b      	ldr	r3, [r3, #8]
 800c824:	681b      	ldr	r3, [r3, #0]
 800c826:	68f8      	ldr	r0, [r7, #12]
 800c828:	4798      	blx	r3
  }

  /* Process some data */
  row_ctr = 0;
 800c82a:	2300      	movs	r3, #0
 800c82c:	617b      	str	r3, [r7, #20]
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
 800c82e:	68fb      	ldr	r3, [r7, #12]
 800c830:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 800c834:	685c      	ldr	r4, [r3, #4]
 800c836:	f107 0214 	add.w	r2, r7, #20
 800c83a:	687b      	ldr	r3, [r7, #4]
 800c83c:	68b9      	ldr	r1, [r7, #8]
 800c83e:	68f8      	ldr	r0, [r7, #12]
 800c840:	47a0      	blx	r4
  cinfo->output_scanline += row_ctr;
 800c842:	68fb      	ldr	r3, [r7, #12]
 800c844:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c848:	697b      	ldr	r3, [r7, #20]
 800c84a:	441a      	add	r2, r3
 800c84c:	68fb      	ldr	r3, [r7, #12]
 800c84e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  return row_ctr;
 800c852:	697b      	ldr	r3, [r7, #20]
}
 800c854:	4618      	mov	r0, r3
 800c856:	371c      	adds	r7, #28
 800c858:	46bd      	mov	sp, r7
 800c85a:	bd90      	pop	{r4, r7, pc}

0800c85c <get_byte>:


LOCAL(int)
get_byte (j_decompress_ptr cinfo)
/* Read next input byte; we do not support suspension in this module. */
{
 800c85c:	b580      	push	{r7, lr}
 800c85e:	b084      	sub	sp, #16
 800c860:	af00      	add	r7, sp, #0
 800c862:	6078      	str	r0, [r7, #4]
  struct jpeg_source_mgr * src = cinfo->src;
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	699b      	ldr	r3, [r3, #24]
 800c868:	60fb      	str	r3, [r7, #12]

  if (src->bytes_in_buffer == 0)
 800c86a:	68fb      	ldr	r3, [r7, #12]
 800c86c:	685b      	ldr	r3, [r3, #4]
 800c86e:	2b00      	cmp	r3, #0
 800c870:	d10f      	bne.n	800c892 <get_byte+0x36>
    if (! (*src->fill_input_buffer) (cinfo))
 800c872:	68fb      	ldr	r3, [r7, #12]
 800c874:	68db      	ldr	r3, [r3, #12]
 800c876:	6878      	ldr	r0, [r7, #4]
 800c878:	4798      	blx	r3
 800c87a:	4603      	mov	r3, r0
 800c87c:	2b00      	cmp	r3, #0
 800c87e:	d108      	bne.n	800c892 <get_byte+0x36>
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
 800c880:	687b      	ldr	r3, [r7, #4]
 800c882:	681b      	ldr	r3, [r3, #0]
 800c884:	2219      	movs	r2, #25
 800c886:	615a      	str	r2, [r3, #20]
 800c888:	687b      	ldr	r3, [r7, #4]
 800c88a:	681b      	ldr	r3, [r3, #0]
 800c88c:	681b      	ldr	r3, [r3, #0]
 800c88e:	6878      	ldr	r0, [r7, #4]
 800c890:	4798      	blx	r3
  src->bytes_in_buffer--;
 800c892:	68fb      	ldr	r3, [r7, #12]
 800c894:	685b      	ldr	r3, [r3, #4]
 800c896:	1e5a      	subs	r2, r3, #1
 800c898:	68fb      	ldr	r3, [r7, #12]
 800c89a:	605a      	str	r2, [r3, #4]
  return GETJOCTET(*src->next_input_byte++);
 800c89c:	68fb      	ldr	r3, [r7, #12]
 800c89e:	681b      	ldr	r3, [r3, #0]
 800c8a0:	1c59      	adds	r1, r3, #1
 800c8a2:	68fa      	ldr	r2, [r7, #12]
 800c8a4:	6011      	str	r1, [r2, #0]
 800c8a6:	781b      	ldrb	r3, [r3, #0]
}
 800c8a8:	4618      	mov	r0, r3
 800c8aa:	3710      	adds	r7, #16
 800c8ac:	46bd      	mov	sp, r7
 800c8ae:	bd80      	pop	{r7, pc}

0800c8b0 <arith_decode>:
 * derived from Markus Kuhn's JBIG implementation.
 */

LOCAL(int)
arith_decode (j_decompress_ptr cinfo, unsigned char *st)
{
 800c8b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c8b4:	b083      	sub	sp, #12
 800c8b6:	af00      	add	r7, sp, #0
 800c8b8:	6078      	str	r0, [r7, #4]
 800c8ba:	6039      	str	r1, [r7, #0]
  register arith_entropy_ptr e = (arith_entropy_ptr) cinfo->entropy;
 800c8bc:	687b      	ldr	r3, [r7, #4]
 800c8be:	f8d3 41d0 	ldr.w	r4, [r3, #464]	; 0x1d0
  register unsigned char nl, nm;
  register INT32 qe, temp;
  register int sv, data;

  /* Renormalization & data input per section D.2.6 */
  while (e->a < 0x8000L) {
 800c8c2:	e036      	b.n	800c932 <arith_decode+0x82>
    if (--e->ct < 0) {
 800c8c4:	6923      	ldr	r3, [r4, #16]
 800c8c6:	3b01      	subs	r3, #1
 800c8c8:	6123      	str	r3, [r4, #16]
 800c8ca:	6923      	ldr	r3, [r4, #16]
 800c8cc:	2b00      	cmp	r3, #0
 800c8ce:	da2d      	bge.n	800c92c <arith_decode+0x7c>
      /* Need to fetch next data byte */
      if (cinfo->unread_marker)
 800c8d0:	687b      	ldr	r3, [r7, #4]
 800c8d2:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 800c8d6:	2b00      	cmp	r3, #0
 800c8d8:	d001      	beq.n	800c8de <arith_decode+0x2e>
	data = 0;		/* stuff zero data */
 800c8da:	2500      	movs	r5, #0
 800c8dc:	e013      	b.n	800c906 <arith_decode+0x56>
      else {
	data = get_byte(cinfo);	/* read next input byte */
 800c8de:	6878      	ldr	r0, [r7, #4]
 800c8e0:	f7ff ffbc 	bl	800c85c <get_byte>
 800c8e4:	4605      	mov	r5, r0
	if (data == 0xFF) {	/* zero stuff or marker code */
 800c8e6:	2dff      	cmp	r5, #255	; 0xff
 800c8e8:	d10d      	bne.n	800c906 <arith_decode+0x56>
	  do data = get_byte(cinfo);
 800c8ea:	6878      	ldr	r0, [r7, #4]
 800c8ec:	f7ff ffb6 	bl	800c85c <get_byte>
 800c8f0:	4605      	mov	r5, r0
	  while (data == 0xFF);	/* swallow extra 0xFF bytes */
 800c8f2:	2dff      	cmp	r5, #255	; 0xff
 800c8f4:	d0f9      	beq.n	800c8ea <arith_decode+0x3a>
	  if (data == 0)
 800c8f6:	2d00      	cmp	r5, #0
 800c8f8:	d101      	bne.n	800c8fe <arith_decode+0x4e>
	    data = 0xFF;	/* discard stuffed zero byte */
 800c8fa:	25ff      	movs	r5, #255	; 0xff
 800c8fc:	e003      	b.n	800c906 <arith_decode+0x56>
	     * a marker while processing the compressed data
	     * segment is legal in arithmetic coding.
	     * The convention is to supply zero data
	     * then until decoding is complete.
	     */
	    cinfo->unread_marker = data;
 800c8fe:	687b      	ldr	r3, [r7, #4]
 800c900:	f8c3 51b4 	str.w	r5, [r3, #436]	; 0x1b4
	    data = 0;
 800c904:	2500      	movs	r5, #0
	  }
	}
      }
      e->c = (e->c << 8) | data; /* insert data into C register */
 800c906:	68a3      	ldr	r3, [r4, #8]
 800c908:	021b      	lsls	r3, r3, #8
 800c90a:	432b      	orrs	r3, r5
 800c90c:	60a3      	str	r3, [r4, #8]
      if ((e->ct += 8) < 0)	 /* update bit shift counter */
 800c90e:	6923      	ldr	r3, [r4, #16]
 800c910:	3308      	adds	r3, #8
 800c912:	6123      	str	r3, [r4, #16]
 800c914:	6923      	ldr	r3, [r4, #16]
 800c916:	2b00      	cmp	r3, #0
 800c918:	da08      	bge.n	800c92c <arith_decode+0x7c>
	/* Need more initial bytes */
	if (++e->ct == 0)
 800c91a:	6923      	ldr	r3, [r4, #16]
 800c91c:	3301      	adds	r3, #1
 800c91e:	6123      	str	r3, [r4, #16]
 800c920:	6923      	ldr	r3, [r4, #16]
 800c922:	2b00      	cmp	r3, #0
 800c924:	d102      	bne.n	800c92c <arith_decode+0x7c>
	  /* Got 2 initial bytes -> re-init A and exit loop */
	  e->a = 0x8000L; /* => e->a = 0x10000L after loop exit */
 800c926:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800c92a:	60e3      	str	r3, [r4, #12]
    }
    e->a <<= 1;
 800c92c:	68e3      	ldr	r3, [r4, #12]
 800c92e:	005b      	lsls	r3, r3, #1
 800c930:	60e3      	str	r3, [r4, #12]
  while (e->a < 0x8000L) {
 800c932:	68e3      	ldr	r3, [r4, #12]
 800c934:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800c938:	dbc4      	blt.n	800c8c4 <arith_decode+0x14>
  }

  /* Fetch values from our compact representation of Table D.3(D.2):
   * Qe values and probability estimation state machine
   */
  sv = *st;
 800c93a:	683b      	ldr	r3, [r7, #0]
 800c93c:	781b      	ldrb	r3, [r3, #0]
 800c93e:	461e      	mov	r6, r3
  qe = jpeg_aritab[sv & 0x7F];	/* => Qe_Value */
 800c940:	f006 037f 	and.w	r3, r6, #127	; 0x7f
 800c944:	4a2c      	ldr	r2, [pc, #176]	; (800c9f8 <arith_decode+0x148>)
 800c946:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
  nl = qe & 0xFF; qe >>= 8;	/* Next_Index_LPS + Switch_MPS */
 800c94a:	fa5f f985 	uxtb.w	r9, r5
 800c94e:	122d      	asrs	r5, r5, #8
  nm = qe & 0xFF; qe >>= 8;	/* Next_Index_MPS */
 800c950:	fa5f f885 	uxtb.w	r8, r5
 800c954:	122d      	asrs	r5, r5, #8

  /* Decode & estimation procedures per sections D.2.4 & D.2.5 */
  temp = e->a - qe;
 800c956:	68e3      	ldr	r3, [r4, #12]
 800c958:	1b5a      	subs	r2, r3, r5
  e->a = temp;
 800c95a:	60e2      	str	r2, [r4, #12]
  temp <<= e->ct;
 800c95c:	6923      	ldr	r3, [r4, #16]
 800c95e:	409a      	lsls	r2, r3
  if (e->c >= temp) {
 800c960:	68a3      	ldr	r3, [r4, #8]
 800c962:	4611      	mov	r1, r2
 800c964:	4299      	cmp	r1, r3
 800c966:	dc21      	bgt.n	800c9ac <arith_decode+0xfc>
    e->c -= temp;
 800c968:	68a3      	ldr	r3, [r4, #8]
 800c96a:	1a9b      	subs	r3, r3, r2
 800c96c:	60a3      	str	r3, [r4, #8]
    /* Conditional LPS (less probable symbol) exchange */
    if (e->a < qe) {
 800c96e:	68e3      	ldr	r3, [r4, #12]
 800c970:	429d      	cmp	r5, r3
 800c972:	dd0c      	ble.n	800c98e <arith_decode+0xde>
      e->a = qe;
 800c974:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 800c976:	b273      	sxtb	r3, r6
 800c978:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c97c:	b25a      	sxtb	r2, r3
 800c97e:	fa4f f388 	sxtb.w	r3, r8
 800c982:	4053      	eors	r3, r2
 800c984:	b25b      	sxtb	r3, r3
 800c986:	b2da      	uxtb	r2, r3
 800c988:	683b      	ldr	r3, [r7, #0]
 800c98a:	701a      	strb	r2, [r3, #0]
 800c98c:	e02e      	b.n	800c9ec <arith_decode+0x13c>
    } else {
      e->a = qe;
 800c98e:	60e5      	str	r5, [r4, #12]
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 800c990:	b273      	sxtb	r3, r6
 800c992:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c996:	b25a      	sxtb	r2, r3
 800c998:	fa4f f389 	sxtb.w	r3, r9
 800c99c:	4053      	eors	r3, r2
 800c99e:	b25b      	sxtb	r3, r3
 800c9a0:	b2da      	uxtb	r2, r3
 800c9a2:	683b      	ldr	r3, [r7, #0]
 800c9a4:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 800c9a6:	f086 0680 	eor.w	r6, r6, #128	; 0x80
 800c9aa:	e01f      	b.n	800c9ec <arith_decode+0x13c>
    }
  } else if (e->a < 0x8000L) {
 800c9ac:	68e3      	ldr	r3, [r4, #12]
 800c9ae:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800c9b2:	da1b      	bge.n	800c9ec <arith_decode+0x13c>
    /* Conditional MPS (more probable symbol) exchange */
    if (e->a < qe) {
 800c9b4:	68e3      	ldr	r3, [r4, #12]
 800c9b6:	429d      	cmp	r5, r3
 800c9b8:	dd0d      	ble.n	800c9d6 <arith_decode+0x126>
      *st = (sv & 0x80) ^ nl;	/* Estimate_after_LPS */
 800c9ba:	b273      	sxtb	r3, r6
 800c9bc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c9c0:	b25a      	sxtb	r2, r3
 800c9c2:	fa4f f389 	sxtb.w	r3, r9
 800c9c6:	4053      	eors	r3, r2
 800c9c8:	b25b      	sxtb	r3, r3
 800c9ca:	b2da      	uxtb	r2, r3
 800c9cc:	683b      	ldr	r3, [r7, #0]
 800c9ce:	701a      	strb	r2, [r3, #0]
      sv ^= 0x80;		/* Exchange LPS/MPS */
 800c9d0:	f086 0680 	eor.w	r6, r6, #128	; 0x80
 800c9d4:	e00a      	b.n	800c9ec <arith_decode+0x13c>
    } else {
      *st = (sv & 0x80) ^ nm;	/* Estimate_after_MPS */
 800c9d6:	b273      	sxtb	r3, r6
 800c9d8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c9dc:	b25a      	sxtb	r2, r3
 800c9de:	fa4f f388 	sxtb.w	r3, r8
 800c9e2:	4053      	eors	r3, r2
 800c9e4:	b25b      	sxtb	r3, r3
 800c9e6:	b2da      	uxtb	r2, r3
 800c9e8:	683b      	ldr	r3, [r7, #0]
 800c9ea:	701a      	strb	r2, [r3, #0]
    }
  }

  return sv >> 7;
 800c9ec:	11f3      	asrs	r3, r6, #7
}
 800c9ee:	4618      	mov	r0, r3
 800c9f0:	370c      	adds	r7, #12
 800c9f2:	46bd      	mov	sp, r7
 800c9f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c9f8:	0802a358 	.word	0x0802a358

0800c9fc <process_restart>:
 * Check for a restart marker & resynchronize decoder.
 */

LOCAL(void)
process_restart (j_decompress_ptr cinfo)
{
 800c9fc:	b580      	push	{r7, lr}
 800c9fe:	b086      	sub	sp, #24
 800ca00:	af00      	add	r7, sp, #0
 800ca02:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800ca04:	687b      	ldr	r3, [r7, #4]
 800ca06:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800ca0a:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 800ca0c:	687b      	ldr	r3, [r7, #4]
 800ca0e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 800ca12:	689b      	ldr	r3, [r3, #8]
 800ca14:	6878      	ldr	r0, [r7, #4]
 800ca16:	4798      	blx	r3
 800ca18:	4603      	mov	r3, r0
 800ca1a:	2b00      	cmp	r3, #0
 800ca1c:	d108      	bne.n	800ca30 <process_restart+0x34>
    ERREXIT(cinfo, JERR_CANT_SUSPEND);
 800ca1e:	687b      	ldr	r3, [r7, #4]
 800ca20:	681b      	ldr	r3, [r3, #0]
 800ca22:	2219      	movs	r2, #25
 800ca24:	615a      	str	r2, [r3, #20]
 800ca26:	687b      	ldr	r3, [r7, #4]
 800ca28:	681b      	ldr	r3, [r3, #0]
 800ca2a:	681b      	ldr	r3, [r3, #0]
 800ca2c:	6878      	ldr	r0, [r7, #4]
 800ca2e:	4798      	blx	r3

  /* Re-initialize statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800ca30:	2300      	movs	r3, #0
 800ca32:	617b      	str	r3, [r7, #20]
 800ca34:	e051      	b.n	800cada <process_restart+0xde>
    compptr = cinfo->cur_comp_info[ci];
 800ca36:	687a      	ldr	r2, [r7, #4]
 800ca38:	697b      	ldr	r3, [r7, #20]
 800ca3a:	3354      	adds	r3, #84	; 0x54
 800ca3c:	009b      	lsls	r3, r3, #2
 800ca3e:	4413      	add	r3, r2
 800ca40:	685b      	ldr	r3, [r3, #4]
 800ca42:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 800ca44:	687b      	ldr	r3, [r7, #4]
 800ca46:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ca4a:	2b00      	cmp	r3, #0
 800ca4c:	d009      	beq.n	800ca62 <process_restart+0x66>
 800ca4e:	687b      	ldr	r3, [r7, #4]
 800ca50:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800ca54:	2b00      	cmp	r3, #0
 800ca56:	d11d      	bne.n	800ca94 <process_restart+0x98>
 800ca58:	687b      	ldr	r3, [r7, #4]
 800ca5a:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800ca5e:	2b00      	cmp	r3, #0
 800ca60:	d118      	bne.n	800ca94 <process_restart+0x98>
      MEMZERO(entropy->dc_stats[compptr->dc_tbl_no], DC_STAT_BINS);
 800ca62:	68fb      	ldr	r3, [r7, #12]
 800ca64:	695a      	ldr	r2, [r3, #20]
 800ca66:	693b      	ldr	r3, [r7, #16]
 800ca68:	320e      	adds	r2, #14
 800ca6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ca6e:	2240      	movs	r2, #64	; 0x40
 800ca70:	2100      	movs	r1, #0
 800ca72:	4618      	mov	r0, r3
 800ca74:	f01b fc04 	bl	8028280 <memset>
      /* Reset DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 800ca78:	693a      	ldr	r2, [r7, #16]
 800ca7a:	697b      	ldr	r3, [r7, #20]
 800ca7c:	3304      	adds	r3, #4
 800ca7e:	009b      	lsls	r3, r3, #2
 800ca80:	4413      	add	r3, r2
 800ca82:	2200      	movs	r2, #0
 800ca84:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 800ca86:	693a      	ldr	r2, [r7, #16]
 800ca88:	697b      	ldr	r3, [r7, #20]
 800ca8a:	3308      	adds	r3, #8
 800ca8c:	009b      	lsls	r3, r3, #2
 800ca8e:	4413      	add	r3, r2
 800ca90:	2200      	movs	r2, #0
 800ca92:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 800ca94:	687b      	ldr	r3, [r7, #4]
 800ca96:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ca9a:	2b00      	cmp	r3, #0
 800ca9c:	d104      	bne.n	800caa8 <process_restart+0xac>
 800ca9e:	687b      	ldr	r3, [r7, #4]
 800caa0:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800caa4:	2b00      	cmp	r3, #0
 800caa6:	d109      	bne.n	800cabc <process_restart+0xc0>
	(cinfo->progressive_mode && cinfo->Ss)) {
 800caa8:	687b      	ldr	r3, [r7, #4]
 800caaa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 800caae:	2b00      	cmp	r3, #0
 800cab0:	d010      	beq.n	800cad4 <process_restart+0xd8>
	(cinfo->progressive_mode && cinfo->Ss)) {
 800cab2:	687b      	ldr	r3, [r7, #4]
 800cab4:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800cab8:	2b00      	cmp	r3, #0
 800caba:	d00b      	beq.n	800cad4 <process_restart+0xd8>
      MEMZERO(entropy->ac_stats[compptr->ac_tbl_no], AC_STAT_BINS);
 800cabc:	68fb      	ldr	r3, [r7, #12]
 800cabe:	699a      	ldr	r2, [r3, #24]
 800cac0:	693b      	ldr	r3, [r7, #16]
 800cac2:	321e      	adds	r2, #30
 800cac4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cac8:	f44f 7280 	mov.w	r2, #256	; 0x100
 800cacc:	2100      	movs	r1, #0
 800cace:	4618      	mov	r0, r3
 800cad0:	f01b fbd6 	bl	8028280 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800cad4:	697b      	ldr	r3, [r7, #20]
 800cad6:	3301      	adds	r3, #1
 800cad8:	617b      	str	r3, [r7, #20]
 800cada:	687b      	ldr	r3, [r7, #4]
 800cadc:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800cae0:	697a      	ldr	r2, [r7, #20]
 800cae2:	429a      	cmp	r2, r3
 800cae4:	dba7      	blt.n	800ca36 <process_restart+0x3a>
    }
  }

  /* Reset arithmetic decoding variables */
  entropy->c = 0;
 800cae6:	693b      	ldr	r3, [r7, #16]
 800cae8:	2200      	movs	r2, #0
 800caea:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 800caec:	693b      	ldr	r3, [r7, #16]
 800caee:	2200      	movs	r2, #0
 800caf0:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 800caf2:	693b      	ldr	r3, [r7, #16]
 800caf4:	f06f 020f 	mvn.w	r2, #15
 800caf8:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 800cafa:	687b      	ldr	r3, [r7, #4]
 800cafc:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800cb00:	693b      	ldr	r3, [r7, #16]
 800cb02:	635a      	str	r2, [r3, #52]	; 0x34
}
 800cb04:	bf00      	nop
 800cb06:	3718      	adds	r7, #24
 800cb08:	46bd      	mov	sp, r7
 800cb0a:	bd80      	pop	{r7, pc}

0800cb0c <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 800cb0c:	b580      	push	{r7, lr}
 800cb0e:	b08c      	sub	sp, #48	; 0x30
 800cb10:	af00      	add	r7, sp, #0
 800cb12:	6078      	str	r0, [r7, #4]
 800cb14:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800cb16:	687b      	ldr	r3, [r7, #4]
 800cb18:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800cb1c:	61fb      	str	r3, [r7, #28]
  unsigned char *st;
  int blkn, ci, tbl, sign;
  int v, m;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 800cb1e:	687b      	ldr	r3, [r7, #4]
 800cb20:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	d00b      	beq.n	800cb40 <decode_mcu_DC_first+0x34>
    if (entropy->restarts_to_go == 0)
 800cb28:	69fb      	ldr	r3, [r7, #28]
 800cb2a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cb2c:	2b00      	cmp	r3, #0
 800cb2e:	d102      	bne.n	800cb36 <decode_mcu_DC_first+0x2a>
      process_restart(cinfo);
 800cb30:	6878      	ldr	r0, [r7, #4]
 800cb32:	f7ff ff63 	bl	800c9fc <process_restart>
    entropy->restarts_to_go--;
 800cb36:	69fb      	ldr	r3, [r7, #28]
 800cb38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cb3a:	1e5a      	subs	r2, r3, #1
 800cb3c:	69fb      	ldr	r3, [r7, #28]
 800cb3e:	635a      	str	r2, [r3, #52]	; 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 800cb40:	69fb      	ldr	r3, [r7, #28]
 800cb42:	691b      	ldr	r3, [r3, #16]
 800cb44:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cb48:	d101      	bne.n	800cb4e <decode_mcu_DC_first+0x42>
 800cb4a:	2301      	movs	r3, #1
 800cb4c:	e0ec      	b.n	800cd28 <decode_mcu_DC_first+0x21c>

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800cb4e:	2300      	movs	r3, #0
 800cb50:	62bb      	str	r3, [r7, #40]	; 0x28
 800cb52:	e0e1      	b.n	800cd18 <decode_mcu_DC_first+0x20c>
    block = MCU_data[blkn];
 800cb54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cb56:	009b      	lsls	r3, r3, #2
 800cb58:	683a      	ldr	r2, [r7, #0]
 800cb5a:	4413      	add	r3, r2
 800cb5c:	681b      	ldr	r3, [r3, #0]
 800cb5e:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 800cb60:	687b      	ldr	r3, [r7, #4]
 800cb62:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cb64:	325c      	adds	r2, #92	; 0x5c
 800cb66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cb6a:	617b      	str	r3, [r7, #20]
    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;
 800cb6c:	687a      	ldr	r2, [r7, #4]
 800cb6e:	697b      	ldr	r3, [r7, #20]
 800cb70:	3354      	adds	r3, #84	; 0x54
 800cb72:	009b      	lsls	r3, r3, #2
 800cb74:	4413      	add	r3, r2
 800cb76:	685b      	ldr	r3, [r3, #4]
 800cb78:	695b      	ldr	r3, [r3, #20]
 800cb7a:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 800cb7c:	69fb      	ldr	r3, [r7, #28]
 800cb7e:	693a      	ldr	r2, [r7, #16]
 800cb80:	320e      	adds	r2, #14
 800cb82:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800cb86:	69f9      	ldr	r1, [r7, #28]
 800cb88:	697b      	ldr	r3, [r7, #20]
 800cb8a:	3308      	adds	r3, #8
 800cb8c:	009b      	lsls	r3, r3, #2
 800cb8e:	440b      	add	r3, r1
 800cb90:	685b      	ldr	r3, [r3, #4]
 800cb92:	4413      	add	r3, r2
 800cb94:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 800cb96:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cb98:	6878      	ldr	r0, [r7, #4]
 800cb9a:	f7ff fe89 	bl	800c8b0 <arith_decode>
 800cb9e:	4603      	mov	r3, r0
 800cba0:	2b00      	cmp	r3, #0
 800cba2:	d107      	bne.n	800cbb4 <decode_mcu_DC_first+0xa8>
      entropy->dc_context[ci] = 0;
 800cba4:	69fa      	ldr	r2, [r7, #28]
 800cba6:	697b      	ldr	r3, [r7, #20]
 800cba8:	3308      	adds	r3, #8
 800cbaa:	009b      	lsls	r3, r3, #2
 800cbac:	4413      	add	r3, r2
 800cbae:	2200      	movs	r2, #0
 800cbb0:	605a      	str	r2, [r3, #4]
 800cbb2:	e0a0      	b.n	800ccf6 <decode_mcu_DC_first+0x1ea>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 800cbb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbb6:	3301      	adds	r3, #1
 800cbb8:	4619      	mov	r1, r3
 800cbba:	6878      	ldr	r0, [r7, #4]
 800cbbc:	f7ff fe78 	bl	800c8b0 <arith_decode>
 800cbc0:	60f8      	str	r0, [r7, #12]
      st += 2; st += sign;
 800cbc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbc4:	3302      	adds	r3, #2
 800cbc6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cbc8:	68fb      	ldr	r3, [r7, #12]
 800cbca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cbcc:	4413      	add	r3, r2
 800cbce:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 800cbd0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cbd2:	6878      	ldr	r0, [r7, #4]
 800cbd4:	f7ff fe6c 	bl	800c8b0 <arith_decode>
 800cbd8:	6238      	str	r0, [r7, #32]
 800cbda:	6a3b      	ldr	r3, [r7, #32]
 800cbdc:	2b00      	cmp	r3, #0
 800cbde:	d029      	beq.n	800cc34 <decode_mcu_DC_first+0x128>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 800cbe0:	69fb      	ldr	r3, [r7, #28]
 800cbe2:	693a      	ldr	r2, [r7, #16]
 800cbe4:	320e      	adds	r2, #14
 800cbe6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cbea:	3314      	adds	r3, #20
 800cbec:	62fb      	str	r3, [r7, #44]	; 0x2c
	while (arith_decode(cinfo, st)) {
 800cbee:	e01a      	b.n	800cc26 <decode_mcu_DC_first+0x11a>
	  if ((m <<= 1) == 0x8000) {
 800cbf0:	6a3b      	ldr	r3, [r7, #32]
 800cbf2:	005b      	lsls	r3, r3, #1
 800cbf4:	623b      	str	r3, [r7, #32]
 800cbf6:	6a3b      	ldr	r3, [r7, #32]
 800cbf8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800cbfc:	d110      	bne.n	800cc20 <decode_mcu_DC_first+0x114>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800cbfe:	687b      	ldr	r3, [r7, #4]
 800cc00:	681b      	ldr	r3, [r3, #0]
 800cc02:	2275      	movs	r2, #117	; 0x75
 800cc04:	615a      	str	r2, [r3, #20]
 800cc06:	687b      	ldr	r3, [r7, #4]
 800cc08:	681b      	ldr	r3, [r3, #0]
 800cc0a:	685b      	ldr	r3, [r3, #4]
 800cc0c:	f04f 31ff 	mov.w	r1, #4294967295
 800cc10:	6878      	ldr	r0, [r7, #4]
 800cc12:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 800cc14:	69fb      	ldr	r3, [r7, #28]
 800cc16:	f04f 32ff 	mov.w	r2, #4294967295
 800cc1a:	611a      	str	r2, [r3, #16]
	    return TRUE;
 800cc1c:	2301      	movs	r3, #1
 800cc1e:	e083      	b.n	800cd28 <decode_mcu_DC_first+0x21c>
	  }
	  st += 1;
 800cc20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cc22:	3301      	adds	r3, #1
 800cc24:	62fb      	str	r3, [r7, #44]	; 0x2c
	while (arith_decode(cinfo, st)) {
 800cc26:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cc28:	6878      	ldr	r0, [r7, #4]
 800cc2a:	f7ff fe41 	bl	800c8b0 <arith_decode>
 800cc2e:	4603      	mov	r3, r0
 800cc30:	2b00      	cmp	r3, #0
 800cc32:	d1dd      	bne.n	800cbf0 <decode_mcu_DC_first+0xe4>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 800cc34:	687a      	ldr	r2, [r7, #4]
 800cc36:	693b      	ldr	r3, [r7, #16]
 800cc38:	4413      	add	r3, r2
 800cc3a:	33e8      	adds	r3, #232	; 0xe8
 800cc3c:	781b      	ldrb	r3, [r3, #0]
 800cc3e:	461a      	mov	r2, r3
 800cc40:	2301      	movs	r3, #1
 800cc42:	4093      	lsls	r3, r2
 800cc44:	105b      	asrs	r3, r3, #1
 800cc46:	6a3a      	ldr	r2, [r7, #32]
 800cc48:	429a      	cmp	r2, r3
 800cc4a:	da07      	bge.n	800cc5c <decode_mcu_DC_first+0x150>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 800cc4c:	69fa      	ldr	r2, [r7, #28]
 800cc4e:	697b      	ldr	r3, [r7, #20]
 800cc50:	3308      	adds	r3, #8
 800cc52:	009b      	lsls	r3, r3, #2
 800cc54:	4413      	add	r3, r2
 800cc56:	2200      	movs	r2, #0
 800cc58:	605a      	str	r2, [r3, #4]
 800cc5a:	e01e      	b.n	800cc9a <decode_mcu_DC_first+0x18e>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 800cc5c:	687a      	ldr	r2, [r7, #4]
 800cc5e:	693b      	ldr	r3, [r7, #16]
 800cc60:	4413      	add	r3, r2
 800cc62:	33f8      	adds	r3, #248	; 0xf8
 800cc64:	781b      	ldrb	r3, [r3, #0]
 800cc66:	461a      	mov	r2, r3
 800cc68:	2301      	movs	r3, #1
 800cc6a:	4093      	lsls	r3, r2
 800cc6c:	105b      	asrs	r3, r3, #1
 800cc6e:	6a3a      	ldr	r2, [r7, #32]
 800cc70:	429a      	cmp	r2, r3
 800cc72:	dd09      	ble.n	800cc88 <decode_mcu_DC_first+0x17c>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 800cc74:	68fb      	ldr	r3, [r7, #12]
 800cc76:	3303      	adds	r3, #3
 800cc78:	009a      	lsls	r2, r3, #2
 800cc7a:	69f9      	ldr	r1, [r7, #28]
 800cc7c:	697b      	ldr	r3, [r7, #20]
 800cc7e:	3308      	adds	r3, #8
 800cc80:	009b      	lsls	r3, r3, #2
 800cc82:	440b      	add	r3, r1
 800cc84:	605a      	str	r2, [r3, #4]
 800cc86:	e008      	b.n	800cc9a <decode_mcu_DC_first+0x18e>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 800cc88:	68fb      	ldr	r3, [r7, #12]
 800cc8a:	3301      	adds	r3, #1
 800cc8c:	009a      	lsls	r2, r3, #2
 800cc8e:	69f9      	ldr	r1, [r7, #28]
 800cc90:	697b      	ldr	r3, [r7, #20]
 800cc92:	3308      	adds	r3, #8
 800cc94:	009b      	lsls	r3, r3, #2
 800cc96:	440b      	add	r3, r1
 800cc98:	605a      	str	r2, [r3, #4]
      v = m;
 800cc9a:	6a3b      	ldr	r3, [r7, #32]
 800cc9c:	627b      	str	r3, [r7, #36]	; 0x24
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 800cc9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cca0:	330e      	adds	r3, #14
 800cca2:	62fb      	str	r3, [r7, #44]	; 0x2c
      while (m >>= 1)
 800cca4:	e00a      	b.n	800ccbc <decode_mcu_DC_first+0x1b0>
	if (arith_decode(cinfo, st)) v |= m;
 800cca6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cca8:	6878      	ldr	r0, [r7, #4]
 800ccaa:	f7ff fe01 	bl	800c8b0 <arith_decode>
 800ccae:	4603      	mov	r3, r0
 800ccb0:	2b00      	cmp	r3, #0
 800ccb2:	d003      	beq.n	800ccbc <decode_mcu_DC_first+0x1b0>
 800ccb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ccb6:	6a3b      	ldr	r3, [r7, #32]
 800ccb8:	4313      	orrs	r3, r2
 800ccba:	627b      	str	r3, [r7, #36]	; 0x24
      while (m >>= 1)
 800ccbc:	6a3b      	ldr	r3, [r7, #32]
 800ccbe:	105b      	asrs	r3, r3, #1
 800ccc0:	623b      	str	r3, [r7, #32]
 800ccc2:	6a3b      	ldr	r3, [r7, #32]
 800ccc4:	2b00      	cmp	r3, #0
 800ccc6:	d1ee      	bne.n	800cca6 <decode_mcu_DC_first+0x19a>
      v += 1; if (sign) v = -v;
 800ccc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccca:	3301      	adds	r3, #1
 800cccc:	627b      	str	r3, [r7, #36]	; 0x24
 800ccce:	68fb      	ldr	r3, [r7, #12]
 800ccd0:	2b00      	cmp	r3, #0
 800ccd2:	d002      	beq.n	800ccda <decode_mcu_DC_first+0x1ce>
 800ccd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ccd6:	425b      	negs	r3, r3
 800ccd8:	627b      	str	r3, [r7, #36]	; 0x24
      entropy->last_dc_val[ci] += v;
 800ccda:	69fa      	ldr	r2, [r7, #28]
 800ccdc:	697b      	ldr	r3, [r7, #20]
 800ccde:	3304      	adds	r3, #4
 800cce0:	009b      	lsls	r3, r3, #2
 800cce2:	4413      	add	r3, r2
 800cce4:	685a      	ldr	r2, [r3, #4]
 800cce6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cce8:	441a      	add	r2, r3
 800ccea:	69f9      	ldr	r1, [r7, #28]
 800ccec:	697b      	ldr	r3, [r7, #20]
 800ccee:	3304      	adds	r3, #4
 800ccf0:	009b      	lsls	r3, r3, #2
 800ccf2:	440b      	add	r3, r1
 800ccf4:	605a      	str	r2, [r3, #4]
    }

    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
    (*block)[0] = (JCOEF) (entropy->last_dc_val[ci] << cinfo->Al);
 800ccf6:	69fa      	ldr	r2, [r7, #28]
 800ccf8:	697b      	ldr	r3, [r7, #20]
 800ccfa:	3304      	adds	r3, #4
 800ccfc:	009b      	lsls	r3, r3, #2
 800ccfe:	4413      	add	r3, r2
 800cd00:	685a      	ldr	r2, [r3, #4]
 800cd02:	687b      	ldr	r3, [r7, #4]
 800cd04:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800cd08:	fa02 f303 	lsl.w	r3, r2, r3
 800cd0c:	b21a      	sxth	r2, r3
 800cd0e:	69bb      	ldr	r3, [r7, #24]
 800cd10:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800cd12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd14:	3301      	adds	r3, #1
 800cd16:	62bb      	str	r3, [r7, #40]	; 0x28
 800cd18:	687b      	ldr	r3, [r7, #4]
 800cd1a:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 800cd1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cd20:	429a      	cmp	r2, r3
 800cd22:	f6ff af17 	blt.w	800cb54 <decode_mcu_DC_first+0x48>
  }

  return TRUE;
 800cd26:	2301      	movs	r3, #1
}
 800cd28:	4618      	mov	r0, r3
 800cd2a:	3730      	adds	r7, #48	; 0x30
 800cd2c:	46bd      	mov	sp, r7
 800cd2e:	bd80      	pop	{r7, pc}

0800cd30 <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 800cd30:	b580      	push	{r7, lr}
 800cd32:	b08c      	sub	sp, #48	; 0x30
 800cd34:	af00      	add	r7, sp, #0
 800cd36:	6078      	str	r0, [r7, #4]
 800cd38:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800cd3a:	687b      	ldr	r3, [r7, #4]
 800cd3c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800cd40:	61fb      	str	r3, [r7, #28]
  int tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 800cd42:	687b      	ldr	r3, [r7, #4]
 800cd44:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800cd48:	2b00      	cmp	r3, #0
 800cd4a:	d00b      	beq.n	800cd64 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 800cd4c:	69fb      	ldr	r3, [r7, #28]
 800cd4e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cd50:	2b00      	cmp	r3, #0
 800cd52:	d102      	bne.n	800cd5a <decode_mcu_AC_first+0x2a>
      process_restart(cinfo);
 800cd54:	6878      	ldr	r0, [r7, #4]
 800cd56:	f7ff fe51 	bl	800c9fc <process_restart>
    entropy->restarts_to_go--;
 800cd5a:	69fb      	ldr	r3, [r7, #28]
 800cd5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cd5e:	1e5a      	subs	r2, r3, #1
 800cd60:	69fb      	ldr	r3, [r7, #28]
 800cd62:	635a      	str	r2, [r3, #52]	; 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 800cd64:	69fb      	ldr	r3, [r7, #28]
 800cd66:	691b      	ldr	r3, [r3, #16]
 800cd68:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cd6c:	d101      	bne.n	800cd72 <decode_mcu_AC_first+0x42>
 800cd6e:	2301      	movs	r3, #1
 800cd70:	e0da      	b.n	800cf28 <decode_mcu_AC_first+0x1f8>

  natural_order = cinfo->natural_order;
 800cd72:	687b      	ldr	r3, [r7, #4]
 800cd74:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800cd78:	61bb      	str	r3, [r7, #24]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 800cd7a:	683b      	ldr	r3, [r7, #0]
 800cd7c:	681b      	ldr	r3, [r3, #0]
 800cd7e:	617b      	str	r3, [r7, #20]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 800cd80:	687b      	ldr	r3, [r7, #4]
 800cd82:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 800cd86:	699b      	ldr	r3, [r3, #24]
 800cd88:	613b      	str	r3, [r7, #16]

  /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

  /* Figure F.20: Decode_AC_coefficients */
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 800cd8a:	687b      	ldr	r3, [r7, #4]
 800cd8c:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800cd90:	62bb      	str	r3, [r7, #40]	; 0x28
 800cd92:	e0bf      	b.n	800cf14 <decode_mcu_AC_first+0x1e4>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 800cd94:	69fb      	ldr	r3, [r7, #28]
 800cd96:	693a      	ldr	r2, [r7, #16]
 800cd98:	321e      	adds	r2, #30
 800cd9a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800cd9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cda0:	1e5a      	subs	r2, r3, #1
 800cda2:	4613      	mov	r3, r2
 800cda4:	005b      	lsls	r3, r3, #1
 800cda6:	4413      	add	r3, r2
 800cda8:	440b      	add	r3, r1
 800cdaa:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 800cdac:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cdae:	6878      	ldr	r0, [r7, #4]
 800cdb0:	f7ff fd7e 	bl	800c8b0 <arith_decode>
 800cdb4:	4603      	mov	r3, r0
 800cdb6:	2b00      	cmp	r3, #0
 800cdb8:	f040 80b4 	bne.w	800cf24 <decode_mcu_AC_first+0x1f4>
    while (arith_decode(cinfo, st + 1) == 0) {
 800cdbc:	e01c      	b.n	800cdf8 <decode_mcu_AC_first+0xc8>
      st += 3; k++;
 800cdbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cdc0:	3303      	adds	r3, #3
 800cdc2:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cdc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdc6:	3301      	adds	r3, #1
 800cdc8:	62bb      	str	r3, [r7, #40]	; 0x28
      if (k > cinfo->Se) {
 800cdca:	687b      	ldr	r3, [r7, #4]
 800cdcc:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800cdd0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cdd2:	429a      	cmp	r2, r3
 800cdd4:	dd10      	ble.n	800cdf8 <decode_mcu_AC_first+0xc8>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800cdd6:	687b      	ldr	r3, [r7, #4]
 800cdd8:	681b      	ldr	r3, [r3, #0]
 800cdda:	2275      	movs	r2, #117	; 0x75
 800cddc:	615a      	str	r2, [r3, #20]
 800cdde:	687b      	ldr	r3, [r7, #4]
 800cde0:	681b      	ldr	r3, [r3, #0]
 800cde2:	685b      	ldr	r3, [r3, #4]
 800cde4:	f04f 31ff 	mov.w	r1, #4294967295
 800cde8:	6878      	ldr	r0, [r7, #4]
 800cdea:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 800cdec:	69fb      	ldr	r3, [r7, #28]
 800cdee:	f04f 32ff 	mov.w	r2, #4294967295
 800cdf2:	611a      	str	r2, [r3, #16]
	return TRUE;
 800cdf4:	2301      	movs	r3, #1
 800cdf6:	e097      	b.n	800cf28 <decode_mcu_AC_first+0x1f8>
    while (arith_decode(cinfo, st + 1) == 0) {
 800cdf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cdfa:	3301      	adds	r3, #1
 800cdfc:	4619      	mov	r1, r3
 800cdfe:	6878      	ldr	r0, [r7, #4]
 800ce00:	f7ff fd56 	bl	800c8b0 <arith_decode>
 800ce04:	4603      	mov	r3, r0
 800ce06:	2b00      	cmp	r3, #0
 800ce08:	d0d9      	beq.n	800cdbe <decode_mcu_AC_first+0x8e>
      }
    }
    /* Figure F.21: Decoding nonzero value v */
    /* Figure F.22: Decoding the sign of v */
    sign = arith_decode(cinfo, entropy->fixed_bin);
 800ce0a:	69fb      	ldr	r3, [r7, #28]
 800ce0c:	33b8      	adds	r3, #184	; 0xb8
 800ce0e:	4619      	mov	r1, r3
 800ce10:	6878      	ldr	r0, [r7, #4]
 800ce12:	f7ff fd4d 	bl	800c8b0 <arith_decode>
 800ce16:	60f8      	str	r0, [r7, #12]
    st += 2;
 800ce18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ce1a:	3302      	adds	r3, #2
 800ce1c:	62fb      	str	r3, [r7, #44]	; 0x2c
    /* Figure F.23: Decoding the magnitude category of v */
    if ((m = arith_decode(cinfo, st)) != 0) {
 800ce1e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ce20:	6878      	ldr	r0, [r7, #4]
 800ce22:	f7ff fd45 	bl	800c8b0 <arith_decode>
 800ce26:	6238      	str	r0, [r7, #32]
 800ce28:	6a3b      	ldr	r3, [r7, #32]
 800ce2a:	2b00      	cmp	r3, #0
 800ce2c:	d040      	beq.n	800ceb0 <decode_mcu_AC_first+0x180>
      if (arith_decode(cinfo, st)) {
 800ce2e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ce30:	6878      	ldr	r0, [r7, #4]
 800ce32:	f7ff fd3d 	bl	800c8b0 <arith_decode>
 800ce36:	4603      	mov	r3, r0
 800ce38:	2b00      	cmp	r3, #0
 800ce3a:	d039      	beq.n	800ceb0 <decode_mcu_AC_first+0x180>
	m <<= 1;
 800ce3c:	6a3b      	ldr	r3, [r7, #32]
 800ce3e:	005b      	lsls	r3, r3, #1
 800ce40:	623b      	str	r3, [r7, #32]
	st = entropy->ac_stats[tbl] +
 800ce42:	69fb      	ldr	r3, [r7, #28]
 800ce44:	693a      	ldr	r2, [r7, #16]
 800ce46:	321e      	adds	r2, #30
 800ce48:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	     (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 800ce4c:	6879      	ldr	r1, [r7, #4]
 800ce4e:	693b      	ldr	r3, [r7, #16]
 800ce50:	440b      	add	r3, r1
 800ce52:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800ce56:	781b      	ldrb	r3, [r3, #0]
 800ce58:	4619      	mov	r1, r3
 800ce5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce5c:	428b      	cmp	r3, r1
 800ce5e:	dc01      	bgt.n	800ce64 <decode_mcu_AC_first+0x134>
 800ce60:	23bd      	movs	r3, #189	; 0xbd
 800ce62:	e000      	b.n	800ce66 <decode_mcu_AC_first+0x136>
 800ce64:	23d9      	movs	r3, #217	; 0xd9
	st = entropy->ac_stats[tbl] +
 800ce66:	4413      	add	r3, r2
 800ce68:	62fb      	str	r3, [r7, #44]	; 0x2c
	while (arith_decode(cinfo, st)) {
 800ce6a:	e01a      	b.n	800cea2 <decode_mcu_AC_first+0x172>
	  if ((m <<= 1) == 0x8000) {
 800ce6c:	6a3b      	ldr	r3, [r7, #32]
 800ce6e:	005b      	lsls	r3, r3, #1
 800ce70:	623b      	str	r3, [r7, #32]
 800ce72:	6a3b      	ldr	r3, [r7, #32]
 800ce74:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800ce78:	d110      	bne.n	800ce9c <decode_mcu_AC_first+0x16c>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800ce7a:	687b      	ldr	r3, [r7, #4]
 800ce7c:	681b      	ldr	r3, [r3, #0]
 800ce7e:	2275      	movs	r2, #117	; 0x75
 800ce80:	615a      	str	r2, [r3, #20]
 800ce82:	687b      	ldr	r3, [r7, #4]
 800ce84:	681b      	ldr	r3, [r3, #0]
 800ce86:	685b      	ldr	r3, [r3, #4]
 800ce88:	f04f 31ff 	mov.w	r1, #4294967295
 800ce8c:	6878      	ldr	r0, [r7, #4]
 800ce8e:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 800ce90:	69fb      	ldr	r3, [r7, #28]
 800ce92:	f04f 32ff 	mov.w	r2, #4294967295
 800ce96:	611a      	str	r2, [r3, #16]
	    return TRUE;
 800ce98:	2301      	movs	r3, #1
 800ce9a:	e045      	b.n	800cf28 <decode_mcu_AC_first+0x1f8>
	  }
	  st += 1;
 800ce9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ce9e:	3301      	adds	r3, #1
 800cea0:	62fb      	str	r3, [r7, #44]	; 0x2c
	while (arith_decode(cinfo, st)) {
 800cea2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cea4:	6878      	ldr	r0, [r7, #4]
 800cea6:	f7ff fd03 	bl	800c8b0 <arith_decode>
 800ceaa:	4603      	mov	r3, r0
 800ceac:	2b00      	cmp	r3, #0
 800ceae:	d1dd      	bne.n	800ce6c <decode_mcu_AC_first+0x13c>
	}
      }
    }
    v = m;
 800ceb0:	6a3b      	ldr	r3, [r7, #32]
 800ceb2:	627b      	str	r3, [r7, #36]	; 0x24
    /* Figure F.24: Decoding the magnitude bit pattern of v */
    st += 14;
 800ceb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ceb6:	330e      	adds	r3, #14
 800ceb8:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (m >>= 1)
 800ceba:	e00a      	b.n	800ced2 <decode_mcu_AC_first+0x1a2>
      if (arith_decode(cinfo, st)) v |= m;
 800cebc:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800cebe:	6878      	ldr	r0, [r7, #4]
 800cec0:	f7ff fcf6 	bl	800c8b0 <arith_decode>
 800cec4:	4603      	mov	r3, r0
 800cec6:	2b00      	cmp	r3, #0
 800cec8:	d003      	beq.n	800ced2 <decode_mcu_AC_first+0x1a2>
 800ceca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cecc:	6a3b      	ldr	r3, [r7, #32]
 800cece:	4313      	orrs	r3, r2
 800ced0:	627b      	str	r3, [r7, #36]	; 0x24
    while (m >>= 1)
 800ced2:	6a3b      	ldr	r3, [r7, #32]
 800ced4:	105b      	asrs	r3, r3, #1
 800ced6:	623b      	str	r3, [r7, #32]
 800ced8:	6a3b      	ldr	r3, [r7, #32]
 800ceda:	2b00      	cmp	r3, #0
 800cedc:	d1ee      	bne.n	800cebc <decode_mcu_AC_first+0x18c>
    v += 1; if (sign) v = -v;
 800cede:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cee0:	3301      	adds	r3, #1
 800cee2:	627b      	str	r3, [r7, #36]	; 0x24
 800cee4:	68fb      	ldr	r3, [r7, #12]
 800cee6:	2b00      	cmp	r3, #0
 800cee8:	d002      	beq.n	800cef0 <decode_mcu_AC_first+0x1c0>
 800ceea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ceec:	425b      	negs	r3, r3
 800ceee:	627b      	str	r3, [r7, #36]	; 0x24
    /* Scale and output coefficient in natural (dezigzagged) order */
    (*block)[natural_order[k]] = (JCOEF) (v << cinfo->Al);
 800cef0:	687b      	ldr	r3, [r7, #4]
 800cef2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800cef6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cef8:	fa02 f103 	lsl.w	r1, r2, r3
 800cefc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cefe:	009b      	lsls	r3, r3, #2
 800cf00:	69ba      	ldr	r2, [r7, #24]
 800cf02:	4413      	add	r3, r2
 800cf04:	681a      	ldr	r2, [r3, #0]
 800cf06:	b209      	sxth	r1, r1
 800cf08:	697b      	ldr	r3, [r7, #20]
 800cf0a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 800cf0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf10:	3301      	adds	r3, #1
 800cf12:	62bb      	str	r3, [r7, #40]	; 0x28
 800cf14:	687b      	ldr	r3, [r7, #4]
 800cf16:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800cf1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cf1c:	429a      	cmp	r2, r3
 800cf1e:	f77f af39 	ble.w	800cd94 <decode_mcu_AC_first+0x64>
 800cf22:	e000      	b.n	800cf26 <decode_mcu_AC_first+0x1f6>
    if (arith_decode(cinfo, st)) break;		/* EOB flag */
 800cf24:	bf00      	nop
  }

  return TRUE;
 800cf26:	2301      	movs	r3, #1
}
 800cf28:	4618      	mov	r0, r3
 800cf2a:	3730      	adds	r7, #48	; 0x30
 800cf2c:	46bd      	mov	sp, r7
 800cf2e:	bd80      	pop	{r7, pc}

0800cf30 <decode_mcu_DC_refine>:
 * MCU decoding for DC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 800cf30:	b580      	push	{r7, lr}
 800cf32:	b086      	sub	sp, #24
 800cf34:	af00      	add	r7, sp, #0
 800cf36:	6078      	str	r0, [r7, #4]
 800cf38:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800cf3a:	687b      	ldr	r3, [r7, #4]
 800cf3c:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800cf40:	613b      	str	r3, [r7, #16]
  unsigned char *st;
  int p1, blkn;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 800cf42:	687b      	ldr	r3, [r7, #4]
 800cf44:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800cf48:	2b00      	cmp	r3, #0
 800cf4a:	d00b      	beq.n	800cf64 <decode_mcu_DC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 800cf4c:	693b      	ldr	r3, [r7, #16]
 800cf4e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cf50:	2b00      	cmp	r3, #0
 800cf52:	d102      	bne.n	800cf5a <decode_mcu_DC_refine+0x2a>
      process_restart(cinfo);
 800cf54:	6878      	ldr	r0, [r7, #4]
 800cf56:	f7ff fd51 	bl	800c9fc <process_restart>
    entropy->restarts_to_go--;
 800cf5a:	693b      	ldr	r3, [r7, #16]
 800cf5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cf5e:	1e5a      	subs	r2, r3, #1
 800cf60:	693b      	ldr	r3, [r7, #16]
 800cf62:	635a      	str	r2, [r3, #52]	; 0x34
  }

  st = entropy->fixed_bin;	/* use fixed probability estimation */
 800cf64:	693b      	ldr	r3, [r7, #16]
 800cf66:	33b8      	adds	r3, #184	; 0xb8
 800cf68:	60fb      	str	r3, [r7, #12]
  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 800cf6a:	687b      	ldr	r3, [r7, #4]
 800cf6c:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800cf70:	2201      	movs	r2, #1
 800cf72:	fa02 f303 	lsl.w	r3, r2, r3
 800cf76:	60bb      	str	r3, [r7, #8]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800cf78:	2300      	movs	r3, #0
 800cf7a:	617b      	str	r3, [r7, #20]
 800cf7c:	e01a      	b.n	800cfb4 <decode_mcu_DC_refine+0x84>
    /* Encoded data is simply the next bit of the two's-complement DC value */
    if (arith_decode(cinfo, st))
 800cf7e:	68f9      	ldr	r1, [r7, #12]
 800cf80:	6878      	ldr	r0, [r7, #4]
 800cf82:	f7ff fc95 	bl	800c8b0 <arith_decode>
 800cf86:	4603      	mov	r3, r0
 800cf88:	2b00      	cmp	r3, #0
 800cf8a:	d010      	beq.n	800cfae <decode_mcu_DC_refine+0x7e>
      MCU_data[blkn][0][0] |= p1;
 800cf8c:	697b      	ldr	r3, [r7, #20]
 800cf8e:	009b      	lsls	r3, r3, #2
 800cf90:	683a      	ldr	r2, [r7, #0]
 800cf92:	4413      	add	r3, r2
 800cf94:	681b      	ldr	r3, [r3, #0]
 800cf96:	f9b3 1000 	ldrsh.w	r1, [r3]
 800cf9a:	68bb      	ldr	r3, [r7, #8]
 800cf9c:	b21a      	sxth	r2, r3
 800cf9e:	697b      	ldr	r3, [r7, #20]
 800cfa0:	009b      	lsls	r3, r3, #2
 800cfa2:	6838      	ldr	r0, [r7, #0]
 800cfa4:	4403      	add	r3, r0
 800cfa6:	681b      	ldr	r3, [r3, #0]
 800cfa8:	430a      	orrs	r2, r1
 800cfaa:	b212      	sxth	r2, r2
 800cfac:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800cfae:	697b      	ldr	r3, [r7, #20]
 800cfb0:	3301      	adds	r3, #1
 800cfb2:	617b      	str	r3, [r7, #20]
 800cfb4:	687b      	ldr	r3, [r7, #4]
 800cfb6:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 800cfba:	697a      	ldr	r2, [r7, #20]
 800cfbc:	429a      	cmp	r2, r3
 800cfbe:	dbde      	blt.n	800cf7e <decode_mcu_DC_refine+0x4e>
  }

  return TRUE;
 800cfc0:	2301      	movs	r3, #1
}
 800cfc2:	4618      	mov	r0, r3
 800cfc4:	3718      	adds	r7, #24
 800cfc6:	46bd      	mov	sp, r7
 800cfc8:	bd80      	pop	{r7, pc}

0800cfca <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 800cfca:	b580      	push	{r7, lr}
 800cfcc:	b08c      	sub	sp, #48	; 0x30
 800cfce:	af00      	add	r7, sp, #0
 800cfd0:	6078      	str	r0, [r7, #4]
 800cfd2:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800cfd4:	687b      	ldr	r3, [r7, #4]
 800cfd6:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800cfda:	623b      	str	r3, [r7, #32]
  int tbl, k, kex;
  int p1, m1;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 800cfdc:	687b      	ldr	r3, [r7, #4]
 800cfde:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800cfe2:	2b00      	cmp	r3, #0
 800cfe4:	d00b      	beq.n	800cffe <decode_mcu_AC_refine+0x34>
    if (entropy->restarts_to_go == 0)
 800cfe6:	6a3b      	ldr	r3, [r7, #32]
 800cfe8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cfea:	2b00      	cmp	r3, #0
 800cfec:	d102      	bne.n	800cff4 <decode_mcu_AC_refine+0x2a>
      process_restart(cinfo);
 800cfee:	6878      	ldr	r0, [r7, #4]
 800cff0:	f7ff fd04 	bl	800c9fc <process_restart>
    entropy->restarts_to_go--;
 800cff4:	6a3b      	ldr	r3, [r7, #32]
 800cff6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cff8:	1e5a      	subs	r2, r3, #1
 800cffa:	6a3b      	ldr	r3, [r7, #32]
 800cffc:	635a      	str	r2, [r3, #52]	; 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 800cffe:	6a3b      	ldr	r3, [r7, #32]
 800d000:	691b      	ldr	r3, [r3, #16]
 800d002:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d006:	d101      	bne.n	800d00c <decode_mcu_AC_refine+0x42>
 800d008:	2301      	movs	r3, #1
 800d00a:	e0c8      	b.n	800d19e <decode_mcu_AC_refine+0x1d4>

  natural_order = cinfo->natural_order;
 800d00c:	687b      	ldr	r3, [r7, #4]
 800d00e:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800d012:	61fb      	str	r3, [r7, #28]

  /* There is always only one block per MCU */
  block = MCU_data[0];
 800d014:	683b      	ldr	r3, [r7, #0]
 800d016:	681b      	ldr	r3, [r3, #0]
 800d018:	61bb      	str	r3, [r7, #24]
  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;
 800d01a:	687b      	ldr	r3, [r7, #4]
 800d01c:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 800d020:	699b      	ldr	r3, [r3, #24]
 800d022:	617b      	str	r3, [r7, #20]

  p1 = 1 << cinfo->Al;		/* 1 in the bit position being coded */
 800d024:	687b      	ldr	r3, [r7, #4]
 800d026:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800d02a:	2201      	movs	r2, #1
 800d02c:	fa02 f303 	lsl.w	r3, r2, r3
 800d030:	613b      	str	r3, [r7, #16]
  m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 800d032:	687b      	ldr	r3, [r7, #4]
 800d034:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800d038:	f04f 32ff 	mov.w	r2, #4294967295
 800d03c:	fa02 f303 	lsl.w	r3, r2, r3
 800d040:	60fb      	str	r3, [r7, #12]

  /* Establish EOBx (previous stage end-of-block) index */
  for (kex = cinfo->Se; kex > 0; kex--)
 800d042:	687b      	ldr	r3, [r7, #4]
 800d044:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800d048:	627b      	str	r3, [r7, #36]	; 0x24
 800d04a:	e00c      	b.n	800d066 <decode_mcu_AC_refine+0x9c>
    if ((*block)[natural_order[kex]]) break;
 800d04c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d04e:	009b      	lsls	r3, r3, #2
 800d050:	69fa      	ldr	r2, [r7, #28]
 800d052:	4413      	add	r3, r2
 800d054:	681a      	ldr	r2, [r3, #0]
 800d056:	69bb      	ldr	r3, [r7, #24]
 800d058:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 800d05c:	2b00      	cmp	r3, #0
 800d05e:	d106      	bne.n	800d06e <decode_mcu_AC_refine+0xa4>
  for (kex = cinfo->Se; kex > 0; kex--)
 800d060:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d062:	3b01      	subs	r3, #1
 800d064:	627b      	str	r3, [r7, #36]	; 0x24
 800d066:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d068:	2b00      	cmp	r3, #0
 800d06a:	dcef      	bgt.n	800d04c <decode_mcu_AC_refine+0x82>
 800d06c:	e000      	b.n	800d070 <decode_mcu_AC_refine+0xa6>
    if ((*block)[natural_order[kex]]) break;
 800d06e:	bf00      	nop

  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 800d070:	687b      	ldr	r3, [r7, #4]
 800d072:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d076:	62bb      	str	r3, [r7, #40]	; 0x28
 800d078:	e087      	b.n	800d18a <decode_mcu_AC_refine+0x1c0>
    st = entropy->ac_stats[tbl] + 3 * (k - 1);
 800d07a:	6a3b      	ldr	r3, [r7, #32]
 800d07c:	697a      	ldr	r2, [r7, #20]
 800d07e:	321e      	adds	r2, #30
 800d080:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800d084:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d086:	1e5a      	subs	r2, r3, #1
 800d088:	4613      	mov	r3, r2
 800d08a:	005b      	lsls	r3, r3, #1
 800d08c:	4413      	add	r3, r2
 800d08e:	440b      	add	r3, r1
 800d090:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (k > kex)
 800d092:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d094:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d096:	429a      	cmp	r2, r3
 800d098:	dd06      	ble.n	800d0a8 <decode_mcu_AC_refine+0xde>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 800d09a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800d09c:	6878      	ldr	r0, [r7, #4]
 800d09e:	f7ff fc07 	bl	800c8b0 <arith_decode>
 800d0a2:	4603      	mov	r3, r0
 800d0a4:	2b00      	cmp	r3, #0
 800d0a6:	d178      	bne.n	800d19a <decode_mcu_AC_refine+0x1d0>
    for (;;) {
      thiscoef = *block + natural_order[k];
 800d0a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d0aa:	009b      	lsls	r3, r3, #2
 800d0ac:	69fa      	ldr	r2, [r7, #28]
 800d0ae:	4413      	add	r3, r2
 800d0b0:	681b      	ldr	r3, [r3, #0]
 800d0b2:	005b      	lsls	r3, r3, #1
 800d0b4:	69ba      	ldr	r2, [r7, #24]
 800d0b6:	4413      	add	r3, r2
 800d0b8:	60bb      	str	r3, [r7, #8]
      if (*thiscoef) {				/* previously nonzero coef */
 800d0ba:	68bb      	ldr	r3, [r7, #8]
 800d0bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d0c0:	2b00      	cmp	r3, #0
 800d0c2:	d025      	beq.n	800d110 <decode_mcu_AC_refine+0x146>
	if (arith_decode(cinfo, st + 2)) {
 800d0c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d0c6:	3302      	adds	r3, #2
 800d0c8:	4619      	mov	r1, r3
 800d0ca:	6878      	ldr	r0, [r7, #4]
 800d0cc:	f7ff fbf0 	bl	800c8b0 <arith_decode>
 800d0d0:	4603      	mov	r3, r0
 800d0d2:	2b00      	cmp	r3, #0
 800d0d4:	d055      	beq.n	800d182 <decode_mcu_AC_refine+0x1b8>
	  if (*thiscoef < 0)
 800d0d6:	68bb      	ldr	r3, [r7, #8]
 800d0d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d0dc:	2b00      	cmp	r3, #0
 800d0de:	da0b      	bge.n	800d0f8 <decode_mcu_AC_refine+0x12e>
	    *thiscoef += m1;
 800d0e0:	68bb      	ldr	r3, [r7, #8]
 800d0e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d0e6:	b29a      	uxth	r2, r3
 800d0e8:	68fb      	ldr	r3, [r7, #12]
 800d0ea:	b29b      	uxth	r3, r3
 800d0ec:	4413      	add	r3, r2
 800d0ee:	b29b      	uxth	r3, r3
 800d0f0:	b21a      	sxth	r2, r3
 800d0f2:	68bb      	ldr	r3, [r7, #8]
 800d0f4:	801a      	strh	r2, [r3, #0]
	  else
	    *thiscoef += p1;
	}
	break;
 800d0f6:	e044      	b.n	800d182 <decode_mcu_AC_refine+0x1b8>
	    *thiscoef += p1;
 800d0f8:	68bb      	ldr	r3, [r7, #8]
 800d0fa:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d0fe:	b29a      	uxth	r2, r3
 800d100:	693b      	ldr	r3, [r7, #16]
 800d102:	b29b      	uxth	r3, r3
 800d104:	4413      	add	r3, r2
 800d106:	b29b      	uxth	r3, r3
 800d108:	b21a      	sxth	r2, r3
 800d10a:	68bb      	ldr	r3, [r7, #8]
 800d10c:	801a      	strh	r2, [r3, #0]
	break;
 800d10e:	e038      	b.n	800d182 <decode_mcu_AC_refine+0x1b8>
      }
      if (arith_decode(cinfo, st + 1)) {	/* newly nonzero coef */
 800d110:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d112:	3301      	adds	r3, #1
 800d114:	4619      	mov	r1, r3
 800d116:	6878      	ldr	r0, [r7, #4]
 800d118:	f7ff fbca 	bl	800c8b0 <arith_decode>
 800d11c:	4603      	mov	r3, r0
 800d11e:	2b00      	cmp	r3, #0
 800d120:	d012      	beq.n	800d148 <decode_mcu_AC_refine+0x17e>
	if (arith_decode(cinfo, entropy->fixed_bin))
 800d122:	6a3b      	ldr	r3, [r7, #32]
 800d124:	33b8      	adds	r3, #184	; 0xb8
 800d126:	4619      	mov	r1, r3
 800d128:	6878      	ldr	r0, [r7, #4]
 800d12a:	f7ff fbc1 	bl	800c8b0 <arith_decode>
 800d12e:	4603      	mov	r3, r0
 800d130:	2b00      	cmp	r3, #0
 800d132:	d004      	beq.n	800d13e <decode_mcu_AC_refine+0x174>
	  *thiscoef = m1;
 800d134:	68fb      	ldr	r3, [r7, #12]
 800d136:	b21a      	sxth	r2, r3
 800d138:	68bb      	ldr	r3, [r7, #8]
 800d13a:	801a      	strh	r2, [r3, #0]
	else
	  *thiscoef = p1;
	break;
 800d13c:	e022      	b.n	800d184 <decode_mcu_AC_refine+0x1ba>
	  *thiscoef = p1;
 800d13e:	693b      	ldr	r3, [r7, #16]
 800d140:	b21a      	sxth	r2, r3
 800d142:	68bb      	ldr	r3, [r7, #8]
 800d144:	801a      	strh	r2, [r3, #0]
	break;
 800d146:	e01d      	b.n	800d184 <decode_mcu_AC_refine+0x1ba>
      }
      st += 3; k++;
 800d148:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d14a:	3303      	adds	r3, #3
 800d14c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800d14e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d150:	3301      	adds	r3, #1
 800d152:	62bb      	str	r3, [r7, #40]	; 0x28
      if (k > cinfo->Se) {
 800d154:	687b      	ldr	r3, [r7, #4]
 800d156:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800d15a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d15c:	429a      	cmp	r2, r3
 800d15e:	dda3      	ble.n	800d0a8 <decode_mcu_AC_refine+0xde>
	WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800d160:	687b      	ldr	r3, [r7, #4]
 800d162:	681b      	ldr	r3, [r3, #0]
 800d164:	2275      	movs	r2, #117	; 0x75
 800d166:	615a      	str	r2, [r3, #20]
 800d168:	687b      	ldr	r3, [r7, #4]
 800d16a:	681b      	ldr	r3, [r3, #0]
 800d16c:	685b      	ldr	r3, [r3, #4]
 800d16e:	f04f 31ff 	mov.w	r1, #4294967295
 800d172:	6878      	ldr	r0, [r7, #4]
 800d174:	4798      	blx	r3
	entropy->ct = -1;			/* spectral overflow */
 800d176:	6a3b      	ldr	r3, [r7, #32]
 800d178:	f04f 32ff 	mov.w	r2, #4294967295
 800d17c:	611a      	str	r2, [r3, #16]
	return TRUE;
 800d17e:	2301      	movs	r3, #1
 800d180:	e00d      	b.n	800d19e <decode_mcu_AC_refine+0x1d4>
	break;
 800d182:	bf00      	nop
  for (k = cinfo->Ss; k <= cinfo->Se; k++) {
 800d184:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d186:	3301      	adds	r3, #1
 800d188:	62bb      	str	r3, [r7, #40]	; 0x28
 800d18a:	687b      	ldr	r3, [r7, #4]
 800d18c:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800d190:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d192:	429a      	cmp	r2, r3
 800d194:	f77f af71 	ble.w	800d07a <decode_mcu_AC_refine+0xb0>
 800d198:	e000      	b.n	800d19c <decode_mcu_AC_refine+0x1d2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 800d19a:	bf00      	nop
      }
    }
  }

  return TRUE;
 800d19c:	2301      	movs	r3, #1
}
 800d19e:	4618      	mov	r0, r3
 800d1a0:	3730      	adds	r7, #48	; 0x30
 800d1a2:	46bd      	mov	sp, r7
 800d1a4:	bd80      	pop	{r7, pc}

0800d1a6 <decode_mcu>:
 * Decode one MCU's worth of arithmetic-compressed coefficients.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 800d1a6:	b580      	push	{r7, lr}
 800d1a8:	b08e      	sub	sp, #56	; 0x38
 800d1aa:	af00      	add	r7, sp, #0
 800d1ac:	6078      	str	r0, [r7, #4]
 800d1ae:	6039      	str	r1, [r7, #0]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800d1b0:	687b      	ldr	r3, [r7, #4]
 800d1b2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800d1b6:	623b      	str	r3, [r7, #32]
  int blkn, ci, tbl, sign, k;
  int v, m;
  const int * natural_order;

  /* Process restart marker if needed */
  if (cinfo->restart_interval) {
 800d1b8:	687b      	ldr	r3, [r7, #4]
 800d1ba:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800d1be:	2b00      	cmp	r3, #0
 800d1c0:	d00b      	beq.n	800d1da <decode_mcu+0x34>
    if (entropy->restarts_to_go == 0)
 800d1c2:	6a3b      	ldr	r3, [r7, #32]
 800d1c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d1c6:	2b00      	cmp	r3, #0
 800d1c8:	d102      	bne.n	800d1d0 <decode_mcu+0x2a>
      process_restart(cinfo);
 800d1ca:	6878      	ldr	r0, [r7, #4]
 800d1cc:	f7ff fc16 	bl	800c9fc <process_restart>
    entropy->restarts_to_go--;
 800d1d0:	6a3b      	ldr	r3, [r7, #32]
 800d1d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d1d4:	1e5a      	subs	r2, r3, #1
 800d1d6:	6a3b      	ldr	r3, [r7, #32]
 800d1d8:	635a      	str	r2, [r3, #52]	; 0x34
  }

  if (entropy->ct == -1) return TRUE;	/* if error do nothing */
 800d1da:	6a3b      	ldr	r3, [r7, #32]
 800d1dc:	691b      	ldr	r3, [r3, #16]
 800d1de:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d1e2:	d101      	bne.n	800d1e8 <decode_mcu+0x42>
 800d1e4:	2301      	movs	r3, #1
 800d1e6:	e1ba      	b.n	800d55e <decode_mcu+0x3b8>

  natural_order = cinfo->natural_order;
 800d1e8:	687b      	ldr	r3, [r7, #4]
 800d1ea:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800d1ee:	61fb      	str	r3, [r7, #28]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800d1f0:	2300      	movs	r3, #0
 800d1f2:	633b      	str	r3, [r7, #48]	; 0x30
 800d1f4:	e1ab      	b.n	800d54e <decode_mcu+0x3a8>
    block = MCU_data[blkn];
 800d1f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d1f8:	009b      	lsls	r3, r3, #2
 800d1fa:	683a      	ldr	r2, [r7, #0]
 800d1fc:	4413      	add	r3, r2
 800d1fe:	681b      	ldr	r3, [r3, #0]
 800d200:	61bb      	str	r3, [r7, #24]
    ci = cinfo->MCU_membership[blkn];
 800d202:	687b      	ldr	r3, [r7, #4]
 800d204:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d206:	325c      	adds	r2, #92	; 0x5c
 800d208:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d20c:	617b      	str	r3, [r7, #20]
    compptr = cinfo->cur_comp_info[ci];
 800d20e:	687a      	ldr	r2, [r7, #4]
 800d210:	697b      	ldr	r3, [r7, #20]
 800d212:	3354      	adds	r3, #84	; 0x54
 800d214:	009b      	lsls	r3, r3, #2
 800d216:	4413      	add	r3, r2
 800d218:	685b      	ldr	r3, [r3, #4]
 800d21a:	613b      	str	r3, [r7, #16]

    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */

    tbl = compptr->dc_tbl_no;
 800d21c:	693b      	ldr	r3, [r7, #16]
 800d21e:	695b      	ldr	r3, [r3, #20]
 800d220:	60fb      	str	r3, [r7, #12]

    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */
    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];
 800d222:	6a3b      	ldr	r3, [r7, #32]
 800d224:	68fa      	ldr	r2, [r7, #12]
 800d226:	320e      	adds	r2, #14
 800d228:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d22c:	6a39      	ldr	r1, [r7, #32]
 800d22e:	697b      	ldr	r3, [r7, #20]
 800d230:	3308      	adds	r3, #8
 800d232:	009b      	lsls	r3, r3, #2
 800d234:	440b      	add	r3, r1
 800d236:	685b      	ldr	r3, [r3, #4]
 800d238:	4413      	add	r3, r2
 800d23a:	637b      	str	r3, [r7, #52]	; 0x34

    /* Figure F.19: Decode_DC_DIFF */
    if (arith_decode(cinfo, st) == 0)
 800d23c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d23e:	6878      	ldr	r0, [r7, #4]
 800d240:	f7ff fb36 	bl	800c8b0 <arith_decode>
 800d244:	4603      	mov	r3, r0
 800d246:	2b00      	cmp	r3, #0
 800d248:	d107      	bne.n	800d25a <decode_mcu+0xb4>
      entropy->dc_context[ci] = 0;
 800d24a:	6a3a      	ldr	r2, [r7, #32]
 800d24c:	697b      	ldr	r3, [r7, #20]
 800d24e:	3308      	adds	r3, #8
 800d250:	009b      	lsls	r3, r3, #2
 800d252:	4413      	add	r3, r2
 800d254:	2200      	movs	r2, #0
 800d256:	605a      	str	r2, [r3, #4]
 800d258:	e0a0      	b.n	800d39c <decode_mcu+0x1f6>
    else {
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, st + 1);
 800d25a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d25c:	3301      	adds	r3, #1
 800d25e:	4619      	mov	r1, r3
 800d260:	6878      	ldr	r0, [r7, #4]
 800d262:	f7ff fb25 	bl	800c8b0 <arith_decode>
 800d266:	60b8      	str	r0, [r7, #8]
      st += 2; st += sign;
 800d268:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d26a:	3302      	adds	r3, #2
 800d26c:	637b      	str	r3, [r7, #52]	; 0x34
 800d26e:	68bb      	ldr	r3, [r7, #8]
 800d270:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d272:	4413      	add	r3, r2
 800d274:	637b      	str	r3, [r7, #52]	; 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 800d276:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d278:	6878      	ldr	r0, [r7, #4]
 800d27a:	f7ff fb19 	bl	800c8b0 <arith_decode>
 800d27e:	6278      	str	r0, [r7, #36]	; 0x24
 800d280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d282:	2b00      	cmp	r3, #0
 800d284:	d029      	beq.n	800d2da <decode_mcu+0x134>
	st = entropy->dc_stats[tbl] + 20;	/* Table F.4: X1 = 20 */
 800d286:	6a3b      	ldr	r3, [r7, #32]
 800d288:	68fa      	ldr	r2, [r7, #12]
 800d28a:	320e      	adds	r2, #14
 800d28c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d290:	3314      	adds	r3, #20
 800d292:	637b      	str	r3, [r7, #52]	; 0x34
	while (arith_decode(cinfo, st)) {
 800d294:	e01a      	b.n	800d2cc <decode_mcu+0x126>
	  if ((m <<= 1) == 0x8000) {
 800d296:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d298:	005b      	lsls	r3, r3, #1
 800d29a:	627b      	str	r3, [r7, #36]	; 0x24
 800d29c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d29e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800d2a2:	d110      	bne.n	800d2c6 <decode_mcu+0x120>
	    WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800d2a4:	687b      	ldr	r3, [r7, #4]
 800d2a6:	681b      	ldr	r3, [r3, #0]
 800d2a8:	2275      	movs	r2, #117	; 0x75
 800d2aa:	615a      	str	r2, [r3, #20]
 800d2ac:	687b      	ldr	r3, [r7, #4]
 800d2ae:	681b      	ldr	r3, [r3, #0]
 800d2b0:	685b      	ldr	r3, [r3, #4]
 800d2b2:	f04f 31ff 	mov.w	r1, #4294967295
 800d2b6:	6878      	ldr	r0, [r7, #4]
 800d2b8:	4798      	blx	r3
	    entropy->ct = -1;			/* magnitude overflow */
 800d2ba:	6a3b      	ldr	r3, [r7, #32]
 800d2bc:	f04f 32ff 	mov.w	r2, #4294967295
 800d2c0:	611a      	str	r2, [r3, #16]
	    return TRUE;
 800d2c2:	2301      	movs	r3, #1
 800d2c4:	e14b      	b.n	800d55e <decode_mcu+0x3b8>
	  }
	  st += 1;
 800d2c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d2c8:	3301      	adds	r3, #1
 800d2ca:	637b      	str	r3, [r7, #52]	; 0x34
	while (arith_decode(cinfo, st)) {
 800d2cc:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d2ce:	6878      	ldr	r0, [r7, #4]
 800d2d0:	f7ff faee 	bl	800c8b0 <arith_decode>
 800d2d4:	4603      	mov	r3, r0
 800d2d6:	2b00      	cmp	r3, #0
 800d2d8:	d1dd      	bne.n	800d296 <decode_mcu+0xf0>
	}
      }
      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */
      if (m < (int) ((1L << cinfo->arith_dc_L[tbl]) >> 1))
 800d2da:	687a      	ldr	r2, [r7, #4]
 800d2dc:	68fb      	ldr	r3, [r7, #12]
 800d2de:	4413      	add	r3, r2
 800d2e0:	33e8      	adds	r3, #232	; 0xe8
 800d2e2:	781b      	ldrb	r3, [r3, #0]
 800d2e4:	461a      	mov	r2, r3
 800d2e6:	2301      	movs	r3, #1
 800d2e8:	4093      	lsls	r3, r2
 800d2ea:	105b      	asrs	r3, r3, #1
 800d2ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d2ee:	429a      	cmp	r2, r3
 800d2f0:	da07      	bge.n	800d302 <decode_mcu+0x15c>
	entropy->dc_context[ci] = 0;		   /* zero diff category */
 800d2f2:	6a3a      	ldr	r2, [r7, #32]
 800d2f4:	697b      	ldr	r3, [r7, #20]
 800d2f6:	3308      	adds	r3, #8
 800d2f8:	009b      	lsls	r3, r3, #2
 800d2fa:	4413      	add	r3, r2
 800d2fc:	2200      	movs	r2, #0
 800d2fe:	605a      	str	r2, [r3, #4]
 800d300:	e01e      	b.n	800d340 <decode_mcu+0x19a>
      else if (m > (int) ((1L << cinfo->arith_dc_U[tbl]) >> 1))
 800d302:	687a      	ldr	r2, [r7, #4]
 800d304:	68fb      	ldr	r3, [r7, #12]
 800d306:	4413      	add	r3, r2
 800d308:	33f8      	adds	r3, #248	; 0xf8
 800d30a:	781b      	ldrb	r3, [r3, #0]
 800d30c:	461a      	mov	r2, r3
 800d30e:	2301      	movs	r3, #1
 800d310:	4093      	lsls	r3, r2
 800d312:	105b      	asrs	r3, r3, #1
 800d314:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d316:	429a      	cmp	r2, r3
 800d318:	dd09      	ble.n	800d32e <decode_mcu+0x188>
	entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */
 800d31a:	68bb      	ldr	r3, [r7, #8]
 800d31c:	3303      	adds	r3, #3
 800d31e:	009a      	lsls	r2, r3, #2
 800d320:	6a39      	ldr	r1, [r7, #32]
 800d322:	697b      	ldr	r3, [r7, #20]
 800d324:	3308      	adds	r3, #8
 800d326:	009b      	lsls	r3, r3, #2
 800d328:	440b      	add	r3, r1
 800d32a:	605a      	str	r2, [r3, #4]
 800d32c:	e008      	b.n	800d340 <decode_mcu+0x19a>
      else
	entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */
 800d32e:	68bb      	ldr	r3, [r7, #8]
 800d330:	3301      	adds	r3, #1
 800d332:	009a      	lsls	r2, r3, #2
 800d334:	6a39      	ldr	r1, [r7, #32]
 800d336:	697b      	ldr	r3, [r7, #20]
 800d338:	3308      	adds	r3, #8
 800d33a:	009b      	lsls	r3, r3, #2
 800d33c:	440b      	add	r3, r1
 800d33e:	605a      	str	r2, [r3, #4]
      v = m;
 800d340:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d342:	62bb      	str	r3, [r7, #40]	; 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 800d344:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d346:	330e      	adds	r3, #14
 800d348:	637b      	str	r3, [r7, #52]	; 0x34
      while (m >>= 1)
 800d34a:	e00a      	b.n	800d362 <decode_mcu+0x1bc>
	if (arith_decode(cinfo, st)) v |= m;
 800d34c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d34e:	6878      	ldr	r0, [r7, #4]
 800d350:	f7ff faae 	bl	800c8b0 <arith_decode>
 800d354:	4603      	mov	r3, r0
 800d356:	2b00      	cmp	r3, #0
 800d358:	d003      	beq.n	800d362 <decode_mcu+0x1bc>
 800d35a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d35c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d35e:	4313      	orrs	r3, r2
 800d360:	62bb      	str	r3, [r7, #40]	; 0x28
      while (m >>= 1)
 800d362:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d364:	105b      	asrs	r3, r3, #1
 800d366:	627b      	str	r3, [r7, #36]	; 0x24
 800d368:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d36a:	2b00      	cmp	r3, #0
 800d36c:	d1ee      	bne.n	800d34c <decode_mcu+0x1a6>
      v += 1; if (sign) v = -v;
 800d36e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d370:	3301      	adds	r3, #1
 800d372:	62bb      	str	r3, [r7, #40]	; 0x28
 800d374:	68bb      	ldr	r3, [r7, #8]
 800d376:	2b00      	cmp	r3, #0
 800d378:	d002      	beq.n	800d380 <decode_mcu+0x1da>
 800d37a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d37c:	425b      	negs	r3, r3
 800d37e:	62bb      	str	r3, [r7, #40]	; 0x28
      entropy->last_dc_val[ci] += v;
 800d380:	6a3a      	ldr	r2, [r7, #32]
 800d382:	697b      	ldr	r3, [r7, #20]
 800d384:	3304      	adds	r3, #4
 800d386:	009b      	lsls	r3, r3, #2
 800d388:	4413      	add	r3, r2
 800d38a:	685a      	ldr	r2, [r3, #4]
 800d38c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d38e:	441a      	add	r2, r3
 800d390:	6a39      	ldr	r1, [r7, #32]
 800d392:	697b      	ldr	r3, [r7, #20]
 800d394:	3304      	adds	r3, #4
 800d396:	009b      	lsls	r3, r3, #2
 800d398:	440b      	add	r3, r1
 800d39a:	605a      	str	r2, [r3, #4]
    }

    (*block)[0] = (JCOEF) entropy->last_dc_val[ci];
 800d39c:	6a3a      	ldr	r2, [r7, #32]
 800d39e:	697b      	ldr	r3, [r7, #20]
 800d3a0:	3304      	adds	r3, #4
 800d3a2:	009b      	lsls	r3, r3, #2
 800d3a4:	4413      	add	r3, r2
 800d3a6:	685b      	ldr	r3, [r3, #4]
 800d3a8:	b21a      	sxth	r2, r3
 800d3aa:	69bb      	ldr	r3, [r7, #24]
 800d3ac:	801a      	strh	r2, [r3, #0]

    /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */

    if (cinfo->lim_Se == 0) continue;
 800d3ae:	687b      	ldr	r3, [r7, #4]
 800d3b0:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d3b4:	2b00      	cmp	r3, #0
 800d3b6:	f000 80c4 	beq.w	800d542 <decode_mcu+0x39c>
    tbl = compptr->ac_tbl_no;
 800d3ba:	693b      	ldr	r3, [r7, #16]
 800d3bc:	699b      	ldr	r3, [r3, #24]
 800d3be:	60fb      	str	r3, [r7, #12]
    k = 0;
 800d3c0:	2300      	movs	r3, #0
 800d3c2:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Figure F.20: Decode_AC_coefficients */
    do {
      st = entropy->ac_stats[tbl] + 3 * k;
 800d3c4:	6a3b      	ldr	r3, [r7, #32]
 800d3c6:	68fa      	ldr	r2, [r7, #12]
 800d3c8:	321e      	adds	r2, #30
 800d3ca:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800d3ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d3d0:	4613      	mov	r3, r2
 800d3d2:	005b      	lsls	r3, r3, #1
 800d3d4:	4413      	add	r3, r2
 800d3d6:	440b      	add	r3, r1
 800d3d8:	637b      	str	r3, [r7, #52]	; 0x34
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 800d3da:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d3dc:	6878      	ldr	r0, [r7, #4]
 800d3de:	f7ff fa67 	bl	800c8b0 <arith_decode>
 800d3e2:	4603      	mov	r3, r0
 800d3e4:	2b00      	cmp	r3, #0
 800d3e6:	f040 80ae 	bne.w	800d546 <decode_mcu+0x3a0>
      for (;;) {
	k++;
 800d3ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d3ec:	3301      	adds	r3, #1
 800d3ee:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (arith_decode(cinfo, st + 1)) break;
 800d3f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3f2:	3301      	adds	r3, #1
 800d3f4:	4619      	mov	r1, r3
 800d3f6:	6878      	ldr	r0, [r7, #4]
 800d3f8:	f7ff fa5a 	bl	800c8b0 <arith_decode>
 800d3fc:	4603      	mov	r3, r0
 800d3fe:	2b00      	cmp	r3, #0
 800d400:	d119      	bne.n	800d436 <decode_mcu+0x290>
	st += 3;
 800d402:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d404:	3303      	adds	r3, #3
 800d406:	637b      	str	r3, [r7, #52]	; 0x34
	if (k >= cinfo->lim_Se) {
 800d408:	687b      	ldr	r3, [r7, #4]
 800d40a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d40e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d410:	429a      	cmp	r2, r3
 800d412:	dbea      	blt.n	800d3ea <decode_mcu+0x244>
	  WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800d414:	687b      	ldr	r3, [r7, #4]
 800d416:	681b      	ldr	r3, [r3, #0]
 800d418:	2275      	movs	r2, #117	; 0x75
 800d41a:	615a      	str	r2, [r3, #20]
 800d41c:	687b      	ldr	r3, [r7, #4]
 800d41e:	681b      	ldr	r3, [r3, #0]
 800d420:	685b      	ldr	r3, [r3, #4]
 800d422:	f04f 31ff 	mov.w	r1, #4294967295
 800d426:	6878      	ldr	r0, [r7, #4]
 800d428:	4798      	blx	r3
	  entropy->ct = -1;			/* spectral overflow */
 800d42a:	6a3b      	ldr	r3, [r7, #32]
 800d42c:	f04f 32ff 	mov.w	r2, #4294967295
 800d430:	611a      	str	r2, [r3, #16]
	  return TRUE;
 800d432:	2301      	movs	r3, #1
 800d434:	e093      	b.n	800d55e <decode_mcu+0x3b8>
	if (arith_decode(cinfo, st + 1)) break;
 800d436:	bf00      	nop
	}
      }
      /* Figure F.21: Decoding nonzero value v */
      /* Figure F.22: Decoding the sign of v */
      sign = arith_decode(cinfo, entropy->fixed_bin);
 800d438:	6a3b      	ldr	r3, [r7, #32]
 800d43a:	33b8      	adds	r3, #184	; 0xb8
 800d43c:	4619      	mov	r1, r3
 800d43e:	6878      	ldr	r0, [r7, #4]
 800d440:	f7ff fa36 	bl	800c8b0 <arith_decode>
 800d444:	60b8      	str	r0, [r7, #8]
      st += 2;
 800d446:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d448:	3302      	adds	r3, #2
 800d44a:	637b      	str	r3, [r7, #52]	; 0x34
      /* Figure F.23: Decoding the magnitude category of v */
      if ((m = arith_decode(cinfo, st)) != 0) {
 800d44c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d44e:	6878      	ldr	r0, [r7, #4]
 800d450:	f7ff fa2e 	bl	800c8b0 <arith_decode>
 800d454:	6278      	str	r0, [r7, #36]	; 0x24
 800d456:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d458:	2b00      	cmp	r3, #0
 800d45a:	d040      	beq.n	800d4de <decode_mcu+0x338>
	if (arith_decode(cinfo, st)) {
 800d45c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d45e:	6878      	ldr	r0, [r7, #4]
 800d460:	f7ff fa26 	bl	800c8b0 <arith_decode>
 800d464:	4603      	mov	r3, r0
 800d466:	2b00      	cmp	r3, #0
 800d468:	d039      	beq.n	800d4de <decode_mcu+0x338>
	  m <<= 1;
 800d46a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d46c:	005b      	lsls	r3, r3, #1
 800d46e:	627b      	str	r3, [r7, #36]	; 0x24
	  st = entropy->ac_stats[tbl] +
 800d470:	6a3b      	ldr	r3, [r7, #32]
 800d472:	68fa      	ldr	r2, [r7, #12]
 800d474:	321e      	adds	r2, #30
 800d476:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	       (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);
 800d47a:	6879      	ldr	r1, [r7, #4]
 800d47c:	68fb      	ldr	r3, [r7, #12]
 800d47e:	440b      	add	r3, r1
 800d480:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800d484:	781b      	ldrb	r3, [r3, #0]
 800d486:	4619      	mov	r1, r3
 800d488:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d48a:	428b      	cmp	r3, r1
 800d48c:	dc01      	bgt.n	800d492 <decode_mcu+0x2ec>
 800d48e:	23bd      	movs	r3, #189	; 0xbd
 800d490:	e000      	b.n	800d494 <decode_mcu+0x2ee>
 800d492:	23d9      	movs	r3, #217	; 0xd9
	  st = entropy->ac_stats[tbl] +
 800d494:	4413      	add	r3, r2
 800d496:	637b      	str	r3, [r7, #52]	; 0x34
	  while (arith_decode(cinfo, st)) {
 800d498:	e01a      	b.n	800d4d0 <decode_mcu+0x32a>
	    if ((m <<= 1) == 0x8000) {
 800d49a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d49c:	005b      	lsls	r3, r3, #1
 800d49e:	627b      	str	r3, [r7, #36]	; 0x24
 800d4a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d4a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800d4a6:	d110      	bne.n	800d4ca <decode_mcu+0x324>
	      WARNMS(cinfo, JWRN_ARITH_BAD_CODE);
 800d4a8:	687b      	ldr	r3, [r7, #4]
 800d4aa:	681b      	ldr	r3, [r3, #0]
 800d4ac:	2275      	movs	r2, #117	; 0x75
 800d4ae:	615a      	str	r2, [r3, #20]
 800d4b0:	687b      	ldr	r3, [r7, #4]
 800d4b2:	681b      	ldr	r3, [r3, #0]
 800d4b4:	685b      	ldr	r3, [r3, #4]
 800d4b6:	f04f 31ff 	mov.w	r1, #4294967295
 800d4ba:	6878      	ldr	r0, [r7, #4]
 800d4bc:	4798      	blx	r3
	      entropy->ct = -1;			/* magnitude overflow */
 800d4be:	6a3b      	ldr	r3, [r7, #32]
 800d4c0:	f04f 32ff 	mov.w	r2, #4294967295
 800d4c4:	611a      	str	r2, [r3, #16]
	      return TRUE;
 800d4c6:	2301      	movs	r3, #1
 800d4c8:	e049      	b.n	800d55e <decode_mcu+0x3b8>
	    }
	    st += 1;
 800d4ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d4cc:	3301      	adds	r3, #1
 800d4ce:	637b      	str	r3, [r7, #52]	; 0x34
	  while (arith_decode(cinfo, st)) {
 800d4d0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d4d2:	6878      	ldr	r0, [r7, #4]
 800d4d4:	f7ff f9ec 	bl	800c8b0 <arith_decode>
 800d4d8:	4603      	mov	r3, r0
 800d4da:	2b00      	cmp	r3, #0
 800d4dc:	d1dd      	bne.n	800d49a <decode_mcu+0x2f4>
	  }
	}
      }
      v = m;
 800d4de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d4e0:	62bb      	str	r3, [r7, #40]	; 0x28
      /* Figure F.24: Decoding the magnitude bit pattern of v */
      st += 14;
 800d4e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d4e4:	330e      	adds	r3, #14
 800d4e6:	637b      	str	r3, [r7, #52]	; 0x34
      while (m >>= 1)
 800d4e8:	e00a      	b.n	800d500 <decode_mcu+0x35a>
	if (arith_decode(cinfo, st)) v |= m;
 800d4ea:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800d4ec:	6878      	ldr	r0, [r7, #4]
 800d4ee:	f7ff f9df 	bl	800c8b0 <arith_decode>
 800d4f2:	4603      	mov	r3, r0
 800d4f4:	2b00      	cmp	r3, #0
 800d4f6:	d003      	beq.n	800d500 <decode_mcu+0x35a>
 800d4f8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d4fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d4fc:	4313      	orrs	r3, r2
 800d4fe:	62bb      	str	r3, [r7, #40]	; 0x28
      while (m >>= 1)
 800d500:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d502:	105b      	asrs	r3, r3, #1
 800d504:	627b      	str	r3, [r7, #36]	; 0x24
 800d506:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d508:	2b00      	cmp	r3, #0
 800d50a:	d1ee      	bne.n	800d4ea <decode_mcu+0x344>
      v += 1; if (sign) v = -v;
 800d50c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d50e:	3301      	adds	r3, #1
 800d510:	62bb      	str	r3, [r7, #40]	; 0x28
 800d512:	68bb      	ldr	r3, [r7, #8]
 800d514:	2b00      	cmp	r3, #0
 800d516:	d002      	beq.n	800d51e <decode_mcu+0x378>
 800d518:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d51a:	425b      	negs	r3, r3
 800d51c:	62bb      	str	r3, [r7, #40]	; 0x28
      (*block)[natural_order[k]] = (JCOEF) v;
 800d51e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d520:	009b      	lsls	r3, r3, #2
 800d522:	69fa      	ldr	r2, [r7, #28]
 800d524:	4413      	add	r3, r2
 800d526:	681a      	ldr	r2, [r3, #0]
 800d528:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d52a:	b219      	sxth	r1, r3
 800d52c:	69bb      	ldr	r3, [r7, #24]
 800d52e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    } while (k < cinfo->lim_Se);
 800d532:	687b      	ldr	r3, [r7, #4]
 800d534:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d538:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d53a:	429a      	cmp	r2, r3
 800d53c:	f6ff af42 	blt.w	800d3c4 <decode_mcu+0x21e>
 800d540:	e002      	b.n	800d548 <decode_mcu+0x3a2>
    if (cinfo->lim_Se == 0) continue;
 800d542:	bf00      	nop
 800d544:	e000      	b.n	800d548 <decode_mcu+0x3a2>
      if (arith_decode(cinfo, st)) break;	/* EOB flag */
 800d546:	bf00      	nop
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 800d548:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d54a:	3301      	adds	r3, #1
 800d54c:	633b      	str	r3, [r7, #48]	; 0x30
 800d54e:	687b      	ldr	r3, [r7, #4]
 800d550:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 800d554:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d556:	429a      	cmp	r2, r3
 800d558:	f6ff ae4d 	blt.w	800d1f6 <decode_mcu+0x50>
  }

  return TRUE;
 800d55c:	2301      	movs	r3, #1
}
 800d55e:	4618      	mov	r0, r3
 800d560:	3738      	adds	r7, #56	; 0x38
 800d562:	46bd      	mov	sp, r7
 800d564:	bd80      	pop	{r7, pc}
	...

0800d568 <start_pass>:
 * Initialize for an arithmetic-compressed scan.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 800d568:	b580      	push	{r7, lr}
 800d56a:	b08a      	sub	sp, #40	; 0x28
 800d56c:	af00      	add	r7, sp, #0
 800d56e:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;
 800d570:	687b      	ldr	r3, [r7, #4]
 800d572:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800d576:	61fb      	str	r3, [r7, #28]
  int ci, tbl;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 800d578:	687b      	ldr	r3, [r7, #4]
 800d57a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d57e:	2b00      	cmp	r3, #0
 800d580:	f000 80e7 	beq.w	800d752 <start_pass+0x1ea>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 800d584:	687b      	ldr	r3, [r7, #4]
 800d586:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d58a:	2b00      	cmp	r3, #0
 800d58c:	d105      	bne.n	800d59a <start_pass+0x32>
      if (cinfo->Se != 0)
 800d58e:	687b      	ldr	r3, [r7, #4]
 800d590:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800d594:	2b00      	cmp	r3, #0
 800d596:	d015      	beq.n	800d5c4 <start_pass+0x5c>
	goto bad;
 800d598:	e02d      	b.n	800d5f6 <start_pass+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 800d59a:	687b      	ldr	r3, [r7, #4]
 800d59c:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 800d5a0:	687b      	ldr	r3, [r7, #4]
 800d5a2:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d5a6:	429a      	cmp	r2, r3
 800d5a8:	db20      	blt.n	800d5ec <start_pass+0x84>
 800d5aa:	687b      	ldr	r3, [r7, #4]
 800d5ac:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 800d5b0:	687b      	ldr	r3, [r7, #4]
 800d5b2:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d5b6:	429a      	cmp	r2, r3
 800d5b8:	dc18      	bgt.n	800d5ec <start_pass+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 800d5ba:	687b      	ldr	r3, [r7, #4]
 800d5bc:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800d5c0:	2b01      	cmp	r3, #1
 800d5c2:	d115      	bne.n	800d5f0 <start_pass+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 800d5c4:	687b      	ldr	r3, [r7, #4]
 800d5c6:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d5ca:	2b00      	cmp	r3, #0
 800d5cc:	d008      	beq.n	800d5e0 <start_pass+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 800d5ce:	687b      	ldr	r3, [r7, #4]
 800d5d0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d5d4:	1e5a      	subs	r2, r3, #1
 800d5d6:	687b      	ldr	r3, [r7, #4]
 800d5d8:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800d5dc:	429a      	cmp	r2, r3
 800d5de:	d109      	bne.n	800d5f4 <start_pass+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 800d5e0:	687b      	ldr	r3, [r7, #4]
 800d5e2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800d5e6:	2b0d      	cmp	r3, #13
 800d5e8:	dd26      	ble.n	800d638 <start_pass+0xd0>
      bad:
 800d5ea:	e004      	b.n	800d5f6 <start_pass+0x8e>
	goto bad;
 800d5ec:	bf00      	nop
 800d5ee:	e002      	b.n	800d5f6 <start_pass+0x8e>
	goto bad;
 800d5f0:	bf00      	nop
 800d5f2:	e000      	b.n	800d5f6 <start_pass+0x8e>
	goto bad;
 800d5f4:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	681b      	ldr	r3, [r3, #0]
 800d5fa:	2211      	movs	r2, #17
 800d5fc:	615a      	str	r2, [r3, #20]
 800d5fe:	687b      	ldr	r3, [r7, #4]
 800d600:	681b      	ldr	r3, [r3, #0]
 800d602:	687a      	ldr	r2, [r7, #4]
 800d604:	f8d2 2198 	ldr.w	r2, [r2, #408]	; 0x198
 800d608:	619a      	str	r2, [r3, #24]
 800d60a:	687b      	ldr	r3, [r7, #4]
 800d60c:	681b      	ldr	r3, [r3, #0]
 800d60e:	687a      	ldr	r2, [r7, #4]
 800d610:	f8d2 219c 	ldr.w	r2, [r2, #412]	; 0x19c
 800d614:	61da      	str	r2, [r3, #28]
 800d616:	687b      	ldr	r3, [r7, #4]
 800d618:	681b      	ldr	r3, [r3, #0]
 800d61a:	687a      	ldr	r2, [r7, #4]
 800d61c:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
 800d620:	621a      	str	r2, [r3, #32]
 800d622:	687b      	ldr	r3, [r7, #4]
 800d624:	681b      	ldr	r3, [r3, #0]
 800d626:	687a      	ldr	r2, [r7, #4]
 800d628:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 800d62c:	625a      	str	r2, [r3, #36]	; 0x24
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	681b      	ldr	r3, [r3, #0]
 800d632:	681b      	ldr	r3, [r3, #0]
 800d634:	6878      	ldr	r0, [r7, #4]
 800d636:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800d638:	2300      	movs	r3, #0
 800d63a:	627b      	str	r3, [r7, #36]	; 0x24
 800d63c:	e064      	b.n	800d708 <start_pass+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 800d63e:	687a      	ldr	r2, [r7, #4]
 800d640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d642:	3354      	adds	r3, #84	; 0x54
 800d644:	009b      	lsls	r3, r3, #2
 800d646:	4413      	add	r3, r2
 800d648:	685b      	ldr	r3, [r3, #4]
 800d64a:	685b      	ldr	r3, [r3, #4]
 800d64c:	61bb      	str	r3, [r7, #24]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 800d64e:	687b      	ldr	r3, [r7, #4]
 800d650:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 800d654:	69bb      	ldr	r3, [r7, #24]
 800d656:	021b      	lsls	r3, r3, #8
 800d658:	4413      	add	r3, r2
 800d65a:	617b      	str	r3, [r7, #20]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 800d65c:	687b      	ldr	r3, [r7, #4]
 800d65e:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d662:	2b00      	cmp	r3, #0
 800d664:	d016      	beq.n	800d694 <start_pass+0x12c>
 800d666:	697b      	ldr	r3, [r7, #20]
 800d668:	681b      	ldr	r3, [r3, #0]
 800d66a:	2b00      	cmp	r3, #0
 800d66c:	da12      	bge.n	800d694 <start_pass+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 800d66e:	687b      	ldr	r3, [r7, #4]
 800d670:	681b      	ldr	r3, [r3, #0]
 800d672:	2276      	movs	r2, #118	; 0x76
 800d674:	615a      	str	r2, [r3, #20]
 800d676:	687b      	ldr	r3, [r7, #4]
 800d678:	681b      	ldr	r3, [r3, #0]
 800d67a:	69ba      	ldr	r2, [r7, #24]
 800d67c:	619a      	str	r2, [r3, #24]
 800d67e:	687b      	ldr	r3, [r7, #4]
 800d680:	681b      	ldr	r3, [r3, #0]
 800d682:	2200      	movs	r2, #0
 800d684:	61da      	str	r2, [r3, #28]
 800d686:	687b      	ldr	r3, [r7, #4]
 800d688:	681b      	ldr	r3, [r3, #0]
 800d68a:	685b      	ldr	r3, [r3, #4]
 800d68c:	f04f 31ff 	mov.w	r1, #4294967295
 800d690:	6878      	ldr	r0, [r7, #4]
 800d692:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 800d694:	687b      	ldr	r3, [r7, #4]
 800d696:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d69a:	623b      	str	r3, [r7, #32]
 800d69c:	e02b      	b.n	800d6f6 <start_pass+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 800d69e:	6a3b      	ldr	r3, [r7, #32]
 800d6a0:	009b      	lsls	r3, r3, #2
 800d6a2:	697a      	ldr	r2, [r7, #20]
 800d6a4:	4413      	add	r3, r2
 800d6a6:	681b      	ldr	r3, [r3, #0]
 800d6a8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800d6ac:	613b      	str	r3, [r7, #16]
	if (cinfo->Ah != expected)
 800d6ae:	687b      	ldr	r3, [r7, #4]
 800d6b0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d6b4:	693a      	ldr	r2, [r7, #16]
 800d6b6:	429a      	cmp	r2, r3
 800d6b8:	d012      	beq.n	800d6e0 <start_pass+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 800d6ba:	687b      	ldr	r3, [r7, #4]
 800d6bc:	681b      	ldr	r3, [r3, #0]
 800d6be:	2276      	movs	r2, #118	; 0x76
 800d6c0:	615a      	str	r2, [r3, #20]
 800d6c2:	687b      	ldr	r3, [r7, #4]
 800d6c4:	681b      	ldr	r3, [r3, #0]
 800d6c6:	69ba      	ldr	r2, [r7, #24]
 800d6c8:	619a      	str	r2, [r3, #24]
 800d6ca:	687b      	ldr	r3, [r7, #4]
 800d6cc:	681b      	ldr	r3, [r3, #0]
 800d6ce:	6a3a      	ldr	r2, [r7, #32]
 800d6d0:	61da      	str	r2, [r3, #28]
 800d6d2:	687b      	ldr	r3, [r7, #4]
 800d6d4:	681b      	ldr	r3, [r3, #0]
 800d6d6:	685b      	ldr	r3, [r3, #4]
 800d6d8:	f04f 31ff 	mov.w	r1, #4294967295
 800d6dc:	6878      	ldr	r0, [r7, #4]
 800d6de:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 800d6e0:	6a3b      	ldr	r3, [r7, #32]
 800d6e2:	009b      	lsls	r3, r3, #2
 800d6e4:	697a      	ldr	r2, [r7, #20]
 800d6e6:	4413      	add	r3, r2
 800d6e8:	687a      	ldr	r2, [r7, #4]
 800d6ea:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 800d6ee:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 800d6f0:	6a3b      	ldr	r3, [r7, #32]
 800d6f2:	3301      	adds	r3, #1
 800d6f4:	623b      	str	r3, [r7, #32]
 800d6f6:	687b      	ldr	r3, [r7, #4]
 800d6f8:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800d6fc:	6a3a      	ldr	r2, [r7, #32]
 800d6fe:	429a      	cmp	r2, r3
 800d700:	ddcd      	ble.n	800d69e <start_pass+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800d702:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d704:	3301      	adds	r3, #1
 800d706:	627b      	str	r3, [r7, #36]	; 0x24
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800d70e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d710:	429a      	cmp	r2, r3
 800d712:	db94      	blt.n	800d63e <start_pass+0xd6>
      }
    }
    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 800d714:	687b      	ldr	r3, [r7, #4]
 800d716:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d71a:	2b00      	cmp	r3, #0
 800d71c:	d10c      	bne.n	800d738 <start_pass+0x1d0>
      if (cinfo->Ss == 0)
 800d71e:	687b      	ldr	r3, [r7, #4]
 800d720:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d724:	2b00      	cmp	r3, #0
 800d726:	d103      	bne.n	800d730 <start_pass+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 800d728:	69fb      	ldr	r3, [r7, #28]
 800d72a:	4a80      	ldr	r2, [pc, #512]	; (800d92c <start_pass+0x3c4>)
 800d72c:	605a      	str	r2, [r3, #4]
 800d72e:	e03a      	b.n	800d7a6 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 800d730:	69fb      	ldr	r3, [r7, #28]
 800d732:	4a7f      	ldr	r2, [pc, #508]	; (800d930 <start_pass+0x3c8>)
 800d734:	605a      	str	r2, [r3, #4]
 800d736:	e036      	b.n	800d7a6 <start_pass+0x23e>
    } else {
      if (cinfo->Ss == 0)
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d73e:	2b00      	cmp	r3, #0
 800d740:	d103      	bne.n	800d74a <start_pass+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 800d742:	69fb      	ldr	r3, [r7, #28]
 800d744:	4a7b      	ldr	r2, [pc, #492]	; (800d934 <start_pass+0x3cc>)
 800d746:	605a      	str	r2, [r3, #4]
 800d748:	e02d      	b.n	800d7a6 <start_pass+0x23e>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 800d74a:	69fb      	ldr	r3, [r7, #28]
 800d74c:	4a7a      	ldr	r2, [pc, #488]	; (800d938 <start_pass+0x3d0>)
 800d74e:	605a      	str	r2, [r3, #4]
 800d750:	e029      	b.n	800d7a6 <start_pass+0x23e>
    }
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 800d752:	687b      	ldr	r3, [r7, #4]
 800d754:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d758:	2b00      	cmp	r3, #0
 800d75a:	d116      	bne.n	800d78a <start_pass+0x222>
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d762:	2b00      	cmp	r3, #0
 800d764:	d111      	bne.n	800d78a <start_pass+0x222>
 800d766:	687b      	ldr	r3, [r7, #4]
 800d768:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800d76c:	2b00      	cmp	r3, #0
 800d76e:	d10c      	bne.n	800d78a <start_pass+0x222>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 800d770:	687b      	ldr	r3, [r7, #4]
 800d772:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 800d776:	2b3f      	cmp	r3, #63	; 0x3f
 800d778:	dc12      	bgt.n	800d7a0 <start_pass+0x238>
	(cinfo->Se < DCTSIZE2 && cinfo->Se != cinfo->lim_Se))
 800d77a:	687b      	ldr	r3, [r7, #4]
 800d77c:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 800d780:	687b      	ldr	r3, [r7, #4]
 800d782:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d786:	429a      	cmp	r2, r3
 800d788:	d00a      	beq.n	800d7a0 <start_pass+0x238>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 800d78a:	687b      	ldr	r3, [r7, #4]
 800d78c:	681b      	ldr	r3, [r3, #0]
 800d78e:	227d      	movs	r2, #125	; 0x7d
 800d790:	615a      	str	r2, [r3, #20]
 800d792:	687b      	ldr	r3, [r7, #4]
 800d794:	681b      	ldr	r3, [r3, #0]
 800d796:	685b      	ldr	r3, [r3, #4]
 800d798:	f04f 31ff 	mov.w	r1, #4294967295
 800d79c:	6878      	ldr	r0, [r7, #4]
 800d79e:	4798      	blx	r3
    /* Select MCU decoding routine */
    entropy->pub.decode_mcu = decode_mcu;
 800d7a0:	69fb      	ldr	r3, [r7, #28]
 800d7a2:	4a66      	ldr	r2, [pc, #408]	; (800d93c <start_pass+0x3d4>)
 800d7a4:	605a      	str	r2, [r3, #4]
  }

  /* Allocate & initialize requested statistics areas */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800d7a6:	2300      	movs	r3, #0
 800d7a8:	627b      	str	r3, [r7, #36]	; 0x24
 800d7aa:	e0a4      	b.n	800d8f6 <start_pass+0x38e>
    compptr = cinfo->cur_comp_info[ci];
 800d7ac:	687a      	ldr	r2, [r7, #4]
 800d7ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d7b0:	3354      	adds	r3, #84	; 0x54
 800d7b2:	009b      	lsls	r3, r3, #2
 800d7b4:	4413      	add	r3, r2
 800d7b6:	685b      	ldr	r3, [r3, #4]
 800d7b8:	60fb      	str	r3, [r7, #12]
    if (! cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {
 800d7ba:	687b      	ldr	r3, [r7, #4]
 800d7bc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d7c0:	2b00      	cmp	r3, #0
 800d7c2:	d009      	beq.n	800d7d8 <start_pass+0x270>
 800d7c4:	687b      	ldr	r3, [r7, #4]
 800d7c6:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d7ca:	2b00      	cmp	r3, #0
 800d7cc:	d146      	bne.n	800d85c <start_pass+0x2f4>
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800d7d4:	2b00      	cmp	r3, #0
 800d7d6:	d141      	bne.n	800d85c <start_pass+0x2f4>
      tbl = compptr->dc_tbl_no;
 800d7d8:	68fb      	ldr	r3, [r7, #12]
 800d7da:	695b      	ldr	r3, [r3, #20]
 800d7dc:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 800d7de:	68bb      	ldr	r3, [r7, #8]
 800d7e0:	2b00      	cmp	r3, #0
 800d7e2:	db02      	blt.n	800d7ea <start_pass+0x282>
 800d7e4:	68bb      	ldr	r3, [r7, #8]
 800d7e6:	2b0f      	cmp	r3, #15
 800d7e8:	dd0c      	ble.n	800d804 <start_pass+0x29c>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 800d7ea:	687b      	ldr	r3, [r7, #4]
 800d7ec:	681b      	ldr	r3, [r3, #0]
 800d7ee:	2232      	movs	r2, #50	; 0x32
 800d7f0:	615a      	str	r2, [r3, #20]
 800d7f2:	687b      	ldr	r3, [r7, #4]
 800d7f4:	681b      	ldr	r3, [r3, #0]
 800d7f6:	68ba      	ldr	r2, [r7, #8]
 800d7f8:	619a      	str	r2, [r3, #24]
 800d7fa:	687b      	ldr	r3, [r7, #4]
 800d7fc:	681b      	ldr	r3, [r3, #0]
 800d7fe:	681b      	ldr	r3, [r3, #0]
 800d800:	6878      	ldr	r0, [r7, #4]
 800d802:	4798      	blx	r3
      if (entropy->dc_stats[tbl] == NULL)
 800d804:	69fb      	ldr	r3, [r7, #28]
 800d806:	68ba      	ldr	r2, [r7, #8]
 800d808:	320e      	adds	r2, #14
 800d80a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d80e:	2b00      	cmp	r3, #0
 800d810:	d10c      	bne.n	800d82c <start_pass+0x2c4>
	entropy->dc_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 800d812:	687b      	ldr	r3, [r7, #4]
 800d814:	685b      	ldr	r3, [r3, #4]
 800d816:	681b      	ldr	r3, [r3, #0]
 800d818:	2240      	movs	r2, #64	; 0x40
 800d81a:	2101      	movs	r1, #1
 800d81c:	6878      	ldr	r0, [r7, #4]
 800d81e:	4798      	blx	r3
 800d820:	4601      	mov	r1, r0
 800d822:	69fb      	ldr	r3, [r7, #28]
 800d824:	68ba      	ldr	r2, [r7, #8]
 800d826:	320e      	adds	r2, #14
 800d828:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, DC_STAT_BINS);
      MEMZERO(entropy->dc_stats[tbl], DC_STAT_BINS);
 800d82c:	69fb      	ldr	r3, [r7, #28]
 800d82e:	68ba      	ldr	r2, [r7, #8]
 800d830:	320e      	adds	r2, #14
 800d832:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d836:	2240      	movs	r2, #64	; 0x40
 800d838:	2100      	movs	r1, #0
 800d83a:	4618      	mov	r0, r3
 800d83c:	f01a fd20 	bl	8028280 <memset>
      /* Initialize DC predictions to 0 */
      entropy->last_dc_val[ci] = 0;
 800d840:	69fa      	ldr	r2, [r7, #28]
 800d842:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d844:	3304      	adds	r3, #4
 800d846:	009b      	lsls	r3, r3, #2
 800d848:	4413      	add	r3, r2
 800d84a:	2200      	movs	r2, #0
 800d84c:	605a      	str	r2, [r3, #4]
      entropy->dc_context[ci] = 0;
 800d84e:	69fa      	ldr	r2, [r7, #28]
 800d850:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d852:	3308      	adds	r3, #8
 800d854:	009b      	lsls	r3, r3, #2
 800d856:	4413      	add	r3, r2
 800d858:	2200      	movs	r2, #0
 800d85a:	605a      	str	r2, [r3, #4]
    }
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 800d85c:	687b      	ldr	r3, [r7, #4]
 800d85e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d862:	2b00      	cmp	r3, #0
 800d864:	d104      	bne.n	800d870 <start_pass+0x308>
 800d866:	687b      	ldr	r3, [r7, #4]
 800d868:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800d86c:	2b00      	cmp	r3, #0
 800d86e:	d109      	bne.n	800d884 <start_pass+0x31c>
	(cinfo->progressive_mode && cinfo->Ss)) {
 800d870:	687b      	ldr	r3, [r7, #4]
 800d872:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    if ((! cinfo->progressive_mode && cinfo->lim_Se) ||
 800d876:	2b00      	cmp	r3, #0
 800d878:	d03a      	beq.n	800d8f0 <start_pass+0x388>
	(cinfo->progressive_mode && cinfo->Ss)) {
 800d87a:	687b      	ldr	r3, [r7, #4]
 800d87c:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800d880:	2b00      	cmp	r3, #0
 800d882:	d035      	beq.n	800d8f0 <start_pass+0x388>
      tbl = compptr->ac_tbl_no;
 800d884:	68fb      	ldr	r3, [r7, #12]
 800d886:	699b      	ldr	r3, [r3, #24]
 800d888:	60bb      	str	r3, [r7, #8]
      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)
 800d88a:	68bb      	ldr	r3, [r7, #8]
 800d88c:	2b00      	cmp	r3, #0
 800d88e:	db02      	blt.n	800d896 <start_pass+0x32e>
 800d890:	68bb      	ldr	r3, [r7, #8]
 800d892:	2b0f      	cmp	r3, #15
 800d894:	dd0c      	ble.n	800d8b0 <start_pass+0x348>
	ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);
 800d896:	687b      	ldr	r3, [r7, #4]
 800d898:	681b      	ldr	r3, [r3, #0]
 800d89a:	2232      	movs	r2, #50	; 0x32
 800d89c:	615a      	str	r2, [r3, #20]
 800d89e:	687b      	ldr	r3, [r7, #4]
 800d8a0:	681b      	ldr	r3, [r3, #0]
 800d8a2:	68ba      	ldr	r2, [r7, #8]
 800d8a4:	619a      	str	r2, [r3, #24]
 800d8a6:	687b      	ldr	r3, [r7, #4]
 800d8a8:	681b      	ldr	r3, [r3, #0]
 800d8aa:	681b      	ldr	r3, [r3, #0]
 800d8ac:	6878      	ldr	r0, [r7, #4]
 800d8ae:	4798      	blx	r3
      if (entropy->ac_stats[tbl] == NULL)
 800d8b0:	69fb      	ldr	r3, [r7, #28]
 800d8b2:	68ba      	ldr	r2, [r7, #8]
 800d8b4:	321e      	adds	r2, #30
 800d8b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d8ba:	2b00      	cmp	r3, #0
 800d8bc:	d10d      	bne.n	800d8da <start_pass+0x372>
	entropy->ac_stats[tbl] = (unsigned char *) (*cinfo->mem->alloc_small)
 800d8be:	687b      	ldr	r3, [r7, #4]
 800d8c0:	685b      	ldr	r3, [r3, #4]
 800d8c2:	681b      	ldr	r3, [r3, #0]
 800d8c4:	f44f 7280 	mov.w	r2, #256	; 0x100
 800d8c8:	2101      	movs	r1, #1
 800d8ca:	6878      	ldr	r0, [r7, #4]
 800d8cc:	4798      	blx	r3
 800d8ce:	4601      	mov	r1, r0
 800d8d0:	69fb      	ldr	r3, [r7, #28]
 800d8d2:	68ba      	ldr	r2, [r7, #8]
 800d8d4:	321e      	adds	r2, #30
 800d8d6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, AC_STAT_BINS);
      MEMZERO(entropy->ac_stats[tbl], AC_STAT_BINS);
 800d8da:	69fb      	ldr	r3, [r7, #28]
 800d8dc:	68ba      	ldr	r2, [r7, #8]
 800d8de:	321e      	adds	r2, #30
 800d8e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d8e4:	f44f 7280 	mov.w	r2, #256	; 0x100
 800d8e8:	2100      	movs	r1, #0
 800d8ea:	4618      	mov	r0, r3
 800d8ec:	f01a fcc8 	bl	8028280 <memset>
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800d8f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d8f2:	3301      	adds	r3, #1
 800d8f4:	627b      	str	r3, [r7, #36]	; 0x24
 800d8f6:	687b      	ldr	r3, [r7, #4]
 800d8f8:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800d8fc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d8fe:	429a      	cmp	r2, r3
 800d900:	f6ff af54 	blt.w	800d7ac <start_pass+0x244>
    }
  }

  /* Initialize arithmetic decoding variables */
  entropy->c = 0;
 800d904:	69fb      	ldr	r3, [r7, #28]
 800d906:	2200      	movs	r2, #0
 800d908:	609a      	str	r2, [r3, #8]
  entropy->a = 0;
 800d90a:	69fb      	ldr	r3, [r7, #28]
 800d90c:	2200      	movs	r2, #0
 800d90e:	60da      	str	r2, [r3, #12]
  entropy->ct = -16;	/* force reading 2 initial bytes to fill C */
 800d910:	69fb      	ldr	r3, [r7, #28]
 800d912:	f06f 020f 	mvn.w	r2, #15
 800d916:	611a      	str	r2, [r3, #16]

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 800d918:	687b      	ldr	r3, [r7, #4]
 800d91a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800d91e:	69fb      	ldr	r3, [r7, #28]
 800d920:	635a      	str	r2, [r3, #52]	; 0x34
}
 800d922:	bf00      	nop
 800d924:	3728      	adds	r7, #40	; 0x28
 800d926:	46bd      	mov	sp, r7
 800d928:	bd80      	pop	{r7, pc}
 800d92a:	bf00      	nop
 800d92c:	0800cb0d 	.word	0x0800cb0d
 800d930:	0800cd31 	.word	0x0800cd31
 800d934:	0800cf31 	.word	0x0800cf31
 800d938:	0800cfcb 	.word	0x0800cfcb
 800d93c:	0800d1a7 	.word	0x0800d1a7

0800d940 <jinit_arith_decoder>:
 * Module initialization routine for arithmetic entropy decoding.
 */

GLOBAL(void)
jinit_arith_decoder (j_decompress_ptr cinfo)
{
 800d940:	b580      	push	{r7, lr}
 800d942:	b086      	sub	sp, #24
 800d944:	af00      	add	r7, sp, #0
 800d946:	6078      	str	r0, [r7, #4]
  arith_entropy_ptr entropy;
  int i;

  entropy = (arith_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800d948:	687b      	ldr	r3, [r7, #4]
 800d94a:	685b      	ldr	r3, [r3, #4]
 800d94c:	681b      	ldr	r3, [r3, #0]
 800d94e:	22bc      	movs	r2, #188	; 0xbc
 800d950:	2101      	movs	r1, #1
 800d952:	6878      	ldr	r0, [r7, #4]
 800d954:	4798      	blx	r3
 800d956:	60b8      	str	r0, [r7, #8]
				SIZEOF(arith_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	68ba      	ldr	r2, [r7, #8]
 800d95c:	f8c3 21d0 	str.w	r2, [r3, #464]	; 0x1d0
  entropy->pub.start_pass = start_pass;
 800d960:	68bb      	ldr	r3, [r7, #8]
 800d962:	4a27      	ldr	r2, [pc, #156]	; (800da00 <jinit_arith_decoder+0xc0>)
 800d964:	601a      	str	r2, [r3, #0]

  /* Mark tables unallocated */
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 800d966:	2300      	movs	r3, #0
 800d968:	617b      	str	r3, [r7, #20]
 800d96a:	e00e      	b.n	800d98a <jinit_arith_decoder+0x4a>
    entropy->dc_stats[i] = NULL;
 800d96c:	68bb      	ldr	r3, [r7, #8]
 800d96e:	697a      	ldr	r2, [r7, #20]
 800d970:	320e      	adds	r2, #14
 800d972:	2100      	movs	r1, #0
 800d974:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    entropy->ac_stats[i] = NULL;
 800d978:	68bb      	ldr	r3, [r7, #8]
 800d97a:	697a      	ldr	r2, [r7, #20]
 800d97c:	321e      	adds	r2, #30
 800d97e:	2100      	movs	r1, #0
 800d980:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 800d984:	697b      	ldr	r3, [r7, #20]
 800d986:	3301      	adds	r3, #1
 800d988:	617b      	str	r3, [r7, #20]
 800d98a:	697b      	ldr	r3, [r7, #20]
 800d98c:	2b0f      	cmp	r3, #15
 800d98e:	dded      	ble.n	800d96c <jinit_arith_decoder+0x2c>
  }

  /* Initialize index for fixed probability estimation */
  entropy->fixed_bin[0] = 113;
 800d990:	68bb      	ldr	r3, [r7, #8]
 800d992:	2271      	movs	r2, #113	; 0x71
 800d994:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

  if (cinfo->progressive_mode) {
 800d998:	687b      	ldr	r3, [r7, #4]
 800d99a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d99e:	2b00      	cmp	r3, #0
 800d9a0:	d02a      	beq.n	800d9f8 <jinit_arith_decoder+0xb8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800d9a2:	687b      	ldr	r3, [r7, #4]
 800d9a4:	685b      	ldr	r3, [r3, #4]
 800d9a6:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 800d9a8:	687a      	ldr	r2, [r7, #4]
 800d9aa:	6a52      	ldr	r2, [r2, #36]	; 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800d9ac:	0212      	lsls	r2, r2, #8
 800d9ae:	2101      	movs	r1, #1
 800d9b0:	6878      	ldr	r0, [r7, #4]
 800d9b2:	4798      	blx	r3
 800d9b4:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 800d9b6:	687b      	ldr	r3, [r7, #4]
 800d9b8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 800d9bc:	687b      	ldr	r3, [r7, #4]
 800d9be:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800d9c2:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++) 
 800d9c4:	2300      	movs	r3, #0
 800d9c6:	60fb      	str	r3, [r7, #12]
 800d9c8:	e011      	b.n	800d9ee <jinit_arith_decoder+0xae>
      for (i = 0; i < DCTSIZE2; i++)
 800d9ca:	2300      	movs	r3, #0
 800d9cc:	617b      	str	r3, [r7, #20]
 800d9ce:	e008      	b.n	800d9e2 <jinit_arith_decoder+0xa2>
	*coef_bit_ptr++ = -1;
 800d9d0:	693b      	ldr	r3, [r7, #16]
 800d9d2:	1d1a      	adds	r2, r3, #4
 800d9d4:	613a      	str	r2, [r7, #16]
 800d9d6:	f04f 32ff 	mov.w	r2, #4294967295
 800d9da:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 800d9dc:	697b      	ldr	r3, [r7, #20]
 800d9de:	3301      	adds	r3, #1
 800d9e0:	617b      	str	r3, [r7, #20]
 800d9e2:	697b      	ldr	r3, [r7, #20]
 800d9e4:	2b3f      	cmp	r3, #63	; 0x3f
 800d9e6:	ddf3      	ble.n	800d9d0 <jinit_arith_decoder+0x90>
    for (ci = 0; ci < cinfo->num_components; ci++) 
 800d9e8:	68fb      	ldr	r3, [r7, #12]
 800d9ea:	3301      	adds	r3, #1
 800d9ec:	60fb      	str	r3, [r7, #12]
 800d9ee:	687b      	ldr	r3, [r7, #4]
 800d9f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d9f2:	68fa      	ldr	r2, [r7, #12]
 800d9f4:	429a      	cmp	r2, r3
 800d9f6:	dbe8      	blt.n	800d9ca <jinit_arith_decoder+0x8a>
  }
}
 800d9f8:	bf00      	nop
 800d9fa:	3718      	adds	r7, #24
 800d9fc:	46bd      	mov	sp, r7
 800d9fe:	bd80      	pop	{r7, pc}
 800da00:	0800d569 	.word	0x0800d569

0800da04 <init_source>:
 * before any data is actually read.
 */
#ifdef JFILE 
METHODDEF(void)
init_source (j_decompress_ptr cinfo)
{
 800da04:	b480      	push	{r7}
 800da06:	b085      	sub	sp, #20
 800da08:	af00      	add	r7, sp, #0
 800da0a:	6078      	str	r0, [r7, #4]
  my_src_ptr src = (my_src_ptr) cinfo->src;
 800da0c:	687b      	ldr	r3, [r7, #4]
 800da0e:	699b      	ldr	r3, [r3, #24]
 800da10:	60fb      	str	r3, [r7, #12]

  /* We reset the empty-input-file flag for each image,
   * but we don't clear the input buffer.
   * This is correct behavior for reading a series of images from one source.
   */
  src->start_of_file = TRUE;
 800da12:	68fb      	ldr	r3, [r7, #12]
 800da14:	2201      	movs	r2, #1
 800da16:	625a      	str	r2, [r3, #36]	; 0x24
}
 800da18:	bf00      	nop
 800da1a:	3714      	adds	r7, #20
 800da1c:	46bd      	mov	sp, r7
 800da1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da22:	4770      	bx	lr

0800da24 <fill_input_buffer>:
 * the front of the buffer rather than discarding it.
 */
#ifdef JFILE 
METHODDEF(boolean)
fill_input_buffer (j_decompress_ptr cinfo)
{
 800da24:	b580      	push	{r7, lr}
 800da26:	b084      	sub	sp, #16
 800da28:	af00      	add	r7, sp, #0
 800da2a:	6078      	str	r0, [r7, #4]
  my_src_ptr src = (my_src_ptr) cinfo->src;
 800da2c:	687b      	ldr	r3, [r7, #4]
 800da2e:	699b      	ldr	r3, [r3, #24]
 800da30:	60bb      	str	r3, [r7, #8]
  size_t nbytes;

  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);
 800da32:	68bb      	ldr	r3, [r7, #8]
 800da34:	69d8      	ldr	r0, [r3, #28]
 800da36:	68bb      	ldr	r3, [r7, #8]
 800da38:	6a1b      	ldr	r3, [r3, #32]
 800da3a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800da3e:	4619      	mov	r1, r3
 800da40:	f7f8 f9cc 	bl	8005ddc <read_file>
 800da44:	60f8      	str	r0, [r7, #12]
  
  if (nbytes <= 0) {
 800da46:	68fb      	ldr	r3, [r7, #12]
 800da48:	2b00      	cmp	r3, #0
 800da4a:	d122      	bne.n	800da92 <fill_input_buffer+0x6e>
    if (src->start_of_file)	/* Treat empty input file as fatal error */
 800da4c:	68bb      	ldr	r3, [r7, #8]
 800da4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800da50:	2b00      	cmp	r3, #0
 800da52:	d008      	beq.n	800da66 <fill_input_buffer+0x42>
      ERREXIT(cinfo, JERR_INPUT_EMPTY);
 800da54:	687b      	ldr	r3, [r7, #4]
 800da56:	681b      	ldr	r3, [r3, #0]
 800da58:	222b      	movs	r2, #43	; 0x2b
 800da5a:	615a      	str	r2, [r3, #20]
 800da5c:	687b      	ldr	r3, [r7, #4]
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	681b      	ldr	r3, [r3, #0]
 800da62:	6878      	ldr	r0, [r7, #4]
 800da64:	4798      	blx	r3
    WARNMS(cinfo, JWRN_JPEG_EOF);
 800da66:	687b      	ldr	r3, [r7, #4]
 800da68:	681b      	ldr	r3, [r3, #0]
 800da6a:	227b      	movs	r2, #123	; 0x7b
 800da6c:	615a      	str	r2, [r3, #20]
 800da6e:	687b      	ldr	r3, [r7, #4]
 800da70:	681b      	ldr	r3, [r3, #0]
 800da72:	685b      	ldr	r3, [r3, #4]
 800da74:	f04f 31ff 	mov.w	r1, #4294967295
 800da78:	6878      	ldr	r0, [r7, #4]
 800da7a:	4798      	blx	r3
    /* Insert a fake EOI marker */
    src->buffer[0] = (JOCTET) 0xFF;
 800da7c:	68bb      	ldr	r3, [r7, #8]
 800da7e:	6a1b      	ldr	r3, [r3, #32]
 800da80:	22ff      	movs	r2, #255	; 0xff
 800da82:	701a      	strb	r2, [r3, #0]
    src->buffer[1] = (JOCTET) JPEG_EOI;
 800da84:	68bb      	ldr	r3, [r7, #8]
 800da86:	6a1b      	ldr	r3, [r3, #32]
 800da88:	3301      	adds	r3, #1
 800da8a:	22d9      	movs	r2, #217	; 0xd9
 800da8c:	701a      	strb	r2, [r3, #0]
    nbytes = 2;
 800da8e:	2302      	movs	r3, #2
 800da90:	60fb      	str	r3, [r7, #12]
  }

  src->pub.next_input_byte = src->buffer;
 800da92:	68bb      	ldr	r3, [r7, #8]
 800da94:	6a1a      	ldr	r2, [r3, #32]
 800da96:	68bb      	ldr	r3, [r7, #8]
 800da98:	601a      	str	r2, [r3, #0]
  src->pub.bytes_in_buffer = nbytes;
 800da9a:	68bb      	ldr	r3, [r7, #8]
 800da9c:	68fa      	ldr	r2, [r7, #12]
 800da9e:	605a      	str	r2, [r3, #4]
  src->start_of_file = FALSE;
 800daa0:	68bb      	ldr	r3, [r7, #8]
 800daa2:	2200      	movs	r2, #0
 800daa4:	625a      	str	r2, [r3, #36]	; 0x24

  return TRUE;
 800daa6:	2301      	movs	r3, #1
}
 800daa8:	4618      	mov	r0, r3
 800daaa:	3710      	adds	r7, #16
 800daac:	46bd      	mov	sp, r7
 800daae:	bd80      	pop	{r7, pc}

0800dab0 <skip_input_data>:
 * buffer is the application writer's problem.
 */

METHODDEF(void)
skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
 800dab0:	b580      	push	{r7, lr}
 800dab2:	b084      	sub	sp, #16
 800dab4:	af00      	add	r7, sp, #0
 800dab6:	6078      	str	r0, [r7, #4]
 800dab8:	6039      	str	r1, [r7, #0]
  struct jpeg_source_mgr * src = cinfo->src;
 800daba:	687b      	ldr	r3, [r7, #4]
 800dabc:	699b      	ldr	r3, [r3, #24]
 800dabe:	60fb      	str	r3, [r7, #12]

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
 800dac0:	683b      	ldr	r3, [r7, #0]
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	dd1c      	ble.n	800db00 <skip_input_data+0x50>
    while (num_bytes > (long) src->bytes_in_buffer) {
 800dac6:	e009      	b.n	800dadc <skip_input_data+0x2c>
      num_bytes -= (long) src->bytes_in_buffer;
 800dac8:	68fb      	ldr	r3, [r7, #12]
 800daca:	685b      	ldr	r3, [r3, #4]
 800dacc:	461a      	mov	r2, r3
 800dace:	683b      	ldr	r3, [r7, #0]
 800dad0:	1a9b      	subs	r3, r3, r2
 800dad2:	603b      	str	r3, [r7, #0]
      (void) (*src->fill_input_buffer) (cinfo);
 800dad4:	68fb      	ldr	r3, [r7, #12]
 800dad6:	68db      	ldr	r3, [r3, #12]
 800dad8:	6878      	ldr	r0, [r7, #4]
 800dada:	4798      	blx	r3
    while (num_bytes > (long) src->bytes_in_buffer) {
 800dadc:	68fb      	ldr	r3, [r7, #12]
 800dade:	685b      	ldr	r3, [r3, #4]
 800dae0:	461a      	mov	r2, r3
 800dae2:	683b      	ldr	r3, [r7, #0]
 800dae4:	4293      	cmp	r3, r2
 800dae6:	dcef      	bgt.n	800dac8 <skip_input_data+0x18>
      /* note we assume that fill_input_buffer will never return FALSE,
       * so suspension need not be handled.
       */
    }
    src->next_input_byte += (size_t) num_bytes;
 800dae8:	68fb      	ldr	r3, [r7, #12]
 800daea:	681a      	ldr	r2, [r3, #0]
 800daec:	683b      	ldr	r3, [r7, #0]
 800daee:	441a      	add	r2, r3
 800daf0:	68fb      	ldr	r3, [r7, #12]
 800daf2:	601a      	str	r2, [r3, #0]
    src->bytes_in_buffer -= (size_t) num_bytes;
 800daf4:	68fb      	ldr	r3, [r7, #12]
 800daf6:	685a      	ldr	r2, [r3, #4]
 800daf8:	683b      	ldr	r3, [r7, #0]
 800dafa:	1ad2      	subs	r2, r2, r3
 800dafc:	68fb      	ldr	r3, [r7, #12]
 800dafe:	605a      	str	r2, [r3, #4]
  }
}
 800db00:	bf00      	nop
 800db02:	3710      	adds	r7, #16
 800db04:	46bd      	mov	sp, r7
 800db06:	bd80      	pop	{r7, pc}

0800db08 <term_source>:
 * for error exit.
 */

METHODDEF(void)
term_source (j_decompress_ptr cinfo)
{
 800db08:	b480      	push	{r7}
 800db0a:	b083      	sub	sp, #12
 800db0c:	af00      	add	r7, sp, #0
 800db0e:	6078      	str	r0, [r7, #4]
  /* no work necessary here */
}
 800db10:	bf00      	nop
 800db12:	370c      	adds	r7, #12
 800db14:	46bd      	mov	sp, r7
 800db16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db1a:	4770      	bx	lr

0800db1c <jpeg_stdio_src>:
 * for closing it after finishing decompression.
 */
#ifdef JFILE
GLOBAL(void)
jpeg_stdio_src (j_decompress_ptr cinfo, JFILE * infile)
{
 800db1c:	b580      	push	{r7, lr}
 800db1e:	b084      	sub	sp, #16
 800db20:	af00      	add	r7, sp, #0
 800db22:	6078      	str	r0, [r7, #4]
 800db24:	6039      	str	r1, [r7, #0]
   * only before the first one.  (If we discarded the buffer at the end of
   * one image, we'd likely lose the start of the next one.)
   * This makes it unsafe to use this manager and a different source
   * manager serially with the same JPEG object.  Caveat programmer.
   */
  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
 800db26:	687b      	ldr	r3, [r7, #4]
 800db28:	699b      	ldr	r3, [r3, #24]
 800db2a:	2b00      	cmp	r3, #0
 800db2c:	d117      	bne.n	800db5e <jpeg_stdio_src+0x42>
    cinfo->src = (struct jpeg_source_mgr *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 800db2e:	687b      	ldr	r3, [r7, #4]
 800db30:	685b      	ldr	r3, [r3, #4]
 800db32:	681b      	ldr	r3, [r3, #0]
 800db34:	2228      	movs	r2, #40	; 0x28
 800db36:	2100      	movs	r1, #0
 800db38:	6878      	ldr	r0, [r7, #4]
 800db3a:	4798      	blx	r3
 800db3c:	4602      	mov	r2, r0
    cinfo->src = (struct jpeg_source_mgr *)
 800db3e:	687b      	ldr	r3, [r7, #4]
 800db40:	619a      	str	r2, [r3, #24]
				  SIZEOF(my_source_mgr));
    src = (my_src_ptr) cinfo->src;
 800db42:	687b      	ldr	r3, [r7, #4]
 800db44:	699b      	ldr	r3, [r3, #24]
 800db46:	60fb      	str	r3, [r7, #12]
    src->buffer = (JOCTET *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 800db48:	687b      	ldr	r3, [r7, #4]
 800db4a:	685b      	ldr	r3, [r3, #4]
 800db4c:	681b      	ldr	r3, [r3, #0]
 800db4e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800db52:	2100      	movs	r1, #0
 800db54:	6878      	ldr	r0, [r7, #4]
 800db56:	4798      	blx	r3
 800db58:	4602      	mov	r2, r0
    src->buffer = (JOCTET *)
 800db5a:	68fb      	ldr	r3, [r7, #12]
 800db5c:	621a      	str	r2, [r3, #32]
				  INPUT_BUF_SIZE * SIZEOF(JOCTET));
  }

  src = (my_src_ptr) cinfo->src;
 800db5e:	687b      	ldr	r3, [r7, #4]
 800db60:	699b      	ldr	r3, [r3, #24]
 800db62:	60fb      	str	r3, [r7, #12]
  src->pub.init_source = init_source;
 800db64:	68fb      	ldr	r3, [r7, #12]
 800db66:	4a0d      	ldr	r2, [pc, #52]	; (800db9c <jpeg_stdio_src+0x80>)
 800db68:	609a      	str	r2, [r3, #8]
  src->pub.fill_input_buffer = fill_input_buffer;
 800db6a:	68fb      	ldr	r3, [r7, #12]
 800db6c:	4a0c      	ldr	r2, [pc, #48]	; (800dba0 <jpeg_stdio_src+0x84>)
 800db6e:	60da      	str	r2, [r3, #12]
  src->pub.skip_input_data = skip_input_data;
 800db70:	68fb      	ldr	r3, [r7, #12]
 800db72:	4a0c      	ldr	r2, [pc, #48]	; (800dba4 <jpeg_stdio_src+0x88>)
 800db74:	611a      	str	r2, [r3, #16]
  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
 800db76:	68fb      	ldr	r3, [r7, #12]
 800db78:	4a0b      	ldr	r2, [pc, #44]	; (800dba8 <jpeg_stdio_src+0x8c>)
 800db7a:	615a      	str	r2, [r3, #20]
  src->pub.term_source = term_source;
 800db7c:	68fb      	ldr	r3, [r7, #12]
 800db7e:	4a0b      	ldr	r2, [pc, #44]	; (800dbac <jpeg_stdio_src+0x90>)
 800db80:	619a      	str	r2, [r3, #24]
  src->infile = infile;
 800db82:	68fb      	ldr	r3, [r7, #12]
 800db84:	683a      	ldr	r2, [r7, #0]
 800db86:	61da      	str	r2, [r3, #28]
  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
 800db88:	68fb      	ldr	r3, [r7, #12]
 800db8a:	2200      	movs	r2, #0
 800db8c:	605a      	str	r2, [r3, #4]
  src->pub.next_input_byte = NULL; /* until buffer loaded */
 800db8e:	68fb      	ldr	r3, [r7, #12]
 800db90:	2200      	movs	r2, #0
 800db92:	601a      	str	r2, [r3, #0]
}
 800db94:	bf00      	nop
 800db96:	3710      	adds	r7, #16
 800db98:	46bd      	mov	sp, r7
 800db9a:	bd80      	pop	{r7, pc}
 800db9c:	0800da05 	.word	0x0800da05
 800dba0:	0800da25 	.word	0x0800da25
 800dba4:	0800dab1 	.word	0x0800dab1
 800dba8:	08015961 	.word	0x08015961
 800dbac:	0800db09 	.word	0x0800db09

0800dbb0 <start_iMCU_row>:


LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
 800dbb0:	b480      	push	{r7}
 800dbb2:	b085      	sub	sp, #20
 800dbb4:	af00      	add	r7, sp, #0
 800dbb6:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800dbb8:	687b      	ldr	r3, [r7, #4]
 800dbba:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800dbbe:	60fb      	str	r3, [r7, #12]

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
 800dbc0:	687b      	ldr	r3, [r7, #4]
 800dbc2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800dbc6:	2b01      	cmp	r3, #1
 800dbc8:	dd03      	ble.n	800dbd2 <start_iMCU_row+0x22>
    coef->MCU_rows_per_iMCU_row = 1;
 800dbca:	68fb      	ldr	r3, [r7, #12]
 800dbcc:	2201      	movs	r2, #1
 800dbce:	61da      	str	r2, [r3, #28]
 800dbd0:	e015      	b.n	800dbfe <start_iMCU_row+0x4e>
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
 800dbd2:	687b      	ldr	r3, [r7, #4]
 800dbd4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800dbd8:	687b      	ldr	r3, [r7, #4]
 800dbda:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800dbde:	3b01      	subs	r3, #1
 800dbe0:	429a      	cmp	r2, r3
 800dbe2:	d206      	bcs.n	800dbf2 <start_iMCU_row+0x42>
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 800dbea:	68da      	ldr	r2, [r3, #12]
 800dbec:	68fb      	ldr	r3, [r7, #12]
 800dbee:	61da      	str	r2, [r3, #28]
 800dbf0:	e005      	b.n	800dbfe <start_iMCU_row+0x4e>
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
 800dbf2:	687b      	ldr	r3, [r7, #4]
 800dbf4:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 800dbf8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800dbfa:	68fb      	ldr	r3, [r7, #12]
 800dbfc:	61da      	str	r2, [r3, #28]
  }

  coef->MCU_ctr = 0;
 800dbfe:	68fb      	ldr	r3, [r7, #12]
 800dc00:	2200      	movs	r2, #0
 800dc02:	615a      	str	r2, [r3, #20]
  coef->MCU_vert_offset = 0;
 800dc04:	68fb      	ldr	r3, [r7, #12]
 800dc06:	2200      	movs	r2, #0
 800dc08:	619a      	str	r2, [r3, #24]
}
 800dc0a:	bf00      	nop
 800dc0c:	3714      	adds	r7, #20
 800dc0e:	46bd      	mov	sp, r7
 800dc10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc14:	4770      	bx	lr

0800dc16 <start_input_pass>:
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 800dc16:	b580      	push	{r7, lr}
 800dc18:	b082      	sub	sp, #8
 800dc1a:	af00      	add	r7, sp, #0
 800dc1c:	6078      	str	r0, [r7, #4]
  cinfo->input_iMCU_row = 0;
 800dc1e:	687b      	ldr	r3, [r7, #4]
 800dc20:	2200      	movs	r2, #0
 800dc22:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  start_iMCU_row(cinfo);
 800dc26:	6878      	ldr	r0, [r7, #4]
 800dc28:	f7ff ffc2 	bl	800dbb0 <start_iMCU_row>
}
 800dc2c:	bf00      	nop
 800dc2e:	3708      	adds	r7, #8
 800dc30:	46bd      	mov	sp, r7
 800dc32:	bd80      	pop	{r7, pc}

0800dc34 <start_output_pass>:
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
 800dc34:	b580      	push	{r7, lr}
 800dc36:	b084      	sub	sp, #16
 800dc38:	af00      	add	r7, sp, #0
 800dc3a:	6078      	str	r0, [r7, #4]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800dc3c:	687b      	ldr	r3, [r7, #4]
 800dc3e:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800dc42:	60fb      	str	r3, [r7, #12]

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
 800dc44:	68fb      	ldr	r3, [r7, #12]
 800dc46:	691b      	ldr	r3, [r3, #16]
 800dc48:	2b00      	cmp	r3, #0
 800dc4a:	d010      	beq.n	800dc6e <start_output_pass+0x3a>
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
 800dc4c:	687b      	ldr	r3, [r7, #4]
 800dc4e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800dc50:	2b00      	cmp	r3, #0
 800dc52:	d009      	beq.n	800dc68 <start_output_pass+0x34>
 800dc54:	6878      	ldr	r0, [r7, #4]
 800dc56:	f000 fad2 	bl	800e1fe <smoothing_ok>
 800dc5a:	4603      	mov	r3, r0
 800dc5c:	2b00      	cmp	r3, #0
 800dc5e:	d003      	beq.n	800dc68 <start_output_pass+0x34>
      coef->pub.decompress_data = decompress_smooth_data;
 800dc60:	68fb      	ldr	r3, [r7, #12]
 800dc62:	4a07      	ldr	r2, [pc, #28]	; (800dc80 <start_output_pass+0x4c>)
 800dc64:	60da      	str	r2, [r3, #12]
 800dc66:	e002      	b.n	800dc6e <start_output_pass+0x3a>
    else
      coef->pub.decompress_data = decompress_data;
 800dc68:	68fb      	ldr	r3, [r7, #12]
 800dc6a:	4a06      	ldr	r2, [pc, #24]	; (800dc84 <start_output_pass+0x50>)
 800dc6c:	60da      	str	r2, [r3, #12]
  }
#endif
  cinfo->output_iMCU_row = 0;
 800dc6e:	687b      	ldr	r3, [r7, #4]
 800dc70:	2200      	movs	r2, #0
 800dc72:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
}
 800dc76:	bf00      	nop
 800dc78:	3710      	adds	r7, #16
 800dc7a:	46bd      	mov	sp, r7
 800dc7c:	bd80      	pop	{r7, pc}
 800dc7e:	bf00      	nop
 800dc80:	0800e325 	.word	0x0800e325
 800dc84:	0800e055 	.word	0x0800e055

0800dc88 <decompress_onepass>:
 * which we index according to the component's SOF position.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 800dc88:	b590      	push	{r4, r7, lr}
 800dc8a:	b095      	sub	sp, #84	; 0x54
 800dc8c:	af02      	add	r7, sp, #8
 800dc8e:	6078      	str	r0, [r7, #4]
 800dc90:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800dc92:	687b      	ldr	r3, [r7, #4]
 800dc94:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800dc98:	627b      	str	r3, [r7, #36]	; 0x24
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
 800dc9a:	687b      	ldr	r3, [r7, #4]
 800dc9c:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
 800dca0:	3b01      	subs	r3, #1
 800dca2:	623b      	str	r3, [r7, #32]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 800dca4:	687b      	ldr	r3, [r7, #4]
 800dca6:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800dcaa:	3b01      	subs	r3, #1
 800dcac:	61fb      	str	r3, [r7, #28]
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 800dcae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcb0:	699b      	ldr	r3, [r3, #24]
 800dcb2:	633b      	str	r3, [r7, #48]	; 0x30
 800dcb4:	e0bf      	b.n	800de36 <decompress_onepass+0x1ae>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 800dcb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcb8:	695b      	ldr	r3, [r3, #20]
 800dcba:	647b      	str	r3, [r7, #68]	; 0x44
 800dcbc:	e0b0      	b.n	800de20 <decompress_onepass+0x198>
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      if (cinfo->lim_Se)	/* can bypass in DC only case */
 800dcbe:	687b      	ldr	r3, [r7, #4]
 800dcc0:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800dcc4:	2b00      	cmp	r3, #0
 800dcc6:	d009      	beq.n	800dcdc <decompress_onepass+0x54>
	FMEMZERO((void FAR *) coef->MCU_buffer[0],
 800dcc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcca:	6a18      	ldr	r0, [r3, #32]
 800dccc:	687b      	ldr	r3, [r7, #4]
 800dcce:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 800dcd2:	01db      	lsls	r3, r3, #7
 800dcd4:	461a      	mov	r2, r3
 800dcd6:	2100      	movs	r1, #0
 800dcd8:	f01a fad2 	bl	8028280 <memset>
		 (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800dce2:	685b      	ldr	r3, [r3, #4]
 800dce4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800dce6:	3220      	adds	r2, #32
 800dce8:	4611      	mov	r1, r2
 800dcea:	6878      	ldr	r0, [r7, #4]
 800dcec:	4798      	blx	r3
 800dcee:	4603      	mov	r3, r0
 800dcf0:	2b00      	cmp	r3, #0
 800dcf2:	d107      	bne.n	800dd04 <decompress_onepass+0x7c>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 800dcf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcf6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800dcf8:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 800dcfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcfc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800dcfe:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 800dd00:	2300      	movs	r3, #0
 800dd02:	e0c0      	b.n	800de86 <decompress_onepass+0x1fe>
      /* Determine where data should go in output_buf and do the IDCT thing.
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
 800dd04:	2300      	movs	r3, #0
 800dd06:	643b      	str	r3, [r7, #64]	; 0x40
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800dd08:	2300      	movs	r3, #0
 800dd0a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800dd0c:	e07e      	b.n	800de0c <decompress_onepass+0x184>
	compptr = cinfo->cur_comp_info[ci];
 800dd0e:	687a      	ldr	r2, [r7, #4]
 800dd10:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dd12:	3354      	adds	r3, #84	; 0x54
 800dd14:	009b      	lsls	r3, r3, #2
 800dd16:	4413      	add	r3, r2
 800dd18:	685b      	ldr	r3, [r3, #4]
 800dd1a:	61bb      	str	r3, [r7, #24]
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
 800dd1c:	69bb      	ldr	r3, [r7, #24]
 800dd1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800dd20:	2b00      	cmp	r3, #0
 800dd22:	d105      	bne.n	800dd30 <decompress_onepass+0xa8>
	  blkn += compptr->MCU_blocks;
 800dd24:	69bb      	ldr	r3, [r7, #24]
 800dd26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dd28:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800dd2a:	4413      	add	r3, r2
 800dd2c:	643b      	str	r3, [r7, #64]	; 0x40
	  continue;
 800dd2e:	e06a      	b.n	800de06 <decompress_onepass+0x17e>
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
 800dd30:	687b      	ldr	r3, [r7, #4]
 800dd32:	f8d3 21d4 	ldr.w	r2, [r3, #468]	; 0x1d4
 800dd36:	69bb      	ldr	r3, [r7, #24]
 800dd38:	685b      	ldr	r3, [r3, #4]
 800dd3a:	009b      	lsls	r3, r3, #2
 800dd3c:	4413      	add	r3, r2
 800dd3e:	685b      	ldr	r3, [r3, #4]
 800dd40:	617b      	str	r3, [r7, #20]
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
 800dd42:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800dd44:	6a3b      	ldr	r3, [r7, #32]
 800dd46:	429a      	cmp	r2, r3
 800dd48:	d202      	bcs.n	800dd50 <decompress_onepass+0xc8>
 800dd4a:	69bb      	ldr	r3, [r7, #24]
 800dd4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dd4e:	e001      	b.n	800dd54 <decompress_onepass+0xcc>
 800dd50:	69bb      	ldr	r3, [r7, #24]
 800dd52:	6c9b      	ldr	r3, [r3, #72]	; 0x48
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
 800dd54:	613b      	str	r3, [r7, #16]
	output_ptr = output_buf[compptr->component_index] +
 800dd56:	69bb      	ldr	r3, [r7, #24]
 800dd58:	685b      	ldr	r3, [r3, #4]
 800dd5a:	009b      	lsls	r3, r3, #2
 800dd5c:	683a      	ldr	r2, [r7, #0]
 800dd5e:	4413      	add	r3, r2
 800dd60:	681a      	ldr	r2, [r3, #0]
	  yoffset * compptr->DCT_v_scaled_size;
 800dd62:	69bb      	ldr	r3, [r7, #24]
 800dd64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dd66:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800dd68:	fb01 f303 	mul.w	r3, r1, r3
	output_ptr = output_buf[compptr->component_index] +
 800dd6c:	009b      	lsls	r3, r3, #2
 800dd6e:	4413      	add	r3, r2
 800dd70:	62fb      	str	r3, [r7, #44]	; 0x2c
	start_col = MCU_col_num * compptr->MCU_sample_width;
 800dd72:	69bb      	ldr	r3, [r7, #24]
 800dd74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dd76:	461a      	mov	r2, r3
 800dd78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800dd7a:	fb02 f303 	mul.w	r3, r2, r3
 800dd7e:	60fb      	str	r3, [r7, #12]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 800dd80:	2300      	movs	r3, #0
 800dd82:	637b      	str	r3, [r7, #52]	; 0x34
 800dd84:	e03a      	b.n	800ddfc <decompress_onepass+0x174>
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 800dd86:	687b      	ldr	r3, [r7, #4]
 800dd88:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800dd8c:	69fa      	ldr	r2, [r7, #28]
 800dd8e:	429a      	cmp	r2, r3
 800dd90:	d806      	bhi.n	800dda0 <decompress_onepass+0x118>
	      yoffset+yindex < compptr->last_row_height) {
 800dd92:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800dd94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd96:	441a      	add	r2, r3
 800dd98:	69bb      	ldr	r3, [r7, #24]
 800dd9a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
 800dd9c:	429a      	cmp	r2, r3
 800dd9e:	da1f      	bge.n	800dde0 <decompress_onepass+0x158>
	    output_col = start_col;
 800dda0:	68fb      	ldr	r3, [r7, #12]
 800dda2:	62bb      	str	r3, [r7, #40]	; 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 800dda4:	2300      	movs	r3, #0
 800dda6:	63bb      	str	r3, [r7, #56]	; 0x38
 800dda8:	e016      	b.n	800ddd8 <decompress_onepass+0x150>
	      (*inverse_DCT) (cinfo, compptr,
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
 800ddaa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ddac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ddae:	441a      	add	r2, r3
 800ddb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ddb2:	3208      	adds	r2, #8
 800ddb4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	      (*inverse_DCT) (cinfo, compptr,
 800ddb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ddba:	9300      	str	r3, [sp, #0]
 800ddbc:	697c      	ldr	r4, [r7, #20]
 800ddbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ddc0:	69b9      	ldr	r1, [r7, #24]
 800ddc2:	6878      	ldr	r0, [r7, #4]
 800ddc4:	47a0      	blx	r4
			      output_ptr, output_col);
	      output_col += compptr->DCT_h_scaled_size;
 800ddc6:	69bb      	ldr	r3, [r7, #24]
 800ddc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddca:	461a      	mov	r2, r3
 800ddcc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ddce:	4413      	add	r3, r2
 800ddd0:	62bb      	str	r3, [r7, #40]	; 0x28
	    for (xindex = 0; xindex < useful_width; xindex++) {
 800ddd2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ddd4:	3301      	adds	r3, #1
 800ddd6:	63bb      	str	r3, [r7, #56]	; 0x38
 800ddd8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ddda:	693b      	ldr	r3, [r7, #16]
 800dddc:	429a      	cmp	r2, r3
 800ddde:	dbe4      	blt.n	800ddaa <decompress_onepass+0x122>
	    }
	  }
	  blkn += compptr->MCU_width;
 800dde0:	69bb      	ldr	r3, [r7, #24]
 800dde2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dde4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800dde6:	4413      	add	r3, r2
 800dde8:	643b      	str	r3, [r7, #64]	; 0x40
	  output_ptr += compptr->DCT_v_scaled_size;
 800ddea:	69bb      	ldr	r3, [r7, #24]
 800ddec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ddee:	009b      	lsls	r3, r3, #2
 800ddf0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ddf2:	4413      	add	r3, r2
 800ddf4:	62fb      	str	r3, [r7, #44]	; 0x2c
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 800ddf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ddf8:	3301      	adds	r3, #1
 800ddfa:	637b      	str	r3, [r7, #52]	; 0x34
 800ddfc:	69bb      	ldr	r3, [r7, #24]
 800ddfe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800de00:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800de02:	429a      	cmp	r2, r3
 800de04:	dbbf      	blt.n	800dd86 <decompress_onepass+0xfe>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800de06:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800de08:	3301      	adds	r3, #1
 800de0a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800de0c:	687b      	ldr	r3, [r7, #4]
 800de0e:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800de12:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800de14:	429a      	cmp	r2, r3
 800de16:	f6ff af7a 	blt.w	800dd0e <decompress_onepass+0x86>
	 MCU_col_num++) {
 800de1a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800de1c:	3301      	adds	r3, #1
 800de1e:	647b      	str	r3, [r7, #68]	; 0x44
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
 800de20:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800de22:	6a3b      	ldr	r3, [r7, #32]
 800de24:	429a      	cmp	r2, r3
 800de26:	f67f af4a 	bls.w	800dcbe <decompress_onepass+0x36>
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 800de2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de2c:	2200      	movs	r2, #0
 800de2e:	615a      	str	r2, [r3, #20]
       yoffset++) {
 800de30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de32:	3301      	adds	r3, #1
 800de34:	633b      	str	r3, [r7, #48]	; 0x30
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 800de36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800de38:	69db      	ldr	r3, [r3, #28]
 800de3a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800de3c:	429a      	cmp	r2, r3
 800de3e:	f6ff af3a 	blt.w	800dcb6 <decompress_onepass+0x2e>
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
 800de42:	687b      	ldr	r3, [r7, #4]
 800de44:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800de48:	1c5a      	adds	r2, r3, #1
 800de4a:	687b      	ldr	r3, [r7, #4]
 800de4c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 800de50:	687b      	ldr	r3, [r7, #4]
 800de52:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800de56:	1c5a      	adds	r2, r3, #1
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 800de5e:	687b      	ldr	r3, [r7, #4]
 800de60:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800de64:	687b      	ldr	r3, [r7, #4]
 800de66:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800de6a:	429a      	cmp	r2, r3
 800de6c:	d204      	bcs.n	800de78 <decompress_onepass+0x1f0>
    start_iMCU_row(cinfo);
 800de6e:	6878      	ldr	r0, [r7, #4]
 800de70:	f7ff fe9e 	bl	800dbb0 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 800de74:	2303      	movs	r3, #3
 800de76:	e006      	b.n	800de86 <decompress_onepass+0x1fe>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800de7e:	68db      	ldr	r3, [r3, #12]
 800de80:	6878      	ldr	r0, [r7, #4]
 800de82:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 800de84:	2304      	movs	r3, #4
}
 800de86:	4618      	mov	r0, r3
 800de88:	374c      	adds	r7, #76	; 0x4c
 800de8a:	46bd      	mov	sp, r7
 800de8c:	bd90      	pop	{r4, r7, pc}

0800de8e <dummy_consume_data>:
 * Dummy consume-input routine for single-pass operation.
 */

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
 800de8e:	b480      	push	{r7}
 800de90:	b083      	sub	sp, #12
 800de92:	af00      	add	r7, sp, #0
 800de94:	6078      	str	r0, [r7, #4]
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
 800de96:	2300      	movs	r3, #0
}
 800de98:	4618      	mov	r0, r3
 800de9a:	370c      	adds	r7, #12
 800de9c:	46bd      	mov	sp, r7
 800de9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dea2:	4770      	bx	lr

0800dea4 <consume_data>:
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
 800dea4:	b590      	push	{r4, r7, lr}
 800dea6:	b093      	sub	sp, #76	; 0x4c
 800dea8:	af02      	add	r7, sp, #8
 800deaa:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800deac:	687b      	ldr	r3, [r7, #4]
 800deae:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800deb2:	623b      	str	r3, [r7, #32]
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800deb4:	2300      	movs	r3, #0
 800deb6:	637b      	str	r3, [r7, #52]	; 0x34
 800deb8:	e029      	b.n	800df0e <consume_data+0x6a>
    compptr = cinfo->cur_comp_info[ci];
 800deba:	687a      	ldr	r2, [r7, #4]
 800debc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800debe:	3354      	adds	r3, #84	; 0x54
 800dec0:	009b      	lsls	r3, r3, #2
 800dec2:	4413      	add	r3, r2
 800dec4:	685b      	ldr	r3, [r3, #4]
 800dec6:	61fb      	str	r3, [r7, #28]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 800dec8:	687b      	ldr	r3, [r7, #4]
 800deca:	685b      	ldr	r3, [r3, #4]
 800decc:	6a1c      	ldr	r4, [r3, #32]
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
 800dece:	69fb      	ldr	r3, [r7, #28]
 800ded0:	685a      	ldr	r2, [r3, #4]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 800ded2:	6a3b      	ldr	r3, [r7, #32]
 800ded4:	3212      	adds	r2, #18
 800ded6:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
       cinfo->input_iMCU_row * compptr->v_samp_factor,
 800deda:	687b      	ldr	r3, [r7, #4]
 800dedc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800dee0:	69fa      	ldr	r2, [r7, #28]
 800dee2:	68d2      	ldr	r2, [r2, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 800dee4:	fb02 f203 	mul.w	r2, r2, r3
       (JDIMENSION) compptr->v_samp_factor, TRUE);
 800dee8:	69fb      	ldr	r3, [r7, #28]
 800deea:	68db      	ldr	r3, [r3, #12]
    buffer[ci] = (*cinfo->mem->access_virt_barray)
 800deec:	4618      	mov	r0, r3
 800deee:	2301      	movs	r3, #1
 800def0:	9300      	str	r3, [sp, #0]
 800def2:	4603      	mov	r3, r0
 800def4:	6878      	ldr	r0, [r7, #4]
 800def6:	47a0      	blx	r4
 800def8:	4602      	mov	r2, r0
 800defa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800defc:	009b      	lsls	r3, r3, #2
 800defe:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800df02:	440b      	add	r3, r1
 800df04:	f843 2c38 	str.w	r2, [r3, #-56]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800df08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df0a:	3301      	adds	r3, #1
 800df0c:	637b      	str	r3, [r7, #52]	; 0x34
 800df0e:	687b      	ldr	r3, [r7, #4]
 800df10:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800df14:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800df16:	429a      	cmp	r2, r3
 800df18:	dbcf      	blt.n	800deba <consume_data+0x16>
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 800df1a:	6a3b      	ldr	r3, [r7, #32]
 800df1c:	699b      	ldr	r3, [r3, #24]
 800df1e:	62bb      	str	r3, [r7, #40]	; 0x28
 800df20:	e074      	b.n	800e00c <consume_data+0x168>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 800df22:	6a3b      	ldr	r3, [r7, #32]
 800df24:	695b      	ldr	r3, [r3, #20]
 800df26:	63fb      	str	r3, [r7, #60]	; 0x3c
 800df28:	e064      	b.n	800dff4 <consume_data+0x150>
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
 800df2a:	2300      	movs	r3, #0
 800df2c:	63bb      	str	r3, [r7, #56]	; 0x38
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800df2e:	2300      	movs	r3, #0
 800df30:	637b      	str	r3, [r7, #52]	; 0x34
 800df32:	e042      	b.n	800dfba <consume_data+0x116>
	compptr = cinfo->cur_comp_info[ci];
 800df34:	687a      	ldr	r2, [r7, #4]
 800df36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df38:	3354      	adds	r3, #84	; 0x54
 800df3a:	009b      	lsls	r3, r3, #2
 800df3c:	4413      	add	r3, r2
 800df3e:	685b      	ldr	r3, [r3, #4]
 800df40:	61fb      	str	r3, [r7, #28]
	start_col = MCU_col_num * compptr->MCU_width;
 800df42:	69fb      	ldr	r3, [r7, #28]
 800df44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800df46:	461a      	mov	r2, r3
 800df48:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800df4a:	fb02 f303 	mul.w	r3, r2, r3
 800df4e:	61bb      	str	r3, [r7, #24]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 800df50:	2300      	movs	r3, #0
 800df52:	62fb      	str	r3, [r7, #44]	; 0x2c
 800df54:	e029      	b.n	800dfaa <consume_data+0x106>
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
 800df56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800df58:	009b      	lsls	r3, r3, #2
 800df5a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800df5e:	4413      	add	r3, r2
 800df60:	f853 2c38 	ldr.w	r2, [r3, #-56]
 800df64:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800df66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800df68:	440b      	add	r3, r1
 800df6a:	009b      	lsls	r3, r3, #2
 800df6c:	4413      	add	r3, r2
 800df6e:	681a      	ldr	r2, [r3, #0]
 800df70:	69bb      	ldr	r3, [r7, #24]
 800df72:	01db      	lsls	r3, r3, #7
 800df74:	4413      	add	r3, r2
 800df76:	627b      	str	r3, [r7, #36]	; 0x24
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 800df78:	2300      	movs	r3, #0
 800df7a:	633b      	str	r3, [r7, #48]	; 0x30
 800df7c:	e00d      	b.n	800df9a <consume_data+0xf6>
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
 800df7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800df80:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800df84:	627a      	str	r2, [r7, #36]	; 0x24
 800df86:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800df88:	1c51      	adds	r1, r2, #1
 800df8a:	63b9      	str	r1, [r7, #56]	; 0x38
 800df8c:	6a39      	ldr	r1, [r7, #32]
 800df8e:	3208      	adds	r2, #8
 800df90:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
 800df94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800df96:	3301      	adds	r3, #1
 800df98:	633b      	str	r3, [r7, #48]	; 0x30
 800df9a:	69fb      	ldr	r3, [r7, #28]
 800df9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800df9e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800dfa0:	429a      	cmp	r2, r3
 800dfa2:	dbec      	blt.n	800df7e <consume_data+0xda>
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 800dfa4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dfa6:	3301      	adds	r3, #1
 800dfa8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800dfaa:	69fb      	ldr	r3, [r7, #28]
 800dfac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800dfae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dfb0:	429a      	cmp	r2, r3
 800dfb2:	dbd0      	blt.n	800df56 <consume_data+0xb2>
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 800dfb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dfb6:	3301      	adds	r3, #1
 800dfb8:	637b      	str	r3, [r7, #52]	; 0x34
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800dfc0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dfc2:	429a      	cmp	r2, r3
 800dfc4:	dbb6      	blt.n	800df34 <consume_data+0x90>
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
 800dfc6:	687b      	ldr	r3, [r7, #4]
 800dfc8:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 800dfcc:	685b      	ldr	r3, [r3, #4]
 800dfce:	6a3a      	ldr	r2, [r7, #32]
 800dfd0:	3220      	adds	r2, #32
 800dfd2:	4611      	mov	r1, r2
 800dfd4:	6878      	ldr	r0, [r7, #4]
 800dfd6:	4798      	blx	r3
 800dfd8:	4603      	mov	r3, r0
 800dfda:	2b00      	cmp	r3, #0
 800dfdc:	d107      	bne.n	800dfee <consume_data+0x14a>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
 800dfde:	6a3b      	ldr	r3, [r7, #32]
 800dfe0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dfe2:	619a      	str	r2, [r3, #24]
	coef->MCU_ctr = MCU_col_num;
 800dfe4:	6a3b      	ldr	r3, [r7, #32]
 800dfe6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800dfe8:	615a      	str	r2, [r3, #20]
	return JPEG_SUSPENDED;
 800dfea:	2300      	movs	r3, #0
 800dfec:	e02e      	b.n	800e04c <consume_data+0x1a8>
	 MCU_col_num++) {
 800dfee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dff0:	3301      	adds	r3, #1
 800dff2:	63fb      	str	r3, [r7, #60]	; 0x3c
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
 800dff4:	687b      	ldr	r3, [r7, #4]
 800dff6:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
 800dffa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800dffc:	429a      	cmp	r2, r3
 800dffe:	d394      	bcc.n	800df2a <consume_data+0x86>
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
 800e000:	6a3b      	ldr	r3, [r7, #32]
 800e002:	2200      	movs	r2, #0
 800e004:	615a      	str	r2, [r3, #20]
       yoffset++) {
 800e006:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e008:	3301      	adds	r3, #1
 800e00a:	62bb      	str	r3, [r7, #40]	; 0x28
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
 800e00c:	6a3b      	ldr	r3, [r7, #32]
 800e00e:	69db      	ldr	r3, [r3, #28]
 800e010:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e012:	429a      	cmp	r2, r3
 800e014:	db85      	blt.n	800df22 <consume_data+0x7e>
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
 800e016:	687b      	ldr	r3, [r7, #4]
 800e018:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800e01c:	1c5a      	adds	r2, r3, #1
 800e01e:	687b      	ldr	r3, [r7, #4]
 800e020:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800e02a:	687b      	ldr	r3, [r7, #4]
 800e02c:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800e030:	429a      	cmp	r2, r3
 800e032:	d204      	bcs.n	800e03e <consume_data+0x19a>
    start_iMCU_row(cinfo);
 800e034:	6878      	ldr	r0, [r7, #4]
 800e036:	f7ff fdbb 	bl	800dbb0 <start_iMCU_row>
    return JPEG_ROW_COMPLETED;
 800e03a:	2303      	movs	r3, #3
 800e03c:	e006      	b.n	800e04c <consume_data+0x1a8>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800e044:	68db      	ldr	r3, [r3, #12]
 800e046:	6878      	ldr	r0, [r7, #4]
 800e048:	4798      	blx	r3
  return JPEG_SCAN_COMPLETED;
 800e04a:	2304      	movs	r3, #4
}
 800e04c:	4618      	mov	r0, r3
 800e04e:	3744      	adds	r7, #68	; 0x44
 800e050:	46bd      	mov	sp, r7
 800e052:	bd90      	pop	{r4, r7, pc}

0800e054 <decompress_data>:
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 800e054:	b590      	push	{r4, r7, lr}
 800e056:	b091      	sub	sp, #68	; 0x44
 800e058:	af02      	add	r7, sp, #8
 800e05a:	6078      	str	r0, [r7, #4]
 800e05c:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800e064:	617b      	str	r3, [r7, #20]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 800e066:	687b      	ldr	r3, [r7, #4]
 800e068:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800e06c:	3b01      	subs	r3, #1
 800e06e:	613b      	str	r3, [r7, #16]
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 800e070:	e00a      	b.n	800e088 <decompress_data+0x34>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 800e072:	687b      	ldr	r3, [r7, #4]
 800e074:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800e078:	681b      	ldr	r3, [r3, #0]
 800e07a:	6878      	ldr	r0, [r7, #4]
 800e07c:	4798      	blx	r3
 800e07e:	4603      	mov	r3, r0
 800e080:	2b00      	cmp	r3, #0
 800e082:	d101      	bne.n	800e088 <decompress_data+0x34>
      return JPEG_SUSPENDED;
 800e084:	2300      	movs	r3, #0
 800e086:	e0b6      	b.n	800e1f6 <decompress_data+0x1a2>
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 800e088:	687b      	ldr	r3, [r7, #4]
 800e08a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800e08e:	687b      	ldr	r3, [r7, #4]
 800e090:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800e094:	429a      	cmp	r2, r3
 800e096:	dbec      	blt.n	800e072 <decompress_data+0x1e>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 800e098:	687b      	ldr	r3, [r7, #4]
 800e09a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800e09e:	687b      	ldr	r3, [r7, #4]
 800e0a0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
 800e0a4:	429a      	cmp	r2, r3
 800e0a6:	d107      	bne.n	800e0b8 <decompress_data+0x64>
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
 800e0a8:	687b      	ldr	r3, [r7, #4]
 800e0aa:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800e0ae:	687b      	ldr	r3, [r7, #4]
 800e0b0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 800e0b4:	429a      	cmp	r2, r3
 800e0b6:	d9dc      	bls.n	800e072 <decompress_data+0x1e>
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800e0b8:	2300      	movs	r3, #0
 800e0ba:	633b      	str	r3, [r7, #48]	; 0x30
 800e0bc:	687b      	ldr	r3, [r7, #4]
 800e0be:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e0c2:	61bb      	str	r3, [r7, #24]
 800e0c4:	e07f      	b.n	800e1c6 <decompress_data+0x172>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 800e0c6:	69bb      	ldr	r3, [r7, #24]
 800e0c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e0ca:	2b00      	cmp	r3, #0
 800e0cc:	d074      	beq.n	800e1b8 <decompress_data+0x164>
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
 800e0ce:	687b      	ldr	r3, [r7, #4]
 800e0d0:	685b      	ldr	r3, [r3, #4]
 800e0d2:	6a1c      	ldr	r4, [r3, #32]
 800e0d4:	697b      	ldr	r3, [r7, #20]
 800e0d6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e0d8:	3212      	adds	r2, #18
 800e0da:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
 800e0de:	687b      	ldr	r3, [r7, #4]
 800e0e0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e0e4:	69ba      	ldr	r2, [r7, #24]
 800e0e6:	68d2      	ldr	r2, [r2, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 800e0e8:	fb02 f203 	mul.w	r2, r2, r3
       (JDIMENSION) compptr->v_samp_factor, FALSE);
 800e0ec:	69bb      	ldr	r3, [r7, #24]
 800e0ee:	68db      	ldr	r3, [r3, #12]
    buffer = (*cinfo->mem->access_virt_barray)
 800e0f0:	4618      	mov	r0, r3
 800e0f2:	2300      	movs	r3, #0
 800e0f4:	9300      	str	r3, [sp, #0]
 800e0f6:	4603      	mov	r3, r0
 800e0f8:	6878      	ldr	r0, [r7, #4]
 800e0fa:	47a0      	blx	r4
 800e0fc:	60f8      	str	r0, [r7, #12]
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
 800e0fe:	687b      	ldr	r3, [r7, #4]
 800e100:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e104:	693a      	ldr	r2, [r7, #16]
 800e106:	429a      	cmp	r2, r3
 800e108:	d903      	bls.n	800e112 <decompress_data+0xbe>
      block_rows = compptr->v_samp_factor;
 800e10a:	69bb      	ldr	r3, [r7, #24]
 800e10c:	68db      	ldr	r3, [r3, #12]
 800e10e:	62bb      	str	r3, [r7, #40]	; 0x28
 800e110:	e00f      	b.n	800e132 <decompress_data+0xde>
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 800e112:	69bb      	ldr	r3, [r7, #24]
 800e114:	6a1b      	ldr	r3, [r3, #32]
 800e116:	69ba      	ldr	r2, [r7, #24]
 800e118:	68d2      	ldr	r2, [r2, #12]
 800e11a:	fbb3 f1f2 	udiv	r1, r3, r2
 800e11e:	fb02 f201 	mul.w	r2, r2, r1
 800e122:	1a9b      	subs	r3, r3, r2
 800e124:	62bb      	str	r3, [r7, #40]	; 0x28
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 800e126:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e128:	2b00      	cmp	r3, #0
 800e12a:	d102      	bne.n	800e132 <decompress_data+0xde>
 800e12c:	69bb      	ldr	r3, [r7, #24]
 800e12e:	68db      	ldr	r3, [r3, #12]
 800e130:	62bb      	str	r3, [r7, #40]	; 0x28
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 800e132:	687b      	ldr	r3, [r7, #4]
 800e134:	f8d3 21d4 	ldr.w	r2, [r3, #468]	; 0x1d4
 800e138:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e13a:	009b      	lsls	r3, r3, #2
 800e13c:	4413      	add	r3, r2
 800e13e:	685b      	ldr	r3, [r3, #4]
 800e140:	60bb      	str	r3, [r7, #8]
    output_ptr = output_buf[ci];
 800e142:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e144:	009b      	lsls	r3, r3, #2
 800e146:	683a      	ldr	r2, [r7, #0]
 800e148:	4413      	add	r3, r2
 800e14a:	681b      	ldr	r3, [r3, #0]
 800e14c:	623b      	str	r3, [r7, #32]
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 800e14e:	2300      	movs	r3, #0
 800e150:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e152:	e02c      	b.n	800e1ae <decompress_data+0x15a>
      buffer_ptr = buffer[block_row];
 800e154:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e156:	009b      	lsls	r3, r3, #2
 800e158:	68fa      	ldr	r2, [r7, #12]
 800e15a:	4413      	add	r3, r2
 800e15c:	681b      	ldr	r3, [r3, #0]
 800e15e:	627b      	str	r3, [r7, #36]	; 0x24
      output_col = 0;
 800e160:	2300      	movs	r3, #0
 800e162:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 800e164:	2300      	movs	r3, #0
 800e166:	637b      	str	r3, [r7, #52]	; 0x34
 800e168:	e013      	b.n	800e192 <decompress_data+0x13e>
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
 800e16a:	69fb      	ldr	r3, [r7, #28]
 800e16c:	9300      	str	r3, [sp, #0]
 800e16e:	68bc      	ldr	r4, [r7, #8]
 800e170:	6a3b      	ldr	r3, [r7, #32]
 800e172:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e174:	69b9      	ldr	r1, [r7, #24]
 800e176:	6878      	ldr	r0, [r7, #4]
 800e178:	47a0      	blx	r4
			output_ptr, output_col);
	buffer_ptr++;
 800e17a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e17c:	3380      	adds	r3, #128	; 0x80
 800e17e:	627b      	str	r3, [r7, #36]	; 0x24
	output_col += compptr->DCT_h_scaled_size;
 800e180:	69bb      	ldr	r3, [r7, #24]
 800e182:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e184:	461a      	mov	r2, r3
 800e186:	69fb      	ldr	r3, [r7, #28]
 800e188:	4413      	add	r3, r2
 800e18a:	61fb      	str	r3, [r7, #28]
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
 800e18c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e18e:	3301      	adds	r3, #1
 800e190:	637b      	str	r3, [r7, #52]	; 0x34
 800e192:	69bb      	ldr	r3, [r7, #24]
 800e194:	69db      	ldr	r3, [r3, #28]
 800e196:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e198:	429a      	cmp	r2, r3
 800e19a:	d3e6      	bcc.n	800e16a <decompress_data+0x116>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 800e19c:	69bb      	ldr	r3, [r7, #24]
 800e19e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e1a0:	009b      	lsls	r3, r3, #2
 800e1a2:	6a3a      	ldr	r2, [r7, #32]
 800e1a4:	4413      	add	r3, r2
 800e1a6:	623b      	str	r3, [r7, #32]
    for (block_row = 0; block_row < block_rows; block_row++) {
 800e1a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e1aa:	3301      	adds	r3, #1
 800e1ac:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e1ae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e1b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e1b2:	429a      	cmp	r2, r3
 800e1b4:	dbce      	blt.n	800e154 <decompress_data+0x100>
 800e1b6:	e000      	b.n	800e1ba <decompress_data+0x166>
      continue;
 800e1b8:	bf00      	nop
       ci++, compptr++) {
 800e1ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e1bc:	3301      	adds	r3, #1
 800e1be:	633b      	str	r3, [r7, #48]	; 0x30
 800e1c0:	69bb      	ldr	r3, [r7, #24]
 800e1c2:	3358      	adds	r3, #88	; 0x58
 800e1c4:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800e1c6:	687b      	ldr	r3, [r7, #4]
 800e1c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e1ca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e1cc:	429a      	cmp	r2, r3
 800e1ce:	f6ff af7a 	blt.w	800e0c6 <decompress_data+0x72>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 800e1d2:	687b      	ldr	r3, [r7, #4]
 800e1d4:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e1d8:	1c5a      	adds	r2, r3, #1
 800e1da:	687b      	ldr	r3, [r7, #4]
 800e1dc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 800e1e0:	687b      	ldr	r3, [r7, #4]
 800e1e2:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800e1e6:	687b      	ldr	r3, [r7, #4]
 800e1e8:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800e1ec:	429a      	cmp	r2, r3
 800e1ee:	d201      	bcs.n	800e1f4 <decompress_data+0x1a0>
    return JPEG_ROW_COMPLETED;
 800e1f0:	2303      	movs	r3, #3
 800e1f2:	e000      	b.n	800e1f6 <decompress_data+0x1a2>
  return JPEG_SCAN_COMPLETED;
 800e1f4:	2304      	movs	r3, #4
}
 800e1f6:	4618      	mov	r0, r3
 800e1f8:	373c      	adds	r7, #60	; 0x3c
 800e1fa:	46bd      	mov	sp, r7
 800e1fc:	bd90      	pop	{r4, r7, pc}

0800e1fe <smoothing_ok>:
 * more accurately than they really are.
 */

LOCAL(boolean)
smoothing_ok (j_decompress_ptr cinfo)
{
 800e1fe:	b590      	push	{r4, r7, lr}
 800e200:	b08b      	sub	sp, #44	; 0x2c
 800e202:	af00      	add	r7, sp, #0
 800e204:	6078      	str	r0, [r7, #4]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800e206:	687b      	ldr	r3, [r7, #4]
 800e208:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800e20c:	613b      	str	r3, [r7, #16]
  boolean smoothing_useful = FALSE;
 800e20e:	2300      	movs	r3, #0
 800e210:	627b      	str	r3, [r7, #36]	; 0x24
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
 800e212:	687b      	ldr	r3, [r7, #4]
 800e214:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800e218:	2b00      	cmp	r3, #0
 800e21a:	d004      	beq.n	800e226 <smoothing_ok+0x28>
 800e21c:	687b      	ldr	r3, [r7, #4]
 800e21e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e222:	2b00      	cmp	r3, #0
 800e224:	d101      	bne.n	800e22a <smoothing_ok+0x2c>
    return FALSE;
 800e226:	2300      	movs	r3, #0
 800e228:	e078      	b.n	800e31c <smoothing_ok+0x11e>

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
 800e22a:	693b      	ldr	r3, [r7, #16]
 800e22c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e22e:	2b00      	cmp	r3, #0
 800e230:	d110      	bne.n	800e254 <smoothing_ok+0x56>
    coef->coef_bits_latch = (int *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	685b      	ldr	r3, [r3, #4]
 800e236:	681c      	ldr	r4, [r3, #0]
				  cinfo->num_components *
 800e238:	687b      	ldr	r3, [r7, #4]
 800e23a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e23c:	461a      	mov	r2, r3
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800e23e:	4613      	mov	r3, r2
 800e240:	005b      	lsls	r3, r3, #1
 800e242:	4413      	add	r3, r2
 800e244:	00db      	lsls	r3, r3, #3
 800e246:	461a      	mov	r2, r3
 800e248:	2101      	movs	r1, #1
 800e24a:	6878      	ldr	r0, [r7, #4]
 800e24c:	47a0      	blx	r4
 800e24e:	4602      	mov	r2, r0
    coef->coef_bits_latch = (int *)
 800e250:	693b      	ldr	r3, [r7, #16]
 800e252:	671a      	str	r2, [r3, #112]	; 0x70
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;
 800e254:	693b      	ldr	r3, [r7, #16]
 800e256:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800e258:	617b      	str	r3, [r7, #20]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800e25a:	2300      	movs	r3, #0
 800e25c:	623b      	str	r3, [r7, #32]
 800e25e:	687b      	ldr	r3, [r7, #4]
 800e260:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e264:	61bb      	str	r3, [r7, #24]
 800e266:	e053      	b.n	800e310 <smoothing_ok+0x112>
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
 800e268:	69bb      	ldr	r3, [r7, #24]
 800e26a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800e26c:	60fb      	str	r3, [r7, #12]
 800e26e:	68fb      	ldr	r3, [r7, #12]
 800e270:	2b00      	cmp	r3, #0
 800e272:	d101      	bne.n	800e278 <smoothing_ok+0x7a>
      return FALSE;
 800e274:	2300      	movs	r3, #0
 800e276:	e051      	b.n	800e31c <smoothing_ok+0x11e>
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
 800e278:	68fb      	ldr	r3, [r7, #12]
 800e27a:	881b      	ldrh	r3, [r3, #0]
 800e27c:	2b00      	cmp	r3, #0
 800e27e:	d013      	beq.n	800e2a8 <smoothing_ok+0xaa>
	qtable->quantval[Q01_POS] == 0 ||
 800e280:	68fb      	ldr	r3, [r7, #12]
 800e282:	885b      	ldrh	r3, [r3, #2]
    if (qtable->quantval[0] == 0 ||
 800e284:	2b00      	cmp	r3, #0
 800e286:	d00f      	beq.n	800e2a8 <smoothing_ok+0xaa>
	qtable->quantval[Q10_POS] == 0 ||
 800e288:	68fb      	ldr	r3, [r7, #12]
 800e28a:	8a1b      	ldrh	r3, [r3, #16]
	qtable->quantval[Q01_POS] == 0 ||
 800e28c:	2b00      	cmp	r3, #0
 800e28e:	d00b      	beq.n	800e2a8 <smoothing_ok+0xaa>
	qtable->quantval[Q20_POS] == 0 ||
 800e290:	68fb      	ldr	r3, [r7, #12]
 800e292:	8c1b      	ldrh	r3, [r3, #32]
	qtable->quantval[Q10_POS] == 0 ||
 800e294:	2b00      	cmp	r3, #0
 800e296:	d007      	beq.n	800e2a8 <smoothing_ok+0xaa>
	qtable->quantval[Q11_POS] == 0 ||
 800e298:	68fb      	ldr	r3, [r7, #12]
 800e29a:	8a5b      	ldrh	r3, [r3, #18]
	qtable->quantval[Q20_POS] == 0 ||
 800e29c:	2b00      	cmp	r3, #0
 800e29e:	d003      	beq.n	800e2a8 <smoothing_ok+0xaa>
	qtable->quantval[Q02_POS] == 0)
 800e2a0:	68fb      	ldr	r3, [r7, #12]
 800e2a2:	889b      	ldrh	r3, [r3, #4]
	qtable->quantval[Q11_POS] == 0 ||
 800e2a4:	2b00      	cmp	r3, #0
 800e2a6:	d101      	bne.n	800e2ac <smoothing_ok+0xae>
      return FALSE;
 800e2a8:	2300      	movs	r3, #0
 800e2aa:	e037      	b.n	800e31c <smoothing_ok+0x11e>
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
 800e2ac:	687b      	ldr	r3, [r7, #4]
 800e2ae:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 800e2b2:	6a3b      	ldr	r3, [r7, #32]
 800e2b4:	021b      	lsls	r3, r3, #8
 800e2b6:	4413      	add	r3, r2
 800e2b8:	60bb      	str	r3, [r7, #8]
    if (coef_bits[0] < 0)
 800e2ba:	68bb      	ldr	r3, [r7, #8]
 800e2bc:	681b      	ldr	r3, [r3, #0]
 800e2be:	2b00      	cmp	r3, #0
 800e2c0:	da01      	bge.n	800e2c6 <smoothing_ok+0xc8>
      return FALSE;
 800e2c2:	2300      	movs	r3, #0
 800e2c4:	e02a      	b.n	800e31c <smoothing_ok+0x11e>
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
 800e2c6:	2301      	movs	r3, #1
 800e2c8:	61fb      	str	r3, [r7, #28]
 800e2ca:	e015      	b.n	800e2f8 <smoothing_ok+0xfa>
      coef_bits_latch[coefi] = coef_bits[coefi];
 800e2cc:	69fb      	ldr	r3, [r7, #28]
 800e2ce:	009b      	lsls	r3, r3, #2
 800e2d0:	68ba      	ldr	r2, [r7, #8]
 800e2d2:	441a      	add	r2, r3
 800e2d4:	69fb      	ldr	r3, [r7, #28]
 800e2d6:	009b      	lsls	r3, r3, #2
 800e2d8:	6979      	ldr	r1, [r7, #20]
 800e2da:	440b      	add	r3, r1
 800e2dc:	6812      	ldr	r2, [r2, #0]
 800e2de:	601a      	str	r2, [r3, #0]
      if (coef_bits[coefi] != 0)
 800e2e0:	69fb      	ldr	r3, [r7, #28]
 800e2e2:	009b      	lsls	r3, r3, #2
 800e2e4:	68ba      	ldr	r2, [r7, #8]
 800e2e6:	4413      	add	r3, r2
 800e2e8:	681b      	ldr	r3, [r3, #0]
 800e2ea:	2b00      	cmp	r3, #0
 800e2ec:	d001      	beq.n	800e2f2 <smoothing_ok+0xf4>
	smoothing_useful = TRUE;
 800e2ee:	2301      	movs	r3, #1
 800e2f0:	627b      	str	r3, [r7, #36]	; 0x24
    for (coefi = 1; coefi <= 5; coefi++) {
 800e2f2:	69fb      	ldr	r3, [r7, #28]
 800e2f4:	3301      	adds	r3, #1
 800e2f6:	61fb      	str	r3, [r7, #28]
 800e2f8:	69fb      	ldr	r3, [r7, #28]
 800e2fa:	2b05      	cmp	r3, #5
 800e2fc:	dde6      	ble.n	800e2cc <smoothing_ok+0xce>
    }
    coef_bits_latch += SAVED_COEFS;
 800e2fe:	697b      	ldr	r3, [r7, #20]
 800e300:	3318      	adds	r3, #24
 800e302:	617b      	str	r3, [r7, #20]
       ci++, compptr++) {
 800e304:	6a3b      	ldr	r3, [r7, #32]
 800e306:	3301      	adds	r3, #1
 800e308:	623b      	str	r3, [r7, #32]
 800e30a:	69bb      	ldr	r3, [r7, #24]
 800e30c:	3358      	adds	r3, #88	; 0x58
 800e30e:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800e310:	687b      	ldr	r3, [r7, #4]
 800e312:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e314:	6a3a      	ldr	r2, [r7, #32]
 800e316:	429a      	cmp	r2, r3
 800e318:	dba6      	blt.n	800e268 <smoothing_ok+0x6a>
  }

  return smoothing_useful;
 800e31a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800e31c:	4618      	mov	r0, r3
 800e31e:	372c      	adds	r7, #44	; 0x2c
 800e320:	46bd      	mov	sp, r7
 800e322:	bd90      	pop	{r4, r7, pc}

0800e324 <decompress_smooth_data>:
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
 800e324:	b5b0      	push	{r4, r5, r7, lr}
 800e326:	b0cc      	sub	sp, #304	; 0x130
 800e328:	af02      	add	r7, sp, #8
 800e32a:	1d3b      	adds	r3, r7, #4
 800e32c:	6018      	str	r0, [r3, #0]
 800e32e:	463b      	mov	r3, r7
 800e330:	6019      	str	r1, [r3, #0]
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
 800e332:	1d3b      	adds	r3, r7, #4
 800e334:	681b      	ldr	r3, [r3, #0]
 800e336:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 800e33a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
 800e33e:	1d3b      	adds	r3, r7, #4
 800e340:	681b      	ldr	r3, [r3, #0]
 800e342:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800e346:	3b01      	subs	r3, #1
 800e348:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 800e34c:	e02f      	b.n	800e3ae <decompress_smooth_data+0x8a>
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
 800e34e:	1d3b      	adds	r3, r7, #4
 800e350:	681b      	ldr	r3, [r3, #0]
 800e352:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800e356:	1d3b      	adds	r3, r7, #4
 800e358:	681b      	ldr	r3, [r3, #0]
 800e35a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800e35e:	429a      	cmp	r2, r3
 800e360:	d117      	bne.n	800e392 <decompress_smooth_data+0x6e>
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
 800e362:	1d3b      	adds	r3, r7, #4
 800e364:	681b      	ldr	r3, [r3, #0]
 800e366:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800e36a:	2b00      	cmp	r3, #0
 800e36c:	bf0c      	ite	eq
 800e36e:	2301      	moveq	r3, #1
 800e370:	2300      	movne	r3, #0
 800e372:	b2db      	uxtb	r3, r3
 800e374:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
 800e378:	1d3b      	adds	r3, r7, #4
 800e37a:	681b      	ldr	r3, [r3, #0]
 800e37c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800e380:	1d3b      	adds	r3, r7, #4
 800e382:	681b      	ldr	r3, [r3, #0]
 800e384:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
 800e388:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800e38c:	440b      	add	r3, r1
 800e38e:	429a      	cmp	r2, r3
 800e390:	d81f      	bhi.n	800e3d2 <decompress_smooth_data+0xae>
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
 800e392:	1d3b      	adds	r3, r7, #4
 800e394:	681b      	ldr	r3, [r3, #0]
 800e396:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800e39a:	681b      	ldr	r3, [r3, #0]
 800e39c:	1d3a      	adds	r2, r7, #4
 800e39e:	6810      	ldr	r0, [r2, #0]
 800e3a0:	4798      	blx	r3
 800e3a2:	4603      	mov	r3, r0
 800e3a4:	2b00      	cmp	r3, #0
 800e3a6:	d102      	bne.n	800e3ae <decompress_smooth_data+0x8a>
      return JPEG_SUSPENDED;
 800e3a8:	2300      	movs	r3, #0
 800e3aa:	f000 bc53 	b.w	800ec54 <decompress_smooth_data+0x930>
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 800e3ae:	1d3b      	adds	r3, r7, #4
 800e3b0:	681b      	ldr	r3, [r3, #0]
 800e3b2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800e3b6:	1d3b      	adds	r3, r7, #4
 800e3b8:	681b      	ldr	r3, [r3, #0]
 800e3ba:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800e3be:	429a      	cmp	r2, r3
 800e3c0:	dc08      	bgt.n	800e3d4 <decompress_smooth_data+0xb0>
	 ! cinfo->inputctl->eoi_reached) {
 800e3c2:	1d3b      	adds	r3, r7, #4
 800e3c4:	681b      	ldr	r3, [r3, #0]
 800e3c6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 800e3ca:	695b      	ldr	r3, [r3, #20]
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
 800e3cc:	2b00      	cmp	r3, #0
 800e3ce:	d0be      	beq.n	800e34e <decompress_smooth_data+0x2a>
 800e3d0:	e000      	b.n	800e3d4 <decompress_smooth_data+0xb0>
	break;
 800e3d2:	bf00      	nop
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800e3d4:	2300      	movs	r3, #0
 800e3d6:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 800e3da:	1d3b      	adds	r3, r7, #4
 800e3dc:	681b      	ldr	r3, [r3, #0]
 800e3de:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e3e2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800e3e6:	f000 bc17 	b.w	800ec18 <decompress_smooth_data+0x8f4>
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
 800e3ea:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e3ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e3f0:	2b00      	cmp	r3, #0
 800e3f2:	f000 8406 	beq.w	800ec02 <decompress_smooth_data+0x8de>
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
 800e3f6:	1d3b      	adds	r3, r7, #4
 800e3f8:	681b      	ldr	r3, [r3, #0]
 800e3fa:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e3fe:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800e402:	429a      	cmp	r2, r3
 800e404:	d90d      	bls.n	800e422 <decompress_smooth_data+0xfe>
      block_rows = compptr->v_samp_factor;
 800e406:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e40a:	68db      	ldr	r3, [r3, #12]
 800e40c:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
      access_rows = block_rows * 2; /* this and next iMCU row */
 800e410:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 800e414:	005b      	lsls	r3, r3, #1
 800e416:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
      last_row = FALSE;
 800e41a:	2300      	movs	r3, #0
 800e41c:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 800e420:	e01c      	b.n	800e45c <decompress_smooth_data+0x138>
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 800e422:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e426:	6a1b      	ldr	r3, [r3, #32]
 800e428:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800e42c:	68d2      	ldr	r2, [r2, #12]
 800e42e:	fbb3 f1f2 	udiv	r1, r3, r2
 800e432:	fb02 f201 	mul.w	r2, r2, r1
 800e436:	1a9b      	subs	r3, r3, r2
 800e438:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
 800e43c:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 800e440:	2b00      	cmp	r3, #0
 800e442:	d104      	bne.n	800e44e <decompress_smooth_data+0x12a>
 800e444:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e448:	68db      	ldr	r3, [r3, #12]
 800e44a:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
      access_rows = block_rows; /* this iMCU row only */
 800e44e:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 800e452:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
      last_row = TRUE;
 800e456:	2301      	movs	r3, #1
 800e458:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
 800e45c:	1d3b      	adds	r3, r7, #4
 800e45e:	681b      	ldr	r3, [r3, #0]
 800e460:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e464:	2b00      	cmp	r3, #0
 800e466:	d032      	beq.n	800e4ce <decompress_smooth_data+0x1aa>
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
 800e468:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e46c:	68db      	ldr	r3, [r3, #12]
 800e46e:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 800e472:	4413      	add	r3, r2
 800e474:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
      buffer = (*cinfo->mem->access_virt_barray)
 800e478:	1d3b      	adds	r3, r7, #4
 800e47a:	681b      	ldr	r3, [r3, #0]
 800e47c:	685b      	ldr	r3, [r3, #4]
 800e47e:	6a1c      	ldr	r4, [r3, #32]
 800e480:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e484:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 800e488:	3212      	adds	r2, #18
 800e48a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
 800e48e:	1d3b      	adds	r3, r7, #4
 800e490:	681b      	ldr	r3, [r3, #0]
 800e492:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800e496:	3b01      	subs	r3, #1
 800e498:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800e49c:	68d2      	ldr	r2, [r2, #12]
      buffer = (*cinfo->mem->access_virt_barray)
 800e49e:	fb02 f203 	mul.w	r2, r2, r3
 800e4a2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 800e4a6:	1d38      	adds	r0, r7, #4
 800e4a8:	2500      	movs	r5, #0
 800e4aa:	9500      	str	r5, [sp, #0]
 800e4ac:	6800      	ldr	r0, [r0, #0]
 800e4ae:	47a0      	blx	r4
 800e4b0:	f8c7 0110 	str.w	r0, [r7, #272]	; 0x110
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
 800e4b4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e4b8:	68db      	ldr	r3, [r3, #12]
 800e4ba:	009b      	lsls	r3, r3, #2
 800e4bc:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 800e4c0:	4413      	add	r3, r2
 800e4c2:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
      first_row = FALSE;
 800e4c6:	2300      	movs	r3, #0
 800e4c8:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 800e4cc:	e017      	b.n	800e4fe <decompress_smooth_data+0x1da>
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
 800e4ce:	1d3b      	adds	r3, r7, #4
 800e4d0:	681b      	ldr	r3, [r3, #0]
 800e4d2:	685b      	ldr	r3, [r3, #4]
 800e4d4:	6a1c      	ldr	r4, [r3, #32]
 800e4d6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e4da:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 800e4de:	3212      	adds	r2, #18
 800e4e0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800e4e4:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 800e4e8:	1d38      	adds	r0, r7, #4
 800e4ea:	2200      	movs	r2, #0
 800e4ec:	9200      	str	r2, [sp, #0]
 800e4ee:	2200      	movs	r2, #0
 800e4f0:	6800      	ldr	r0, [r0, #0]
 800e4f2:	47a0      	blx	r4
 800e4f4:	f8c7 0110 	str.w	r0, [r7, #272]	; 0x110
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
 800e4f8:	2301      	movs	r3, #1
 800e4fa:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
 800e4fe:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e502:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800e504:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 800e508:	4613      	mov	r3, r2
 800e50a:	005b      	lsls	r3, r3, #1
 800e50c:	4413      	add	r3, r2
 800e50e:	00db      	lsls	r3, r3, #3
 800e510:	440b      	add	r3, r1
 800e512:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    quanttbl = compptr->quant_table;
 800e516:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e51a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800e51c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    Q00 = quanttbl->quantval[0];
 800e520:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e524:	881b      	ldrh	r3, [r3, #0]
 800e526:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    Q01 = quanttbl->quantval[Q01_POS];
 800e52a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e52e:	885b      	ldrh	r3, [r3, #2]
 800e530:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    Q10 = quanttbl->quantval[Q10_POS];
 800e534:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e538:	8a1b      	ldrh	r3, [r3, #16]
 800e53a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    Q20 = quanttbl->quantval[Q20_POS];
 800e53e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e542:	8c1b      	ldrh	r3, [r3, #32]
 800e544:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    Q11 = quanttbl->quantval[Q11_POS];
 800e548:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e54c:	8a5b      	ldrh	r3, [r3, #18]
 800e54e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    Q02 = quanttbl->quantval[Q02_POS];
 800e552:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e556:	889b      	ldrh	r3, [r3, #4]
 800e558:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
 800e55c:	1d3b      	adds	r3, r7, #4
 800e55e:	681b      	ldr	r3, [r3, #0]
 800e560:	f8d3 21d4 	ldr.w	r2, [r3, #468]	; 0x1d4
 800e564:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800e568:	009b      	lsls	r3, r3, #2
 800e56a:	4413      	add	r3, r2
 800e56c:	685b      	ldr	r3, [r3, #4]
 800e56e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    output_ptr = output_buf[ci];
 800e572:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800e576:	009b      	lsls	r3, r3, #2
 800e578:	463a      	mov	r2, r7
 800e57a:	6812      	ldr	r2, [r2, #0]
 800e57c:	4413      	add	r3, r2
 800e57e:	681b      	ldr	r3, [r3, #0]
 800e580:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
 800e584:	2300      	movs	r3, #0
 800e586:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 800e58a:	e332      	b.n	800ebf2 <decompress_smooth_data+0x8ce>
      buffer_ptr = buffer[block_row];
 800e58c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800e590:	009b      	lsls	r3, r3, #2
 800e592:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 800e596:	4413      	add	r3, r2
 800e598:	681b      	ldr	r3, [r3, #0]
 800e59a:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
      if (first_row && block_row == 0)
 800e59e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 800e5a2:	2b00      	cmp	r3, #0
 800e5a4:	d008      	beq.n	800e5b8 <decompress_smooth_data+0x294>
 800e5a6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800e5aa:	2b00      	cmp	r3, #0
 800e5ac:	d104      	bne.n	800e5b8 <decompress_smooth_data+0x294>
	prev_block_row = buffer_ptr;
 800e5ae:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800e5b2:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800e5b6:	e00b      	b.n	800e5d0 <decompress_smooth_data+0x2ac>
      else
	prev_block_row = buffer[block_row-1];
 800e5b8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800e5bc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800e5c0:	3b01      	subs	r3, #1
 800e5c2:	009b      	lsls	r3, r3, #2
 800e5c4:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 800e5c8:	4413      	add	r3, r2
 800e5ca:	681b      	ldr	r3, [r3, #0]
 800e5cc:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
      if (last_row && block_row == block_rows-1)
 800e5d0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 800e5d4:	2b00      	cmp	r3, #0
 800e5d6:	d00b      	beq.n	800e5f0 <decompress_smooth_data+0x2cc>
 800e5d8:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 800e5dc:	3b01      	subs	r3, #1
 800e5de:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 800e5e2:	429a      	cmp	r2, r3
 800e5e4:	d104      	bne.n	800e5f0 <decompress_smooth_data+0x2cc>
	next_block_row = buffer_ptr;
 800e5e6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800e5ea:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800e5ee:	e009      	b.n	800e604 <decompress_smooth_data+0x2e0>
      else
	next_block_row = buffer[block_row+1];
 800e5f0:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800e5f4:	3301      	adds	r3, #1
 800e5f6:	009b      	lsls	r3, r3, #2
 800e5f8:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 800e5fc:	4413      	add	r3, r2
 800e5fe:	681b      	ldr	r3, [r3, #0]
 800e600:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
 800e604:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800e608:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e60c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 800e610:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e614:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 800e618:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800e61c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
 800e620:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800e624:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e628:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 800e62c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800e630:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800e634:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800e638:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
 800e63c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800e640:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e644:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 800e648:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800e64c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800e650:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800e654:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      output_col = 0;
 800e658:	2300      	movs	r3, #0
 800e65a:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
      last_block_column = compptr->width_in_blocks - 1;
 800e65e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800e662:	69db      	ldr	r3, [r3, #28]
 800e664:	3b01      	subs	r3, #1
 800e666:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 800e66a:	2300      	movs	r3, #0
 800e66c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 800e670:	e2aa      	b.n	800ebc8 <decompress_smooth_data+0x8a4>
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
 800e672:	f107 030c 	add.w	r3, r7, #12
 800e676:	2201      	movs	r2, #1
 800e678:	4619      	mov	r1, r3
 800e67a:	f8d7 010c 	ldr.w	r0, [r7, #268]	; 0x10c
 800e67e:	f019 faa1 	bl	8027bc4 <jcopy_block_row>
	/* Update DC values */
	if (block_num < last_block_column) {
 800e682:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 800e686:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800e68a:	429a      	cmp	r2, r3
 800e68c:	d214      	bcs.n	800e6b8 <decompress_smooth_data+0x394>
	  DC3 = (int) prev_block_row[1][0];
 800e68e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800e692:	3380      	adds	r3, #128	; 0x80
 800e694:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e698:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
	  DC6 = (int) buffer_ptr[1][0];
 800e69c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800e6a0:	3380      	adds	r3, #128	; 0x80
 800e6a2:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e6a6:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	  DC9 = (int) next_block_row[1][0];
 800e6aa:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800e6ae:	3380      	adds	r3, #128	; 0x80
 800e6b0:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e6b4:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
 800e6b8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800e6bc:	685b      	ldr	r3, [r3, #4]
 800e6be:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e6c2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e6c6:	2b00      	cmp	r3, #0
 800e6c8:	d068      	beq.n	800e79c <decompress_smooth_data+0x478>
 800e6ca:	f107 030c 	add.w	r3, r7, #12
 800e6ce:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800e6d2:	2b00      	cmp	r3, #0
 800e6d4:	d162      	bne.n	800e79c <decompress_smooth_data+0x478>
	  num = 36 * Q00 * (DC4 - DC6);
 800e6d6:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800e6da:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800e6de:	1ad3      	subs	r3, r2, r3
 800e6e0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800e6e4:	fb02 f203 	mul.w	r2, r2, r3
 800e6e8:	4613      	mov	r3, r2
 800e6ea:	00db      	lsls	r3, r3, #3
 800e6ec:	4413      	add	r3, r2
 800e6ee:	009b      	lsls	r3, r3, #2
 800e6f0:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	  if (num >= 0) {
 800e6f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e6f8:	2b00      	cmp	r3, #0
 800e6fa:	db22      	blt.n	800e742 <decompress_smooth_data+0x41e>
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
 800e6fc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e700:	01da      	lsls	r2, r3, #7
 800e702:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e706:	441a      	add	r2, r3
 800e708:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e70c:	021b      	lsls	r3, r3, #8
 800e70e:	fb92 f3f3 	sdiv	r3, r2, r3
 800e712:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e716:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e71a:	2b00      	cmp	r3, #0
 800e71c:	dd38      	ble.n	800e790 <decompress_smooth_data+0x46c>
 800e71e:	2201      	movs	r2, #1
 800e720:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e724:	fa02 f303 	lsl.w	r3, r2, r3
 800e728:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e72c:	429a      	cmp	r2, r3
 800e72e:	db2f      	blt.n	800e790 <decompress_smooth_data+0x46c>
	      pred = (1<<Al)-1;
 800e730:	2201      	movs	r2, #1
 800e732:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e736:	fa02 f303 	lsl.w	r3, r2, r3
 800e73a:	3b01      	subs	r3, #1
 800e73c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800e740:	e026      	b.n	800e790 <decompress_smooth_data+0x46c>
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
 800e742:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e746:	01da      	lsls	r2, r3, #7
 800e748:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e74c:	1ad2      	subs	r2, r2, r3
 800e74e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e752:	021b      	lsls	r3, r3, #8
 800e754:	fb92 f3f3 	sdiv	r3, r2, r3
 800e758:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e75c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e760:	2b00      	cmp	r3, #0
 800e762:	dd10      	ble.n	800e786 <decompress_smooth_data+0x462>
 800e764:	2201      	movs	r2, #1
 800e766:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e76a:	fa02 f303 	lsl.w	r3, r2, r3
 800e76e:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e772:	429a      	cmp	r2, r3
 800e774:	db07      	blt.n	800e786 <decompress_smooth_data+0x462>
	      pred = (1<<Al)-1;
 800e776:	2201      	movs	r2, #1
 800e778:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e77c:	fa02 f303 	lsl.w	r3, r2, r3
 800e780:	3b01      	subs	r3, #1
 800e782:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    pred = -pred;
 800e786:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e78a:	425b      	negs	r3, r3
 800e78c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	  }
	  workspace[1] = (JCOEF) pred;
 800e790:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e794:	b21a      	sxth	r2, r3
 800e796:	f107 030c 	add.w	r3, r7, #12
 800e79a:	805a      	strh	r2, [r3, #2]
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
 800e79c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800e7a0:	689b      	ldr	r3, [r3, #8]
 800e7a2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e7a6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e7aa:	2b00      	cmp	r3, #0
 800e7ac:	d068      	beq.n	800e880 <decompress_smooth_data+0x55c>
 800e7ae:	f107 030c 	add.w	r3, r7, #12
 800e7b2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800e7b6:	2b00      	cmp	r3, #0
 800e7b8:	d162      	bne.n	800e880 <decompress_smooth_data+0x55c>
	  num = 36 * Q00 * (DC2 - DC8);
 800e7ba:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 800e7be:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800e7c2:	1ad3      	subs	r3, r2, r3
 800e7c4:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800e7c8:	fb02 f203 	mul.w	r2, r2, r3
 800e7cc:	4613      	mov	r3, r2
 800e7ce:	00db      	lsls	r3, r3, #3
 800e7d0:	4413      	add	r3, r2
 800e7d2:	009b      	lsls	r3, r3, #2
 800e7d4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	  if (num >= 0) {
 800e7d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e7dc:	2b00      	cmp	r3, #0
 800e7de:	db22      	blt.n	800e826 <decompress_smooth_data+0x502>
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
 800e7e0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800e7e4:	01da      	lsls	r2, r3, #7
 800e7e6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e7ea:	441a      	add	r2, r3
 800e7ec:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800e7f0:	021b      	lsls	r3, r3, #8
 800e7f2:	fb92 f3f3 	sdiv	r3, r2, r3
 800e7f6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e7fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e7fe:	2b00      	cmp	r3, #0
 800e800:	dd38      	ble.n	800e874 <decompress_smooth_data+0x550>
 800e802:	2201      	movs	r2, #1
 800e804:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e808:	fa02 f303 	lsl.w	r3, r2, r3
 800e80c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e810:	429a      	cmp	r2, r3
 800e812:	db2f      	blt.n	800e874 <decompress_smooth_data+0x550>
	      pred = (1<<Al)-1;
 800e814:	2201      	movs	r2, #1
 800e816:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e81a:	fa02 f303 	lsl.w	r3, r2, r3
 800e81e:	3b01      	subs	r3, #1
 800e820:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800e824:	e026      	b.n	800e874 <decompress_smooth_data+0x550>
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
 800e826:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800e82a:	01da      	lsls	r2, r3, #7
 800e82c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e830:	1ad2      	subs	r2, r2, r3
 800e832:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800e836:	021b      	lsls	r3, r3, #8
 800e838:	fb92 f3f3 	sdiv	r3, r2, r3
 800e83c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e840:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e844:	2b00      	cmp	r3, #0
 800e846:	dd10      	ble.n	800e86a <decompress_smooth_data+0x546>
 800e848:	2201      	movs	r2, #1
 800e84a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e84e:	fa02 f303 	lsl.w	r3, r2, r3
 800e852:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e856:	429a      	cmp	r2, r3
 800e858:	db07      	blt.n	800e86a <decompress_smooth_data+0x546>
	      pred = (1<<Al)-1;
 800e85a:	2201      	movs	r2, #1
 800e85c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e860:	fa02 f303 	lsl.w	r3, r2, r3
 800e864:	3b01      	subs	r3, #1
 800e866:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    pred = -pred;
 800e86a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e86e:	425b      	negs	r3, r3
 800e870:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	  }
	  workspace[8] = (JCOEF) pred;
 800e874:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e878:	b21a      	sxth	r2, r3
 800e87a:	f107 030c 	add.w	r3, r7, #12
 800e87e:	821a      	strh	r2, [r3, #16]
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
 800e880:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800e884:	68db      	ldr	r3, [r3, #12]
 800e886:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e88a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e88e:	2b00      	cmp	r3, #0
 800e890:	d06b      	beq.n	800e96a <decompress_smooth_data+0x646>
 800e892:	f107 030c 	add.w	r3, r7, #12
 800e896:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 800e89a:	2b00      	cmp	r3, #0
 800e89c:	d165      	bne.n	800e96a <decompress_smooth_data+0x646>
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
 800e89e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 800e8a2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800e8a6:	441a      	add	r2, r3
 800e8a8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800e8ac:	005b      	lsls	r3, r3, #1
 800e8ae:	1ad3      	subs	r3, r2, r3
 800e8b0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800e8b4:	fb02 f203 	mul.w	r2, r2, r3
 800e8b8:	4613      	mov	r3, r2
 800e8ba:	00db      	lsls	r3, r3, #3
 800e8bc:	4413      	add	r3, r2
 800e8be:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	  if (num >= 0) {
 800e8c2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e8c6:	2b00      	cmp	r3, #0
 800e8c8:	db22      	blt.n	800e910 <decompress_smooth_data+0x5ec>
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
 800e8ca:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e8ce:	01da      	lsls	r2, r3, #7
 800e8d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e8d4:	441a      	add	r2, r3
 800e8d6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e8da:	021b      	lsls	r3, r3, #8
 800e8dc:	fb92 f3f3 	sdiv	r3, r2, r3
 800e8e0:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e8e4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e8e8:	2b00      	cmp	r3, #0
 800e8ea:	dd38      	ble.n	800e95e <decompress_smooth_data+0x63a>
 800e8ec:	2201      	movs	r2, #1
 800e8ee:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e8f2:	fa02 f303 	lsl.w	r3, r2, r3
 800e8f6:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e8fa:	429a      	cmp	r2, r3
 800e8fc:	db2f      	blt.n	800e95e <decompress_smooth_data+0x63a>
	      pred = (1<<Al)-1;
 800e8fe:	2201      	movs	r2, #1
 800e900:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e904:	fa02 f303 	lsl.w	r3, r2, r3
 800e908:	3b01      	subs	r3, #1
 800e90a:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800e90e:	e026      	b.n	800e95e <decompress_smooth_data+0x63a>
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
 800e910:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e914:	01da      	lsls	r2, r3, #7
 800e916:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e91a:	1ad2      	subs	r2, r2, r3
 800e91c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e920:	021b      	lsls	r3, r3, #8
 800e922:	fb92 f3f3 	sdiv	r3, r2, r3
 800e926:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e92a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e92e:	2b00      	cmp	r3, #0
 800e930:	dd10      	ble.n	800e954 <decompress_smooth_data+0x630>
 800e932:	2201      	movs	r2, #1
 800e934:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e938:	fa02 f303 	lsl.w	r3, r2, r3
 800e93c:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e940:	429a      	cmp	r2, r3
 800e942:	db07      	blt.n	800e954 <decompress_smooth_data+0x630>
	      pred = (1<<Al)-1;
 800e944:	2201      	movs	r2, #1
 800e946:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e94a:	fa02 f303 	lsl.w	r3, r2, r3
 800e94e:	3b01      	subs	r3, #1
 800e950:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    pred = -pred;
 800e954:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e958:	425b      	negs	r3, r3
 800e95a:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	  }
	  workspace[16] = (JCOEF) pred;
 800e95e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e962:	b21a      	sxth	r2, r3
 800e964:	f107 030c 	add.w	r3, r7, #12
 800e968:	841a      	strh	r2, [r3, #32]
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
 800e96a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800e96e:	691b      	ldr	r3, [r3, #16]
 800e970:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e974:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e978:	2b00      	cmp	r3, #0
 800e97a:	d06d      	beq.n	800ea58 <decompress_smooth_data+0x734>
 800e97c:	f107 030c 	add.w	r3, r7, #12
 800e980:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800e984:	2b00      	cmp	r3, #0
 800e986:	d167      	bne.n	800ea58 <decompress_smooth_data+0x734>
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
 800e988:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 800e98c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e990:	1ad2      	subs	r2, r2, r3
 800e992:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800e996:	1ad2      	subs	r2, r2, r3
 800e998:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800e99c:	4413      	add	r3, r2
 800e99e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800e9a2:	fb02 f203 	mul.w	r2, r2, r3
 800e9a6:	4613      	mov	r3, r2
 800e9a8:	009b      	lsls	r3, r3, #2
 800e9aa:	4413      	add	r3, r2
 800e9ac:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	  if (num >= 0) {
 800e9b0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e9b4:	2b00      	cmp	r3, #0
 800e9b6:	db22      	blt.n	800e9fe <decompress_smooth_data+0x6da>
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
 800e9b8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e9bc:	01da      	lsls	r2, r3, #7
 800e9be:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e9c2:	441a      	add	r2, r3
 800e9c4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e9c8:	021b      	lsls	r3, r3, #8
 800e9ca:	fb92 f3f3 	sdiv	r3, r2, r3
 800e9ce:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800e9d2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e9d6:	2b00      	cmp	r3, #0
 800e9d8:	dd38      	ble.n	800ea4c <decompress_smooth_data+0x728>
 800e9da:	2201      	movs	r2, #1
 800e9dc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e9e0:	fa02 f303 	lsl.w	r3, r2, r3
 800e9e4:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800e9e8:	429a      	cmp	r2, r3
 800e9ea:	db2f      	blt.n	800ea4c <decompress_smooth_data+0x728>
	      pred = (1<<Al)-1;
 800e9ec:	2201      	movs	r2, #1
 800e9ee:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e9f2:	fa02 f303 	lsl.w	r3, r2, r3
 800e9f6:	3b01      	subs	r3, #1
 800e9f8:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800e9fc:	e026      	b.n	800ea4c <decompress_smooth_data+0x728>
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
 800e9fe:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800ea02:	01da      	lsls	r2, r3, #7
 800ea04:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ea08:	1ad2      	subs	r2, r2, r3
 800ea0a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800ea0e:	021b      	lsls	r3, r3, #8
 800ea10:	fb92 f3f3 	sdiv	r3, r2, r3
 800ea14:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800ea18:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800ea1c:	2b00      	cmp	r3, #0
 800ea1e:	dd10      	ble.n	800ea42 <decompress_smooth_data+0x71e>
 800ea20:	2201      	movs	r2, #1
 800ea22:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800ea26:	fa02 f303 	lsl.w	r3, r2, r3
 800ea2a:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800ea2e:	429a      	cmp	r2, r3
 800ea30:	db07      	blt.n	800ea42 <decompress_smooth_data+0x71e>
	      pred = (1<<Al)-1;
 800ea32:	2201      	movs	r2, #1
 800ea34:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800ea38:	fa02 f303 	lsl.w	r3, r2, r3
 800ea3c:	3b01      	subs	r3, #1
 800ea3e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    pred = -pred;
 800ea42:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800ea46:	425b      	negs	r3, r3
 800ea48:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	  }
	  workspace[9] = (JCOEF) pred;
 800ea4c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800ea50:	b21a      	sxth	r2, r3
 800ea52:	f107 030c 	add.w	r3, r7, #12
 800ea56:	825a      	strh	r2, [r3, #18]
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
 800ea58:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800ea5c:	695b      	ldr	r3, [r3, #20]
 800ea5e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800ea62:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800ea66:	2b00      	cmp	r3, #0
 800ea68:	d06b      	beq.n	800eb42 <decompress_smooth_data+0x81e>
 800ea6a:	f107 030c 	add.w	r3, r7, #12
 800ea6e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800ea72:	2b00      	cmp	r3, #0
 800ea74:	d165      	bne.n	800eb42 <decompress_smooth_data+0x81e>
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
 800ea76:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800ea7a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800ea7e:	441a      	add	r2, r3
 800ea80:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800ea84:	005b      	lsls	r3, r3, #1
 800ea86:	1ad3      	subs	r3, r2, r3
 800ea88:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800ea8c:	fb02 f203 	mul.w	r2, r2, r3
 800ea90:	4613      	mov	r3, r2
 800ea92:	00db      	lsls	r3, r3, #3
 800ea94:	4413      	add	r3, r2
 800ea96:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	  if (num >= 0) {
 800ea9a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ea9e:	2b00      	cmp	r3, #0
 800eaa0:	db22      	blt.n	800eae8 <decompress_smooth_data+0x7c4>
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
 800eaa2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800eaa6:	01da      	lsls	r2, r3, #7
 800eaa8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800eaac:	441a      	add	r2, r3
 800eaae:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800eab2:	021b      	lsls	r3, r3, #8
 800eab4:	fb92 f3f3 	sdiv	r3, r2, r3
 800eab8:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800eabc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eac0:	2b00      	cmp	r3, #0
 800eac2:	dd38      	ble.n	800eb36 <decompress_smooth_data+0x812>
 800eac4:	2201      	movs	r2, #1
 800eac6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eaca:	fa02 f303 	lsl.w	r3, r2, r3
 800eace:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800ead2:	429a      	cmp	r2, r3
 800ead4:	db2f      	blt.n	800eb36 <decompress_smooth_data+0x812>
	      pred = (1<<Al)-1;
 800ead6:	2201      	movs	r2, #1
 800ead8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eadc:	fa02 f303 	lsl.w	r3, r2, r3
 800eae0:	3b01      	subs	r3, #1
 800eae2:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800eae6:	e026      	b.n	800eb36 <decompress_smooth_data+0x812>
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
 800eae8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800eaec:	01da      	lsls	r2, r3, #7
 800eaee:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800eaf2:	1ad2      	subs	r2, r2, r3
 800eaf4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800eaf8:	021b      	lsls	r3, r3, #8
 800eafa:	fb92 f3f3 	sdiv	r3, r2, r3
 800eafe:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    if (Al > 0 && pred >= (1<<Al))
 800eb02:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eb06:	2b00      	cmp	r3, #0
 800eb08:	dd10      	ble.n	800eb2c <decompress_smooth_data+0x808>
 800eb0a:	2201      	movs	r2, #1
 800eb0c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eb10:	fa02 f303 	lsl.w	r3, r2, r3
 800eb14:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 800eb18:	429a      	cmp	r2, r3
 800eb1a:	db07      	blt.n	800eb2c <decompress_smooth_data+0x808>
	      pred = (1<<Al)-1;
 800eb1c:	2201      	movs	r2, #1
 800eb1e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eb22:	fa02 f303 	lsl.w	r3, r2, r3
 800eb26:	3b01      	subs	r3, #1
 800eb28:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	    pred = -pred;
 800eb2c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800eb30:	425b      	negs	r3, r3
 800eb32:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	  }
	  workspace[2] = (JCOEF) pred;
 800eb36:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800eb3a:	b21a      	sxth	r2, r3
 800eb3c:	f107 030c 	add.w	r3, r7, #12
 800eb40:	809a      	strh	r2, [r3, #4]
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
 800eb42:	f107 020c 	add.w	r2, r7, #12
 800eb46:	1d38      	adds	r0, r7, #4
 800eb48:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800eb4c:	9300      	str	r3, [sp, #0]
 800eb4e:	f8d7 4098 	ldr.w	r4, [r7, #152]	; 0x98
 800eb52:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800eb56:	f8d7 10f8 	ldr.w	r1, [r7, #248]	; 0xf8
 800eb5a:	6800      	ldr	r0, [r0, #0]
 800eb5c:	47a0      	blx	r4
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
 800eb5e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 800eb62:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 800eb66:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800eb6a:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
	DC4 = DC5; DC5 = DC6;
 800eb6e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800eb72:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 800eb76:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800eb7a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
	DC7 = DC8; DC8 = DC9;
 800eb7e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800eb82:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 800eb86:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800eb8a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	buffer_ptr++, prev_block_row++, next_block_row++;
 800eb8e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800eb92:	3380      	adds	r3, #128	; 0x80
 800eb94:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 800eb98:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800eb9c:	3380      	adds	r3, #128	; 0x80
 800eb9e:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800eba2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800eba6:	3380      	adds	r3, #128	; 0x80
 800eba8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
	output_col += compptr->DCT_h_scaled_size;
 800ebac:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ebb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ebb2:	461a      	mov	r2, r3
 800ebb4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800ebb8:	4413      	add	r3, r2
 800ebba:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
      for (block_num = 0; block_num <= last_block_column; block_num++) {
 800ebbe:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 800ebc2:	3301      	adds	r3, #1
 800ebc4:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 800ebc8:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 800ebcc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ebd0:	429a      	cmp	r2, r3
 800ebd2:	f67f ad4e 	bls.w	800e672 <decompress_smooth_data+0x34e>
      }
      output_ptr += compptr->DCT_v_scaled_size;
 800ebd6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ebda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ebdc:	009b      	lsls	r3, r3, #2
 800ebde:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 800ebe2:	4413      	add	r3, r2
 800ebe4:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    for (block_row = 0; block_row < block_rows; block_row++) {
 800ebe8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 800ebec:	3301      	adds	r3, #1
 800ebee:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 800ebf2:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 800ebf6:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 800ebfa:	429a      	cmp	r2, r3
 800ebfc:	f6ff acc6 	blt.w	800e58c <decompress_smooth_data+0x268>
 800ec00:	e000      	b.n	800ec04 <decompress_smooth_data+0x8e0>
      continue;
 800ec02:	bf00      	nop
       ci++, compptr++) {
 800ec04:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 800ec08:	3301      	adds	r3, #1
 800ec0a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 800ec0e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ec12:	3358      	adds	r3, #88	; 0x58
 800ec14:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800ec18:	1d3b      	adds	r3, r7, #4
 800ec1a:	681b      	ldr	r3, [r3, #0]
 800ec1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec1e:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 800ec22:	429a      	cmp	r2, r3
 800ec24:	f6ff abe1 	blt.w	800e3ea <decompress_smooth_data+0xc6>
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
 800ec28:	1d3b      	adds	r3, r7, #4
 800ec2a:	681b      	ldr	r3, [r3, #0]
 800ec2c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800ec30:	1c5a      	adds	r2, r3, #1
 800ec32:	1d3b      	adds	r3, r7, #4
 800ec34:	681b      	ldr	r3, [r3, #0]
 800ec36:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 800ec3a:	1d3b      	adds	r3, r7, #4
 800ec3c:	681b      	ldr	r3, [r3, #0]
 800ec3e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800ec42:	1d3b      	adds	r3, r7, #4
 800ec44:	681b      	ldr	r3, [r3, #0]
 800ec46:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 800ec4a:	429a      	cmp	r2, r3
 800ec4c:	d201      	bcs.n	800ec52 <decompress_smooth_data+0x92e>
    return JPEG_ROW_COMPLETED;
 800ec4e:	2303      	movs	r3, #3
 800ec50:	e000      	b.n	800ec54 <decompress_smooth_data+0x930>
  return JPEG_SCAN_COMPLETED;
 800ec52:	2304      	movs	r3, #4
}
 800ec54:	4618      	mov	r0, r3
 800ec56:	f507 7794 	add.w	r7, r7, #296	; 0x128
 800ec5a:	46bd      	mov	sp, r7
 800ec5c:	bdb0      	pop	{r4, r5, r7, pc}
	...

0800ec60 <jinit_d_coef_controller>:
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 800ec60:	b5b0      	push	{r4, r5, r7, lr}
 800ec62:	b08a      	sub	sp, #40	; 0x28
 800ec64:	af02      	add	r7, sp, #8
 800ec66:	6078      	str	r0, [r7, #4]
 800ec68:	6039      	str	r1, [r7, #0]
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800ec6a:	687b      	ldr	r3, [r7, #4]
 800ec6c:	685b      	ldr	r3, [r3, #4]
 800ec6e:	681b      	ldr	r3, [r3, #0]
 800ec70:	2274      	movs	r2, #116	; 0x74
 800ec72:	2101      	movs	r1, #1
 800ec74:	6878      	ldr	r0, [r7, #4]
 800ec76:	4798      	blx	r3
 800ec78:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
 800ec7a:	687b      	ldr	r3, [r7, #4]
 800ec7c:	68fa      	ldr	r2, [r7, #12]
 800ec7e:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
  coef->pub.start_input_pass = start_input_pass;
 800ec82:	68fb      	ldr	r3, [r7, #12]
 800ec84:	4a47      	ldr	r2, [pc, #284]	; (800eda4 <jinit_d_coef_controller+0x144>)
 800ec86:	601a      	str	r2, [r3, #0]
  coef->pub.start_output_pass = start_output_pass;
 800ec88:	68fb      	ldr	r3, [r7, #12]
 800ec8a:	4a47      	ldr	r2, [pc, #284]	; (800eda8 <jinit_d_coef_controller+0x148>)
 800ec8c:	609a      	str	r2, [r3, #8]
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
 800ec8e:	68fb      	ldr	r3, [r7, #12]
 800ec90:	2200      	movs	r2, #0
 800ec92:	671a      	str	r2, [r3, #112]	; 0x70
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
 800ec94:	683b      	ldr	r3, [r7, #0]
 800ec96:	2b00      	cmp	r3, #0
 800ec98:	d051      	beq.n	800ed3e <jinit_d_coef_controller+0xde>
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800ec9a:	2300      	movs	r3, #0
 800ec9c:	61fb      	str	r3, [r7, #28]
 800ec9e:	687b      	ldr	r3, [r7, #4]
 800eca0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800eca4:	617b      	str	r3, [r7, #20]
 800eca6:	e039      	b.n	800ed1c <jinit_d_coef_controller+0xbc>
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
 800eca8:	697b      	ldr	r3, [r7, #20]
 800ecaa:	68db      	ldr	r3, [r3, #12]
 800ecac:	61bb      	str	r3, [r7, #24]
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ecb4:	2b00      	cmp	r3, #0
 800ecb6:	d004      	beq.n	800ecc2 <jinit_d_coef_controller+0x62>
	access_rows *= 3;
 800ecb8:	69ba      	ldr	r2, [r7, #24]
 800ecba:	4613      	mov	r3, r2
 800ecbc:	005b      	lsls	r3, r3, #1
 800ecbe:	4413      	add	r3, r2
 800ecc0:	61bb      	str	r3, [r7, #24]
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 800ecc2:	687b      	ldr	r3, [r7, #4]
 800ecc4:	685b      	ldr	r3, [r3, #4]
 800ecc6:	695c      	ldr	r4, [r3, #20]
	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 800ecc8:	697b      	ldr	r3, [r7, #20]
 800ecca:	69db      	ldr	r3, [r3, #28]
 800eccc:	461a      	mov	r2, r3
				(long) compptr->h_samp_factor),
 800ecce:	697b      	ldr	r3, [r7, #20]
 800ecd0:	689b      	ldr	r3, [r3, #8]
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
 800ecd2:	4619      	mov	r1, r3
 800ecd4:	4610      	mov	r0, r2
 800ecd6:	f018 ff33 	bl	8027b40 <jround_up>
 800ecda:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 800ecdc:	461d      	mov	r5, r3
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 800ecde:	697b      	ldr	r3, [r7, #20]
 800ece0:	6a1b      	ldr	r3, [r3, #32]
 800ece2:	461a      	mov	r2, r3
				(long) compptr->v_samp_factor),
 800ece4:	697b      	ldr	r3, [r7, #20]
 800ece6:	68db      	ldr	r3, [r3, #12]
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
 800ece8:	4619      	mov	r1, r3
 800ecea:	4610      	mov	r0, r2
 800ecec:	f018 ff28 	bl	8027b40 <jround_up>
 800ecf0:	4603      	mov	r3, r0
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
 800ecf2:	461a      	mov	r2, r3
 800ecf4:	69bb      	ldr	r3, [r7, #24]
 800ecf6:	9301      	str	r3, [sp, #4]
 800ecf8:	9200      	str	r2, [sp, #0]
 800ecfa:	462b      	mov	r3, r5
 800ecfc:	2201      	movs	r2, #1
 800ecfe:	2101      	movs	r1, #1
 800ed00:	6878      	ldr	r0, [r7, #4]
 800ed02:	47a0      	blx	r4
 800ed04:	4601      	mov	r1, r0
 800ed06:	68fb      	ldr	r3, [r7, #12]
 800ed08:	69fa      	ldr	r2, [r7, #28]
 800ed0a:	3212      	adds	r2, #18
 800ed0c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	 ci++, compptr++) {
 800ed10:	69fb      	ldr	r3, [r7, #28]
 800ed12:	3301      	adds	r3, #1
 800ed14:	61fb      	str	r3, [r7, #28]
 800ed16:	697b      	ldr	r3, [r7, #20]
 800ed18:	3358      	adds	r3, #88	; 0x58
 800ed1a:	617b      	str	r3, [r7, #20]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800ed1c:	687b      	ldr	r3, [r7, #4]
 800ed1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed20:	69fa      	ldr	r2, [r7, #28]
 800ed22:	429a      	cmp	r2, r3
 800ed24:	dbc0      	blt.n	800eca8 <jinit_d_coef_controller+0x48>
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
 800ed26:	68fb      	ldr	r3, [r7, #12]
 800ed28:	4a20      	ldr	r2, [pc, #128]	; (800edac <jinit_d_coef_controller+0x14c>)
 800ed2a:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_data;
 800ed2c:	68fb      	ldr	r3, [r7, #12]
 800ed2e:	4a20      	ldr	r2, [pc, #128]	; (800edb0 <jinit_d_coef_controller+0x150>)
 800ed30:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
 800ed32:	68fb      	ldr	r3, [r7, #12]
 800ed34:	f103 0248 	add.w	r2, r3, #72	; 0x48
 800ed38:	68fb      	ldr	r3, [r7, #12]
 800ed3a:	611a      	str	r2, [r3, #16]
	       (size_t) (D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK)));
    coef->pub.consume_data = dummy_consume_data;
    coef->pub.decompress_data = decompress_onepass;
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
  }
}
 800ed3c:	e02e      	b.n	800ed9c <jinit_d_coef_controller+0x13c>
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800ed3e:	687b      	ldr	r3, [r7, #4]
 800ed40:	685b      	ldr	r3, [r3, #4]
 800ed42:	685b      	ldr	r3, [r3, #4]
 800ed44:	f44f 62a0 	mov.w	r2, #1280	; 0x500
 800ed48:	2101      	movs	r1, #1
 800ed4a:	6878      	ldr	r0, [r7, #4]
 800ed4c:	4798      	blx	r3
 800ed4e:	60b8      	str	r0, [r7, #8]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 800ed50:	2300      	movs	r3, #0
 800ed52:	613b      	str	r3, [r7, #16]
 800ed54:	e00b      	b.n	800ed6e <jinit_d_coef_controller+0x10e>
      coef->MCU_buffer[i] = buffer + i;
 800ed56:	693b      	ldr	r3, [r7, #16]
 800ed58:	01db      	lsls	r3, r3, #7
 800ed5a:	68ba      	ldr	r2, [r7, #8]
 800ed5c:	18d1      	adds	r1, r2, r3
 800ed5e:	68fb      	ldr	r3, [r7, #12]
 800ed60:	693a      	ldr	r2, [r7, #16]
 800ed62:	3208      	adds	r2, #8
 800ed64:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
 800ed68:	693b      	ldr	r3, [r7, #16]
 800ed6a:	3301      	adds	r3, #1
 800ed6c:	613b      	str	r3, [r7, #16]
 800ed6e:	693b      	ldr	r3, [r7, #16]
 800ed70:	2b09      	cmp	r3, #9
 800ed72:	ddf0      	ble.n	800ed56 <jinit_d_coef_controller+0xf6>
    if (cinfo->lim_Se == 0)	/* DC only case: want to bypass later */
 800ed74:	687b      	ldr	r3, [r7, #4]
 800ed76:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800ed7a:	2b00      	cmp	r3, #0
 800ed7c:	d105      	bne.n	800ed8a <jinit_d_coef_controller+0x12a>
      FMEMZERO((void FAR *) buffer,
 800ed7e:	f44f 62a0 	mov.w	r2, #1280	; 0x500
 800ed82:	2100      	movs	r1, #0
 800ed84:	68b8      	ldr	r0, [r7, #8]
 800ed86:	f019 fa7b 	bl	8028280 <memset>
    coef->pub.consume_data = dummy_consume_data;
 800ed8a:	68fb      	ldr	r3, [r7, #12]
 800ed8c:	4a09      	ldr	r2, [pc, #36]	; (800edb4 <jinit_d_coef_controller+0x154>)
 800ed8e:	605a      	str	r2, [r3, #4]
    coef->pub.decompress_data = decompress_onepass;
 800ed90:	68fb      	ldr	r3, [r7, #12]
 800ed92:	4a09      	ldr	r2, [pc, #36]	; (800edb8 <jinit_d_coef_controller+0x158>)
 800ed94:	60da      	str	r2, [r3, #12]
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
 800ed96:	68fb      	ldr	r3, [r7, #12]
 800ed98:	2200      	movs	r2, #0
 800ed9a:	611a      	str	r2, [r3, #16]
}
 800ed9c:	bf00      	nop
 800ed9e:	3720      	adds	r7, #32
 800eda0:	46bd      	mov	sp, r7
 800eda2:	bdb0      	pop	{r4, r5, r7, pc}
 800eda4:	0800dc17 	.word	0x0800dc17
 800eda8:	0800dc35 	.word	0x0800dc35
 800edac:	0800dea5 	.word	0x0800dea5
 800edb0:	0800e055 	.word	0x0800e055
 800edb4:	0800de8f 	.word	0x0800de8f
 800edb8:	0800dc89 	.word	0x0800dc89

0800edbc <build_ycc_rgb_table>:
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 800edbc:	b580      	push	{r7, lr}
 800edbe:	b086      	sub	sp, #24
 800edc0:	af00      	add	r7, sp, #0
 800edc2:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 800edc4:	687b      	ldr	r3, [r7, #4]
 800edc6:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 800edca:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800edcc:	687b      	ldr	r3, [r7, #4]
 800edce:	685b      	ldr	r3, [r3, #4]
 800edd0:	681b      	ldr	r3, [r3, #0]
 800edd2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800edd6:	2101      	movs	r1, #1
 800edd8:	6878      	ldr	r0, [r7, #4]
 800edda:	4798      	blx	r3
 800eddc:	4602      	mov	r2, r0
  cconvert->Cr_r_tab = (int *)
 800edde:	68fb      	ldr	r3, [r7, #12]
 800ede0:	609a      	str	r2, [r3, #8]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800ede2:	687b      	ldr	r3, [r7, #4]
 800ede4:	685b      	ldr	r3, [r3, #4]
 800ede6:	681b      	ldr	r3, [r3, #0]
 800ede8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800edec:	2101      	movs	r1, #1
 800edee:	6878      	ldr	r0, [r7, #4]
 800edf0:	4798      	blx	r3
 800edf2:	4602      	mov	r2, r0
  cconvert->Cb_b_tab = (int *)
 800edf4:	68fb      	ldr	r3, [r7, #12]
 800edf6:	60da      	str	r2, [r3, #12]
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800edf8:	687b      	ldr	r3, [r7, #4]
 800edfa:	685b      	ldr	r3, [r3, #4]
 800edfc:	681b      	ldr	r3, [r3, #0]
 800edfe:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ee02:	2101      	movs	r1, #1
 800ee04:	6878      	ldr	r0, [r7, #4]
 800ee06:	4798      	blx	r3
 800ee08:	4602      	mov	r2, r0
  cconvert->Cr_g_tab = (INT32 *)
 800ee0a:	68fb      	ldr	r3, [r7, #12]
 800ee0c:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800ee0e:	687b      	ldr	r3, [r7, #4]
 800ee10:	685b      	ldr	r3, [r3, #4]
 800ee12:	681b      	ldr	r3, [r3, #0]
 800ee14:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ee18:	2101      	movs	r1, #1
 800ee1a:	6878      	ldr	r0, [r7, #4]
 800ee1c:	4798      	blx	r3
 800ee1e:	4602      	mov	r2, r0
  cconvert->Cb_g_tab = (INT32 *)
 800ee20:	68fb      	ldr	r3, [r7, #12]
 800ee22:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 800ee24:	2300      	movs	r3, #0
 800ee26:	617b      	str	r3, [r7, #20]
 800ee28:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 800ee2c:	613b      	str	r3, [r7, #16]
 800ee2e:	e035      	b.n	800ee9c <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 800ee30:	693b      	ldr	r3, [r7, #16]
 800ee32:	4a1e      	ldr	r2, [pc, #120]	; (800eeac <build_ycc_rgb_table+0xf0>)
 800ee34:	fb02 f303 	mul.w	r3, r2, r3
 800ee38:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
    cconvert->Cr_r_tab[i] = (int)
 800ee3c:	68fb      	ldr	r3, [r7, #12]
 800ee3e:	6899      	ldr	r1, [r3, #8]
 800ee40:	697b      	ldr	r3, [r7, #20]
 800ee42:	009b      	lsls	r3, r3, #2
 800ee44:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 800ee46:	1412      	asrs	r2, r2, #16
    cconvert->Cr_r_tab[i] = (int)
 800ee48:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 800ee4a:	693b      	ldr	r3, [r7, #16]
 800ee4c:	4a18      	ldr	r2, [pc, #96]	; (800eeb0 <build_ycc_rgb_table+0xf4>)
 800ee4e:	fb02 f303 	mul.w	r3, r2, r3
 800ee52:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
    cconvert->Cb_b_tab[i] = (int)
 800ee56:	68fb      	ldr	r3, [r7, #12]
 800ee58:	68d9      	ldr	r1, [r3, #12]
 800ee5a:	697b      	ldr	r3, [r7, #20]
 800ee5c:	009b      	lsls	r3, r3, #2
 800ee5e:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 800ee60:	1412      	asrs	r2, r2, #16
    cconvert->Cb_b_tab[i] = (int)
 800ee62:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 800ee64:	68fb      	ldr	r3, [r7, #12]
 800ee66:	691a      	ldr	r2, [r3, #16]
 800ee68:	697b      	ldr	r3, [r7, #20]
 800ee6a:	009b      	lsls	r3, r3, #2
 800ee6c:	4413      	add	r3, r2
 800ee6e:	693a      	ldr	r2, [r7, #16]
 800ee70:	4910      	ldr	r1, [pc, #64]	; (800eeb4 <build_ycc_rgb_table+0xf8>)
 800ee72:	fb01 f202 	mul.w	r2, r1, r2
 800ee76:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 800ee78:	693b      	ldr	r3, [r7, #16]
 800ee7a:	4a0f      	ldr	r2, [pc, #60]	; (800eeb8 <build_ycc_rgb_table+0xfc>)
 800ee7c:	fb02 f203 	mul.w	r2, r2, r3
 800ee80:	68fb      	ldr	r3, [r7, #12]
 800ee82:	6959      	ldr	r1, [r3, #20]
 800ee84:	697b      	ldr	r3, [r7, #20]
 800ee86:	009b      	lsls	r3, r3, #2
 800ee88:	440b      	add	r3, r1
 800ee8a:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 800ee8e:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 800ee90:	697b      	ldr	r3, [r7, #20]
 800ee92:	3301      	adds	r3, #1
 800ee94:	617b      	str	r3, [r7, #20]
 800ee96:	693b      	ldr	r3, [r7, #16]
 800ee98:	3301      	adds	r3, #1
 800ee9a:	613b      	str	r3, [r7, #16]
 800ee9c:	697b      	ldr	r3, [r7, #20]
 800ee9e:	2bff      	cmp	r3, #255	; 0xff
 800eea0:	ddc6      	ble.n	800ee30 <build_ycc_rgb_table+0x74>
  }
}
 800eea2:	bf00      	nop
 800eea4:	bf00      	nop
 800eea6:	3718      	adds	r7, #24
 800eea8:	46bd      	mov	sp, r7
 800eeaa:	bd80      	pop	{r7, pc}
 800eeac:	000166e9 	.word	0x000166e9
 800eeb0:	0001c5a2 	.word	0x0001c5a2
 800eeb4:	ffff492e 	.word	0xffff492e
 800eeb8:	ffffa7e6 	.word	0xffffa7e6

0800eebc <ycc_rgb_convert>:

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
 800eebc:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800eec0:	b08d      	sub	sp, #52	; 0x34
 800eec2:	af00      	add	r7, sp, #0
 800eec4:	6278      	str	r0, [r7, #36]	; 0x24
 800eec6:	6239      	str	r1, [r7, #32]
 800eec8:	61fa      	str	r2, [r7, #28]
 800eeca:	61bb      	str	r3, [r7, #24]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 800eecc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eece:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 800eed2:	62fb      	str	r3, [r7, #44]	; 0x2c
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 800eed4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eed6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800eed8:	62bb      	str	r3, [r7, #40]	; 0x28
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 800eeda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eedc:	f8d3 614c 	ldr.w	r6, [r3, #332]	; 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 800eee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eee2:	689b      	ldr	r3, [r3, #8]
 800eee4:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 800eee6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eee8:	68db      	ldr	r3, [r3, #12]
 800eeea:	617b      	str	r3, [r7, #20]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 800eeec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eeee:	691b      	ldr	r3, [r3, #16]
 800eef0:	613b      	str	r3, [r7, #16]
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 800eef2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eef4:	695b      	ldr	r3, [r3, #20]
 800eef6:	60fb      	str	r3, [r7, #12]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 800eef8:	e054      	b.n	800efa4 <ycc_rgb_convert+0xe8>
    inptr0 = input_buf[0][input_row];
 800eefa:	6a3b      	ldr	r3, [r7, #32]
 800eefc:	681a      	ldr	r2, [r3, #0]
 800eefe:	69fb      	ldr	r3, [r7, #28]
 800ef00:	009b      	lsls	r3, r3, #2
 800ef02:	4413      	add	r3, r2
 800ef04:	681b      	ldr	r3, [r3, #0]
 800ef06:	60bb      	str	r3, [r7, #8]
    inptr1 = input_buf[1][input_row];
 800ef08:	6a3b      	ldr	r3, [r7, #32]
 800ef0a:	3304      	adds	r3, #4
 800ef0c:	681a      	ldr	r2, [r3, #0]
 800ef0e:	69fb      	ldr	r3, [r7, #28]
 800ef10:	009b      	lsls	r3, r3, #2
 800ef12:	4413      	add	r3, r2
 800ef14:	681b      	ldr	r3, [r3, #0]
 800ef16:	607b      	str	r3, [r7, #4]
    inptr2 = input_buf[2][input_row];
 800ef18:	6a3b      	ldr	r3, [r7, #32]
 800ef1a:	3308      	adds	r3, #8
 800ef1c:	681a      	ldr	r2, [r3, #0]
 800ef1e:	69fb      	ldr	r3, [r7, #28]
 800ef20:	009b      	lsls	r3, r3, #2
 800ef22:	4413      	add	r3, r2
 800ef24:	681b      	ldr	r3, [r3, #0]
 800ef26:	603b      	str	r3, [r7, #0]
    input_row++;
 800ef28:	69fb      	ldr	r3, [r7, #28]
 800ef2a:	3301      	adds	r3, #1
 800ef2c:	61fb      	str	r3, [r7, #28]
    outptr = *output_buf++;
 800ef2e:	69bb      	ldr	r3, [r7, #24]
 800ef30:	1d1a      	adds	r2, r3, #4
 800ef32:	61ba      	str	r2, [r7, #24]
 800ef34:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 800ef36:	2400      	movs	r4, #0
 800ef38:	e031      	b.n	800ef9e <ycc_rgb_convert+0xe2>
      y  = GETJSAMPLE(inptr0[col]);
 800ef3a:	68bb      	ldr	r3, [r7, #8]
 800ef3c:	4423      	add	r3, r4
 800ef3e:	781b      	ldrb	r3, [r3, #0]
 800ef40:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 800ef42:	687b      	ldr	r3, [r7, #4]
 800ef44:	4423      	add	r3, r4
 800ef46:	781b      	ldrb	r3, [r3, #0]
 800ef48:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 800ef4a:	683b      	ldr	r3, [r7, #0]
 800ef4c:	4423      	add	r3, r4
 800ef4e:	781b      	ldrb	r3, [r3, #0]
 800ef50:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
 800ef52:	464b      	mov	r3, r9
 800ef54:	009b      	lsls	r3, r3, #2
 800ef56:	4602      	mov	r2, r0
 800ef58:	4413      	add	r3, r2
 800ef5a:	681b      	ldr	r3, [r3, #0]
 800ef5c:	4443      	add	r3, r8
 800ef5e:	4433      	add	r3, r6
 800ef60:	781b      	ldrb	r3, [r3, #0]
 800ef62:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 800ef64:	4653      	mov	r3, sl
 800ef66:	009b      	lsls	r3, r3, #2
 800ef68:	68fa      	ldr	r2, [r7, #12]
 800ef6a:	4413      	add	r3, r2
 800ef6c:	681a      	ldr	r2, [r3, #0]
 800ef6e:	464b      	mov	r3, r9
 800ef70:	009b      	lsls	r3, r3, #2
 800ef72:	6939      	ldr	r1, [r7, #16]
 800ef74:	440b      	add	r3, r1
 800ef76:	681b      	ldr	r3, [r3, #0]
 800ef78:	4413      	add	r3, r2
 800ef7a:	141b      	asrs	r3, r3, #16
      outptr[RGB_GREEN] = range_limit[y +
 800ef7c:	4443      	add	r3, r8
 800ef7e:	4433      	add	r3, r6
 800ef80:	1c6a      	adds	r2, r5, #1
 800ef82:	781b      	ldrb	r3, [r3, #0]
 800ef84:	7013      	strb	r3, [r2, #0]
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
 800ef86:	4653      	mov	r3, sl
 800ef88:	009b      	lsls	r3, r3, #2
 800ef8a:	697a      	ldr	r2, [r7, #20]
 800ef8c:	4413      	add	r3, r2
 800ef8e:	681b      	ldr	r3, [r3, #0]
 800ef90:	4443      	add	r3, r8
 800ef92:	18f2      	adds	r2, r6, r3
 800ef94:	1cab      	adds	r3, r5, #2
 800ef96:	7812      	ldrb	r2, [r2, #0]
 800ef98:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 800ef9a:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 800ef9c:	3401      	adds	r4, #1
 800ef9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800efa0:	429c      	cmp	r4, r3
 800efa2:	d3ca      	bcc.n	800ef3a <ycc_rgb_convert+0x7e>
  while (--num_rows >= 0) {
 800efa4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800efa6:	3b01      	subs	r3, #1
 800efa8:	653b      	str	r3, [r7, #80]	; 0x50
 800efaa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800efac:	2b00      	cmp	r3, #0
 800efae:	daa4      	bge.n	800eefa <ycc_rgb_convert+0x3e>
    }
  }
}
 800efb0:	bf00      	nop
 800efb2:	bf00      	nop
 800efb4:	3734      	adds	r7, #52	; 0x34
 800efb6:	46bd      	mov	sp, r7
 800efb8:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800efbc:	4770      	bx	lr

0800efbe <build_rgb_y_table>:
 * Initialize for RGB->grayscale colorspace conversion.
 */

LOCAL(void)
build_rgb_y_table (j_decompress_ptr cinfo)
{
 800efbe:	b580      	push	{r7, lr}
 800efc0:	b086      	sub	sp, #24
 800efc2:	af00      	add	r7, sp, #0
 800efc4:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 800efc6:	687b      	ldr	r3, [r7, #4]
 800efc8:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 800efcc:	613b      	str	r3, [r7, #16]
  INT32 * rgb_y_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800efce:	687b      	ldr	r3, [r7, #4]
 800efd0:	685b      	ldr	r3, [r3, #4]
 800efd2:	681b      	ldr	r3, [r3, #0]
 800efd4:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 800efd8:	2101      	movs	r1, #1
 800efda:	6878      	ldr	r0, [r7, #4]
 800efdc:	4798      	blx	r3
 800efde:	60f8      	str	r0, [r7, #12]
  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
 800efe0:	693b      	ldr	r3, [r7, #16]
 800efe2:	68fa      	ldr	r2, [r7, #12]
 800efe4:	619a      	str	r2, [r3, #24]
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
 800efe6:	2300      	movs	r3, #0
 800efe8:	617b      	str	r3, [r7, #20]
 800efea:	e026      	b.n	800f03a <build_rgb_y_table+0x7c>
    rgb_y_tab[i+R_Y_OFF] = FIX(0.29900) * i;
 800efec:	697b      	ldr	r3, [r7, #20]
 800efee:	009b      	lsls	r3, r3, #2
 800eff0:	68fa      	ldr	r2, [r7, #12]
 800eff2:	4413      	add	r3, r2
 800eff4:	697a      	ldr	r2, [r7, #20]
 800eff6:	f644 418b 	movw	r1, #19595	; 0x4c8b
 800effa:	fb01 f202 	mul.w	r2, r1, r2
 800effe:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+G_Y_OFF] = FIX(0.58700) * i;
 800f000:	697b      	ldr	r3, [r7, #20]
 800f002:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800f006:	009b      	lsls	r3, r3, #2
 800f008:	68fa      	ldr	r2, [r7, #12]
 800f00a:	4413      	add	r3, r2
 800f00c:	697a      	ldr	r2, [r7, #20]
 800f00e:	f249 6146 	movw	r1, #38470	; 0x9646
 800f012:	fb01 f202 	mul.w	r2, r1, r2
 800f016:	601a      	str	r2, [r3, #0]
    rgb_y_tab[i+B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;
 800f018:	697b      	ldr	r3, [r7, #20]
 800f01a:	f641 522f 	movw	r2, #7471	; 0x1d2f
 800f01e:	fb02 f203 	mul.w	r2, r2, r3
 800f022:	697b      	ldr	r3, [r7, #20]
 800f024:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f028:	009b      	lsls	r3, r3, #2
 800f02a:	68f9      	ldr	r1, [r7, #12]
 800f02c:	440b      	add	r3, r1
 800f02e:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 800f032:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++) {
 800f034:	697b      	ldr	r3, [r7, #20]
 800f036:	3301      	adds	r3, #1
 800f038:	617b      	str	r3, [r7, #20]
 800f03a:	697b      	ldr	r3, [r7, #20]
 800f03c:	2bff      	cmp	r3, #255	; 0xff
 800f03e:	ddd5      	ble.n	800efec <build_rgb_y_table+0x2e>
  }
}
 800f040:	bf00      	nop
 800f042:	bf00      	nop
 800f044:	3718      	adds	r7, #24
 800f046:	46bd      	mov	sp, r7
 800f048:	bd80      	pop	{r7, pc}

0800f04a <rgb_gray_convert>:

METHODDEF(void)
rgb_gray_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 800f04a:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800f04e:	b089      	sub	sp, #36	; 0x24
 800f050:	af00      	add	r7, sp, #0
 800f052:	6178      	str	r0, [r7, #20]
 800f054:	6139      	str	r1, [r7, #16]
 800f056:	60fa      	str	r2, [r7, #12]
 800f058:	60bb      	str	r3, [r7, #8]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 800f05a:	697b      	ldr	r3, [r7, #20]
 800f05c:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 800f060:	61fb      	str	r3, [r7, #28]
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_y_tab;
 800f062:	69fb      	ldr	r3, [r7, #28]
 800f064:	699d      	ldr	r5, [r3, #24]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 800f066:	697b      	ldr	r3, [r7, #20]
 800f068:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f06a:	61bb      	str	r3, [r7, #24]

  while (--num_rows >= 0) {
 800f06c:	e045      	b.n	800f0fa <rgb_gray_convert+0xb0>
    inptr0 = input_buf[0][input_row];
 800f06e:	693b      	ldr	r3, [r7, #16]
 800f070:	681a      	ldr	r2, [r3, #0]
 800f072:	68fb      	ldr	r3, [r7, #12]
 800f074:	009b      	lsls	r3, r3, #2
 800f076:	4413      	add	r3, r2
 800f078:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 800f07a:	693b      	ldr	r3, [r7, #16]
 800f07c:	3304      	adds	r3, #4
 800f07e:	681a      	ldr	r2, [r3, #0]
 800f080:	68fb      	ldr	r3, [r7, #12]
 800f082:	009b      	lsls	r3, r3, #2
 800f084:	4413      	add	r3, r2
 800f086:	681b      	ldr	r3, [r3, #0]
 800f088:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 800f08a:	693b      	ldr	r3, [r7, #16]
 800f08c:	3308      	adds	r3, #8
 800f08e:	681a      	ldr	r2, [r3, #0]
 800f090:	68fb      	ldr	r3, [r7, #12]
 800f092:	009b      	lsls	r3, r3, #2
 800f094:	4413      	add	r3, r2
 800f096:	681b      	ldr	r3, [r3, #0]
 800f098:	4618      	mov	r0, r3
    input_row++;
 800f09a:	68fb      	ldr	r3, [r7, #12]
 800f09c:	3301      	adds	r3, #1
 800f09e:	60fb      	str	r3, [r7, #12]
    outptr = *output_buf++;
 800f0a0:	68bb      	ldr	r3, [r7, #8]
 800f0a2:	1d1a      	adds	r2, r3, #4
 800f0a4:	60ba      	str	r2, [r7, #8]
 800f0a6:	681b      	ldr	r3, [r3, #0]
 800f0a8:	607b      	str	r3, [r7, #4]
    for (col = 0; col < num_cols; col++) {
 800f0aa:	2400      	movs	r4, #0
 800f0ac:	e022      	b.n	800f0f4 <rgb_gray_convert+0xaa>
      r = GETJSAMPLE(inptr0[col]);
 800f0ae:	1933      	adds	r3, r6, r4
 800f0b0:	781b      	ldrb	r3, [r3, #0]
 800f0b2:	469a      	mov	sl, r3
      g = GETJSAMPLE(inptr1[col]);
 800f0b4:	460b      	mov	r3, r1
 800f0b6:	4423      	add	r3, r4
 800f0b8:	781b      	ldrb	r3, [r3, #0]
 800f0ba:	4699      	mov	r9, r3
      b = GETJSAMPLE(inptr2[col]);
 800f0bc:	4603      	mov	r3, r0
 800f0be:	4423      	add	r3, r4
 800f0c0:	781b      	ldrb	r3, [r3, #0]
 800f0c2:	4698      	mov	r8, r3
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 800f0c4:	4653      	mov	r3, sl
 800f0c6:	009b      	lsls	r3, r3, #2
 800f0c8:	442b      	add	r3, r5
 800f0ca:	681a      	ldr	r2, [r3, #0]
 800f0cc:	464b      	mov	r3, r9
 800f0ce:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800f0d2:	009b      	lsls	r3, r3, #2
 800f0d4:	442b      	add	r3, r5
 800f0d6:	681b      	ldr	r3, [r3, #0]
 800f0d8:	441a      	add	r2, r3
 800f0da:	4643      	mov	r3, r8
 800f0dc:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f0e0:	009b      	lsls	r3, r3, #2
 800f0e2:	442b      	add	r3, r5
 800f0e4:	681b      	ldr	r3, [r3, #0]
 800f0e6:	4413      	add	r3, r2
		 >> SCALEBITS);
 800f0e8:	141a      	asrs	r2, r3, #16
      outptr[col] = (JSAMPLE)
 800f0ea:	687b      	ldr	r3, [r7, #4]
 800f0ec:	4423      	add	r3, r4
 800f0ee:	b2d2      	uxtb	r2, r2
 800f0f0:	701a      	strb	r2, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 800f0f2:	3401      	adds	r4, #1
 800f0f4:	69bb      	ldr	r3, [r7, #24]
 800f0f6:	429c      	cmp	r4, r3
 800f0f8:	d3d9      	bcc.n	800f0ae <rgb_gray_convert+0x64>
  while (--num_rows >= 0) {
 800f0fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f0fc:	3b01      	subs	r3, #1
 800f0fe:	643b      	str	r3, [r7, #64]	; 0x40
 800f100:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f102:	2b00      	cmp	r3, #0
 800f104:	dab3      	bge.n	800f06e <rgb_gray_convert+0x24>
    }
  }
}
 800f106:	bf00      	nop
 800f108:	bf00      	nop
 800f10a:	3724      	adds	r7, #36	; 0x24
 800f10c:	46bd      	mov	sp, r7
 800f10e:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800f112:	4770      	bx	lr

0800f114 <rgb_convert>:

METHODDEF(void)
rgb_convert (j_decompress_ptr cinfo,
	     JSAMPIMAGE input_buf, JDIMENSION input_row,
	     JSAMPARRAY output_buf, int num_rows)
{
 800f114:	b4f0      	push	{r4, r5, r6, r7}
 800f116:	b086      	sub	sp, #24
 800f118:	af00      	add	r7, sp, #0
 800f11a:	60f8      	str	r0, [r7, #12]
 800f11c:	60b9      	str	r1, [r7, #8]
 800f11e:	607a      	str	r2, [r7, #4]
 800f120:	603b      	str	r3, [r7, #0]
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 800f122:	68fb      	ldr	r3, [r7, #12]
 800f124:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f126:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 800f128:	e030      	b.n	800f18c <rgb_convert+0x78>
    inptr0 = input_buf[0][input_row];
 800f12a:	68bb      	ldr	r3, [r7, #8]
 800f12c:	681a      	ldr	r2, [r3, #0]
 800f12e:	687b      	ldr	r3, [r7, #4]
 800f130:	009b      	lsls	r3, r3, #2
 800f132:	4413      	add	r3, r2
 800f134:	681e      	ldr	r6, [r3, #0]
    inptr1 = input_buf[1][input_row];
 800f136:	68bb      	ldr	r3, [r7, #8]
 800f138:	3304      	adds	r3, #4
 800f13a:	681a      	ldr	r2, [r3, #0]
 800f13c:	687b      	ldr	r3, [r7, #4]
 800f13e:	009b      	lsls	r3, r3, #2
 800f140:	4413      	add	r3, r2
 800f142:	681b      	ldr	r3, [r3, #0]
 800f144:	4619      	mov	r1, r3
    inptr2 = input_buf[2][input_row];
 800f146:	68bb      	ldr	r3, [r7, #8]
 800f148:	3308      	adds	r3, #8
 800f14a:	681a      	ldr	r2, [r3, #0]
 800f14c:	687b      	ldr	r3, [r7, #4]
 800f14e:	009b      	lsls	r3, r3, #2
 800f150:	4413      	add	r3, r2
 800f152:	681b      	ldr	r3, [r3, #0]
 800f154:	4618      	mov	r0, r3
    input_row++;
 800f156:	687b      	ldr	r3, [r7, #4]
 800f158:	3301      	adds	r3, #1
 800f15a:	607b      	str	r3, [r7, #4]
    outptr = *output_buf++;
 800f15c:	683b      	ldr	r3, [r7, #0]
 800f15e:	1d1a      	adds	r2, r3, #4
 800f160:	603a      	str	r2, [r7, #0]
 800f162:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 800f164:	2400      	movs	r4, #0
 800f166:	e00e      	b.n	800f186 <rgb_convert+0x72>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED]   = inptr0[col];
 800f168:	1933      	adds	r3, r6, r4
 800f16a:	781b      	ldrb	r3, [r3, #0]
 800f16c:	702b      	strb	r3, [r5, #0]
      outptr[RGB_GREEN] = inptr1[col];
 800f16e:	460b      	mov	r3, r1
 800f170:	191a      	adds	r2, r3, r4
 800f172:	1c6b      	adds	r3, r5, #1
 800f174:	7812      	ldrb	r2, [r2, #0]
 800f176:	701a      	strb	r2, [r3, #0]
      outptr[RGB_BLUE]  = inptr2[col];
 800f178:	4603      	mov	r3, r0
 800f17a:	191a      	adds	r2, r3, r4
 800f17c:	1cab      	adds	r3, r5, #2
 800f17e:	7812      	ldrb	r2, [r2, #0]
 800f180:	701a      	strb	r2, [r3, #0]
      outptr += RGB_PIXELSIZE;
 800f182:	3503      	adds	r5, #3
    for (col = 0; col < num_cols; col++) {
 800f184:	3401      	adds	r4, #1
 800f186:	697b      	ldr	r3, [r7, #20]
 800f188:	429c      	cmp	r4, r3
 800f18a:	d3ed      	bcc.n	800f168 <rgb_convert+0x54>
  while (--num_rows >= 0) {
 800f18c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f18e:	3b01      	subs	r3, #1
 800f190:	62bb      	str	r3, [r7, #40]	; 0x28
 800f192:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f194:	2b00      	cmp	r3, #0
 800f196:	dac8      	bge.n	800f12a <rgb_convert+0x16>
    }
  }
}
 800f198:	bf00      	nop
 800f19a:	bf00      	nop
 800f19c:	3718      	adds	r7, #24
 800f19e:	46bd      	mov	sp, r7
 800f1a0:	bcf0      	pop	{r4, r5, r6, r7}
 800f1a2:	4770      	bx	lr

0800f1a4 <null_convert>:

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
 800f1a4:	b4f0      	push	{r4, r5, r6, r7}
 800f1a6:	b086      	sub	sp, #24
 800f1a8:	af00      	add	r7, sp, #0
 800f1aa:	60f8      	str	r0, [r7, #12]
 800f1ac:	60b9      	str	r1, [r7, #8]
 800f1ae:	607a      	str	r2, [r7, #4]
 800f1b0:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
 800f1b2:	68fb      	ldr	r3, [r7, #12]
 800f1b4:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  JDIMENSION num_cols = cinfo->output_width;
 800f1b6:	68fb      	ldr	r3, [r7, #12]
 800f1b8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f1ba:	613b      	str	r3, [r7, #16]
  int ci;

  while (--num_rows >= 0) {
 800f1bc:	e028      	b.n	800f210 <null_convert+0x6c>
    for (ci = 0; ci < num_components; ci++) {
 800f1be:	2300      	movs	r3, #0
 800f1c0:	617b      	str	r3, [r7, #20]
 800f1c2:	e01c      	b.n	800f1fe <null_convert+0x5a>
      inptr = input_buf[ci][input_row];
 800f1c4:	697b      	ldr	r3, [r7, #20]
 800f1c6:	009b      	lsls	r3, r3, #2
 800f1c8:	68ba      	ldr	r2, [r7, #8]
 800f1ca:	4413      	add	r3, r2
 800f1cc:	681a      	ldr	r2, [r3, #0]
 800f1ce:	687b      	ldr	r3, [r7, #4]
 800f1d0:	009b      	lsls	r3, r3, #2
 800f1d2:	4413      	add	r3, r2
 800f1d4:	681b      	ldr	r3, [r3, #0]
 800f1d6:	4619      	mov	r1, r3
      outptr = output_buf[0] + ci;
 800f1d8:	683b      	ldr	r3, [r7, #0]
 800f1da:	681a      	ldr	r2, [r3, #0]
 800f1dc:	697b      	ldr	r3, [r7, #20]
 800f1de:	18d5      	adds	r5, r2, r3
      for (count = num_cols; count > 0; count--) {
 800f1e0:	693c      	ldr	r4, [r7, #16]
 800f1e2:	e007      	b.n	800f1f4 <null_convert+0x50>
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
 800f1e4:	460b      	mov	r3, r1
 800f1e6:	1c5a      	adds	r2, r3, #1
 800f1e8:	4611      	mov	r1, r2
 800f1ea:	781b      	ldrb	r3, [r3, #0]
 800f1ec:	702b      	strb	r3, [r5, #0]
	outptr += num_components;
 800f1ee:	4633      	mov	r3, r6
 800f1f0:	441d      	add	r5, r3
      for (count = num_cols; count > 0; count--) {
 800f1f2:	3c01      	subs	r4, #1
 800f1f4:	2c00      	cmp	r4, #0
 800f1f6:	d1f5      	bne.n	800f1e4 <null_convert+0x40>
    for (ci = 0; ci < num_components; ci++) {
 800f1f8:	697b      	ldr	r3, [r7, #20]
 800f1fa:	3301      	adds	r3, #1
 800f1fc:	617b      	str	r3, [r7, #20]
 800f1fe:	697b      	ldr	r3, [r7, #20]
 800f200:	42b3      	cmp	r3, r6
 800f202:	dbdf      	blt.n	800f1c4 <null_convert+0x20>
      }
    }
    input_row++;
 800f204:	687b      	ldr	r3, [r7, #4]
 800f206:	3301      	adds	r3, #1
 800f208:	607b      	str	r3, [r7, #4]
    output_buf++;
 800f20a:	683b      	ldr	r3, [r7, #0]
 800f20c:	3304      	adds	r3, #4
 800f20e:	603b      	str	r3, [r7, #0]
  while (--num_rows >= 0) {
 800f210:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f212:	3b01      	subs	r3, #1
 800f214:	62bb      	str	r3, [r7, #40]	; 0x28
 800f216:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f218:	2b00      	cmp	r3, #0
 800f21a:	dad0      	bge.n	800f1be <null_convert+0x1a>
  }
}
 800f21c:	bf00      	nop
 800f21e:	bf00      	nop
 800f220:	3718      	adds	r7, #24
 800f222:	46bd      	mov	sp, r7
 800f224:	bcf0      	pop	{r4, r5, r6, r7}
 800f226:	4770      	bx	lr

0800f228 <grayscale_convert>:

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 800f228:	b580      	push	{r7, lr}
 800f22a:	b086      	sub	sp, #24
 800f22c:	af02      	add	r7, sp, #8
 800f22e:	60f8      	str	r0, [r7, #12]
 800f230:	60b9      	str	r1, [r7, #8]
 800f232:	607a      	str	r2, [r7, #4]
 800f234:	603b      	str	r3, [r7, #0]
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
 800f236:	68bb      	ldr	r3, [r7, #8]
 800f238:	6818      	ldr	r0, [r3, #0]
 800f23a:	6879      	ldr	r1, [r7, #4]
 800f23c:	68fb      	ldr	r3, [r7, #12]
 800f23e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f240:	9301      	str	r3, [sp, #4]
 800f242:	69bb      	ldr	r3, [r7, #24]
 800f244:	9300      	str	r3, [sp, #0]
 800f246:	2300      	movs	r3, #0
 800f248:	683a      	ldr	r2, [r7, #0]
 800f24a:	f018 fc93 	bl	8027b74 <jcopy_sample_rows>
		    num_rows, cinfo->output_width);
}
 800f24e:	bf00      	nop
 800f250:	3710      	adds	r7, #16
 800f252:	46bd      	mov	sp, r7
 800f254:	bd80      	pop	{r7, pc}

0800f256 <gray_rgb_convert>:

METHODDEF(void)
gray_rgb_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
 800f256:	b4f0      	push	{r4, r5, r6, r7}
 800f258:	b086      	sub	sp, #24
 800f25a:	af00      	add	r7, sp, #0
 800f25c:	60f8      	str	r0, [r7, #12]
 800f25e:	60b9      	str	r1, [r7, #8]
 800f260:	607a      	str	r2, [r7, #4]
 800f262:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 800f264:	68fb      	ldr	r3, [r7, #12]
 800f266:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f268:	617b      	str	r3, [r7, #20]

  while (--num_rows >= 0) {
 800f26a:	e01b      	b.n	800f2a4 <gray_rgb_convert+0x4e>
    inptr = input_buf[0][input_row++];
 800f26c:	68bb      	ldr	r3, [r7, #8]
 800f26e:	681a      	ldr	r2, [r3, #0]
 800f270:	687b      	ldr	r3, [r7, #4]
 800f272:	1c59      	adds	r1, r3, #1
 800f274:	6079      	str	r1, [r7, #4]
 800f276:	009b      	lsls	r3, r3, #2
 800f278:	4413      	add	r3, r2
 800f27a:	681e      	ldr	r6, [r3, #0]
    outptr = *output_buf++;
 800f27c:	683b      	ldr	r3, [r7, #0]
 800f27e:	1d1a      	adds	r2, r3, #4
 800f280:	603a      	str	r2, [r7, #0]
 800f282:	681c      	ldr	r4, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 800f284:	2500      	movs	r5, #0
 800f286:	e00a      	b.n	800f29e <gray_rgb_convert+0x48>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
 800f288:	1973      	adds	r3, r6, r5
 800f28a:	1ca2      	adds	r2, r4, #2
 800f28c:	781b      	ldrb	r3, [r3, #0]
 800f28e:	7013      	strb	r3, [r2, #0]
 800f290:	1c63      	adds	r3, r4, #1
 800f292:	7812      	ldrb	r2, [r2, #0]
 800f294:	701a      	strb	r2, [r3, #0]
 800f296:	781b      	ldrb	r3, [r3, #0]
 800f298:	7023      	strb	r3, [r4, #0]
      outptr += RGB_PIXELSIZE;
 800f29a:	3403      	adds	r4, #3
    for (col = 0; col < num_cols; col++) {
 800f29c:	3501      	adds	r5, #1
 800f29e:	697b      	ldr	r3, [r7, #20]
 800f2a0:	429d      	cmp	r5, r3
 800f2a2:	d3f1      	bcc.n	800f288 <gray_rgb_convert+0x32>
  while (--num_rows >= 0) {
 800f2a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f2a6:	3b01      	subs	r3, #1
 800f2a8:	62bb      	str	r3, [r7, #40]	; 0x28
 800f2aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f2ac:	2b00      	cmp	r3, #0
 800f2ae:	dadd      	bge.n	800f26c <gray_rgb_convert+0x16>
    }
  }
}
 800f2b0:	bf00      	nop
 800f2b2:	bf00      	nop
 800f2b4:	3718      	adds	r7, #24
 800f2b6:	46bd      	mov	sp, r7
 800f2b8:	bcf0      	pop	{r4, r5, r6, r7}
 800f2ba:	4770      	bx	lr

0800f2bc <ycck_cmyk_convert>:

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
 800f2bc:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800f2c0:	b08f      	sub	sp, #60	; 0x3c
 800f2c2:	af00      	add	r7, sp, #0
 800f2c4:	62f8      	str	r0, [r7, #44]	; 0x2c
 800f2c6:	62b9      	str	r1, [r7, #40]	; 0x28
 800f2c8:	627a      	str	r2, [r7, #36]	; 0x24
 800f2ca:	623b      	str	r3, [r7, #32]
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
 800f2cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f2ce:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 800f2d2:	637b      	str	r3, [r7, #52]	; 0x34
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
 800f2d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f2d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f2d8:	633b      	str	r3, [r7, #48]	; 0x30
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 800f2da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f2dc:	f8d3 614c 	ldr.w	r6, [r3, #332]	; 0x14c
  register int * Crrtab = cconvert->Cr_r_tab;
 800f2e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f2e2:	689b      	ldr	r3, [r3, #8]
 800f2e4:	4618      	mov	r0, r3
  register int * Cbbtab = cconvert->Cb_b_tab;
 800f2e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f2e8:	68db      	ldr	r3, [r3, #12]
 800f2ea:	61fb      	str	r3, [r7, #28]
  register INT32 * Crgtab = cconvert->Cr_g_tab;
 800f2ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f2ee:	691b      	ldr	r3, [r3, #16]
 800f2f0:	61bb      	str	r3, [r7, #24]
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
 800f2f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f2f4:	695b      	ldr	r3, [r3, #20]
 800f2f6:	617b      	str	r3, [r7, #20]
  SHIFT_TEMPS

  while (--num_rows >= 0) {
 800f2f8:	e067      	b.n	800f3ca <ycck_cmyk_convert+0x10e>
    inptr0 = input_buf[0][input_row];
 800f2fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f2fc:	681a      	ldr	r2, [r3, #0]
 800f2fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f300:	009b      	lsls	r3, r3, #2
 800f302:	4413      	add	r3, r2
 800f304:	681b      	ldr	r3, [r3, #0]
 800f306:	613b      	str	r3, [r7, #16]
    inptr1 = input_buf[1][input_row];
 800f308:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f30a:	3304      	adds	r3, #4
 800f30c:	681a      	ldr	r2, [r3, #0]
 800f30e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f310:	009b      	lsls	r3, r3, #2
 800f312:	4413      	add	r3, r2
 800f314:	681b      	ldr	r3, [r3, #0]
 800f316:	60fb      	str	r3, [r7, #12]
    inptr2 = input_buf[2][input_row];
 800f318:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f31a:	3308      	adds	r3, #8
 800f31c:	681a      	ldr	r2, [r3, #0]
 800f31e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f320:	009b      	lsls	r3, r3, #2
 800f322:	4413      	add	r3, r2
 800f324:	681b      	ldr	r3, [r3, #0]
 800f326:	60bb      	str	r3, [r7, #8]
    inptr3 = input_buf[3][input_row];
 800f328:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f32a:	330c      	adds	r3, #12
 800f32c:	681a      	ldr	r2, [r3, #0]
 800f32e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f330:	009b      	lsls	r3, r3, #2
 800f332:	4413      	add	r3, r2
 800f334:	681b      	ldr	r3, [r3, #0]
 800f336:	607b      	str	r3, [r7, #4]
    input_row++;
 800f338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f33a:	3301      	adds	r3, #1
 800f33c:	627b      	str	r3, [r7, #36]	; 0x24
    outptr = *output_buf++;
 800f33e:	6a3b      	ldr	r3, [r7, #32]
 800f340:	1d1a      	adds	r2, r3, #4
 800f342:	623a      	str	r2, [r7, #32]
 800f344:	681d      	ldr	r5, [r3, #0]
    for (col = 0; col < num_cols; col++) {
 800f346:	2400      	movs	r4, #0
 800f348:	e03c      	b.n	800f3c4 <ycck_cmyk_convert+0x108>
      y  = GETJSAMPLE(inptr0[col]);
 800f34a:	693b      	ldr	r3, [r7, #16]
 800f34c:	4423      	add	r3, r4
 800f34e:	781b      	ldrb	r3, [r3, #0]
 800f350:	4698      	mov	r8, r3
      cb = GETJSAMPLE(inptr1[col]);
 800f352:	68fb      	ldr	r3, [r7, #12]
 800f354:	4423      	add	r3, r4
 800f356:	781b      	ldrb	r3, [r3, #0]
 800f358:	469a      	mov	sl, r3
      cr = GETJSAMPLE(inptr2[col]);
 800f35a:	68bb      	ldr	r3, [r7, #8]
 800f35c:	4423      	add	r3, r4
 800f35e:	781b      	ldrb	r3, [r3, #0]
 800f360:	4699      	mov	r9, r3
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
 800f362:	464b      	mov	r3, r9
 800f364:	009b      	lsls	r3, r3, #2
 800f366:	4602      	mov	r2, r0
 800f368:	4413      	add	r3, r2
 800f36a:	681b      	ldr	r3, [r3, #0]
 800f36c:	4443      	add	r3, r8
 800f36e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800f372:	4433      	add	r3, r6
 800f374:	781b      	ldrb	r3, [r3, #0]
 800f376:	702b      	strb	r3, [r5, #0]
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 800f378:	4653      	mov	r3, sl
 800f37a:	009b      	lsls	r3, r3, #2
 800f37c:	697a      	ldr	r2, [r7, #20]
 800f37e:	4413      	add	r3, r2
 800f380:	681a      	ldr	r2, [r3, #0]
 800f382:	464b      	mov	r3, r9
 800f384:	009b      	lsls	r3, r3, #2
 800f386:	69b9      	ldr	r1, [r7, #24]
 800f388:	440b      	add	r3, r1
 800f38a:	681b      	ldr	r3, [r3, #0]
 800f38c:	4413      	add	r3, r2
 800f38e:	141b      	asrs	r3, r3, #16
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
 800f390:	4443      	add	r3, r8
 800f392:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800f396:	4433      	add	r3, r6
 800f398:	1c6a      	adds	r2, r5, #1
 800f39a:	781b      	ldrb	r3, [r3, #0]
 800f39c:	7013      	strb	r3, [r2, #0]
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
 800f39e:	4653      	mov	r3, sl
 800f3a0:	009b      	lsls	r3, r3, #2
 800f3a2:	69fa      	ldr	r2, [r7, #28]
 800f3a4:	4413      	add	r3, r2
 800f3a6:	681b      	ldr	r3, [r3, #0]
 800f3a8:	4443      	add	r3, r8
 800f3aa:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800f3ae:	18f2      	adds	r2, r6, r3
 800f3b0:	1cab      	adds	r3, r5, #2
 800f3b2:	7812      	ldrb	r2, [r2, #0]
 800f3b4:	701a      	strb	r2, [r3, #0]
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
 800f3b6:	687b      	ldr	r3, [r7, #4]
 800f3b8:	191a      	adds	r2, r3, r4
 800f3ba:	1ceb      	adds	r3, r5, #3
 800f3bc:	7812      	ldrb	r2, [r2, #0]
 800f3be:	701a      	strb	r2, [r3, #0]
      outptr += 4;
 800f3c0:	3504      	adds	r5, #4
    for (col = 0; col < num_cols; col++) {
 800f3c2:	3401      	adds	r4, #1
 800f3c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f3c6:	429c      	cmp	r4, r3
 800f3c8:	d3bf      	bcc.n	800f34a <ycck_cmyk_convert+0x8e>
  while (--num_rows >= 0) {
 800f3ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f3cc:	3b01      	subs	r3, #1
 800f3ce:	65bb      	str	r3, [r7, #88]	; 0x58
 800f3d0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f3d2:	2b00      	cmp	r3, #0
 800f3d4:	da91      	bge.n	800f2fa <ycck_cmyk_convert+0x3e>
    }
  }
}
 800f3d6:	bf00      	nop
 800f3d8:	bf00      	nop
 800f3da:	373c      	adds	r7, #60	; 0x3c
 800f3dc:	46bd      	mov	sp, r7
 800f3de:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 800f3e2:	4770      	bx	lr

0800f3e4 <start_pass_dcolor>:
 * Empty method for start_pass.
 */

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
 800f3e4:	b480      	push	{r7}
 800f3e6:	b083      	sub	sp, #12
 800f3e8:	af00      	add	r7, sp, #0
 800f3ea:	6078      	str	r0, [r7, #4]
  /* no work needed */
}
 800f3ec:	bf00      	nop
 800f3ee:	370c      	adds	r7, #12
 800f3f0:	46bd      	mov	sp, r7
 800f3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3f6:	4770      	bx	lr

0800f3f8 <jinit_color_deconverter>:
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
 800f3f8:	b580      	push	{r7, lr}
 800f3fa:	b084      	sub	sp, #16
 800f3fc:	af00      	add	r7, sp, #0
 800f3fe:	6078      	str	r0, [r7, #4]
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800f400:	687b      	ldr	r3, [r7, #4]
 800f402:	685b      	ldr	r3, [r3, #4]
 800f404:	681b      	ldr	r3, [r3, #0]
 800f406:	221c      	movs	r2, #28
 800f408:	2101      	movs	r1, #1
 800f40a:	6878      	ldr	r0, [r7, #4]
 800f40c:	4798      	blx	r3
 800f40e:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
 800f410:	687b      	ldr	r3, [r7, #4]
 800f412:	68ba      	ldr	r2, [r7, #8]
 800f414:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
  cconvert->pub.start_pass = start_pass_dcolor;
 800f418:	68bb      	ldr	r3, [r7, #8]
 800f41a:	4a88      	ldr	r2, [pc, #544]	; (800f63c <jinit_color_deconverter+0x244>)
 800f41c:	601a      	str	r2, [r3, #0]

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
 800f41e:	687b      	ldr	r3, [r7, #4]
 800f420:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f424:	2b05      	cmp	r3, #5
 800f426:	dc33      	bgt.n	800f490 <jinit_color_deconverter+0x98>
 800f428:	2b04      	cmp	r3, #4
 800f42a:	da23      	bge.n	800f474 <jinit_color_deconverter+0x7c>
 800f42c:	2b01      	cmp	r3, #1
 800f42e:	d005      	beq.n	800f43c <jinit_color_deconverter+0x44>
 800f430:	2b00      	cmp	r3, #0
 800f432:	dd2d      	ble.n	800f490 <jinit_color_deconverter+0x98>
 800f434:	3b02      	subs	r3, #2
 800f436:	2b01      	cmp	r3, #1
 800f438:	d82a      	bhi.n	800f490 <jinit_color_deconverter+0x98>
 800f43a:	e00d      	b.n	800f458 <jinit_color_deconverter+0x60>
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
 800f43c:	687b      	ldr	r3, [r7, #4]
 800f43e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f440:	2b01      	cmp	r3, #1
 800f442:	d033      	beq.n	800f4ac <jinit_color_deconverter+0xb4>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 800f444:	687b      	ldr	r3, [r7, #4]
 800f446:	681b      	ldr	r3, [r3, #0]
 800f448:	220b      	movs	r2, #11
 800f44a:	615a      	str	r2, [r3, #20]
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	681b      	ldr	r3, [r3, #0]
 800f450:	681b      	ldr	r3, [r3, #0]
 800f452:	6878      	ldr	r0, [r7, #4]
 800f454:	4798      	blx	r3
    break;
 800f456:	e029      	b.n	800f4ac <jinit_color_deconverter+0xb4>

  case JCS_RGB:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
 800f458:	687b      	ldr	r3, [r7, #4]
 800f45a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f45c:	2b03      	cmp	r3, #3
 800f45e:	d027      	beq.n	800f4b0 <jinit_color_deconverter+0xb8>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 800f460:	687b      	ldr	r3, [r7, #4]
 800f462:	681b      	ldr	r3, [r3, #0]
 800f464:	220b      	movs	r2, #11
 800f466:	615a      	str	r2, [r3, #20]
 800f468:	687b      	ldr	r3, [r7, #4]
 800f46a:	681b      	ldr	r3, [r3, #0]
 800f46c:	681b      	ldr	r3, [r3, #0]
 800f46e:	6878      	ldr	r0, [r7, #4]
 800f470:	4798      	blx	r3
    break;
 800f472:	e01d      	b.n	800f4b0 <jinit_color_deconverter+0xb8>

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
 800f474:	687b      	ldr	r3, [r7, #4]
 800f476:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f478:	2b04      	cmp	r3, #4
 800f47a:	d01b      	beq.n	800f4b4 <jinit_color_deconverter+0xbc>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 800f47c:	687b      	ldr	r3, [r7, #4]
 800f47e:	681b      	ldr	r3, [r3, #0]
 800f480:	220b      	movs	r2, #11
 800f482:	615a      	str	r2, [r3, #20]
 800f484:	687b      	ldr	r3, [r7, #4]
 800f486:	681b      	ldr	r3, [r3, #0]
 800f488:	681b      	ldr	r3, [r3, #0]
 800f48a:	6878      	ldr	r0, [r7, #4]
 800f48c:	4798      	blx	r3
    break;
 800f48e:	e011      	b.n	800f4b4 <jinit_color_deconverter+0xbc>

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
 800f490:	687b      	ldr	r3, [r7, #4]
 800f492:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f494:	2b00      	cmp	r3, #0
 800f496:	dc0f      	bgt.n	800f4b8 <jinit_color_deconverter+0xc0>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
 800f498:	687b      	ldr	r3, [r7, #4]
 800f49a:	681b      	ldr	r3, [r3, #0]
 800f49c:	220b      	movs	r2, #11
 800f49e:	615a      	str	r2, [r3, #20]
 800f4a0:	687b      	ldr	r3, [r7, #4]
 800f4a2:	681b      	ldr	r3, [r3, #0]
 800f4a4:	681b      	ldr	r3, [r3, #0]
 800f4a6:	6878      	ldr	r0, [r7, #4]
 800f4a8:	4798      	blx	r3
    break;
 800f4aa:	e005      	b.n	800f4b8 <jinit_color_deconverter+0xc0>
    break;
 800f4ac:	bf00      	nop
 800f4ae:	e004      	b.n	800f4ba <jinit_color_deconverter+0xc2>
    break;
 800f4b0:	bf00      	nop
 800f4b2:	e002      	b.n	800f4ba <jinit_color_deconverter+0xc2>
    break;
 800f4b4:	bf00      	nop
 800f4b6:	e000      	b.n	800f4ba <jinit_color_deconverter+0xc2>
    break;
 800f4b8:	bf00      	nop
  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
 800f4ba:	687b      	ldr	r3, [r7, #4]
 800f4bc:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800f4c0:	2b04      	cmp	r3, #4
 800f4c2:	d06f      	beq.n	800f5a4 <jinit_color_deconverter+0x1ac>
 800f4c4:	2b04      	cmp	r3, #4
 800f4c6:	f300 808f 	bgt.w	800f5e8 <jinit_color_deconverter+0x1f0>
 800f4ca:	2b01      	cmp	r3, #1
 800f4cc:	d002      	beq.n	800f4d4 <jinit_color_deconverter+0xdc>
 800f4ce:	2b02      	cmp	r3, #2
 800f4d0:	d03d      	beq.n	800f54e <jinit_color_deconverter+0x156>
 800f4d2:	e089      	b.n	800f5e8 <jinit_color_deconverter+0x1f0>
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 800f4d4:	687b      	ldr	r3, [r7, #4]
 800f4d6:	2201      	movs	r2, #1
 800f4d8:	679a      	str	r2, [r3, #120]	; 0x78
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 800f4da:	687b      	ldr	r3, [r7, #4]
 800f4dc:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f4e0:	2b01      	cmp	r3, #1
 800f4e2:	d004      	beq.n	800f4ee <jinit_color_deconverter+0xf6>
	cinfo->jpeg_color_space == JCS_YCbCr) {
 800f4e4:	687b      	ldr	r3, [r7, #4]
 800f4e6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 800f4ea:	2b03      	cmp	r3, #3
 800f4ec:	d118      	bne.n	800f520 <jinit_color_deconverter+0x128>
      cconvert->pub.color_convert = grayscale_convert;
 800f4ee:	68bb      	ldr	r3, [r7, #8]
 800f4f0:	4a53      	ldr	r2, [pc, #332]	; (800f640 <jinit_color_deconverter+0x248>)
 800f4f2:	605a      	str	r2, [r3, #4]
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
 800f4f4:	2301      	movs	r3, #1
 800f4f6:	60fb      	str	r3, [r7, #12]
 800f4f8:	e00c      	b.n	800f514 <jinit_color_deconverter+0x11c>
	cinfo->comp_info[ci].component_needed = FALSE;
 800f4fa:	687b      	ldr	r3, [r7, #4]
 800f4fc:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800f500:	68fb      	ldr	r3, [r7, #12]
 800f502:	2158      	movs	r1, #88	; 0x58
 800f504:	fb01 f303 	mul.w	r3, r1, r3
 800f508:	4413      	add	r3, r2
 800f50a:	2200      	movs	r2, #0
 800f50c:	635a      	str	r2, [r3, #52]	; 0x34
      for (ci = 1; ci < cinfo->num_components; ci++)
 800f50e:	68fb      	ldr	r3, [r7, #12]
 800f510:	3301      	adds	r3, #1
 800f512:	60fb      	str	r3, [r7, #12]
 800f514:	687b      	ldr	r3, [r7, #4]
 800f516:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f518:	68fa      	ldr	r2, [r7, #12]
 800f51a:	429a      	cmp	r2, r3
 800f51c:	dbed      	blt.n	800f4fa <jinit_color_deconverter+0x102>
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 800f51e:	e015      	b.n	800f54c <jinit_color_deconverter+0x154>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 800f520:	687b      	ldr	r3, [r7, #4]
 800f522:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f526:	2b02      	cmp	r3, #2
 800f528:	d106      	bne.n	800f538 <jinit_color_deconverter+0x140>
      cconvert->pub.color_convert = rgb_gray_convert;
 800f52a:	68bb      	ldr	r3, [r7, #8]
 800f52c:	4a45      	ldr	r2, [pc, #276]	; (800f644 <jinit_color_deconverter+0x24c>)
 800f52e:	605a      	str	r2, [r3, #4]
      build_rgb_y_table(cinfo);
 800f530:	6878      	ldr	r0, [r7, #4]
 800f532:	f7ff fd44 	bl	800efbe <build_rgb_y_table>
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 800f536:	e071      	b.n	800f61c <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 800f538:	687b      	ldr	r3, [r7, #4]
 800f53a:	681b      	ldr	r3, [r3, #0]
 800f53c:	221c      	movs	r2, #28
 800f53e:	615a      	str	r2, [r3, #20]
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	681b      	ldr	r3, [r3, #0]
 800f544:	681b      	ldr	r3, [r3, #0]
 800f546:	6878      	ldr	r0, [r7, #4]
 800f548:	4798      	blx	r3
    break;
 800f54a:	e067      	b.n	800f61c <jinit_color_deconverter+0x224>
 800f54c:	e066      	b.n	800f61c <jinit_color_deconverter+0x224>

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 800f54e:	687b      	ldr	r3, [r7, #4]
 800f550:	2203      	movs	r2, #3
 800f552:	679a      	str	r2, [r3, #120]	; 0x78
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
 800f554:	687b      	ldr	r3, [r7, #4]
 800f556:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f55a:	2b03      	cmp	r3, #3
 800f55c:	d106      	bne.n	800f56c <jinit_color_deconverter+0x174>
      cconvert->pub.color_convert = ycc_rgb_convert;
 800f55e:	68bb      	ldr	r3, [r7, #8]
 800f560:	4a39      	ldr	r2, [pc, #228]	; (800f648 <jinit_color_deconverter+0x250>)
 800f562:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 800f564:	6878      	ldr	r0, [r7, #4]
 800f566:	f7ff fc29 	bl	800edbc <build_ycc_rgb_table>
      cconvert->pub.color_convert = gray_rgb_convert;
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
      cconvert->pub.color_convert = rgb_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 800f56a:	e057      	b.n	800f61c <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f572:	2b01      	cmp	r3, #1
 800f574:	d103      	bne.n	800f57e <jinit_color_deconverter+0x186>
      cconvert->pub.color_convert = gray_rgb_convert;
 800f576:	68bb      	ldr	r3, [r7, #8]
 800f578:	4a34      	ldr	r2, [pc, #208]	; (800f64c <jinit_color_deconverter+0x254>)
 800f57a:	605a      	str	r2, [r3, #4]
    break;
 800f57c:	e04e      	b.n	800f61c <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_RGB) {
 800f57e:	687b      	ldr	r3, [r7, #4]
 800f580:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f584:	2b02      	cmp	r3, #2
 800f586:	d103      	bne.n	800f590 <jinit_color_deconverter+0x198>
      cconvert->pub.color_convert = rgb_convert;
 800f588:	68bb      	ldr	r3, [r7, #8]
 800f58a:	4a31      	ldr	r2, [pc, #196]	; (800f650 <jinit_color_deconverter+0x258>)
 800f58c:	605a      	str	r2, [r3, #4]
    break;
 800f58e:	e045      	b.n	800f61c <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 800f590:	687b      	ldr	r3, [r7, #4]
 800f592:	681b      	ldr	r3, [r3, #0]
 800f594:	221c      	movs	r2, #28
 800f596:	615a      	str	r2, [r3, #20]
 800f598:	687b      	ldr	r3, [r7, #4]
 800f59a:	681b      	ldr	r3, [r3, #0]
 800f59c:	681b      	ldr	r3, [r3, #0]
 800f59e:	6878      	ldr	r0, [r7, #4]
 800f5a0:	4798      	blx	r3
    break;
 800f5a2:	e03b      	b.n	800f61c <jinit_color_deconverter+0x224>

  case JCS_CMYK:
    cinfo->out_color_components = 4;
 800f5a4:	687b      	ldr	r3, [r7, #4]
 800f5a6:	2204      	movs	r2, #4
 800f5a8:	679a      	str	r2, [r3, #120]	; 0x78
    if (cinfo->jpeg_color_space == JCS_YCCK) {
 800f5aa:	687b      	ldr	r3, [r7, #4]
 800f5ac:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f5b0:	2b05      	cmp	r3, #5
 800f5b2:	d106      	bne.n	800f5c2 <jinit_color_deconverter+0x1ca>
      cconvert->pub.color_convert = ycck_cmyk_convert;
 800f5b4:	68bb      	ldr	r3, [r7, #8]
 800f5b6:	4a27      	ldr	r2, [pc, #156]	; (800f654 <jinit_color_deconverter+0x25c>)
 800f5b8:	605a      	str	r2, [r3, #4]
      build_ycc_rgb_table(cinfo);
 800f5ba:	6878      	ldr	r0, [r7, #4]
 800f5bc:	f7ff fbfe 	bl	800edbc <build_ycc_rgb_table>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
      cconvert->pub.color_convert = null_convert;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 800f5c0:	e02c      	b.n	800f61c <jinit_color_deconverter+0x224>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
 800f5c2:	687b      	ldr	r3, [r7, #4]
 800f5c4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f5c8:	2b04      	cmp	r3, #4
 800f5ca:	d103      	bne.n	800f5d4 <jinit_color_deconverter+0x1dc>
      cconvert->pub.color_convert = null_convert;
 800f5cc:	68bb      	ldr	r3, [r7, #8]
 800f5ce:	4a22      	ldr	r2, [pc, #136]	; (800f658 <jinit_color_deconverter+0x260>)
 800f5d0:	605a      	str	r2, [r3, #4]
    break;
 800f5d2:	e023      	b.n	800f61c <jinit_color_deconverter+0x224>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 800f5d4:	687b      	ldr	r3, [r7, #4]
 800f5d6:	681b      	ldr	r3, [r3, #0]
 800f5d8:	221c      	movs	r2, #28
 800f5da:	615a      	str	r2, [r3, #20]
 800f5dc:	687b      	ldr	r3, [r7, #4]
 800f5de:	681b      	ldr	r3, [r3, #0]
 800f5e0:	681b      	ldr	r3, [r3, #0]
 800f5e2:	6878      	ldr	r0, [r7, #4]
 800f5e4:	4798      	blx	r3
    break;
 800f5e6:	e019      	b.n	800f61c <jinit_color_deconverter+0x224>

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
 800f5e8:	687b      	ldr	r3, [r7, #4]
 800f5ea:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800f5ee:	687b      	ldr	r3, [r7, #4]
 800f5f0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800f5f4:	429a      	cmp	r2, r3
 800f5f6:	d107      	bne.n	800f608 <jinit_color_deconverter+0x210>
      cinfo->out_color_components = cinfo->num_components;
 800f5f8:	687b      	ldr	r3, [r7, #4]
 800f5fa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f5fc:	687b      	ldr	r3, [r7, #4]
 800f5fe:	679a      	str	r2, [r3, #120]	; 0x78
      cconvert->pub.color_convert = null_convert;
 800f600:	68bb      	ldr	r3, [r7, #8]
 800f602:	4a15      	ldr	r2, [pc, #84]	; (800f658 <jinit_color_deconverter+0x260>)
 800f604:	605a      	str	r2, [r3, #4]
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;
 800f606:	e008      	b.n	800f61a <jinit_color_deconverter+0x222>
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
 800f608:	687b      	ldr	r3, [r7, #4]
 800f60a:	681b      	ldr	r3, [r3, #0]
 800f60c:	221c      	movs	r2, #28
 800f60e:	615a      	str	r2, [r3, #20]
 800f610:	687b      	ldr	r3, [r7, #4]
 800f612:	681b      	ldr	r3, [r3, #0]
 800f614:	681b      	ldr	r3, [r3, #0]
 800f616:	6878      	ldr	r0, [r7, #4]
 800f618:	4798      	blx	r3
    break;
 800f61a:	bf00      	nop
  }

  if (cinfo->quantize_colors)
 800f61c:	687b      	ldr	r3, [r7, #4]
 800f61e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f620:	2b00      	cmp	r3, #0
 800f622:	d003      	beq.n	800f62c <jinit_color_deconverter+0x234>
    cinfo->output_components = 1; /* single colormapped output component */
 800f624:	687b      	ldr	r3, [r7, #4]
 800f626:	2201      	movs	r2, #1
 800f628:	67da      	str	r2, [r3, #124]	; 0x7c
  else
    cinfo->output_components = cinfo->out_color_components;
}
 800f62a:	e003      	b.n	800f634 <jinit_color_deconverter+0x23c>
    cinfo->output_components = cinfo->out_color_components;
 800f62c:	687b      	ldr	r3, [r7, #4]
 800f62e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800f630:	687b      	ldr	r3, [r7, #4]
 800f632:	67da      	str	r2, [r3, #124]	; 0x7c
}
 800f634:	bf00      	nop
 800f636:	3710      	adds	r7, #16
 800f638:	46bd      	mov	sp, r7
 800f63a:	bd80      	pop	{r7, pc}
 800f63c:	0800f3e5 	.word	0x0800f3e5
 800f640:	0800f229 	.word	0x0800f229
 800f644:	0800f04b 	.word	0x0800f04b
 800f648:	0800eebd 	.word	0x0800eebd
 800f64c:	0800f257 	.word	0x0800f257
 800f650:	0800f115 	.word	0x0800f115
 800f654:	0800f2bd 	.word	0x0800f2bd
 800f658:	0800f1a5 	.word	0x0800f1a5

0800f65c <start_pass>:
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
 800f65c:	b590      	push	{r4, r7, lr}
 800f65e:	b08f      	sub	sp, #60	; 0x3c
 800f660:	af00      	add	r7, sp, #0
 800f662:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	f8d3 31d4 	ldr.w	r3, [r3, #468]	; 0x1d4
 800f66a:	61bb      	str	r3, [r7, #24]
  int ci, i;
  jpeg_component_info *compptr;
  int method = 0;
 800f66c:	2300      	movs	r3, #0
 800f66e:	62bb      	str	r3, [r7, #40]	; 0x28
  inverse_DCT_method_ptr method_ptr = NULL;
 800f670:	2300      	movs	r3, #0
 800f672:	627b      	str	r3, [r7, #36]	; 0x24
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800f674:	2300      	movs	r3, #0
 800f676:	637b      	str	r3, [r7, #52]	; 0x34
 800f678:	687b      	ldr	r3, [r7, #4]
 800f67a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800f67e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f680:	e30d      	b.n	800fc9e <start_pass+0x642>
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch ((compptr->DCT_h_scaled_size << 8) + compptr->DCT_v_scaled_size) {
 800f682:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f684:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f686:	021a      	lsls	r2, r3, #8
 800f688:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f68a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f68c:	4413      	add	r3, r2
 800f68e:	f241 0210 	movw	r2, #4112	; 0x1010
 800f692:	4293      	cmp	r3, r2
 800f694:	f000 8168 	beq.w	800f968 <start_pass+0x30c>
 800f698:	f241 0210 	movw	r2, #4112	; 0x1010
 800f69c:	4293      	cmp	r3, r2
 800f69e:	f300 81de 	bgt.w	800fa5e <start_pass+0x402>
 800f6a2:	f241 0208 	movw	r2, #4104	; 0x1008
 800f6a6:	4293      	cmp	r3, r2
 800f6a8:	f000 8163 	beq.w	800f972 <start_pass+0x316>
 800f6ac:	f241 0208 	movw	r2, #4104	; 0x1008
 800f6b0:	4293      	cmp	r3, r2
 800f6b2:	f300 81d4 	bgt.w	800fa5e <start_pass+0x402>
 800f6b6:	f640 720f 	movw	r2, #3855	; 0xf0f
 800f6ba:	4293      	cmp	r3, r2
 800f6bc:	f000 814f 	beq.w	800f95e <start_pass+0x302>
 800f6c0:	f5b3 6f71 	cmp.w	r3, #3856	; 0xf10
 800f6c4:	f280 81cb 	bge.w	800fa5e <start_pass+0x402>
 800f6c8:	f640 620e 	movw	r2, #3598	; 0xe0e
 800f6cc:	4293      	cmp	r3, r2
 800f6ce:	f000 8141 	beq.w	800f954 <start_pass+0x2f8>
 800f6d2:	f640 620e 	movw	r2, #3598	; 0xe0e
 800f6d6:	4293      	cmp	r3, r2
 800f6d8:	f300 81c1 	bgt.w	800fa5e <start_pass+0x402>
 800f6dc:	f640 6207 	movw	r2, #3591	; 0xe07
 800f6e0:	4293      	cmp	r3, r2
 800f6e2:	f000 814b 	beq.w	800f97c <start_pass+0x320>
 800f6e6:	f640 6207 	movw	r2, #3591	; 0xe07
 800f6ea:	4293      	cmp	r3, r2
 800f6ec:	f300 81b7 	bgt.w	800fa5e <start_pass+0x402>
 800f6f0:	f640 520d 	movw	r2, #3341	; 0xd0d
 800f6f4:	4293      	cmp	r3, r2
 800f6f6:	f000 8128 	beq.w	800f94a <start_pass+0x2ee>
 800f6fa:	f640 520d 	movw	r2, #3341	; 0xd0d
 800f6fe:	4293      	cmp	r3, r2
 800f700:	f300 81ad 	bgt.w	800fa5e <start_pass+0x402>
 800f704:	f640 420c 	movw	r2, #3084	; 0xc0c
 800f708:	4293      	cmp	r3, r2
 800f70a:	f000 8119 	beq.w	800f940 <start_pass+0x2e4>
 800f70e:	f640 420c 	movw	r2, #3084	; 0xc0c
 800f712:	4293      	cmp	r3, r2
 800f714:	f300 81a3 	bgt.w	800fa5e <start_pass+0x402>
 800f718:	f640 4206 	movw	r2, #3078	; 0xc06
 800f71c:	4293      	cmp	r3, r2
 800f71e:	f000 8132 	beq.w	800f986 <start_pass+0x32a>
 800f722:	f640 4206 	movw	r2, #3078	; 0xc06
 800f726:	4293      	cmp	r3, r2
 800f728:	f300 8199 	bgt.w	800fa5e <start_pass+0x402>
 800f72c:	f640 320b 	movw	r2, #2827	; 0xb0b
 800f730:	4293      	cmp	r3, r2
 800f732:	f000 8100 	beq.w	800f936 <start_pass+0x2da>
 800f736:	f640 320b 	movw	r2, #2827	; 0xb0b
 800f73a:	4293      	cmp	r3, r2
 800f73c:	f300 818f 	bgt.w	800fa5e <start_pass+0x402>
 800f740:	f640 220a 	movw	r2, #2570	; 0xa0a
 800f744:	4293      	cmp	r3, r2
 800f746:	f000 80f1 	beq.w	800f92c <start_pass+0x2d0>
 800f74a:	f640 220a 	movw	r2, #2570	; 0xa0a
 800f74e:	4293      	cmp	r3, r2
 800f750:	f300 8185 	bgt.w	800fa5e <start_pass+0x402>
 800f754:	f640 2205 	movw	r2, #2565	; 0xa05
 800f758:	4293      	cmp	r3, r2
 800f75a:	f000 8119 	beq.w	800f990 <start_pass+0x334>
 800f75e:	f640 2205 	movw	r2, #2565	; 0xa05
 800f762:	4293      	cmp	r3, r2
 800f764:	f300 817b 	bgt.w	800fa5e <start_pass+0x402>
 800f768:	f640 1209 	movw	r2, #2313	; 0x909
 800f76c:	4293      	cmp	r3, r2
 800f76e:	f000 80d8 	beq.w	800f922 <start_pass+0x2c6>
 800f772:	f640 1209 	movw	r2, #2313	; 0x909
 800f776:	4293      	cmp	r3, r2
 800f778:	f300 8171 	bgt.w	800fa5e <start_pass+0x402>
 800f77c:	f5b3 6f01 	cmp.w	r3, #2064	; 0x810
 800f780:	f000 811f 	beq.w	800f9c2 <start_pass+0x366>
 800f784:	f5b3 6f01 	cmp.w	r3, #2064	; 0x810
 800f788:	f300 8169 	bgt.w	800fa5e <start_pass+0x402>
 800f78c:	f640 0208 	movw	r2, #2056	; 0x808
 800f790:	4293      	cmp	r3, r2
 800f792:	f000 813e 	beq.w	800fa12 <start_pass+0x3b6>
 800f796:	f640 0208 	movw	r2, #2056	; 0x808
 800f79a:	4293      	cmp	r3, r2
 800f79c:	f300 815f 	bgt.w	800fa5e <start_pass+0x402>
 800f7a0:	f640 0204 	movw	r2, #2052	; 0x804
 800f7a4:	4293      	cmp	r3, r2
 800f7a6:	f000 80f8 	beq.w	800f99a <start_pass+0x33e>
 800f7aa:	f640 0204 	movw	r2, #2052	; 0x804
 800f7ae:	4293      	cmp	r3, r2
 800f7b0:	f300 8155 	bgt.w	800fa5e <start_pass+0x402>
 800f7b4:	f240 720e 	movw	r2, #1806	; 0x70e
 800f7b8:	4293      	cmp	r3, r2
 800f7ba:	f000 8107 	beq.w	800f9cc <start_pass+0x370>
 800f7be:	f240 720e 	movw	r2, #1806	; 0x70e
 800f7c2:	4293      	cmp	r3, r2
 800f7c4:	f300 814b 	bgt.w	800fa5e <start_pass+0x402>
 800f7c8:	f240 7207 	movw	r2, #1799	; 0x707
 800f7cc:	4293      	cmp	r3, r2
 800f7ce:	f000 80a3 	beq.w	800f918 <start_pass+0x2bc>
 800f7d2:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 800f7d6:	f280 8142 	bge.w	800fa5e <start_pass+0x402>
 800f7da:	f240 620c 	movw	r2, #1548	; 0x60c
 800f7de:	4293      	cmp	r3, r2
 800f7e0:	f000 80f9 	beq.w	800f9d6 <start_pass+0x37a>
 800f7e4:	f240 620c 	movw	r2, #1548	; 0x60c
 800f7e8:	4293      	cmp	r3, r2
 800f7ea:	f300 8138 	bgt.w	800fa5e <start_pass+0x402>
 800f7ee:	f240 6206 	movw	r2, #1542	; 0x606
 800f7f2:	4293      	cmp	r3, r2
 800f7f4:	f000 808b 	beq.w	800f90e <start_pass+0x2b2>
 800f7f8:	f240 6206 	movw	r2, #1542	; 0x606
 800f7fc:	4293      	cmp	r3, r2
 800f7fe:	f300 812e 	bgt.w	800fa5e <start_pass+0x402>
 800f802:	f240 6203 	movw	r2, #1539	; 0x603
 800f806:	4293      	cmp	r3, r2
 800f808:	f000 80cc 	beq.w	800f9a4 <start_pass+0x348>
 800f80c:	f240 6203 	movw	r2, #1539	; 0x603
 800f810:	4293      	cmp	r3, r2
 800f812:	f300 8124 	bgt.w	800fa5e <start_pass+0x402>
 800f816:	f240 520a 	movw	r2, #1290	; 0x50a
 800f81a:	4293      	cmp	r3, r2
 800f81c:	f000 80e0 	beq.w	800f9e0 <start_pass+0x384>
 800f820:	f240 520a 	movw	r2, #1290	; 0x50a
 800f824:	4293      	cmp	r3, r2
 800f826:	f300 811a 	bgt.w	800fa5e <start_pass+0x402>
 800f82a:	f240 5205 	movw	r2, #1285	; 0x505
 800f82e:	4293      	cmp	r3, r2
 800f830:	d068      	beq.n	800f904 <start_pass+0x2a8>
 800f832:	f240 5205 	movw	r2, #1285	; 0x505
 800f836:	4293      	cmp	r3, r2
 800f838:	f300 8111 	bgt.w	800fa5e <start_pass+0x402>
 800f83c:	f5b3 6f81 	cmp.w	r3, #1032	; 0x408
 800f840:	f000 80d3 	beq.w	800f9ea <start_pass+0x38e>
 800f844:	f5b3 6f81 	cmp.w	r3, #1032	; 0x408
 800f848:	f300 8109 	bgt.w	800fa5e <start_pass+0x402>
 800f84c:	f240 4204 	movw	r2, #1028	; 0x404
 800f850:	4293      	cmp	r3, r2
 800f852:	d052      	beq.n	800f8fa <start_pass+0x29e>
 800f854:	f240 4204 	movw	r2, #1028	; 0x404
 800f858:	4293      	cmp	r3, r2
 800f85a:	f300 8100 	bgt.w	800fa5e <start_pass+0x402>
 800f85e:	f240 4202 	movw	r2, #1026	; 0x402
 800f862:	4293      	cmp	r3, r2
 800f864:	f000 80a3 	beq.w	800f9ae <start_pass+0x352>
 800f868:	f240 4202 	movw	r2, #1026	; 0x402
 800f86c:	4293      	cmp	r3, r2
 800f86e:	f300 80f6 	bgt.w	800fa5e <start_pass+0x402>
 800f872:	f240 3206 	movw	r2, #774	; 0x306
 800f876:	4293      	cmp	r3, r2
 800f878:	f000 80bc 	beq.w	800f9f4 <start_pass+0x398>
 800f87c:	f240 3206 	movw	r2, #774	; 0x306
 800f880:	4293      	cmp	r3, r2
 800f882:	f300 80ec 	bgt.w	800fa5e <start_pass+0x402>
 800f886:	f240 3203 	movw	r2, #771	; 0x303
 800f88a:	4293      	cmp	r3, r2
 800f88c:	d030      	beq.n	800f8f0 <start_pass+0x294>
 800f88e:	f5b3 7f41 	cmp.w	r3, #772	; 0x304
 800f892:	f280 80e4 	bge.w	800fa5e <start_pass+0x402>
 800f896:	f5b3 7f01 	cmp.w	r3, #516	; 0x204
 800f89a:	f000 80b0 	beq.w	800f9fe <start_pass+0x3a2>
 800f89e:	f5b3 7f01 	cmp.w	r3, #516	; 0x204
 800f8a2:	f300 80dc 	bgt.w	800fa5e <start_pass+0x402>
 800f8a6:	f240 2202 	movw	r2, #514	; 0x202
 800f8aa:	4293      	cmp	r3, r2
 800f8ac:	d01b      	beq.n	800f8e6 <start_pass+0x28a>
 800f8ae:	f240 2202 	movw	r2, #514	; 0x202
 800f8b2:	4293      	cmp	r3, r2
 800f8b4:	f300 80d3 	bgt.w	800fa5e <start_pass+0x402>
 800f8b8:	f240 2201 	movw	r2, #513	; 0x201
 800f8bc:	4293      	cmp	r3, r2
 800f8be:	d07b      	beq.n	800f9b8 <start_pass+0x35c>
 800f8c0:	f240 2201 	movw	r2, #513	; 0x201
 800f8c4:	4293      	cmp	r3, r2
 800f8c6:	f300 80ca 	bgt.w	800fa5e <start_pass+0x402>
 800f8ca:	f240 1201 	movw	r2, #257	; 0x101
 800f8ce:	4293      	cmp	r3, r2
 800f8d0:	d004      	beq.n	800f8dc <start_pass+0x280>
 800f8d2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 800f8d6:	f000 8097 	beq.w	800fa08 <start_pass+0x3ac>
 800f8da:	e0c0      	b.n	800fa5e <start_pass+0x402>
#ifdef IDCT_SCALING_SUPPORTED
    case ((1 << 8) + 1):
      method_ptr = jpeg_idct_1x1;
 800f8dc:	4b91      	ldr	r3, [pc, #580]	; (800fb24 <start_pass+0x4c8>)
 800f8de:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f8e0:	2300      	movs	r3, #0
 800f8e2:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f8e4:	e0cf      	b.n	800fa86 <start_pass+0x42a>
    case ((2 << 8) + 2):
      method_ptr = jpeg_idct_2x2;
 800f8e6:	4b90      	ldr	r3, [pc, #576]	; (800fb28 <start_pass+0x4cc>)
 800f8e8:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f8ea:	2300      	movs	r3, #0
 800f8ec:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f8ee:	e0ca      	b.n	800fa86 <start_pass+0x42a>
    case ((3 << 8) + 3):
      method_ptr = jpeg_idct_3x3;
 800f8f0:	4b8e      	ldr	r3, [pc, #568]	; (800fb2c <start_pass+0x4d0>)
 800f8f2:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f8f4:	2300      	movs	r3, #0
 800f8f6:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f8f8:	e0c5      	b.n	800fa86 <start_pass+0x42a>
    case ((4 << 8) + 4):
      method_ptr = jpeg_idct_4x4;
 800f8fa:	4b8d      	ldr	r3, [pc, #564]	; (800fb30 <start_pass+0x4d4>)
 800f8fc:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f8fe:	2300      	movs	r3, #0
 800f900:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f902:	e0c0      	b.n	800fa86 <start_pass+0x42a>
    case ((5 << 8) + 5):
      method_ptr = jpeg_idct_5x5;
 800f904:	4b8b      	ldr	r3, [pc, #556]	; (800fb34 <start_pass+0x4d8>)
 800f906:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f908:	2300      	movs	r3, #0
 800f90a:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f90c:	e0bb      	b.n	800fa86 <start_pass+0x42a>
    case ((6 << 8) + 6):
      method_ptr = jpeg_idct_6x6;
 800f90e:	4b8a      	ldr	r3, [pc, #552]	; (800fb38 <start_pass+0x4dc>)
 800f910:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f912:	2300      	movs	r3, #0
 800f914:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f916:	e0b6      	b.n	800fa86 <start_pass+0x42a>
    case ((7 << 8) + 7):
      method_ptr = jpeg_idct_7x7;
 800f918:	4b88      	ldr	r3, [pc, #544]	; (800fb3c <start_pass+0x4e0>)
 800f91a:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f91c:	2300      	movs	r3, #0
 800f91e:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f920:	e0b1      	b.n	800fa86 <start_pass+0x42a>
    case ((9 << 8) + 9):
      method_ptr = jpeg_idct_9x9;
 800f922:	4b87      	ldr	r3, [pc, #540]	; (800fb40 <start_pass+0x4e4>)
 800f924:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f926:	2300      	movs	r3, #0
 800f928:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f92a:	e0ac      	b.n	800fa86 <start_pass+0x42a>
    case ((10 << 8) + 10):
      method_ptr = jpeg_idct_10x10;
 800f92c:	4b85      	ldr	r3, [pc, #532]	; (800fb44 <start_pass+0x4e8>)
 800f92e:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f930:	2300      	movs	r3, #0
 800f932:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f934:	e0a7      	b.n	800fa86 <start_pass+0x42a>
    case ((11 << 8) + 11):
      method_ptr = jpeg_idct_11x11;
 800f936:	4b84      	ldr	r3, [pc, #528]	; (800fb48 <start_pass+0x4ec>)
 800f938:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f93a:	2300      	movs	r3, #0
 800f93c:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f93e:	e0a2      	b.n	800fa86 <start_pass+0x42a>
    case ((12 << 8) + 12):
      method_ptr = jpeg_idct_12x12;
 800f940:	4b82      	ldr	r3, [pc, #520]	; (800fb4c <start_pass+0x4f0>)
 800f942:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f944:	2300      	movs	r3, #0
 800f946:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f948:	e09d      	b.n	800fa86 <start_pass+0x42a>
    case ((13 << 8) + 13):
      method_ptr = jpeg_idct_13x13;
 800f94a:	4b81      	ldr	r3, [pc, #516]	; (800fb50 <start_pass+0x4f4>)
 800f94c:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f94e:	2300      	movs	r3, #0
 800f950:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f952:	e098      	b.n	800fa86 <start_pass+0x42a>
    case ((14 << 8) + 14):
      method_ptr = jpeg_idct_14x14;
 800f954:	4b7f      	ldr	r3, [pc, #508]	; (800fb54 <start_pass+0x4f8>)
 800f956:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f958:	2300      	movs	r3, #0
 800f95a:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f95c:	e093      	b.n	800fa86 <start_pass+0x42a>
    case ((15 << 8) + 15):
      method_ptr = jpeg_idct_15x15;
 800f95e:	4b7e      	ldr	r3, [pc, #504]	; (800fb58 <start_pass+0x4fc>)
 800f960:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f962:	2300      	movs	r3, #0
 800f964:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f966:	e08e      	b.n	800fa86 <start_pass+0x42a>
    case ((16 << 8) + 16):
      method_ptr = jpeg_idct_16x16;
 800f968:	4b7c      	ldr	r3, [pc, #496]	; (800fb5c <start_pass+0x500>)
 800f96a:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f96c:	2300      	movs	r3, #0
 800f96e:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f970:	e089      	b.n	800fa86 <start_pass+0x42a>
    case ((16 << 8) + 8):
      method_ptr = jpeg_idct_16x8;
 800f972:	4b7b      	ldr	r3, [pc, #492]	; (800fb60 <start_pass+0x504>)
 800f974:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f976:	2300      	movs	r3, #0
 800f978:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f97a:	e084      	b.n	800fa86 <start_pass+0x42a>
    case ((14 << 8) + 7):
      method_ptr = jpeg_idct_14x7;
 800f97c:	4b79      	ldr	r3, [pc, #484]	; (800fb64 <start_pass+0x508>)
 800f97e:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f980:	2300      	movs	r3, #0
 800f982:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f984:	e07f      	b.n	800fa86 <start_pass+0x42a>
    case ((12 << 8) + 6):
      method_ptr = jpeg_idct_12x6;
 800f986:	4b78      	ldr	r3, [pc, #480]	; (800fb68 <start_pass+0x50c>)
 800f988:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f98a:	2300      	movs	r3, #0
 800f98c:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f98e:	e07a      	b.n	800fa86 <start_pass+0x42a>
    case ((10 << 8) + 5):
      method_ptr = jpeg_idct_10x5;
 800f990:	4b76      	ldr	r3, [pc, #472]	; (800fb6c <start_pass+0x510>)
 800f992:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f994:	2300      	movs	r3, #0
 800f996:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f998:	e075      	b.n	800fa86 <start_pass+0x42a>
    case ((8 << 8) + 4):
      method_ptr = jpeg_idct_8x4;
 800f99a:	4b75      	ldr	r3, [pc, #468]	; (800fb70 <start_pass+0x514>)
 800f99c:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f99e:	2300      	movs	r3, #0
 800f9a0:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9a2:	e070      	b.n	800fa86 <start_pass+0x42a>
    case ((6 << 8) + 3):
      method_ptr = jpeg_idct_6x3;
 800f9a4:	4b73      	ldr	r3, [pc, #460]	; (800fb74 <start_pass+0x518>)
 800f9a6:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9a8:	2300      	movs	r3, #0
 800f9aa:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9ac:	e06b      	b.n	800fa86 <start_pass+0x42a>
    case ((4 << 8) + 2):
      method_ptr = jpeg_idct_4x2;
 800f9ae:	4b72      	ldr	r3, [pc, #456]	; (800fb78 <start_pass+0x51c>)
 800f9b0:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9b2:	2300      	movs	r3, #0
 800f9b4:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9b6:	e066      	b.n	800fa86 <start_pass+0x42a>
    case ((2 << 8) + 1):
      method_ptr = jpeg_idct_2x1;
 800f9b8:	4b70      	ldr	r3, [pc, #448]	; (800fb7c <start_pass+0x520>)
 800f9ba:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9bc:	2300      	movs	r3, #0
 800f9be:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9c0:	e061      	b.n	800fa86 <start_pass+0x42a>
    case ((8 << 8) + 16):
      method_ptr = jpeg_idct_8x16;
 800f9c2:	4b6f      	ldr	r3, [pc, #444]	; (800fb80 <start_pass+0x524>)
 800f9c4:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9c6:	2300      	movs	r3, #0
 800f9c8:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9ca:	e05c      	b.n	800fa86 <start_pass+0x42a>
    case ((7 << 8) + 14):
      method_ptr = jpeg_idct_7x14;
 800f9cc:	4b6d      	ldr	r3, [pc, #436]	; (800fb84 <start_pass+0x528>)
 800f9ce:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9d0:	2300      	movs	r3, #0
 800f9d2:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9d4:	e057      	b.n	800fa86 <start_pass+0x42a>
    case ((6 << 8) + 12):
      method_ptr = jpeg_idct_6x12;
 800f9d6:	4b6c      	ldr	r3, [pc, #432]	; (800fb88 <start_pass+0x52c>)
 800f9d8:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9da:	2300      	movs	r3, #0
 800f9dc:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9de:	e052      	b.n	800fa86 <start_pass+0x42a>
    case ((5 << 8) + 10):
      method_ptr = jpeg_idct_5x10;
 800f9e0:	4b6a      	ldr	r3, [pc, #424]	; (800fb8c <start_pass+0x530>)
 800f9e2:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9e4:	2300      	movs	r3, #0
 800f9e6:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9e8:	e04d      	b.n	800fa86 <start_pass+0x42a>
    case ((4 << 8) + 8):
      method_ptr = jpeg_idct_4x8;
 800f9ea:	4b69      	ldr	r3, [pc, #420]	; (800fb90 <start_pass+0x534>)
 800f9ec:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9ee:	2300      	movs	r3, #0
 800f9f0:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9f2:	e048      	b.n	800fa86 <start_pass+0x42a>
    case ((3 << 8) + 6):
      method_ptr = jpeg_idct_3x6;
 800f9f4:	4b67      	ldr	r3, [pc, #412]	; (800fb94 <start_pass+0x538>)
 800f9f6:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800f9f8:	2300      	movs	r3, #0
 800f9fa:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800f9fc:	e043      	b.n	800fa86 <start_pass+0x42a>
    case ((2 << 8) + 4):
      method_ptr = jpeg_idct_2x4;
 800f9fe:	4b66      	ldr	r3, [pc, #408]	; (800fb98 <start_pass+0x53c>)
 800fa00:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800fa02:	2300      	movs	r3, #0
 800fa04:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800fa06:	e03e      	b.n	800fa86 <start_pass+0x42a>
    case ((1 << 8) + 2):
      method_ptr = jpeg_idct_1x2;
 800fa08:	4b64      	ldr	r3, [pc, #400]	; (800fb9c <start_pass+0x540>)
 800fa0a:	627b      	str	r3, [r7, #36]	; 0x24
      method = JDCT_ISLOW;	/* jidctint uses islow-style table */
 800fa0c:	2300      	movs	r3, #0
 800fa0e:	62bb      	str	r3, [r7, #40]	; 0x28
      break;
 800fa10:	e039      	b.n	800fa86 <start_pass+0x42a>
#endif
    case ((DCTSIZE << 8) + DCTSIZE):
      switch (cinfo->dct_method) {
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 800fa18:	2b02      	cmp	r3, #2
 800fa1a:	d010      	beq.n	800fa3e <start_pass+0x3e2>
 800fa1c:	2b02      	cmp	r3, #2
 800fa1e:	dc13      	bgt.n	800fa48 <start_pass+0x3ec>
 800fa20:	2b00      	cmp	r3, #0
 800fa22:	d002      	beq.n	800fa2a <start_pass+0x3ce>
 800fa24:	2b01      	cmp	r3, #1
 800fa26:	d005      	beq.n	800fa34 <start_pass+0x3d8>
 800fa28:	e00e      	b.n	800fa48 <start_pass+0x3ec>
#ifdef DCT_ISLOW_SUPPORTED
      case JDCT_ISLOW:
	method_ptr = jpeg_idct_islow;
 800fa2a:	4b5d      	ldr	r3, [pc, #372]	; (800fba0 <start_pass+0x544>)
 800fa2c:	627b      	str	r3, [r7, #36]	; 0x24
	method = JDCT_ISLOW;
 800fa2e:	2300      	movs	r3, #0
 800fa30:	62bb      	str	r3, [r7, #40]	; 0x28
	break;
 800fa32:	e013      	b.n	800fa5c <start_pass+0x400>
#endif
#ifdef DCT_IFAST_SUPPORTED
      case JDCT_IFAST:
	method_ptr = jpeg_idct_ifast;
 800fa34:	4b5b      	ldr	r3, [pc, #364]	; (800fba4 <start_pass+0x548>)
 800fa36:	627b      	str	r3, [r7, #36]	; 0x24
	method = JDCT_IFAST;
 800fa38:	2301      	movs	r3, #1
 800fa3a:	62bb      	str	r3, [r7, #40]	; 0x28
	break;
 800fa3c:	e00e      	b.n	800fa5c <start_pass+0x400>
#endif
#ifdef DCT_FLOAT_SUPPORTED
      case JDCT_FLOAT:
	method_ptr = jpeg_idct_float;
 800fa3e:	4b5a      	ldr	r3, [pc, #360]	; (800fba8 <start_pass+0x54c>)
 800fa40:	627b      	str	r3, [r7, #36]	; 0x24
	method = JDCT_FLOAT;
 800fa42:	2302      	movs	r3, #2
 800fa44:	62bb      	str	r3, [r7, #40]	; 0x28
	break;
 800fa46:	e009      	b.n	800fa5c <start_pass+0x400>
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
 800fa48:	687b      	ldr	r3, [r7, #4]
 800fa4a:	681b      	ldr	r3, [r3, #0]
 800fa4c:	2231      	movs	r2, #49	; 0x31
 800fa4e:	615a      	str	r2, [r3, #20]
 800fa50:	687b      	ldr	r3, [r7, #4]
 800fa52:	681b      	ldr	r3, [r3, #0]
 800fa54:	681b      	ldr	r3, [r3, #0]
 800fa56:	6878      	ldr	r0, [r7, #4]
 800fa58:	4798      	blx	r3
	break;
 800fa5a:	bf00      	nop
      }
      break;
 800fa5c:	e013      	b.n	800fa86 <start_pass+0x42a>
    default:
      ERREXIT2(cinfo, JERR_BAD_DCTSIZE,
 800fa5e:	687b      	ldr	r3, [r7, #4]
 800fa60:	681b      	ldr	r3, [r3, #0]
 800fa62:	2207      	movs	r2, #7
 800fa64:	615a      	str	r2, [r3, #20]
 800fa66:	687b      	ldr	r3, [r7, #4]
 800fa68:	681b      	ldr	r3, [r3, #0]
 800fa6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fa6c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800fa6e:	619a      	str	r2, [r3, #24]
 800fa70:	687b      	ldr	r3, [r7, #4]
 800fa72:	681b      	ldr	r3, [r3, #0]
 800fa74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fa76:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800fa78:	61da      	str	r2, [r3, #28]
 800fa7a:	687b      	ldr	r3, [r7, #4]
 800fa7c:	681b      	ldr	r3, [r3, #0]
 800fa7e:	681b      	ldr	r3, [r3, #0]
 800fa80:	6878      	ldr	r0, [r7, #4]
 800fa82:	4798      	blx	r3
	       compptr->DCT_h_scaled_size, compptr->DCT_v_scaled_size);
      break;
 800fa84:	bf00      	nop
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
 800fa86:	69ba      	ldr	r2, [r7, #24]
 800fa88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fa8a:	009b      	lsls	r3, r3, #2
 800fa8c:	4413      	add	r3, r2
 800fa8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800fa90:	605a      	str	r2, [r3, #4]
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
 800fa92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fa94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800fa96:	2b00      	cmp	r3, #0
 800fa98:	f000 80f8 	beq.w	800fc8c <start_pass+0x630>
 800fa9c:	69ba      	ldr	r2, [r7, #24]
 800fa9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800faa0:	330a      	adds	r3, #10
 800faa2:	009b      	lsls	r3, r3, #2
 800faa4:	4413      	add	r3, r2
 800faa6:	685b      	ldr	r3, [r3, #4]
 800faa8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800faaa:	429a      	cmp	r2, r3
 800faac:	f000 80ee 	beq.w	800fc8c <start_pass+0x630>
      continue;
    qtbl = compptr->quant_table;
 800fab0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fab2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800fab4:	617b      	str	r3, [r7, #20]
    if (qtbl == NULL)		/* happens if no data yet for component */
 800fab6:	697b      	ldr	r3, [r7, #20]
 800fab8:	2b00      	cmp	r3, #0
 800faba:	f000 80e9 	beq.w	800fc90 <start_pass+0x634>
      continue;
    idct->cur_method[ci] = method;
 800fabe:	69ba      	ldr	r2, [r7, #24]
 800fac0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fac2:	330a      	adds	r3, #10
 800fac4:	009b      	lsls	r3, r3, #2
 800fac6:	4413      	add	r3, r2
 800fac8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800faca:	605a      	str	r2, [r3, #4]
    switch (method) {
 800facc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800face:	2b02      	cmp	r3, #2
 800fad0:	f000 8086 	beq.w	800fbe0 <start_pass+0x584>
 800fad4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fad6:	2b02      	cmp	r3, #2
 800fad8:	f300 80ce 	bgt.w	800fc78 <start_pass+0x61c>
 800fadc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fade:	2b00      	cmp	r3, #0
 800fae0:	d003      	beq.n	800faea <start_pass+0x48e>
 800fae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fae4:	2b01      	cmp	r3, #1
 800fae6:	d017      	beq.n	800fb18 <start_pass+0x4bc>
 800fae8:	e0c6      	b.n	800fc78 <start_pass+0x61c>
    case JDCT_ISLOW:
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
 800faea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800faec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800faee:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < DCTSIZE2; i++) {
 800faf0:	2300      	movs	r3, #0
 800faf2:	633b      	str	r3, [r7, #48]	; 0x30
 800faf4:	e00c      	b.n	800fb10 <start_pass+0x4b4>
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
 800faf6:	697b      	ldr	r3, [r7, #20]
 800faf8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800fafa:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 800fafe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fb00:	009b      	lsls	r3, r3, #2
 800fb02:	68ba      	ldr	r2, [r7, #8]
 800fb04:	4413      	add	r3, r2
 800fb06:	460a      	mov	r2, r1
 800fb08:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 800fb0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fb0c:	3301      	adds	r3, #1
 800fb0e:	633b      	str	r3, [r7, #48]	; 0x30
 800fb10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fb12:	2b3f      	cmp	r3, #63	; 0x3f
 800fb14:	ddef      	ble.n	800faf6 <start_pass+0x49a>
	}
      }
      break;
 800fb16:	e0bc      	b.n	800fc92 <start_pass+0x636>
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * For integer operation, the multiplier table is to be scaled by
	 * IFAST_SCALE_BITS.
	 */
	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
 800fb18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fb1a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fb1c:	60fb      	str	r3, [r7, #12]
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
 800fb1e:	2300      	movs	r3, #0
 800fb20:	633b      	str	r3, [r7, #48]	; 0x30
 800fb22:	e059      	b.n	800fbd8 <start_pass+0x57c>
 800fb24:	0801a35b 	.word	0x0801a35b
 800fb28:	0801a245 	.word	0x0801a245
 800fb2c:	0801a095 	.word	0x0801a095
 800fb30:	08019e59 	.word	0x08019e59
 800fb34:	08019a8d 	.word	0x08019a8d
 800fb38:	08019625 	.word	0x08019625
 800fb3c:	08018fbd 	.word	0x08018fbd
 800fb40:	0801a3b5 	.word	0x0801a3b5
 800fb44:	0801aabd 	.word	0x0801aabd
 800fb48:	0801b291 	.word	0x0801b291
 800fb4c:	0801bc15 	.word	0x0801bc15
 800fb50:	0801c531 	.word	0x0801c531
 800fb54:	0801d02d 	.word	0x0801d02d
 800fb58:	0801daa5 	.word	0x0801daa5
 800fb5c:	0801e5ad 	.word	0x0801e5ad
 800fb60:	0801f289 	.word	0x0801f289
 800fb64:	0801fdd5 	.word	0x0801fdd5
 800fb68:	0802065d 	.word	0x0802065d
 800fb6c:	08020d39 	.word	0x08020d39
 800fb70:	08021315 	.word	0x08021315
 800fb74:	08021825 	.word	0x08021825
 800fb78:	08021aed 	.word	0x08021aed
 800fb7c:	08021c71 	.word	0x08021c71
 800fb80:	08021d01 	.word	0x08021d01
 800fb84:	080226f5 	.word	0x080226f5
 800fb88:	08022f45 	.word	0x08022f45
 800fb8c:	080235fd 	.word	0x080235fd
 800fb90:	08023bdd 	.word	0x08023bdd
 800fb94:	08024209 	.word	0x08024209
 800fb98:	080244d9 	.word	0x080244d9
 800fb9c:	08024669 	.word	0x08024669
 800fba0:	08018685 	.word	0x08018685
 800fba4:	08017e9d 	.word	0x08017e9d
 800fba8:	08017665 	.word	0x08017665
	  ifmtbl[i] = (IFAST_MULT_TYPE)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 800fbac:	697b      	ldr	r3, [r7, #20]
 800fbae:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800fbb0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800fbb4:	4619      	mov	r1, r3
 800fbb6:	4a3f      	ldr	r2, [pc, #252]	; (800fcb4 <start_pass+0x658>)
 800fbb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbba:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 800fbbe:	fb03 f301 	mul.w	r3, r3, r1
 800fbc2:	f503 6200 	add.w	r2, r3, #2048	; 0x800
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 800fbc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbc8:	009b      	lsls	r3, r3, #2
 800fbca:	68f9      	ldr	r1, [r7, #12]
 800fbcc:	440b      	add	r3, r1
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
 800fbce:	1312      	asrs	r2, r2, #12
	  ifmtbl[i] = (IFAST_MULT_TYPE)
 800fbd0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < DCTSIZE2; i++) {
 800fbd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbd4:	3301      	adds	r3, #1
 800fbd6:	633b      	str	r3, [r7, #48]	; 0x30
 800fbd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbda:	2b3f      	cmp	r3, #63	; 0x3f
 800fbdc:	dde6      	ble.n	800fbac <start_pass+0x550>
				  (INT32) aanscales[i]),
		    CONST_BITS-IFAST_SCALE_BITS);
	}
      }
      break;
 800fbde:	e058      	b.n	800fc92 <start_pass+0x636>
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 1/8.
	 */
	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
 800fbe0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fbe2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fbe4:	613b      	str	r3, [r7, #16]
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	i = 0;
 800fbe6:	2300      	movs	r3, #0
 800fbe8:	633b      	str	r3, [r7, #48]	; 0x30
	for (row = 0; row < DCTSIZE; row++) {
 800fbea:	2300      	movs	r3, #0
 800fbec:	623b      	str	r3, [r7, #32]
 800fbee:	e03f      	b.n	800fc70 <start_pass+0x614>
	  for (col = 0; col < DCTSIZE; col++) {
 800fbf0:	2300      	movs	r3, #0
 800fbf2:	61fb      	str	r3, [r7, #28]
 800fbf4:	e036      	b.n	800fc64 <start_pass+0x608>
	    fmtbl[i] = (FLOAT_MULT_TYPE)
	      ((double) qtbl->quantval[i] *
 800fbf6:	697b      	ldr	r3, [r7, #20]
 800fbf8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800fbfa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800fbfe:	4618      	mov	r0, r3
 800fc00:	f7f0 fc80 	bl	8000504 <__aeabi_ui2d>
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 800fc04:	4a2c      	ldr	r2, [pc, #176]	; (800fcb8 <start_pass+0x65c>)
 800fc06:	6a3b      	ldr	r3, [r7, #32]
 800fc08:	00db      	lsls	r3, r3, #3
 800fc0a:	4413      	add	r3, r2
 800fc0c:	e9d3 2300 	ldrd	r2, r3, [r3]
	      ((double) qtbl->quantval[i] *
 800fc10:	f7f0 fcf2 	bl	80005f8 <__aeabi_dmul>
 800fc14:	4602      	mov	r2, r0
 800fc16:	460b      	mov	r3, r1
 800fc18:	4610      	mov	r0, r2
 800fc1a:	4619      	mov	r1, r3
	       aanscalefactor[row] * aanscalefactor[col] * 0.125);
 800fc1c:	4a26      	ldr	r2, [pc, #152]	; (800fcb8 <start_pass+0x65c>)
 800fc1e:	69fb      	ldr	r3, [r7, #28]
 800fc20:	00db      	lsls	r3, r3, #3
 800fc22:	4413      	add	r3, r2
 800fc24:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fc28:	f7f0 fce6 	bl	80005f8 <__aeabi_dmul>
 800fc2c:	4602      	mov	r2, r0
 800fc2e:	460b      	mov	r3, r1
 800fc30:	4610      	mov	r0, r2
 800fc32:	4619      	mov	r1, r3
 800fc34:	f04f 0200 	mov.w	r2, #0
 800fc38:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 800fc3c:	f7f0 fcdc 	bl	80005f8 <__aeabi_dmul>
 800fc40:	4602      	mov	r2, r0
 800fc42:	460b      	mov	r3, r1
 800fc44:	4610      	mov	r0, r2
 800fc46:	4619      	mov	r1, r3
	    fmtbl[i] = (FLOAT_MULT_TYPE)
 800fc48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc4a:	009b      	lsls	r3, r3, #2
 800fc4c:	693a      	ldr	r2, [r7, #16]
 800fc4e:	18d4      	adds	r4, r2, r3
 800fc50:	f7f0 fee4 	bl	8000a1c <__aeabi_d2f>
 800fc54:	4603      	mov	r3, r0
 800fc56:	6023      	str	r3, [r4, #0]
	    i++;
 800fc58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc5a:	3301      	adds	r3, #1
 800fc5c:	633b      	str	r3, [r7, #48]	; 0x30
	  for (col = 0; col < DCTSIZE; col++) {
 800fc5e:	69fb      	ldr	r3, [r7, #28]
 800fc60:	3301      	adds	r3, #1
 800fc62:	61fb      	str	r3, [r7, #28]
 800fc64:	69fb      	ldr	r3, [r7, #28]
 800fc66:	2b07      	cmp	r3, #7
 800fc68:	ddc5      	ble.n	800fbf6 <start_pass+0x59a>
	for (row = 0; row < DCTSIZE; row++) {
 800fc6a:	6a3b      	ldr	r3, [r7, #32]
 800fc6c:	3301      	adds	r3, #1
 800fc6e:	623b      	str	r3, [r7, #32]
 800fc70:	6a3b      	ldr	r3, [r7, #32]
 800fc72:	2b07      	cmp	r3, #7
 800fc74:	ddbc      	ble.n	800fbf0 <start_pass+0x594>
	  }
	}
      }
      break;
 800fc76:	e00c      	b.n	800fc92 <start_pass+0x636>
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
 800fc78:	687b      	ldr	r3, [r7, #4]
 800fc7a:	681b      	ldr	r3, [r3, #0]
 800fc7c:	2231      	movs	r2, #49	; 0x31
 800fc7e:	615a      	str	r2, [r3, #20]
 800fc80:	687b      	ldr	r3, [r7, #4]
 800fc82:	681b      	ldr	r3, [r3, #0]
 800fc84:	681b      	ldr	r3, [r3, #0]
 800fc86:	6878      	ldr	r0, [r7, #4]
 800fc88:	4798      	blx	r3
      break;
 800fc8a:	e002      	b.n	800fc92 <start_pass+0x636>
      continue;
 800fc8c:	bf00      	nop
 800fc8e:	e000      	b.n	800fc92 <start_pass+0x636>
      continue;
 800fc90:	bf00      	nop
       ci++, compptr++) {
 800fc92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc94:	3301      	adds	r3, #1
 800fc96:	637b      	str	r3, [r7, #52]	; 0x34
 800fc98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fc9a:	3358      	adds	r3, #88	; 0x58
 800fc9c:	62fb      	str	r3, [r7, #44]	; 0x2c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800fc9e:	687b      	ldr	r3, [r7, #4]
 800fca0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fca2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800fca4:	429a      	cmp	r2, r3
 800fca6:	f6ff acec 	blt.w	800f682 <start_pass+0x26>
    }
  }
}
 800fcaa:	bf00      	nop
 800fcac:	bf00      	nop
 800fcae:	373c      	adds	r7, #60	; 0x3c
 800fcb0:	46bd      	mov	sp, r7
 800fcb2:	bd90      	pop	{r4, r7, pc}
 800fcb4:	0802a520 	.word	0x0802a520
 800fcb8:	0802a5a0 	.word	0x0802a5a0

0800fcbc <jinit_inverse_dct>:
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
 800fcbc:	b580      	push	{r7, lr}
 800fcbe:	b086      	sub	sp, #24
 800fcc0:	af00      	add	r7, sp, #0
 800fcc2:	6078      	str	r0, [r7, #4]
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800fcc4:	687b      	ldr	r3, [r7, #4]
 800fcc6:	685b      	ldr	r3, [r3, #4]
 800fcc8:	681b      	ldr	r3, [r3, #0]
 800fcca:	2254      	movs	r2, #84	; 0x54
 800fccc:	2101      	movs	r1, #1
 800fcce:	6878      	ldr	r0, [r7, #4]
 800fcd0:	4798      	blx	r3
 800fcd2:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
 800fcd4:	687b      	ldr	r3, [r7, #4]
 800fcd6:	68fa      	ldr	r2, [r7, #12]
 800fcd8:	f8c3 21d4 	str.w	r2, [r3, #468]	; 0x1d4
  idct->pub.start_pass = start_pass;
 800fcdc:	68fb      	ldr	r3, [r7, #12]
 800fcde:	4a1a      	ldr	r2, [pc, #104]	; (800fd48 <jinit_inverse_dct+0x8c>)
 800fce0:	601a      	str	r2, [r3, #0]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800fce2:	2300      	movs	r3, #0
 800fce4:	617b      	str	r3, [r7, #20]
 800fce6:	687b      	ldr	r3, [r7, #4]
 800fce8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800fcec:	613b      	str	r3, [r7, #16]
 800fcee:	e020      	b.n	800fd32 <jinit_inverse_dct+0x76>
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800fcf0:	687b      	ldr	r3, [r7, #4]
 800fcf2:	685b      	ldr	r3, [r3, #4]
 800fcf4:	681b      	ldr	r3, [r3, #0]
 800fcf6:	f44f 7280 	mov.w	r2, #256	; 0x100
 800fcfa:	2101      	movs	r1, #1
 800fcfc:	6878      	ldr	r0, [r7, #4]
 800fcfe:	4798      	blx	r3
 800fd00:	4602      	mov	r2, r0
    compptr->dct_table =
 800fd02:	693b      	ldr	r3, [r7, #16]
 800fd04:	655a      	str	r2, [r3, #84]	; 0x54
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
 800fd06:	693b      	ldr	r3, [r7, #16]
 800fd08:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fd0a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800fd0e:	2100      	movs	r1, #0
 800fd10:	4618      	mov	r0, r3
 800fd12:	f018 fab5 	bl	8028280 <memset>
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
 800fd16:	68fa      	ldr	r2, [r7, #12]
 800fd18:	697b      	ldr	r3, [r7, #20]
 800fd1a:	330a      	adds	r3, #10
 800fd1c:	009b      	lsls	r3, r3, #2
 800fd1e:	4413      	add	r3, r2
 800fd20:	f04f 32ff 	mov.w	r2, #4294967295
 800fd24:	605a      	str	r2, [r3, #4]
       ci++, compptr++) {
 800fd26:	697b      	ldr	r3, [r7, #20]
 800fd28:	3301      	adds	r3, #1
 800fd2a:	617b      	str	r3, [r7, #20]
 800fd2c:	693b      	ldr	r3, [r7, #16]
 800fd2e:	3358      	adds	r3, #88	; 0x58
 800fd30:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 800fd32:	687b      	ldr	r3, [r7, #4]
 800fd34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fd36:	697a      	ldr	r2, [r7, #20]
 800fd38:	429a      	cmp	r2, r3
 800fd3a:	dbd9      	blt.n	800fcf0 <jinit_inverse_dct+0x34>
  }
}
 800fd3c:	bf00      	nop
 800fd3e:	bf00      	nop
 800fd40:	3718      	adds	r7, #24
 800fd42:	46bd      	mov	sp, r7
 800fd44:	bd80      	pop	{r7, pc}
 800fd46:	bf00      	nop
 800fd48:	0800f65d 	.word	0x0800f65d

0800fd4c <jpeg_make_d_derived_tbl>:
 */

LOCAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
			 d_derived_tbl ** pdtbl)
{
 800fd4c:	b590      	push	{r4, r7, lr}
 800fd4e:	f2ad 5d4c 	subw	sp, sp, #1356	; 0x54c
 800fd52:	af00      	add	r7, sp, #0
 800fd54:	f107 040c 	add.w	r4, r7, #12
 800fd58:	6020      	str	r0, [r4, #0]
 800fd5a:	f107 0008 	add.w	r0, r7, #8
 800fd5e:	6001      	str	r1, [r0, #0]
 800fd60:	1d39      	adds	r1, r7, #4
 800fd62:	600a      	str	r2, [r1, #0]
 800fd64:	463a      	mov	r2, r7
 800fd66:	6013      	str	r3, [r2, #0]
  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
 800fd68:	1d3b      	adds	r3, r7, #4
 800fd6a:	681b      	ldr	r3, [r3, #0]
 800fd6c:	2b00      	cmp	r3, #0
 800fd6e:	db03      	blt.n	800fd78 <jpeg_make_d_derived_tbl+0x2c>
 800fd70:	1d3b      	adds	r3, r7, #4
 800fd72:	681b      	ldr	r3, [r3, #0]
 800fd74:	2b03      	cmp	r3, #3
 800fd76:	dd15      	ble.n	800fda4 <jpeg_make_d_derived_tbl+0x58>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 800fd78:	f107 030c 	add.w	r3, r7, #12
 800fd7c:	681b      	ldr	r3, [r3, #0]
 800fd7e:	681b      	ldr	r3, [r3, #0]
 800fd80:	2234      	movs	r2, #52	; 0x34
 800fd82:	615a      	str	r2, [r3, #20]
 800fd84:	f107 030c 	add.w	r3, r7, #12
 800fd88:	681b      	ldr	r3, [r3, #0]
 800fd8a:	681b      	ldr	r3, [r3, #0]
 800fd8c:	1d3a      	adds	r2, r7, #4
 800fd8e:	6812      	ldr	r2, [r2, #0]
 800fd90:	619a      	str	r2, [r3, #24]
 800fd92:	f107 030c 	add.w	r3, r7, #12
 800fd96:	681b      	ldr	r3, [r3, #0]
 800fd98:	681b      	ldr	r3, [r3, #0]
 800fd9a:	681b      	ldr	r3, [r3, #0]
 800fd9c:	f107 020c 	add.w	r2, r7, #12
 800fda0:	6810      	ldr	r0, [r2, #0]
 800fda2:	4798      	blx	r3
  htbl =
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
 800fda4:	f107 0308 	add.w	r3, r7, #8
 800fda8:	681b      	ldr	r3, [r3, #0]
 800fdaa:	2b00      	cmp	r3, #0
 800fdac:	d009      	beq.n	800fdc2 <jpeg_make_d_derived_tbl+0x76>
 800fdae:	f107 030c 	add.w	r3, r7, #12
 800fdb2:	681a      	ldr	r2, [r3, #0]
 800fdb4:	1d3b      	adds	r3, r7, #4
 800fdb6:	681b      	ldr	r3, [r3, #0]
 800fdb8:	332c      	adds	r3, #44	; 0x2c
 800fdba:	009b      	lsls	r3, r3, #2
 800fdbc:	4413      	add	r3, r2
 800fdbe:	685b      	ldr	r3, [r3, #4]
 800fdc0:	e008      	b.n	800fdd4 <jpeg_make_d_derived_tbl+0x88>
 800fdc2:	f107 030c 	add.w	r3, r7, #12
 800fdc6:	681a      	ldr	r2, [r3, #0]
 800fdc8:	1d3b      	adds	r3, r7, #4
 800fdca:	681b      	ldr	r3, [r3, #0]
 800fdcc:	3330      	adds	r3, #48	; 0x30
 800fdce:	009b      	lsls	r3, r3, #2
 800fdd0:	4413      	add	r3, r2
 800fdd2:	685b      	ldr	r3, [r3, #4]
  htbl =
 800fdd4:	f8c7 3528 	str.w	r3, [r7, #1320]	; 0x528
  if (htbl == NULL)
 800fdd8:	f8d7 3528 	ldr.w	r3, [r7, #1320]	; 0x528
 800fddc:	2b00      	cmp	r3, #0
 800fdde:	d115      	bne.n	800fe0c <jpeg_make_d_derived_tbl+0xc0>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 800fde0:	f107 030c 	add.w	r3, r7, #12
 800fde4:	681b      	ldr	r3, [r3, #0]
 800fde6:	681b      	ldr	r3, [r3, #0]
 800fde8:	2234      	movs	r2, #52	; 0x34
 800fdea:	615a      	str	r2, [r3, #20]
 800fdec:	f107 030c 	add.w	r3, r7, #12
 800fdf0:	681b      	ldr	r3, [r3, #0]
 800fdf2:	681b      	ldr	r3, [r3, #0]
 800fdf4:	1d3a      	adds	r2, r7, #4
 800fdf6:	6812      	ldr	r2, [r2, #0]
 800fdf8:	619a      	str	r2, [r3, #24]
 800fdfa:	f107 030c 	add.w	r3, r7, #12
 800fdfe:	681b      	ldr	r3, [r3, #0]
 800fe00:	681b      	ldr	r3, [r3, #0]
 800fe02:	681b      	ldr	r3, [r3, #0]
 800fe04:	f107 020c 	add.w	r2, r7, #12
 800fe08:	6810      	ldr	r0, [r2, #0]
 800fe0a:	4798      	blx	r3

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
 800fe0c:	463b      	mov	r3, r7
 800fe0e:	681b      	ldr	r3, [r3, #0]
 800fe10:	681b      	ldr	r3, [r3, #0]
 800fe12:	2b00      	cmp	r3, #0
 800fe14:	d10f      	bne.n	800fe36 <jpeg_make_d_derived_tbl+0xea>
    *pdtbl = (d_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 800fe16:	f107 030c 	add.w	r3, r7, #12
 800fe1a:	681b      	ldr	r3, [r3, #0]
 800fe1c:	685b      	ldr	r3, [r3, #4]
 800fe1e:	681b      	ldr	r3, [r3, #0]
 800fe20:	f107 000c 	add.w	r0, r7, #12
 800fe24:	f44f 62b2 	mov.w	r2, #1424	; 0x590
 800fe28:	2101      	movs	r1, #1
 800fe2a:	6800      	ldr	r0, [r0, #0]
 800fe2c:	4798      	blx	r3
 800fe2e:	4602      	mov	r2, r0
    *pdtbl = (d_derived_tbl *)
 800fe30:	463b      	mov	r3, r7
 800fe32:	681b      	ldr	r3, [r3, #0]
 800fe34:	601a      	str	r2, [r3, #0]
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
 800fe36:	463b      	mov	r3, r7
 800fe38:	681b      	ldr	r3, [r3, #0]
 800fe3a:	681b      	ldr	r3, [r3, #0]
 800fe3c:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
  dtbl->pub = htbl;		/* fill in back link */
 800fe40:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 800fe44:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 800fe48:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  
  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
 800fe4c:	2300      	movs	r3, #0
 800fe4e:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
  for (l = 1; l <= 16; l++) {
 800fe52:	2301      	movs	r3, #1
 800fe54:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 800fe58:	e03a      	b.n	800fed0 <jpeg_make_d_derived_tbl+0x184>
    i = (int) htbl->bits[l];
 800fe5a:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 800fe5e:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 800fe62:	4413      	add	r3, r2
 800fe64:	781b      	ldrb	r3, [r3, #0]
 800fe66:	f8c7 3540 	str.w	r3, [r7, #1344]	; 0x540
    if (i < 0 || p + i > 256)	/* protect against table overrun */
 800fe6a:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 800fe6e:	2b00      	cmp	r3, #0
 800fe70:	db07      	blt.n	800fe82 <jpeg_make_d_derived_tbl+0x136>
 800fe72:	f8d7 2544 	ldr.w	r2, [r7, #1348]	; 0x544
 800fe76:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 800fe7a:	4413      	add	r3, r2
 800fe7c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800fe80:	dd1a      	ble.n	800feb8 <jpeg_make_d_derived_tbl+0x16c>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 800fe82:	f107 030c 	add.w	r3, r7, #12
 800fe86:	681b      	ldr	r3, [r3, #0]
 800fe88:	681b      	ldr	r3, [r3, #0]
 800fe8a:	2209      	movs	r2, #9
 800fe8c:	615a      	str	r2, [r3, #20]
 800fe8e:	f107 030c 	add.w	r3, r7, #12
 800fe92:	681b      	ldr	r3, [r3, #0]
 800fe94:	681b      	ldr	r3, [r3, #0]
 800fe96:	681b      	ldr	r3, [r3, #0]
 800fe98:	f107 020c 	add.w	r2, r7, #12
 800fe9c:	6810      	ldr	r0, [r2, #0]
 800fe9e:	4798      	blx	r3
    while (i--)
 800fea0:	e00a      	b.n	800feb8 <jpeg_make_d_derived_tbl+0x16c>
      huffsize[p++] = (char) l;
 800fea2:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800fea6:	1c5a      	adds	r2, r3, #1
 800fea8:	f8c7 2544 	str.w	r2, [r7, #1348]	; 0x544
 800feac:	f8d7 253c 	ldr.w	r2, [r7, #1340]	; 0x53c
 800feb0:	b2d1      	uxtb	r1, r2
 800feb2:	f507 6283 	add.w	r2, r7, #1048	; 0x418
 800feb6:	54d1      	strb	r1, [r2, r3]
    while (i--)
 800feb8:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 800febc:	1e5a      	subs	r2, r3, #1
 800febe:	f8c7 2540 	str.w	r2, [r7, #1344]	; 0x540
 800fec2:	2b00      	cmp	r3, #0
 800fec4:	d1ed      	bne.n	800fea2 <jpeg_make_d_derived_tbl+0x156>
  for (l = 1; l <= 16; l++) {
 800fec6:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 800feca:	3301      	adds	r3, #1
 800fecc:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 800fed0:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 800fed4:	2b10      	cmp	r3, #16
 800fed6:	ddc0      	ble.n	800fe5a <jpeg_make_d_derived_tbl+0x10e>
  }
  huffsize[p] = 0;
 800fed8:	f507 6283 	add.w	r2, r7, #1048	; 0x418
 800fedc:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800fee0:	4413      	add	r3, r2
 800fee2:	2200      	movs	r2, #0
 800fee4:	701a      	strb	r2, [r3, #0]
  numsymbols = p;
 800fee6:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800feea:	f8c7 3520 	str.w	r3, [r7, #1312]	; 0x520
  
  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */
  
  code = 0;
 800feee:	2300      	movs	r3, #0
 800fef0:	f8c7 352c 	str.w	r3, [r7, #1324]	; 0x52c
  si = huffsize[0];
 800fef4:	f507 6383 	add.w	r3, r7, #1048	; 0x418
 800fef8:	781b      	ldrb	r3, [r3, #0]
 800fefa:	f8c7 3538 	str.w	r3, [r7, #1336]	; 0x538
  p = 0;
 800fefe:	2300      	movs	r3, #0
 800ff00:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
  while (huffsize[p]) {
 800ff04:	e03b      	b.n	800ff7e <jpeg_make_d_derived_tbl+0x232>
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
 800ff06:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ff0a:	1c5a      	adds	r2, r3, #1
 800ff0c:	f8c7 2544 	str.w	r2, [r7, #1348]	; 0x544
 800ff10:	f107 0214 	add.w	r2, r7, #20
 800ff14:	f8d7 152c 	ldr.w	r1, [r7, #1324]	; 0x52c
 800ff18:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      code++;
 800ff1c:	f8d7 352c 	ldr.w	r3, [r7, #1324]	; 0x52c
 800ff20:	3301      	adds	r3, #1
 800ff22:	f8c7 352c 	str.w	r3, [r7, #1324]	; 0x52c
    while (((int) huffsize[p]) == si) {
 800ff26:	f507 6283 	add.w	r2, r7, #1048	; 0x418
 800ff2a:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ff2e:	4413      	add	r3, r2
 800ff30:	781b      	ldrb	r3, [r3, #0]
 800ff32:	461a      	mov	r2, r3
 800ff34:	f8d7 3538 	ldr.w	r3, [r7, #1336]	; 0x538
 800ff38:	4293      	cmp	r3, r2
 800ff3a:	d0e4      	beq.n	800ff06 <jpeg_make_d_derived_tbl+0x1ba>
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
 800ff3c:	2201      	movs	r2, #1
 800ff3e:	f8d7 3538 	ldr.w	r3, [r7, #1336]	; 0x538
 800ff42:	409a      	lsls	r2, r3
 800ff44:	f8d7 352c 	ldr.w	r3, [r7, #1324]	; 0x52c
 800ff48:	429a      	cmp	r2, r3
 800ff4a:	dc0e      	bgt.n	800ff6a <jpeg_make_d_derived_tbl+0x21e>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 800ff4c:	f107 030c 	add.w	r3, r7, #12
 800ff50:	681b      	ldr	r3, [r3, #0]
 800ff52:	681b      	ldr	r3, [r3, #0]
 800ff54:	2209      	movs	r2, #9
 800ff56:	615a      	str	r2, [r3, #20]
 800ff58:	f107 030c 	add.w	r3, r7, #12
 800ff5c:	681b      	ldr	r3, [r3, #0]
 800ff5e:	681b      	ldr	r3, [r3, #0]
 800ff60:	681b      	ldr	r3, [r3, #0]
 800ff62:	f107 020c 	add.w	r2, r7, #12
 800ff66:	6810      	ldr	r0, [r2, #0]
 800ff68:	4798      	blx	r3
    code <<= 1;
 800ff6a:	f8d7 352c 	ldr.w	r3, [r7, #1324]	; 0x52c
 800ff6e:	005b      	lsls	r3, r3, #1
 800ff70:	f8c7 352c 	str.w	r3, [r7, #1324]	; 0x52c
    si++;
 800ff74:	f8d7 3538 	ldr.w	r3, [r7, #1336]	; 0x538
 800ff78:	3301      	adds	r3, #1
 800ff7a:	f8c7 3538 	str.w	r3, [r7, #1336]	; 0x538
  while (huffsize[p]) {
 800ff7e:	f507 6283 	add.w	r2, r7, #1048	; 0x418
 800ff82:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ff86:	4413      	add	r3, r2
 800ff88:	781b      	ldrb	r3, [r3, #0]
 800ff8a:	2b00      	cmp	r3, #0
 800ff8c:	d1cb      	bne.n	800ff26 <jpeg_make_d_derived_tbl+0x1da>
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
 800ff8e:	2300      	movs	r3, #0
 800ff90:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
  for (l = 1; l <= 16; l++) {
 800ff94:	2301      	movs	r3, #1
 800ff96:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 800ff9a:	e040      	b.n	801001e <jpeg_make_d_derived_tbl+0x2d2>
    if (htbl->bits[l]) {
 800ff9c:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 800ffa0:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 800ffa4:	4413      	add	r3, r2
 800ffa6:	781b      	ldrb	r3, [r3, #0]
 800ffa8:	2b00      	cmp	r3, #0
 800ffaa:	d02b      	beq.n	8010004 <jpeg_make_d_derived_tbl+0x2b8>
      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
       * minus the minimum code of length l
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
 800ffac:	f107 0314 	add.w	r3, r7, #20
 800ffb0:	f8d7 2544 	ldr.w	r2, [r7, #1348]	; 0x544
 800ffb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ffb8:	461a      	mov	r2, r3
 800ffba:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ffbe:	1a99      	subs	r1, r3, r2
 800ffc0:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 800ffc4:	f8d7 253c 	ldr.w	r2, [r7, #1340]	; 0x53c
 800ffc8:	3212      	adds	r2, #18
 800ffca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      p += htbl->bits[l];
 800ffce:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 800ffd2:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 800ffd6:	4413      	add	r3, r2
 800ffd8:	781b      	ldrb	r3, [r3, #0]
 800ffda:	461a      	mov	r2, r3
 800ffdc:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ffe0:	4413      	add	r3, r2
 800ffe2:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
 800ffe6:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 800ffea:	1e5a      	subs	r2, r3, #1
 800ffec:	f107 0314 	add.w	r3, r7, #20
 800fff0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800fff4:	4619      	mov	r1, r3
 800fff6:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 800fffa:	f8d7 253c 	ldr.w	r2, [r7, #1340]	; 0x53c
 800fffe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8010002:	e007      	b.n	8010014 <jpeg_make_d_derived_tbl+0x2c8>
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
 8010004:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 8010008:	f8d7 253c 	ldr.w	r2, [r7, #1340]	; 0x53c
 801000c:	f04f 31ff 	mov.w	r1, #4294967295
 8010010:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (l = 1; l <= 16; l++) {
 8010014:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 8010018:	3301      	adds	r3, #1
 801001a:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 801001e:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 8010022:	2b10      	cmp	r3, #16
 8010024:	ddba      	ble.n	800ff9c <jpeg_make_d_derived_tbl+0x250>
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
 8010026:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 801002a:	4a56      	ldr	r2, [pc, #344]	; (8010184 <jpeg_make_d_derived_tbl+0x438>)
 801002c:	645a      	str	r2, [r3, #68]	; 0x44
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
 801002e:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 8010032:	3390      	adds	r3, #144	; 0x90
 8010034:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8010038:	2100      	movs	r1, #0
 801003a:	4618      	mov	r0, r3
 801003c:	f018 f920 	bl	8028280 <memset>

  p = 0;
 8010040:	2300      	movs	r3, #0
 8010042:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 8010046:	2301      	movs	r3, #1
 8010048:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 801004c:	e05c      	b.n	8010108 <jpeg_make_d_derived_tbl+0x3bc>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 801004e:	2301      	movs	r3, #1
 8010050:	f8c7 3540 	str.w	r3, [r7, #1344]	; 0x540
 8010054:	e048      	b.n	80100e8 <jpeg_make_d_derived_tbl+0x39c>
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
 8010056:	f107 0314 	add.w	r3, r7, #20
 801005a:	f8d7 2544 	ldr.w	r2, [r7, #1348]	; 0x544
 801005e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010062:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 8010066:	f1c3 0308 	rsb	r3, r3, #8
 801006a:	fa02 f303 	lsl.w	r3, r2, r3
 801006e:	f8c7 3534 	str.w	r3, [r7, #1332]	; 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 8010072:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 8010076:	f1c3 0308 	rsb	r3, r3, #8
 801007a:	2201      	movs	r2, #1
 801007c:	fa02 f303 	lsl.w	r3, r2, r3
 8010080:	f8c7 3530 	str.w	r3, [r7, #1328]	; 0x530
 8010084:	e022      	b.n	80100cc <jpeg_make_d_derived_tbl+0x380>
	dtbl->look_nbits[lookbits] = l;
 8010086:	f8d7 3524 	ldr.w	r3, [r7, #1316]	; 0x524
 801008a:	f8d7 2534 	ldr.w	r2, [r7, #1332]	; 0x534
 801008e:	3224      	adds	r2, #36	; 0x24
 8010090:	f8d7 153c 	ldr.w	r1, [r7, #1340]	; 0x53c
 8010094:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	dtbl->look_sym[lookbits] = htbl->huffval[p];
 8010098:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 801009c:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 80100a0:	4413      	add	r3, r2
 80100a2:	3311      	adds	r3, #17
 80100a4:	7819      	ldrb	r1, [r3, #0]
 80100a6:	f8d7 2524 	ldr.w	r2, [r7, #1316]	; 0x524
 80100aa:	f8d7 3534 	ldr.w	r3, [r7, #1332]	; 0x534
 80100ae:	4413      	add	r3, r2
 80100b0:	f503 6392 	add.w	r3, r3, #1168	; 0x490
 80100b4:	460a      	mov	r2, r1
 80100b6:	701a      	strb	r2, [r3, #0]
	lookbits++;
 80100b8:	f8d7 3534 	ldr.w	r3, [r7, #1332]	; 0x534
 80100bc:	3301      	adds	r3, #1
 80100be:	f8c7 3534 	str.w	r3, [r7, #1332]	; 0x534
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
 80100c2:	f8d7 3530 	ldr.w	r3, [r7, #1328]	; 0x530
 80100c6:	3b01      	subs	r3, #1
 80100c8:	f8c7 3530 	str.w	r3, [r7, #1328]	; 0x530
 80100cc:	f8d7 3530 	ldr.w	r3, [r7, #1328]	; 0x530
 80100d0:	2b00      	cmp	r3, #0
 80100d2:	dcd8      	bgt.n	8010086 <jpeg_make_d_derived_tbl+0x33a>
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
 80100d4:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 80100d8:	3301      	adds	r3, #1
 80100da:	f8c7 3540 	str.w	r3, [r7, #1344]	; 0x540
 80100de:	f8d7 3544 	ldr.w	r3, [r7, #1348]	; 0x544
 80100e2:	3301      	adds	r3, #1
 80100e4:	f8c7 3544 	str.w	r3, [r7, #1348]	; 0x544
 80100e8:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 80100ec:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 80100f0:	4413      	add	r3, r2
 80100f2:	781b      	ldrb	r3, [r3, #0]
 80100f4:	461a      	mov	r2, r3
 80100f6:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 80100fa:	4293      	cmp	r3, r2
 80100fc:	ddab      	ble.n	8010056 <jpeg_make_d_derived_tbl+0x30a>
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
 80100fe:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 8010102:	3301      	adds	r3, #1
 8010104:	f8c7 353c 	str.w	r3, [r7, #1340]	; 0x53c
 8010108:	f8d7 353c 	ldr.w	r3, [r7, #1340]	; 0x53c
 801010c:	2b08      	cmp	r3, #8
 801010e:	dd9e      	ble.n	801004e <jpeg_make_d_derived_tbl+0x302>
   * For AC tables, we make no check, but accept all byte values 0..255.
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
 8010110:	f107 0308 	add.w	r3, r7, #8
 8010114:	681b      	ldr	r3, [r3, #0]
 8010116:	2b00      	cmp	r3, #0
 8010118:	d02e      	beq.n	8010178 <jpeg_make_d_derived_tbl+0x42c>
    for (i = 0; i < numsymbols; i++) {
 801011a:	2300      	movs	r3, #0
 801011c:	f8c7 3540 	str.w	r3, [r7, #1344]	; 0x540
 8010120:	e024      	b.n	801016c <jpeg_make_d_derived_tbl+0x420>
      int sym = htbl->huffval[i];
 8010122:	f8d7 2528 	ldr.w	r2, [r7, #1320]	; 0x528
 8010126:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 801012a:	4413      	add	r3, r2
 801012c:	3311      	adds	r3, #17
 801012e:	781b      	ldrb	r3, [r3, #0]
 8010130:	f8c7 351c 	str.w	r3, [r7, #1308]	; 0x51c
      if (sym < 0 || sym > 15)
 8010134:	f8d7 351c 	ldr.w	r3, [r7, #1308]	; 0x51c
 8010138:	2b00      	cmp	r3, #0
 801013a:	db03      	blt.n	8010144 <jpeg_make_d_derived_tbl+0x3f8>
 801013c:	f8d7 351c 	ldr.w	r3, [r7, #1308]	; 0x51c
 8010140:	2b0f      	cmp	r3, #15
 8010142:	dd0e      	ble.n	8010162 <jpeg_make_d_derived_tbl+0x416>
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8010144:	f107 030c 	add.w	r3, r7, #12
 8010148:	681b      	ldr	r3, [r3, #0]
 801014a:	681b      	ldr	r3, [r3, #0]
 801014c:	2209      	movs	r2, #9
 801014e:	615a      	str	r2, [r3, #20]
 8010150:	f107 030c 	add.w	r3, r7, #12
 8010154:	681b      	ldr	r3, [r3, #0]
 8010156:	681b      	ldr	r3, [r3, #0]
 8010158:	681b      	ldr	r3, [r3, #0]
 801015a:	f107 020c 	add.w	r2, r7, #12
 801015e:	6810      	ldr	r0, [r2, #0]
 8010160:	4798      	blx	r3
    for (i = 0; i < numsymbols; i++) {
 8010162:	f8d7 3540 	ldr.w	r3, [r7, #1344]	; 0x540
 8010166:	3301      	adds	r3, #1
 8010168:	f8c7 3540 	str.w	r3, [r7, #1344]	; 0x540
 801016c:	f8d7 2540 	ldr.w	r2, [r7, #1344]	; 0x540
 8010170:	f8d7 3520 	ldr.w	r3, [r7, #1312]	; 0x520
 8010174:	429a      	cmp	r2, r3
 8010176:	dbd4      	blt.n	8010122 <jpeg_make_d_derived_tbl+0x3d6>
    }
  }
}
 8010178:	bf00      	nop
 801017a:	f207 574c 	addw	r7, r7, #1356	; 0x54c
 801017e:	46bd      	mov	sp, r7
 8010180:	bd90      	pop	{r4, r7, pc}
 8010182:	bf00      	nop
 8010184:	000fffff 	.word	0x000fffff

08010188 <jpeg_fill_bit_buffer>:
LOCAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
 8010188:	b5f0      	push	{r4, r5, r6, r7, lr}
 801018a:	b087      	sub	sp, #28
 801018c:	af00      	add	r7, sp, #0
 801018e:	60f8      	str	r0, [r7, #12]
 8010190:	6079      	str	r1, [r7, #4]
 8010192:	4615      	mov	r5, r2
 8010194:	60bb      	str	r3, [r7, #8]
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
 8010196:	68fb      	ldr	r3, [r7, #12]
 8010198:	681e      	ldr	r6, [r3, #0]
  register size_t bytes_in_buffer = state->bytes_in_buffer;
 801019a:	68fb      	ldr	r3, [r7, #12]
 801019c:	685c      	ldr	r4, [r3, #4]
  j_decompress_ptr cinfo = state->cinfo;
 801019e:	68fb      	ldr	r3, [r7, #12]
 80101a0:	691b      	ldr	r3, [r3, #16]
 80101a2:	617b      	str	r3, [r7, #20]

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
 80101a4:	697b      	ldr	r3, [r7, #20]
 80101a6:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80101aa:	2b00      	cmp	r3, #0
 80101ac:	d143      	bne.n	8010236 <jpeg_fill_bit_buffer+0xae>
    while (bits_left < MIN_GET_BITS) {
 80101ae:	e03f      	b.n	8010230 <jpeg_fill_bit_buffer+0xa8>
      register int c;

      /* Attempt to read a byte */
      if (bytes_in_buffer == 0) {
 80101b0:	2c00      	cmp	r4, #0
 80101b2:	d10f      	bne.n	80101d4 <jpeg_fill_bit_buffer+0x4c>
	if (! (*cinfo->src->fill_input_buffer) (cinfo))
 80101b4:	697b      	ldr	r3, [r7, #20]
 80101b6:	699b      	ldr	r3, [r3, #24]
 80101b8:	68db      	ldr	r3, [r3, #12]
 80101ba:	6978      	ldr	r0, [r7, #20]
 80101bc:	4798      	blx	r3
 80101be:	4603      	mov	r3, r0
 80101c0:	2b00      	cmp	r3, #0
 80101c2:	d101      	bne.n	80101c8 <jpeg_fill_bit_buffer+0x40>
	  return FALSE;
 80101c4:	2300      	movs	r3, #0
 80101c6:	e060      	b.n	801028a <jpeg_fill_bit_buffer+0x102>
	next_input_byte = cinfo->src->next_input_byte;
 80101c8:	697b      	ldr	r3, [r7, #20]
 80101ca:	699b      	ldr	r3, [r3, #24]
 80101cc:	681e      	ldr	r6, [r3, #0]
	bytes_in_buffer = cinfo->src->bytes_in_buffer;
 80101ce:	697b      	ldr	r3, [r7, #20]
 80101d0:	699b      	ldr	r3, [r3, #24]
 80101d2:	685c      	ldr	r4, [r3, #4]
      }
      bytes_in_buffer--;
 80101d4:	3c01      	subs	r4, #1
      c = GETJOCTET(*next_input_byte++);
 80101d6:	4633      	mov	r3, r6
 80101d8:	1c5e      	adds	r6, r3, #1
 80101da:	781b      	ldrb	r3, [r3, #0]
 80101dc:	461a      	mov	r2, r3

      /* If it's 0xFF, check and discard stuffed zero byte */
      if (c == 0xFF) {
 80101de:	2bff      	cmp	r3, #255	; 0xff
 80101e0:	d121      	bne.n	8010226 <jpeg_fill_bit_buffer+0x9e>
	 * so that we can save a valid unread_marker value.  NOTE: we will
	 * accept multiple FF's followed by a 0 as meaning a single FF data
	 * byte.  This data pattern is not valid according to the standard.
	 */
	do {
	  if (bytes_in_buffer == 0) {
 80101e2:	2c00      	cmp	r4, #0
 80101e4:	d10f      	bne.n	8010206 <jpeg_fill_bit_buffer+0x7e>
	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
 80101e6:	697b      	ldr	r3, [r7, #20]
 80101e8:	699b      	ldr	r3, [r3, #24]
 80101ea:	68db      	ldr	r3, [r3, #12]
 80101ec:	6978      	ldr	r0, [r7, #20]
 80101ee:	4798      	blx	r3
 80101f0:	4603      	mov	r3, r0
 80101f2:	2b00      	cmp	r3, #0
 80101f4:	d101      	bne.n	80101fa <jpeg_fill_bit_buffer+0x72>
	      return FALSE;
 80101f6:	2300      	movs	r3, #0
 80101f8:	e047      	b.n	801028a <jpeg_fill_bit_buffer+0x102>
	    next_input_byte = cinfo->src->next_input_byte;
 80101fa:	697b      	ldr	r3, [r7, #20]
 80101fc:	699b      	ldr	r3, [r3, #24]
 80101fe:	681e      	ldr	r6, [r3, #0]
	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
 8010200:	697b      	ldr	r3, [r7, #20]
 8010202:	699b      	ldr	r3, [r3, #24]
 8010204:	685c      	ldr	r4, [r3, #4]
	  }
	  bytes_in_buffer--;
 8010206:	3c01      	subs	r4, #1
	  c = GETJOCTET(*next_input_byte++);
 8010208:	4633      	mov	r3, r6
 801020a:	1c5e      	adds	r6, r3, #1
 801020c:	781b      	ldrb	r3, [r3, #0]
 801020e:	461a      	mov	r2, r3
	} while (c == 0xFF);
 8010210:	2bff      	cmp	r3, #255	; 0xff
 8010212:	d0e6      	beq.n	80101e2 <jpeg_fill_bit_buffer+0x5a>

	if (c == 0) {
 8010214:	2b00      	cmp	r3, #0
 8010216:	d102      	bne.n	801021e <jpeg_fill_bit_buffer+0x96>
	  /* Found FF/00, which represents an FF data byte */
	  c = 0xFF;
 8010218:	23ff      	movs	r3, #255	; 0xff
 801021a:	461a      	mov	r2, r3
 801021c:	e003      	b.n	8010226 <jpeg_fill_bit_buffer+0x9e>
	   * bitread working state, not straight into permanent state.  But
	   * once we have hit a marker, we cannot need to suspend within the
	   * current MCU, because we will read no more bytes from the data
	   * source.  So it is OK to update permanent state right away.
	   */
	  cinfo->unread_marker = c;
 801021e:	697b      	ldr	r3, [r7, #20]
 8010220:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
	  /* See if we need to insert some fake zero bits. */
	  goto no_more_bytes;
 8010224:	e008      	b.n	8010238 <jpeg_fill_bit_buffer+0xb0>
	}
      }

      /* OK, load c into get_buffer */
      get_buffer = (get_buffer << 8) | c;
 8010226:	687b      	ldr	r3, [r7, #4]
 8010228:	021b      	lsls	r3, r3, #8
 801022a:	431a      	orrs	r2, r3
 801022c:	607a      	str	r2, [r7, #4]
      bits_left += 8;
 801022e:	3508      	adds	r5, #8
    while (bits_left < MIN_GET_BITS) {
 8010230:	2d18      	cmp	r5, #24
 8010232:	ddbd      	ble.n	80101b0 <jpeg_fill_bit_buffer+0x28>
 8010234:	e01f      	b.n	8010276 <jpeg_fill_bit_buffer+0xee>
    } /* end while */
  } else {
  no_more_bytes:
 8010236:	bf00      	nop
    /* We get here if we've read the marker that terminates the compressed
     * data segment.  There should be enough bits in the buffer register
     * to satisfy the request; if so, no problem.
     */
    if (nbits > bits_left) {
 8010238:	68bb      	ldr	r3, [r7, #8]
 801023a:	42ab      	cmp	r3, r5
 801023c:	dd1b      	ble.n	8010276 <jpeg_fill_bit_buffer+0xee>
      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
       * the data stream, so that we can produce some kind of image.
       * We use a nonvolatile flag to ensure that only one warning message
       * appears per data segment.
       */
      if (! ((huff_entropy_ptr) cinfo->entropy)->insufficient_data) {
 801023e:	697b      	ldr	r3, [r7, #20]
 8010240:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010246:	2b00      	cmp	r3, #0
 8010248:	d10f      	bne.n	801026a <jpeg_fill_bit_buffer+0xe2>
	WARNMS(cinfo, JWRN_HIT_MARKER);
 801024a:	697b      	ldr	r3, [r7, #20]
 801024c:	681b      	ldr	r3, [r3, #0]
 801024e:	2278      	movs	r2, #120	; 0x78
 8010250:	615a      	str	r2, [r3, #20]
 8010252:	697b      	ldr	r3, [r7, #20]
 8010254:	681b      	ldr	r3, [r3, #0]
 8010256:	685b      	ldr	r3, [r3, #4]
 8010258:	f04f 31ff 	mov.w	r1, #4294967295
 801025c:	6978      	ldr	r0, [r7, #20]
 801025e:	4798      	blx	r3
	((huff_entropy_ptr) cinfo->entropy)->insufficient_data = TRUE;
 8010260:	697b      	ldr	r3, [r7, #20]
 8010262:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010266:	2201      	movs	r2, #1
 8010268:	625a      	str	r2, [r3, #36]	; 0x24
      }
      /* Fill the buffer with zero bits */
      get_buffer <<= MIN_GET_BITS - bits_left;
 801026a:	f1c5 0319 	rsb	r3, r5, #25
 801026e:	687a      	ldr	r2, [r7, #4]
 8010270:	409a      	lsls	r2, r3
 8010272:	607a      	str	r2, [r7, #4]
      bits_left = MIN_GET_BITS;
 8010274:	2519      	movs	r5, #25
    }
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
 8010276:	68fb      	ldr	r3, [r7, #12]
 8010278:	601e      	str	r6, [r3, #0]
  state->bytes_in_buffer = bytes_in_buffer;
 801027a:	68fb      	ldr	r3, [r7, #12]
 801027c:	605c      	str	r4, [r3, #4]
  state->get_buffer = get_buffer;
 801027e:	68fb      	ldr	r3, [r7, #12]
 8010280:	687a      	ldr	r2, [r7, #4]
 8010282:	609a      	str	r2, [r3, #8]
  state->bits_left = bits_left;
 8010284:	68fb      	ldr	r3, [r7, #12]
 8010286:	60dd      	str	r5, [r3, #12]

  return TRUE;
 8010288:	2301      	movs	r3, #1
}
 801028a:	4618      	mov	r0, r3
 801028c:	371c      	adds	r7, #28
 801028e:	46bd      	mov	sp, r7
 8010290:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08010294 <jpeg_huff_decode>:

LOCAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
 8010294:	b5b0      	push	{r4, r5, r7, lr}
 8010296:	b082      	sub	sp, #8
 8010298:	af00      	add	r7, sp, #0
 801029a:	6078      	str	r0, [r7, #4]
 801029c:	603b      	str	r3, [r7, #0]
  register int l = min_bits;
 801029e:	69bc      	ldr	r4, [r7, #24]
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
 80102a0:	42a2      	cmp	r2, r4
 80102a2:	da0d      	bge.n	80102c0 <jpeg_huff_decode+0x2c>
 80102a4:	4623      	mov	r3, r4
 80102a6:	6878      	ldr	r0, [r7, #4]
 80102a8:	f7ff ff6e 	bl	8010188 <jpeg_fill_bit_buffer>
 80102ac:	4603      	mov	r3, r0
 80102ae:	2b00      	cmp	r3, #0
 80102b0:	d102      	bne.n	80102b8 <jpeg_huff_decode+0x24>
 80102b2:	f04f 33ff 	mov.w	r3, #4294967295
 80102b6:	e04b      	b.n	8010350 <jpeg_huff_decode+0xbc>
 80102b8:	687b      	ldr	r3, [r7, #4]
 80102ba:	6899      	ldr	r1, [r3, #8]
 80102bc:	687b      	ldr	r3, [r7, #4]
 80102be:	68da      	ldr	r2, [r3, #12]
  code = GET_BITS(l);
 80102c0:	1b12      	subs	r2, r2, r4
 80102c2:	fa41 f002 	asr.w	r0, r1, r2
 80102c6:	4b24      	ldr	r3, [pc, #144]	; (8010358 <jpeg_huff_decode+0xc4>)
 80102c8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80102cc:	ea00 0503 	and.w	r5, r0, r3

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
 80102d0:	e017      	b.n	8010302 <jpeg_huff_decode+0x6e>
    code <<= 1;
 80102d2:	006d      	lsls	r5, r5, #1
    CHECK_BIT_BUFFER(*state, 1, return -1);
 80102d4:	2a00      	cmp	r2, #0
 80102d6:	dc0d      	bgt.n	80102f4 <jpeg_huff_decode+0x60>
 80102d8:	2301      	movs	r3, #1
 80102da:	6878      	ldr	r0, [r7, #4]
 80102dc:	f7ff ff54 	bl	8010188 <jpeg_fill_bit_buffer>
 80102e0:	4603      	mov	r3, r0
 80102e2:	2b00      	cmp	r3, #0
 80102e4:	d102      	bne.n	80102ec <jpeg_huff_decode+0x58>
 80102e6:	f04f 33ff 	mov.w	r3, #4294967295
 80102ea:	e031      	b.n	8010350 <jpeg_huff_decode+0xbc>
 80102ec:	687b      	ldr	r3, [r7, #4]
 80102ee:	6899      	ldr	r1, [r3, #8]
 80102f0:	687b      	ldr	r3, [r7, #4]
 80102f2:	68da      	ldr	r2, [r3, #12]
    code |= GET_BITS(1);
 80102f4:	3a01      	subs	r2, #1
 80102f6:	fa41 f302 	asr.w	r3, r1, r2
 80102fa:	2001      	movs	r0, #1
 80102fc:	4003      	ands	r3, r0
 80102fe:	431d      	orrs	r5, r3
    l++;
 8010300:	3401      	adds	r4, #1
  while (code > htbl->maxcode[l]) {
 8010302:	683b      	ldr	r3, [r7, #0]
 8010304:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8010308:	429d      	cmp	r5, r3
 801030a:	dce2      	bgt.n	80102d2 <jpeg_huff_decode+0x3e>
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
 801030c:	687b      	ldr	r3, [r7, #4]
 801030e:	6099      	str	r1, [r3, #8]
  state->bits_left = bits_left;
 8010310:	687b      	ldr	r3, [r7, #4]
 8010312:	60da      	str	r2, [r3, #12]

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
 8010314:	2c10      	cmp	r4, #16
 8010316:	dd10      	ble.n	801033a <jpeg_huff_decode+0xa6>
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
 8010318:	687b      	ldr	r3, [r7, #4]
 801031a:	691b      	ldr	r3, [r3, #16]
 801031c:	681b      	ldr	r3, [r3, #0]
 801031e:	2279      	movs	r2, #121	; 0x79
 8010320:	615a      	str	r2, [r3, #20]
 8010322:	687b      	ldr	r3, [r7, #4]
 8010324:	691b      	ldr	r3, [r3, #16]
 8010326:	681b      	ldr	r3, [r3, #0]
 8010328:	685b      	ldr	r3, [r3, #4]
 801032a:	687a      	ldr	r2, [r7, #4]
 801032c:	6912      	ldr	r2, [r2, #16]
 801032e:	f04f 31ff 	mov.w	r1, #4294967295
 8010332:	4610      	mov	r0, r2
 8010334:	4798      	blx	r3
    return 0;			/* fake a zero as the safest result */
 8010336:	2300      	movs	r3, #0
 8010338:	e00a      	b.n	8010350 <jpeg_huff_decode+0xbc>
  }

  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
 801033a:	683b      	ldr	r3, [r7, #0]
 801033c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8010340:	683b      	ldr	r3, [r7, #0]
 8010342:	f104 0112 	add.w	r1, r4, #18
 8010346:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801034a:	442b      	add	r3, r5
 801034c:	4413      	add	r3, r2
 801034e:	7c5b      	ldrb	r3, [r3, #17]
}
 8010350:	4618      	mov	r0, r3
 8010352:	3708      	adds	r7, #8
 8010354:	46bd      	mov	sp, r7
 8010356:	bdb0      	pop	{r4, r5, r7, pc}
 8010358:	0802a90c 	.word	0x0802a90c

0801035c <process_restart>:
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
 801035c:	b580      	push	{r7, lr}
 801035e:	b084      	sub	sp, #16
 8010360:	af00      	add	r7, sp, #0
 8010362:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8010364:	687b      	ldr	r3, [r7, #4]
 8010366:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 801036a:	60bb      	str	r3, [r7, #8]
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
 801036c:	687b      	ldr	r3, [r7, #4]
 801036e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8010372:	699a      	ldr	r2, [r3, #24]
 8010374:	68bb      	ldr	r3, [r7, #8]
 8010376:	68db      	ldr	r3, [r3, #12]
 8010378:	2b00      	cmp	r3, #0
 801037a:	da00      	bge.n	801037e <process_restart+0x22>
 801037c:	3307      	adds	r3, #7
 801037e:	10db      	asrs	r3, r3, #3
 8010380:	4619      	mov	r1, r3
 8010382:	687b      	ldr	r3, [r7, #4]
 8010384:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8010388:	440a      	add	r2, r1
 801038a:	619a      	str	r2, [r3, #24]
  entropy->bitstate.bits_left = 0;
 801038c:	68bb      	ldr	r3, [r7, #8]
 801038e:	2200      	movs	r2, #0
 8010390:	60da      	str	r2, [r3, #12]

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
 8010392:	687b      	ldr	r3, [r7, #4]
 8010394:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8010398:	689b      	ldr	r3, [r3, #8]
 801039a:	6878      	ldr	r0, [r7, #4]
 801039c:	4798      	blx	r3
 801039e:	4603      	mov	r3, r0
 80103a0:	2b00      	cmp	r3, #0
 80103a2:	d101      	bne.n	80103a8 <process_restart+0x4c>
    return FALSE;
 80103a4:	2300      	movs	r3, #0
 80103a6:	e023      	b.n	80103f0 <process_restart+0x94>

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 80103a8:	2300      	movs	r3, #0
 80103aa:	60fb      	str	r3, [r7, #12]
 80103ac:	e009      	b.n	80103c2 <process_restart+0x66>
    entropy->saved.last_dc_val[ci] = 0;
 80103ae:	68ba      	ldr	r2, [r7, #8]
 80103b0:	68fb      	ldr	r3, [r7, #12]
 80103b2:	3304      	adds	r3, #4
 80103b4:	009b      	lsls	r3, r3, #2
 80103b6:	4413      	add	r3, r2
 80103b8:	2200      	movs	r2, #0
 80103ba:	605a      	str	r2, [r3, #4]
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
 80103bc:	68fb      	ldr	r3, [r7, #12]
 80103be:	3301      	adds	r3, #1
 80103c0:	60fb      	str	r3, [r7, #12]
 80103c2:	687b      	ldr	r3, [r7, #4]
 80103c4:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80103c8:	68fa      	ldr	r2, [r7, #12]
 80103ca:	429a      	cmp	r2, r3
 80103cc:	dbef      	blt.n	80103ae <process_restart+0x52>
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;
 80103ce:	68bb      	ldr	r3, [r7, #8]
 80103d0:	2200      	movs	r2, #0
 80103d2:	611a      	str	r2, [r3, #16]

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 80103d4:	687b      	ldr	r3, [r7, #4]
 80103d6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80103da:	68bb      	ldr	r3, [r7, #8]
 80103dc:	629a      	str	r2, [r3, #40]	; 0x28
  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
 80103de:	687b      	ldr	r3, [r7, #4]
 80103e0:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80103e4:	2b00      	cmp	r3, #0
 80103e6:	d102      	bne.n	80103ee <process_restart+0x92>
    entropy->insufficient_data = FALSE;
 80103e8:	68bb      	ldr	r3, [r7, #8]
 80103ea:	2200      	movs	r2, #0
 80103ec:	625a      	str	r2, [r3, #36]	; 0x24

  return TRUE;
 80103ee:	2301      	movs	r3, #1
}
 80103f0:	4618      	mov	r0, r3
 80103f2:	3710      	adds	r7, #16
 80103f4:	46bd      	mov	sp, r7
 80103f6:	bd80      	pop	{r7, pc}

080103f8 <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 80103f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80103fc:	b096      	sub	sp, #88	; 0x58
 80103fe:	af02      	add	r7, sp, #8
 8010400:	6078      	str	r0, [r7, #4]
 8010402:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8010404:	687b      	ldr	r3, [r7, #4]
 8010406:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 801040a:	64bb      	str	r3, [r7, #72]	; 0x48
  int Al = cinfo->Al;
 801040c:	687b      	ldr	r3, [r7, #4]
 801040e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8010412:	647b      	str	r3, [r7, #68]	; 0x44
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8010414:	687b      	ldr	r3, [r7, #4]
 8010416:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801041a:	2b00      	cmp	r3, #0
 801041c:	d00b      	beq.n	8010436 <decode_mcu_DC_first+0x3e>
    if (entropy->restarts_to_go == 0)
 801041e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010420:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010422:	2b00      	cmp	r3, #0
 8010424:	d107      	bne.n	8010436 <decode_mcu_DC_first+0x3e>
      if (! process_restart(cinfo))
 8010426:	6878      	ldr	r0, [r7, #4]
 8010428:	f7ff ff98 	bl	801035c <process_restart>
 801042c:	4603      	mov	r3, r0
 801042e:	2b00      	cmp	r3, #0
 8010430:	d101      	bne.n	8010436 <decode_mcu_DC_first+0x3e>
	return FALSE;
 8010432:	2300      	movs	r3, #0
 8010434:	e0d6      	b.n	80105e4 <decode_mcu_DC_first+0x1ec>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8010436:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010438:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801043a:	2b00      	cmp	r3, #0
 801043c:	f040 80cc 	bne.w	80105d8 <decode_mcu_DC_first+0x1e0>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8010440:	687b      	ldr	r3, [r7, #4]
 8010442:	633b      	str	r3, [r7, #48]	; 0x30
 8010444:	687b      	ldr	r3, [r7, #4]
 8010446:	699b      	ldr	r3, [r3, #24]
 8010448:	681b      	ldr	r3, [r3, #0]
 801044a:	623b      	str	r3, [r7, #32]
 801044c:	687b      	ldr	r3, [r7, #4]
 801044e:	699b      	ldr	r3, [r3, #24]
 8010450:	685b      	ldr	r3, [r3, #4]
 8010452:	627b      	str	r3, [r7, #36]	; 0x24
 8010454:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010456:	689e      	ldr	r6, [r3, #8]
 8010458:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801045a:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 801045c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801045e:	f107 050c 	add.w	r5, r7, #12
 8010462:	f103 0c10 	add.w	ip, r3, #16
 8010466:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801046a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801046c:	f8dc 3000 	ldr.w	r3, [ip]
 8010470:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8010472:	2300      	movs	r3, #0
 8010474:	64fb      	str	r3, [r7, #76]	; 0x4c
 8010476:	e093      	b.n	80105a0 <decode_mcu_DC_first+0x1a8>
      block = MCU_data[blkn];
 8010478:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801047a:	009b      	lsls	r3, r3, #2
 801047c:	683a      	ldr	r2, [r7, #0]
 801047e:	4413      	add	r3, r2
 8010480:	681b      	ldr	r3, [r3, #0]
 8010482:	643b      	str	r3, [r7, #64]	; 0x40
      ci = cinfo->MCU_membership[blkn];
 8010484:	687b      	ldr	r3, [r7, #4]
 8010486:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010488:	325c      	adds	r2, #92	; 0x5c
 801048a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801048e:	63fb      	str	r3, [r7, #60]	; 0x3c
      compptr = cinfo->cur_comp_info[ci];
 8010490:	687a      	ldr	r2, [r7, #4]
 8010492:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010494:	3354      	adds	r3, #84	; 0x54
 8010496:	009b      	lsls	r3, r3, #2
 8010498:	4413      	add	r3, r2
 801049a:	685b      	ldr	r3, [r3, #4]
 801049c:	63bb      	str	r3, [r7, #56]	; 0x38
      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
 801049e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104a0:	695b      	ldr	r3, [r3, #20]
 80104a2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80104a4:	330a      	adds	r3, #10
 80104a6:	009b      	lsls	r3, r3, #2
 80104a8:	4413      	add	r3, r2
 80104aa:	685b      	ldr	r3, [r3, #4]
 80104ac:	637b      	str	r3, [r7, #52]	; 0x34

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 80104ae:	2c07      	cmp	r4, #7
 80104b0:	dc11      	bgt.n	80104d6 <decode_mcu_DC_first+0xde>
 80104b2:	f107 0020 	add.w	r0, r7, #32
 80104b6:	2300      	movs	r3, #0
 80104b8:	4622      	mov	r2, r4
 80104ba:	4631      	mov	r1, r6
 80104bc:	f7ff fe64 	bl	8010188 <jpeg_fill_bit_buffer>
 80104c0:	4603      	mov	r3, r0
 80104c2:	2b00      	cmp	r3, #0
 80104c4:	d101      	bne.n	80104ca <decode_mcu_DC_first+0xd2>
 80104c6:	2300      	movs	r3, #0
 80104c8:	e08c      	b.n	80105e4 <decode_mcu_DC_first+0x1ec>
 80104ca:	6abe      	ldr	r6, [r7, #40]	; 0x28
 80104cc:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 80104ce:	2c07      	cmp	r4, #7
 80104d0:	dc01      	bgt.n	80104d6 <decode_mcu_DC_first+0xde>
 80104d2:	2501      	movs	r5, #1
 80104d4:	e015      	b.n	8010502 <decode_mcu_DC_first+0x10a>
 80104d6:	f1a4 0308 	sub.w	r3, r4, #8
 80104da:	fa46 f303 	asr.w	r3, r6, r3
 80104de:	22ff      	movs	r2, #255	; 0xff
 80104e0:	ea03 0802 	and.w	r8, r3, r2
 80104e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80104e6:	f108 0224 	add.w	r2, r8, #36	; 0x24
 80104ea:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80104ee:	2d00      	cmp	r5, #0
 80104f0:	d006      	beq.n	8010500 <decode_mcu_DC_first+0x108>
 80104f2:	1b64      	subs	r4, r4, r5
 80104f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80104f6:	4443      	add	r3, r8
 80104f8:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 80104fc:	461d      	mov	r5, r3
 80104fe:	e00f      	b.n	8010520 <decode_mcu_DC_first+0x128>
 8010500:	2509      	movs	r5, #9
 8010502:	f107 0020 	add.w	r0, r7, #32
 8010506:	9500      	str	r5, [sp, #0]
 8010508:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801050a:	4622      	mov	r2, r4
 801050c:	4631      	mov	r1, r6
 801050e:	f7ff fec1 	bl	8010294 <jpeg_huff_decode>
 8010512:	4605      	mov	r5, r0
 8010514:	2d00      	cmp	r5, #0
 8010516:	da01      	bge.n	801051c <decode_mcu_DC_first+0x124>
 8010518:	2300      	movs	r3, #0
 801051a:	e063      	b.n	80105e4 <decode_mcu_DC_first+0x1ec>
 801051c:	6abe      	ldr	r6, [r7, #40]	; 0x28
 801051e:	6afc      	ldr	r4, [r7, #44]	; 0x2c
      if (s) {
 8010520:	2d00      	cmp	r5, #0
 8010522:	d025      	beq.n	8010570 <decode_mcu_DC_first+0x178>
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8010524:	42ac      	cmp	r4, r5
 8010526:	da0d      	bge.n	8010544 <decode_mcu_DC_first+0x14c>
 8010528:	f107 0020 	add.w	r0, r7, #32
 801052c:	462b      	mov	r3, r5
 801052e:	4622      	mov	r2, r4
 8010530:	4631      	mov	r1, r6
 8010532:	f7ff fe29 	bl	8010188 <jpeg_fill_bit_buffer>
 8010536:	4603      	mov	r3, r0
 8010538:	2b00      	cmp	r3, #0
 801053a:	d101      	bne.n	8010540 <decode_mcu_DC_first+0x148>
 801053c:	2300      	movs	r3, #0
 801053e:	e051      	b.n	80105e4 <decode_mcu_DC_first+0x1ec>
 8010540:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8010542:	6afc      	ldr	r4, [r7, #44]	; 0x2c
	r = GET_BITS(s);
 8010544:	1b64      	subs	r4, r4, r5
 8010546:	fa46 f204 	asr.w	r2, r6, r4
 801054a:	4b29      	ldr	r3, [pc, #164]	; (80105f0 <decode_mcu_DC_first+0x1f8>)
 801054c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8010550:	ea02 0803 	and.w	r8, r2, r3
	s = HUFF_EXTEND(r, s);
 8010554:	1e6b      	subs	r3, r5, #1
 8010556:	4a26      	ldr	r2, [pc, #152]	; (80105f0 <decode_mcu_DC_first+0x1f8>)
 8010558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801055c:	4598      	cmp	r8, r3
 801055e:	dc05      	bgt.n	801056c <decode_mcu_DC_first+0x174>
 8010560:	4b23      	ldr	r3, [pc, #140]	; (80105f0 <decode_mcu_DC_first+0x1f8>)
 8010562:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8010566:	eba8 0303 	sub.w	r3, r8, r3
 801056a:	e000      	b.n	801056e <decode_mcu_DC_first+0x176>
 801056c:	4643      	mov	r3, r8
 801056e:	461d      	mov	r5, r3
      }

      /* Convert DC difference to actual value, update last_dc_val */
      s += state.last_dc_val[ci];
 8010570:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010572:	009b      	lsls	r3, r3, #2
 8010574:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8010578:	4413      	add	r3, r2
 801057a:	f853 3c40 	ldr.w	r3, [r3, #-64]
 801057e:	441d      	add	r5, r3
      state.last_dc_val[ci] = s;
 8010580:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010582:	009b      	lsls	r3, r3, #2
 8010584:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8010588:	4413      	add	r3, r2
 801058a:	f843 5c40 	str.w	r5, [r3, #-64]
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
 801058e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010590:	fa05 f303 	lsl.w	r3, r5, r3
 8010594:	b21a      	sxth	r2, r3
 8010596:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010598:	801a      	strh	r2, [r3, #0]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801059a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801059c:	3301      	adds	r3, #1
 801059e:	64fb      	str	r3, [r7, #76]	; 0x4c
 80105a0:	687b      	ldr	r3, [r7, #4]
 80105a2:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 80105a6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80105a8:	429a      	cmp	r2, r3
 80105aa:	f6ff af65 	blt.w	8010478 <decode_mcu_DC_first+0x80>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 80105ae:	687b      	ldr	r3, [r7, #4]
 80105b0:	699b      	ldr	r3, [r3, #24]
 80105b2:	6a3a      	ldr	r2, [r7, #32]
 80105b4:	601a      	str	r2, [r3, #0]
 80105b6:	687b      	ldr	r3, [r7, #4]
 80105b8:	699b      	ldr	r3, [r3, #24]
 80105ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80105bc:	605a      	str	r2, [r3, #4]
 80105be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105c0:	609e      	str	r6, [r3, #8]
 80105c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105c4:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 80105c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105c8:	f103 0410 	add.w	r4, r3, #16
 80105cc:	f107 050c 	add.w	r5, r7, #12
 80105d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80105d2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80105d4:	682b      	ldr	r3, [r5, #0]
 80105d6:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 80105d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80105dc:	1e5a      	subs	r2, r3, #1
 80105de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80105e0:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 80105e2:	2301      	movs	r3, #1
}
 80105e4:	4618      	mov	r0, r3
 80105e6:	3750      	adds	r7, #80	; 0x50
 80105e8:	46bd      	mov	sp, r7
 80105ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80105ee:	bf00      	nop
 80105f0:	0802a90c 	.word	0x0802a90c

080105f4 <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 80105f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80105f6:	b093      	sub	sp, #76	; 0x4c
 80105f8:	af02      	add	r7, sp, #8
 80105fa:	60f8      	str	r0, [r7, #12]
 80105fc:	60b9      	str	r1, [r7, #8]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 80105fe:	68fb      	ldr	r3, [r7, #12]
 8010600:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010604:	63bb      	str	r3, [r7, #56]	; 0x38
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8010606:	68fb      	ldr	r3, [r7, #12]
 8010608:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801060c:	2b00      	cmp	r3, #0
 801060e:	d00b      	beq.n	8010628 <decode_mcu_AC_first+0x34>
    if (entropy->restarts_to_go == 0)
 8010610:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010612:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010614:	2b00      	cmp	r3, #0
 8010616:	d107      	bne.n	8010628 <decode_mcu_AC_first+0x34>
      if (! process_restart(cinfo))
 8010618:	68f8      	ldr	r0, [r7, #12]
 801061a:	f7ff fe9f 	bl	801035c <process_restart>
 801061e:	4603      	mov	r3, r0
 8010620:	2b00      	cmp	r3, #0
 8010622:	d101      	bne.n	8010628 <decode_mcu_AC_first+0x34>
	return FALSE;
 8010624:	2300      	movs	r3, #0
 8010626:	e0f7      	b.n	8010818 <decode_mcu_AC_first+0x224>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8010628:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801062a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801062c:	2b00      	cmp	r3, #0
 801062e:	f040 80ed 	bne.w	801080c <decode_mcu_AC_first+0x218>

    Se = cinfo->Se;
 8010632:	68fb      	ldr	r3, [r7, #12]
 8010634:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 8010638:	637b      	str	r3, [r7, #52]	; 0x34
    Al = cinfo->Al;
 801063a:	68fb      	ldr	r3, [r7, #12]
 801063c:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8010640:	633b      	str	r3, [r7, #48]	; 0x30
    natural_order = cinfo->natural_order;
 8010642:	68fb      	ldr	r3, [r7, #12]
 8010644:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 8010648:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Load up working state.
     * We can avoid loading/saving bitread state if in an EOB run.
     */
    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
 801064a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801064c:	691b      	ldr	r3, [r3, #16]
 801064e:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* There is always only one block per MCU */

    if (EOBRUN > 0)		/* if it's a band of zeroes... */
 8010650:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010652:	2b00      	cmp	r3, #0
 8010654:	d003      	beq.n	801065e <decode_mcu_AC_first+0x6a>
      EOBRUN--;			/* ...process it now (we do nothing) */
 8010656:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010658:	3b01      	subs	r3, #1
 801065a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801065c:	e0d3      	b.n	8010806 <decode_mcu_AC_first+0x212>
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 801065e:	68fb      	ldr	r3, [r7, #12]
 8010660:	623b      	str	r3, [r7, #32]
 8010662:	68fb      	ldr	r3, [r7, #12]
 8010664:	699b      	ldr	r3, [r3, #24]
 8010666:	681b      	ldr	r3, [r3, #0]
 8010668:	613b      	str	r3, [r7, #16]
 801066a:	68fb      	ldr	r3, [r7, #12]
 801066c:	699b      	ldr	r3, [r3, #24]
 801066e:	685b      	ldr	r3, [r3, #4]
 8010670:	617b      	str	r3, [r7, #20]
 8010672:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010674:	689b      	ldr	r3, [r3, #8]
 8010676:	607b      	str	r3, [r7, #4]
 8010678:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801067a:	68dc      	ldr	r4, [r3, #12]
      block = MCU_data[0];
 801067c:	68bb      	ldr	r3, [r7, #8]
 801067e:	681b      	ldr	r3, [r3, #0]
 8010680:	62bb      	str	r3, [r7, #40]	; 0x28
      tbl = entropy->ac_derived_tbl;
 8010682:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010684:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010686:	627b      	str	r3, [r7, #36]	; 0x24

      for (k = cinfo->Ss; k <= Se; k++) {
 8010688:	68fb      	ldr	r3, [r7, #12]
 801068a:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 801068e:	603b      	str	r3, [r7, #0]
 8010690:	e0a7      	b.n	80107e2 <decode_mcu_AC_first+0x1ee>
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 8010692:	2c07      	cmp	r4, #7
 8010694:	dc12      	bgt.n	80106bc <decode_mcu_AC_first+0xc8>
 8010696:	f107 0010 	add.w	r0, r7, #16
 801069a:	2300      	movs	r3, #0
 801069c:	4622      	mov	r2, r4
 801069e:	6879      	ldr	r1, [r7, #4]
 80106a0:	f7ff fd72 	bl	8010188 <jpeg_fill_bit_buffer>
 80106a4:	4603      	mov	r3, r0
 80106a6:	2b00      	cmp	r3, #0
 80106a8:	d101      	bne.n	80106ae <decode_mcu_AC_first+0xba>
 80106aa:	2300      	movs	r3, #0
 80106ac:	e0b4      	b.n	8010818 <decode_mcu_AC_first+0x224>
 80106ae:	69bb      	ldr	r3, [r7, #24]
 80106b0:	607b      	str	r3, [r7, #4]
 80106b2:	69fc      	ldr	r4, [r7, #28]
 80106b4:	2c07      	cmp	r4, #7
 80106b6:	dc01      	bgt.n	80106bc <decode_mcu_AC_first+0xc8>
 80106b8:	2501      	movs	r5, #1
 80106ba:	e016      	b.n	80106ea <decode_mcu_AC_first+0xf6>
 80106bc:	f1a4 0308 	sub.w	r3, r4, #8
 80106c0:	687a      	ldr	r2, [r7, #4]
 80106c2:	fa42 f303 	asr.w	r3, r2, r3
 80106c6:	22ff      	movs	r2, #255	; 0xff
 80106c8:	ea03 0602 	and.w	r6, r3, r2
 80106cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106ce:	f106 0224 	add.w	r2, r6, #36	; 0x24
 80106d2:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80106d6:	2d00      	cmp	r5, #0
 80106d8:	d006      	beq.n	80106e8 <decode_mcu_AC_first+0xf4>
 80106da:	1b64      	subs	r4, r4, r5
 80106dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106de:	4433      	add	r3, r6
 80106e0:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 80106e4:	461e      	mov	r6, r3
 80106e6:	e010      	b.n	801070a <decode_mcu_AC_first+0x116>
 80106e8:	2509      	movs	r5, #9
 80106ea:	f107 0010 	add.w	r0, r7, #16
 80106ee:	9500      	str	r5, [sp, #0]
 80106f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106f2:	4622      	mov	r2, r4
 80106f4:	6879      	ldr	r1, [r7, #4]
 80106f6:	f7ff fdcd 	bl	8010294 <jpeg_huff_decode>
 80106fa:	4606      	mov	r6, r0
 80106fc:	2e00      	cmp	r6, #0
 80106fe:	da01      	bge.n	8010704 <decode_mcu_AC_first+0x110>
 8010700:	2300      	movs	r3, #0
 8010702:	e089      	b.n	8010818 <decode_mcu_AC_first+0x224>
 8010704:	69bb      	ldr	r3, [r7, #24]
 8010706:	607b      	str	r3, [r7, #4]
 8010708:	69fc      	ldr	r4, [r7, #28]
	r = s >> 4;
 801070a:	1135      	asrs	r5, r6, #4
	s &= 15;
 801070c:	f006 060f 	and.w	r6, r6, #15
	if (s) {
 8010710:	2e00      	cmp	r6, #0
 8010712:	d036      	beq.n	8010782 <decode_mcu_AC_first+0x18e>
	  k += r;
 8010714:	683b      	ldr	r3, [r7, #0]
 8010716:	442b      	add	r3, r5
 8010718:	603b      	str	r3, [r7, #0]
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801071a:	42b4      	cmp	r4, r6
 801071c:	da0e      	bge.n	801073c <decode_mcu_AC_first+0x148>
 801071e:	f107 0010 	add.w	r0, r7, #16
 8010722:	4633      	mov	r3, r6
 8010724:	4622      	mov	r2, r4
 8010726:	6879      	ldr	r1, [r7, #4]
 8010728:	f7ff fd2e 	bl	8010188 <jpeg_fill_bit_buffer>
 801072c:	4603      	mov	r3, r0
 801072e:	2b00      	cmp	r3, #0
 8010730:	d101      	bne.n	8010736 <decode_mcu_AC_first+0x142>
 8010732:	2300      	movs	r3, #0
 8010734:	e070      	b.n	8010818 <decode_mcu_AC_first+0x224>
 8010736:	69bb      	ldr	r3, [r7, #24]
 8010738:	607b      	str	r3, [r7, #4]
 801073a:	69fc      	ldr	r4, [r7, #28]
	  r = GET_BITS(s);
 801073c:	1ba4      	subs	r4, r4, r6
 801073e:	687b      	ldr	r3, [r7, #4]
 8010740:	fa43 f204 	asr.w	r2, r3, r4
 8010744:	4b36      	ldr	r3, [pc, #216]	; (8010820 <decode_mcu_AC_first+0x22c>)
 8010746:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 801074a:	ea02 0503 	and.w	r5, r2, r3
	  s = HUFF_EXTEND(r, s);
 801074e:	1e73      	subs	r3, r6, #1
 8010750:	4a33      	ldr	r2, [pc, #204]	; (8010820 <decode_mcu_AC_first+0x22c>)
 8010752:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010756:	429d      	cmp	r5, r3
 8010758:	dc04      	bgt.n	8010764 <decode_mcu_AC_first+0x170>
 801075a:	4b31      	ldr	r3, [pc, #196]	; (8010820 <decode_mcu_AC_first+0x22c>)
 801075c:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8010760:	1aeb      	subs	r3, r5, r3
 8010762:	e000      	b.n	8010766 <decode_mcu_AC_first+0x172>
 8010764:	462b      	mov	r3, r5
 8010766:	461e      	mov	r6, r3
	  /* Scale and output coefficient in natural (dezigzagged) order */
	  (*block)[natural_order[k]] = (JCOEF) (s << Al);
 8010768:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801076a:	fa06 f103 	lsl.w	r1, r6, r3
 801076e:	683b      	ldr	r3, [r7, #0]
 8010770:	009b      	lsls	r3, r3, #2
 8010772:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010774:	4413      	add	r3, r2
 8010776:	681a      	ldr	r2, [r3, #0]
 8010778:	b209      	sxth	r1, r1
 801077a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801077c:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 8010780:	e02c      	b.n	80107dc <decode_mcu_AC_first+0x1e8>
	} else {
	  if (r == 15) {	/* ZRL */
 8010782:	2d0f      	cmp	r5, #15
 8010784:	d103      	bne.n	801078e <decode_mcu_AC_first+0x19a>
	    k += 15;		/* skip 15 zeroes in band */
 8010786:	683b      	ldr	r3, [r7, #0]
 8010788:	330f      	adds	r3, #15
 801078a:	603b      	str	r3, [r7, #0]
 801078c:	e026      	b.n	80107dc <decode_mcu_AC_first+0x1e8>
	  } else {		/* EOBr, run length is 2^r + appended bits */
	    EOBRUN = 1 << r;
 801078e:	2301      	movs	r3, #1
 8010790:	40ab      	lsls	r3, r5
 8010792:	63fb      	str	r3, [r7, #60]	; 0x3c
	    if (r) {		/* EOBr, r > 0 */
 8010794:	2d00      	cmp	r5, #0
 8010796:	d01d      	beq.n	80107d4 <decode_mcu_AC_first+0x1e0>
	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
 8010798:	42ac      	cmp	r4, r5
 801079a:	da0e      	bge.n	80107ba <decode_mcu_AC_first+0x1c6>
 801079c:	f107 0010 	add.w	r0, r7, #16
 80107a0:	462b      	mov	r3, r5
 80107a2:	4622      	mov	r2, r4
 80107a4:	6879      	ldr	r1, [r7, #4]
 80107a6:	f7ff fcef 	bl	8010188 <jpeg_fill_bit_buffer>
 80107aa:	4603      	mov	r3, r0
 80107ac:	2b00      	cmp	r3, #0
 80107ae:	d101      	bne.n	80107b4 <decode_mcu_AC_first+0x1c0>
 80107b0:	2300      	movs	r3, #0
 80107b2:	e031      	b.n	8010818 <decode_mcu_AC_first+0x224>
 80107b4:	69bb      	ldr	r3, [r7, #24]
 80107b6:	607b      	str	r3, [r7, #4]
 80107b8:	69fc      	ldr	r4, [r7, #28]
	      r = GET_BITS(r);
 80107ba:	1b64      	subs	r4, r4, r5
 80107bc:	687b      	ldr	r3, [r7, #4]
 80107be:	fa43 f204 	asr.w	r2, r3, r4
 80107c2:	4b17      	ldr	r3, [pc, #92]	; (8010820 <decode_mcu_AC_first+0x22c>)
 80107c4:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80107c8:	ea02 0503 	and.w	r5, r2, r3
	      EOBRUN += r;
 80107cc:	462a      	mov	r2, r5
 80107ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80107d0:	4413      	add	r3, r2
 80107d2:	63fb      	str	r3, [r7, #60]	; 0x3c
	    }
	    EOBRUN--;		/* this band is processed at this moment */
 80107d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80107d6:	3b01      	subs	r3, #1
 80107d8:	63fb      	str	r3, [r7, #60]	; 0x3c
	    break;		/* force end-of-band */
 80107da:	e007      	b.n	80107ec <decode_mcu_AC_first+0x1f8>
      for (k = cinfo->Ss; k <= Se; k++) {
 80107dc:	683b      	ldr	r3, [r7, #0]
 80107de:	3301      	adds	r3, #1
 80107e0:	603b      	str	r3, [r7, #0]
 80107e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80107e4:	683a      	ldr	r2, [r7, #0]
 80107e6:	429a      	cmp	r2, r3
 80107e8:	f77f af53 	ble.w	8010692 <decode_mcu_AC_first+0x9e>
	  }
	}
      }

      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 80107ec:	68fb      	ldr	r3, [r7, #12]
 80107ee:	699b      	ldr	r3, [r3, #24]
 80107f0:	693a      	ldr	r2, [r7, #16]
 80107f2:	601a      	str	r2, [r3, #0]
 80107f4:	68fb      	ldr	r3, [r7, #12]
 80107f6:	699b      	ldr	r3, [r3, #24]
 80107f8:	697a      	ldr	r2, [r7, #20]
 80107fa:	605a      	str	r2, [r3, #4]
 80107fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80107fe:	687a      	ldr	r2, [r7, #4]
 8010800:	609a      	str	r2, [r3, #8]
 8010802:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010804:	60dc      	str	r4, [r3, #12]
    }

    /* Completed MCU, so update state */
    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
 8010806:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010808:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801080a:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 801080c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801080e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010810:	1e5a      	subs	r2, r3, #1
 8010812:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010814:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 8010816:	2301      	movs	r3, #1
}
 8010818:	4618      	mov	r0, r3
 801081a:	3744      	adds	r7, #68	; 0x44
 801081c:	46bd      	mov	sp, r7
 801081e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010820:	0802a90c 	.word	0x0802a90c

08010824 <decode_mcu_DC_refine>:
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8010824:	b5b0      	push	{r4, r5, r7, lr}
 8010826:	b08c      	sub	sp, #48	; 0x30
 8010828:	af00      	add	r7, sp, #0
 801082a:	6078      	str	r0, [r7, #4]
 801082c:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 801082e:	687b      	ldr	r3, [r7, #4]
 8010830:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010834:	62bb      	str	r3, [r7, #40]	; 0x28
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 8010836:	687b      	ldr	r3, [r7, #4]
 8010838:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 801083c:	2201      	movs	r2, #1
 801083e:	fa02 f303 	lsl.w	r3, r2, r3
 8010842:	627b      	str	r3, [r7, #36]	; 0x24
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8010844:	687b      	ldr	r3, [r7, #4]
 8010846:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801084a:	2b00      	cmp	r3, #0
 801084c:	d00b      	beq.n	8010866 <decode_mcu_DC_refine+0x42>
    if (entropy->restarts_to_go == 0)
 801084e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010850:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010852:	2b00      	cmp	r3, #0
 8010854:	d107      	bne.n	8010866 <decode_mcu_DC_refine+0x42>
      if (! process_restart(cinfo))
 8010856:	6878      	ldr	r0, [r7, #4]
 8010858:	f7ff fd80 	bl	801035c <process_restart>
 801085c:	4603      	mov	r3, r0
 801085e:	2b00      	cmp	r3, #0
 8010860:	d101      	bne.n	8010866 <decode_mcu_DC_refine+0x42>
	return FALSE;
 8010862:	2300      	movs	r3, #0
 8010864:	e051      	b.n	801090a <decode_mcu_DC_refine+0xe6>
  /* Not worth the cycles to check insufficient_data here,
   * since we will not change the data anyway if we read zeroes.
   */

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8010866:	687b      	ldr	r3, [r7, #4]
 8010868:	61fb      	str	r3, [r7, #28]
 801086a:	687b      	ldr	r3, [r7, #4]
 801086c:	699b      	ldr	r3, [r3, #24]
 801086e:	681b      	ldr	r3, [r3, #0]
 8010870:	60fb      	str	r3, [r7, #12]
 8010872:	687b      	ldr	r3, [r7, #4]
 8010874:	699b      	ldr	r3, [r3, #24]
 8010876:	685b      	ldr	r3, [r3, #4]
 8010878:	613b      	str	r3, [r7, #16]
 801087a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801087c:	689d      	ldr	r5, [r3, #8]
 801087e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010880:	68dc      	ldr	r4, [r3, #12]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8010882:	2300      	movs	r3, #0
 8010884:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010886:	e028      	b.n	80108da <decode_mcu_DC_refine+0xb6>
    block = MCU_data[blkn];
 8010888:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801088a:	009b      	lsls	r3, r3, #2
 801088c:	683a      	ldr	r2, [r7, #0]
 801088e:	4413      	add	r3, r2
 8010890:	681b      	ldr	r3, [r3, #0]
 8010892:	623b      	str	r3, [r7, #32]

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 8010894:	2c00      	cmp	r4, #0
 8010896:	dc0d      	bgt.n	80108b4 <decode_mcu_DC_refine+0x90>
 8010898:	f107 000c 	add.w	r0, r7, #12
 801089c:	2301      	movs	r3, #1
 801089e:	4622      	mov	r2, r4
 80108a0:	4629      	mov	r1, r5
 80108a2:	f7ff fc71 	bl	8010188 <jpeg_fill_bit_buffer>
 80108a6:	4603      	mov	r3, r0
 80108a8:	2b00      	cmp	r3, #0
 80108aa:	d101      	bne.n	80108b0 <decode_mcu_DC_refine+0x8c>
 80108ac:	2300      	movs	r3, #0
 80108ae:	e02c      	b.n	801090a <decode_mcu_DC_refine+0xe6>
 80108b0:	697d      	ldr	r5, [r7, #20]
 80108b2:	69bc      	ldr	r4, [r7, #24]
    if (GET_BITS(1))
 80108b4:	3c01      	subs	r4, #1
 80108b6:	fa45 f304 	asr.w	r3, r5, r4
 80108ba:	2201      	movs	r2, #1
 80108bc:	4013      	ands	r3, r2
 80108be:	2b00      	cmp	r3, #0
 80108c0:	d008      	beq.n	80108d4 <decode_mcu_DC_refine+0xb0>
      (*block)[0] |= p1;
 80108c2:	6a3b      	ldr	r3, [r7, #32]
 80108c4:	f9b3 2000 	ldrsh.w	r2, [r3]
 80108c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108ca:	b21b      	sxth	r3, r3
 80108cc:	4313      	orrs	r3, r2
 80108ce:	b21a      	sxth	r2, r3
 80108d0:	6a3b      	ldr	r3, [r7, #32]
 80108d2:	801a      	strh	r2, [r3, #0]
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 80108d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80108d6:	3301      	adds	r3, #1
 80108d8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80108da:	687b      	ldr	r3, [r7, #4]
 80108dc:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 80108e0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80108e2:	429a      	cmp	r2, r3
 80108e4:	dbd0      	blt.n	8010888 <decode_mcu_DC_refine+0x64>
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 80108e6:	687b      	ldr	r3, [r7, #4]
 80108e8:	699b      	ldr	r3, [r3, #24]
 80108ea:	68fa      	ldr	r2, [r7, #12]
 80108ec:	601a      	str	r2, [r3, #0]
 80108ee:	687b      	ldr	r3, [r7, #4]
 80108f0:	699b      	ldr	r3, [r3, #24]
 80108f2:	693a      	ldr	r2, [r7, #16]
 80108f4:	605a      	str	r2, [r3, #4]
 80108f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108f8:	609d      	str	r5, [r3, #8]
 80108fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108fc:	60dc      	str	r4, [r3, #12]

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 80108fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010900:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010902:	1e5a      	subs	r2, r3, #1
 8010904:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010906:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 8010908:	2301      	movs	r3, #1
}
 801090a:	4618      	mov	r0, r3
 801090c:	3730      	adds	r7, #48	; 0x30
 801090e:	46bd      	mov	sp, r7
 8010910:	bdb0      	pop	{r4, r5, r7, pc}
	...

08010914 <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{   
 8010914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010918:	b0d6      	sub	sp, #344	; 0x158
 801091a:	af02      	add	r7, sp, #8
 801091c:	f107 030c 	add.w	r3, r7, #12
 8010920:	6018      	str	r0, [r3, #0]
 8010922:	f107 0308 	add.w	r3, r7, #8
 8010926:	6019      	str	r1, [r3, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8010928:	f107 030c 	add.w	r3, r7, #12
 801092c:	681b      	ldr	r3, [r3, #0]
 801092e:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010932:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8010936:	f107 030c 	add.w	r3, r7, #12
 801093a:	681b      	ldr	r3, [r3, #0]
 801093c:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8010940:	2b00      	cmp	r3, #0
 8010942:	d00e      	beq.n	8010962 <decode_mcu_AC_refine+0x4e>
    if (entropy->restarts_to_go == 0)
 8010944:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010948:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801094a:	2b00      	cmp	r3, #0
 801094c:	d109      	bne.n	8010962 <decode_mcu_AC_refine+0x4e>
      if (! process_restart(cinfo))
 801094e:	f107 030c 	add.w	r3, r7, #12
 8010952:	6818      	ldr	r0, [r3, #0]
 8010954:	f7ff fd02 	bl	801035c <process_restart>
 8010958:	4603      	mov	r3, r0
 801095a:	2b00      	cmp	r3, #0
 801095c:	d101      	bne.n	8010962 <decode_mcu_AC_refine+0x4e>
	return FALSE;
 801095e:	2300      	movs	r3, #0
 8010960:	e23a      	b.n	8010dd8 <decode_mcu_AC_refine+0x4c4>
  }

  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->insufficient_data) {
 8010962:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010966:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010968:	2b00      	cmp	r3, #0
 801096a:	f040 820b 	bne.w	8010d84 <decode_mcu_AC_refine+0x470>

    Se = cinfo->Se;
 801096e:	f107 030c 	add.w	r3, r7, #12
 8010972:	681b      	ldr	r3, [r3, #0]
 8010974:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 8010978:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
 801097c:	f107 030c 	add.w	r3, r7, #12
 8010980:	681b      	ldr	r3, [r3, #0]
 8010982:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8010986:	2201      	movs	r2, #1
 8010988:	fa02 f303 	lsl.w	r3, r2, r3
 801098c:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
 8010990:	f107 030c 	add.w	r3, r7, #12
 8010994:	681b      	ldr	r3, [r3, #0]
 8010996:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 801099a:	f04f 32ff 	mov.w	r2, #4294967295
 801099e:	fa02 f303 	lsl.w	r3, r2, r3
 80109a2:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    natural_order = cinfo->natural_order;
 80109a6:	f107 030c 	add.w	r3, r7, #12
 80109aa:	681b      	ldr	r3, [r3, #0]
 80109ac:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 80109b0:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 80109b4:	f107 030c 	add.w	r3, r7, #12
 80109b8:	681b      	ldr	r3, [r3, #0]
 80109ba:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 80109be:	f107 030c 	add.w	r3, r7, #12
 80109c2:	681b      	ldr	r3, [r3, #0]
 80109c4:	699b      	ldr	r3, [r3, #24]
 80109c6:	681b      	ldr	r3, [r3, #0]
 80109c8:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
 80109cc:	f107 030c 	add.w	r3, r7, #12
 80109d0:	681b      	ldr	r3, [r3, #0]
 80109d2:	699b      	ldr	r3, [r3, #24]
 80109d4:	685b      	ldr	r3, [r3, #4]
 80109d6:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 80109da:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80109de:	689d      	ldr	r5, [r3, #8]
 80109e0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80109e4:	68dc      	ldr	r4, [r3, #12]
    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
 80109e6:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80109ea:	691b      	ldr	r3, [r3, #16]
 80109ec:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    /* There is always only one block per MCU */
    block = MCU_data[0];
 80109f0:	f107 0308 	add.w	r3, r7, #8
 80109f4:	681b      	ldr	r3, [r3, #0]
 80109f6:	681b      	ldr	r3, [r3, #0]
 80109f8:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tbl = entropy->ac_derived_tbl;
 80109fc:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010a00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010a02:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
     * nonzero coefficients in the block, because otherwise we'd get confused
     * next time about which coefficients were already nonzero.
     * But we need not undo addition of bits to already-nonzero coefficients;
     * instead, we can test the current bit to see if we already did it.
     */
    num_newnz = 0;
 8010a06:	2300      	movs	r3, #0
 8010a08:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;
 8010a0c:	f107 030c 	add.w	r3, r7, #12
 8010a10:	681b      	ldr	r3, [r3, #0]
 8010a12:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8010a16:	607b      	str	r3, [r7, #4]

    if (EOBRUN == 0) {
 8010a18:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8010a1c:	2b00      	cmp	r3, #0
 8010a1e:	f040 8130 	bne.w	8010c82 <decode_mcu_AC_refine+0x36e>
      for (; k <= Se; k++) {
 8010a22:	e126      	b.n	8010c72 <decode_mcu_AC_refine+0x35e>
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
 8010a24:	2c07      	cmp	r4, #7
 8010a26:	dc12      	bgt.n	8010a4e <decode_mcu_AC_refine+0x13a>
 8010a28:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010a2c:	2300      	movs	r3, #0
 8010a2e:	4622      	mov	r2, r4
 8010a30:	4629      	mov	r1, r5
 8010a32:	f7ff fba9 	bl	8010188 <jpeg_fill_bit_buffer>
 8010a36:	4603      	mov	r3, r0
 8010a38:	2b00      	cmp	r3, #0
 8010a3a:	f000 81ac 	beq.w	8010d96 <decode_mcu_AC_refine+0x482>
 8010a3e:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010a42:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
 8010a46:	2c07      	cmp	r4, #7
 8010a48:	dc01      	bgt.n	8010a4e <decode_mcu_AC_refine+0x13a>
 8010a4a:	2601      	movs	r6, #1
 8010a4c:	e017      	b.n	8010a7e <decode_mcu_AC_refine+0x16a>
 8010a4e:	f1a4 0308 	sub.w	r3, r4, #8
 8010a52:	fa45 f303 	asr.w	r3, r5, r3
 8010a56:	22ff      	movs	r2, #255	; 0xff
 8010a58:	ea03 0802 	and.w	r8, r3, r2
 8010a5c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8010a60:	f108 0224 	add.w	r2, r8, #36	; 0x24
 8010a64:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
 8010a68:	2e00      	cmp	r6, #0
 8010a6a:	d007      	beq.n	8010a7c <decode_mcu_AC_refine+0x168>
 8010a6c:	1ba4      	subs	r4, r4, r6
 8010a6e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8010a72:	4443      	add	r3, r8
 8010a74:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 8010a78:	603b      	str	r3, [r7, #0]
 8010a7a:	e012      	b.n	8010aa2 <decode_mcu_AC_refine+0x18e>
 8010a7c:	2609      	movs	r6, #9
 8010a7e:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010a82:	9600      	str	r6, [sp, #0]
 8010a84:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8010a88:	4622      	mov	r2, r4
 8010a8a:	4629      	mov	r1, r5
 8010a8c:	f7ff fc02 	bl	8010294 <jpeg_huff_decode>
 8010a90:	4603      	mov	r3, r0
 8010a92:	603b      	str	r3, [r7, #0]
 8010a94:	2b00      	cmp	r3, #0
 8010a96:	f2c0 8180 	blt.w	8010d9a <decode_mcu_AC_refine+0x486>
 8010a9a:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010a9e:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
	r = s >> 4;
 8010aa2:	683b      	ldr	r3, [r7, #0]
 8010aa4:	111e      	asrs	r6, r3, #4
	s &= 15;
 8010aa6:	f003 030f 	and.w	r3, r3, #15
 8010aaa:	603b      	str	r3, [r7, #0]
	if (s) {
 8010aac:	2b00      	cmp	r3, #0
 8010aae:	d032      	beq.n	8010b16 <decode_mcu_AC_refine+0x202>
	  if (s != 1)		/* size of new coef should always be 1 */
 8010ab0:	2b01      	cmp	r3, #1
 8010ab2:	d010      	beq.n	8010ad6 <decode_mcu_AC_refine+0x1c2>
	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
 8010ab4:	f107 030c 	add.w	r3, r7, #12
 8010ab8:	681b      	ldr	r3, [r3, #0]
 8010aba:	681b      	ldr	r3, [r3, #0]
 8010abc:	2279      	movs	r2, #121	; 0x79
 8010abe:	615a      	str	r2, [r3, #20]
 8010ac0:	f107 030c 	add.w	r3, r7, #12
 8010ac4:	681b      	ldr	r3, [r3, #0]
 8010ac6:	681b      	ldr	r3, [r3, #0]
 8010ac8:	685b      	ldr	r3, [r3, #4]
 8010aca:	f107 020c 	add.w	r2, r7, #12
 8010ace:	f04f 31ff 	mov.w	r1, #4294967295
 8010ad2:	6810      	ldr	r0, [r2, #0]
 8010ad4:	4798      	blx	r3
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010ad6:	2c00      	cmp	r4, #0
 8010ad8:	dc0e      	bgt.n	8010af8 <decode_mcu_AC_refine+0x1e4>
 8010ada:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010ade:	2301      	movs	r3, #1
 8010ae0:	4622      	mov	r2, r4
 8010ae2:	4629      	mov	r1, r5
 8010ae4:	f7ff fb50 	bl	8010188 <jpeg_fill_bit_buffer>
 8010ae8:	4603      	mov	r3, r0
 8010aea:	2b00      	cmp	r3, #0
 8010aec:	f000 8157 	beq.w	8010d9e <decode_mcu_AC_refine+0x48a>
 8010af0:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010af4:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
	  if (GET_BITS(1))
 8010af8:	3c01      	subs	r4, #1
 8010afa:	fa45 f304 	asr.w	r3, r5, r4
 8010afe:	2201      	movs	r2, #1
 8010b00:	4013      	ands	r3, r2
 8010b02:	2b00      	cmp	r3, #0
 8010b04:	d003      	beq.n	8010b0e <decode_mcu_AC_refine+0x1fa>
	    s = p1;		/* newly nonzero coef is positive */
 8010b06:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8010b0a:	603b      	str	r3, [r7, #0]
 8010b0c:	e02c      	b.n	8010b68 <decode_mcu_AC_refine+0x254>
	  else
	    s = m1;		/* newly nonzero coef is negative */
 8010b0e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8010b12:	603b      	str	r3, [r7, #0]
 8010b14:	e028      	b.n	8010b68 <decode_mcu_AC_refine+0x254>
	} else {
	  if (r != 15) {
 8010b16:	2e0f      	cmp	r6, #15
 8010b18:	d026      	beq.n	8010b68 <decode_mcu_AC_refine+0x254>
	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
 8010b1a:	2301      	movs	r3, #1
 8010b1c:	40b3      	lsls	r3, r6
 8010b1e:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
	    if (r) {
 8010b22:	2e00      	cmp	r6, #0
 8010b24:	f000 80ac 	beq.w	8010c80 <decode_mcu_AC_refine+0x36c>
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
 8010b28:	42b4      	cmp	r4, r6
 8010b2a:	da0e      	bge.n	8010b4a <decode_mcu_AC_refine+0x236>
 8010b2c:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010b30:	4633      	mov	r3, r6
 8010b32:	4622      	mov	r2, r4
 8010b34:	4629      	mov	r1, r5
 8010b36:	f7ff fb27 	bl	8010188 <jpeg_fill_bit_buffer>
 8010b3a:	4603      	mov	r3, r0
 8010b3c:	2b00      	cmp	r3, #0
 8010b3e:	f000 8130 	beq.w	8010da2 <decode_mcu_AC_refine+0x48e>
 8010b42:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010b46:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
	      r = GET_BITS(r);
 8010b4a:	1ba4      	subs	r4, r4, r6
 8010b4c:	fa45 f204 	asr.w	r2, r5, r4
 8010b50:	4ba4      	ldr	r3, [pc, #656]	; (8010de4 <decode_mcu_AC_refine+0x4d0>)
 8010b52:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8010b56:	ea02 0603 	and.w	r6, r2, r3
	      EOBRUN += r;
 8010b5a:	4632      	mov	r2, r6
 8010b5c:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8010b60:	4413      	add	r3, r2
 8010b62:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
	    }
	    break;		/* rest of block is handled by EOB logic */
 8010b66:	e08b      	b.n	8010c80 <decode_mcu_AC_refine+0x36c>
	/* Advance over already-nonzero coefs and r still-zero coefs,
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + natural_order[k];
 8010b68:	687b      	ldr	r3, [r7, #4]
 8010b6a:	009b      	lsls	r3, r3, #2
 8010b6c:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8010b70:	4413      	add	r3, r2
 8010b72:	681b      	ldr	r3, [r3, #0]
 8010b74:	005b      	lsls	r3, r3, #1
 8010b76:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8010b7a:	4413      	add	r3, r2
 8010b7c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
	  if (*thiscoef != 0) {
 8010b80:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010b84:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010b88:	2b00      	cmp	r3, #0
 8010b8a:	d045      	beq.n	8010c18 <decode_mcu_AC_refine+0x304>
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010b8c:	2c00      	cmp	r4, #0
 8010b8e:	dc0e      	bgt.n	8010bae <decode_mcu_AC_refine+0x29a>
 8010b90:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010b94:	2301      	movs	r3, #1
 8010b96:	4622      	mov	r2, r4
 8010b98:	4629      	mov	r1, r5
 8010b9a:	f7ff faf5 	bl	8010188 <jpeg_fill_bit_buffer>
 8010b9e:	4603      	mov	r3, r0
 8010ba0:	2b00      	cmp	r3, #0
 8010ba2:	f000 8100 	beq.w	8010da6 <decode_mcu_AC_refine+0x492>
 8010ba6:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010baa:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
	    if (GET_BITS(1)) {
 8010bae:	3c01      	subs	r4, #1
 8010bb0:	fa45 f304 	asr.w	r3, r5, r4
 8010bb4:	2201      	movs	r2, #1
 8010bb6:	4013      	ands	r3, r2
 8010bb8:	2b00      	cmp	r3, #0
 8010bba:	d030      	beq.n	8010c1e <decode_mcu_AC_refine+0x30a>
	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
 8010bbc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010bc0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010bc4:	461a      	mov	r2, r3
 8010bc6:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8010bca:	4013      	ands	r3, r2
 8010bcc:	2b00      	cmp	r3, #0
 8010bce:	d126      	bne.n	8010c1e <decode_mcu_AC_refine+0x30a>
		if (*thiscoef >= 0)
 8010bd0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010bd4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010bd8:	2b00      	cmp	r3, #0
 8010bda:	db0e      	blt.n	8010bfa <decode_mcu_AC_refine+0x2e6>
		  *thiscoef += p1;
 8010bdc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010be0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010be4:	b29a      	uxth	r2, r3
 8010be6:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8010bea:	b29b      	uxth	r3, r3
 8010bec:	4413      	add	r3, r2
 8010bee:	b29b      	uxth	r3, r3
 8010bf0:	b21a      	sxth	r2, r3
 8010bf2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010bf6:	801a      	strh	r2, [r3, #0]
 8010bf8:	e011      	b.n	8010c1e <decode_mcu_AC_refine+0x30a>
		else
		  *thiscoef += m1;
 8010bfa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010bfe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010c02:	b29a      	uxth	r2, r3
 8010c04:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8010c08:	b29b      	uxth	r3, r3
 8010c0a:	4413      	add	r3, r2
 8010c0c:	b29b      	uxth	r3, r3
 8010c0e:	b21a      	sxth	r2, r3
 8010c10:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010c14:	801a      	strh	r2, [r3, #0]
 8010c16:	e002      	b.n	8010c1e <decode_mcu_AC_refine+0x30a>
	      }
	    }
	  } else {
	    if (--r < 0)
 8010c18:	3e01      	subs	r6, #1
 8010c1a:	2e00      	cmp	r6, #0
 8010c1c:	db08      	blt.n	8010c30 <decode_mcu_AC_refine+0x31c>
	      break;		/* reached target zero coefficient */
	  }
	  k++;
 8010c1e:	687b      	ldr	r3, [r7, #4]
 8010c20:	3301      	adds	r3, #1
 8010c22:	461a      	mov	r2, r3
 8010c24:	607a      	str	r2, [r7, #4]
	} while (k <= Se);
 8010c26:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8010c2a:	429a      	cmp	r2, r3
 8010c2c:	dd9c      	ble.n	8010b68 <decode_mcu_AC_refine+0x254>
 8010c2e:	e000      	b.n	8010c32 <decode_mcu_AC_refine+0x31e>
	      break;		/* reached target zero coefficient */
 8010c30:	bf00      	nop
	if (s) {
 8010c32:	6839      	ldr	r1, [r7, #0]
 8010c34:	2900      	cmp	r1, #0
 8010c36:	d019      	beq.n	8010c6c <decode_mcu_AC_refine+0x358>
	  int pos = natural_order[k];
 8010c38:	687b      	ldr	r3, [r7, #4]
 8010c3a:	009b      	lsls	r3, r3, #2
 8010c3c:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8010c40:	4413      	add	r3, r2
 8010c42:	681b      	ldr	r3, [r3, #0]
 8010c44:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
	  /* Output newly nonzero coefficient */
	  (*block)[pos] = (JCOEF) s;
 8010c48:	b209      	sxth	r1, r1
 8010c4a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8010c4e:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8010c52:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	  /* Remember its position in case we have to suspend */
	  newnz_pos[num_newnz++] = pos;
 8010c56:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8010c5a:	1c5a      	adds	r2, r3, #1
 8010c5c:	f8c7 2148 	str.w	r2, [r7, #328]	; 0x148
 8010c60:	f107 0210 	add.w	r2, r7, #16
 8010c64:	f8d7 1124 	ldr.w	r1, [r7, #292]	; 0x124
 8010c68:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      for (; k <= Se; k++) {
 8010c6c:	687b      	ldr	r3, [r7, #4]
 8010c6e:	3301      	adds	r3, #1
 8010c70:	607b      	str	r3, [r7, #4]
 8010c72:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8010c76:	687a      	ldr	r2, [r7, #4]
 8010c78:	429a      	cmp	r2, r3
 8010c7a:	f77f aed3 	ble.w	8010a24 <decode_mcu_AC_refine+0x110>
 8010c7e:	e000      	b.n	8010c82 <decode_mcu_AC_refine+0x36e>
	    break;		/* rest of block is handled by EOB logic */
 8010c80:	bf00      	nop
	}
      }
    }

    if (EOBRUN > 0) {
 8010c82:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8010c86:	2b00      	cmp	r3, #0
 8010c88:	d063      	beq.n	8010d52 <decode_mcu_AC_refine+0x43e>
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
 8010c8a:	e058      	b.n	8010d3e <decode_mcu_AC_refine+0x42a>
	thiscoef = *block + natural_order[k];
 8010c8c:	687b      	ldr	r3, [r7, #4]
 8010c8e:	009b      	lsls	r3, r3, #2
 8010c90:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8010c94:	4413      	add	r3, r2
 8010c96:	681b      	ldr	r3, [r3, #0]
 8010c98:	005b      	lsls	r3, r3, #1
 8010c9a:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8010c9e:	4413      	add	r3, r2
 8010ca0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
	if (*thiscoef != 0) {
 8010ca4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010ca8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010cac:	2b00      	cmp	r3, #0
 8010cae:	d043      	beq.n	8010d38 <decode_mcu_AC_refine+0x424>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010cb0:	2c00      	cmp	r4, #0
 8010cb2:	dc0d      	bgt.n	8010cd0 <decode_mcu_AC_refine+0x3bc>
 8010cb4:	f507 7088 	add.w	r0, r7, #272	; 0x110
 8010cb8:	2301      	movs	r3, #1
 8010cba:	4622      	mov	r2, r4
 8010cbc:	4629      	mov	r1, r5
 8010cbe:	f7ff fa63 	bl	8010188 <jpeg_fill_bit_buffer>
 8010cc2:	4603      	mov	r3, r0
 8010cc4:	2b00      	cmp	r3, #0
 8010cc6:	d070      	beq.n	8010daa <decode_mcu_AC_refine+0x496>
 8010cc8:	f8d7 5118 	ldr.w	r5, [r7, #280]	; 0x118
 8010ccc:	f8d7 411c 	ldr.w	r4, [r7, #284]	; 0x11c
	  if (GET_BITS(1)) {
 8010cd0:	3c01      	subs	r4, #1
 8010cd2:	fa45 f304 	asr.w	r3, r5, r4
 8010cd6:	2201      	movs	r2, #1
 8010cd8:	4013      	ands	r3, r2
 8010cda:	2b00      	cmp	r3, #0
 8010cdc:	d02c      	beq.n	8010d38 <decode_mcu_AC_refine+0x424>
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
 8010cde:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010ce2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010ce6:	461a      	mov	r2, r3
 8010ce8:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8010cec:	4013      	ands	r3, r2
 8010cee:	2b00      	cmp	r3, #0
 8010cf0:	d122      	bne.n	8010d38 <decode_mcu_AC_refine+0x424>
	      if (*thiscoef >= 0)
 8010cf2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010cf6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010cfa:	2b00      	cmp	r3, #0
 8010cfc:	db0e      	blt.n	8010d1c <decode_mcu_AC_refine+0x408>
		*thiscoef += p1;
 8010cfe:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010d02:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010d06:	b29a      	uxth	r2, r3
 8010d08:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8010d0c:	b29b      	uxth	r3, r3
 8010d0e:	4413      	add	r3, r2
 8010d10:	b29b      	uxth	r3, r3
 8010d12:	b21a      	sxth	r2, r3
 8010d14:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010d18:	801a      	strh	r2, [r3, #0]
 8010d1a:	e00d      	b.n	8010d38 <decode_mcu_AC_refine+0x424>
	      else
		*thiscoef += m1;
 8010d1c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010d20:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010d24:	b29a      	uxth	r2, r3
 8010d26:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8010d2a:	b29b      	uxth	r3, r3
 8010d2c:	4413      	add	r3, r2
 8010d2e:	b29b      	uxth	r3, r3
 8010d30:	b21a      	sxth	r2, r3
 8010d32:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8010d36:	801a      	strh	r2, [r3, #0]
      for (; k <= Se; k++) {
 8010d38:	687b      	ldr	r3, [r7, #4]
 8010d3a:	3301      	adds	r3, #1
 8010d3c:	607b      	str	r3, [r7, #4]
 8010d3e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8010d42:	687a      	ldr	r2, [r7, #4]
 8010d44:	429a      	cmp	r2, r3
 8010d46:	dda1      	ble.n	8010c8c <decode_mcu_AC_refine+0x378>
	    }
	  }
	}
      }
      /* Count one block completed in EOB run */
      EOBRUN--;
 8010d48:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8010d4c:	3b01      	subs	r3, #1
 8010d4e:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8010d52:	f107 030c 	add.w	r3, r7, #12
 8010d56:	681b      	ldr	r3, [r3, #0]
 8010d58:	699b      	ldr	r3, [r3, #24]
 8010d5a:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8010d5e:	601a      	str	r2, [r3, #0]
 8010d60:	f107 030c 	add.w	r3, r7, #12
 8010d64:	681b      	ldr	r3, [r3, #0]
 8010d66:	699b      	ldr	r3, [r3, #24]
 8010d68:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8010d6c:	605a      	str	r2, [r3, #4]
 8010d6e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010d72:	609d      	str	r5, [r3, #8]
 8010d74:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010d78:	60dc      	str	r4, [r3, #12]
    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
 8010d7a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010d7e:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8010d82:	611a      	str	r2, [r3, #16]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8010d84:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010d88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010d8a:	1e5a      	subs	r2, r3, #1
 8010d8c:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8010d90:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 8010d92:	2301      	movs	r3, #1
 8010d94:	e020      	b.n	8010dd8 <decode_mcu_AC_refine+0x4c4>
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
 8010d96:	bf00      	nop
 8010d98:	e019      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
 8010d9a:	bf00      	nop
 8010d9c:	e017      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010d9e:	bf00      	nop
 8010da0:	e015      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
 8010da2:	bf00      	nop
 8010da4:	e013      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010da6:	bf00      	nop
 8010da8:	e011      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 8010daa:	bf00      	nop

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
 8010dac:	e00f      	b.n	8010dce <decode_mcu_AC_refine+0x4ba>
    (*block)[newnz_pos[--num_newnz]] = 0;
 8010dae:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8010db2:	3b01      	subs	r3, #1
 8010db4:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
 8010db8:	f107 0310 	add.w	r3, r7, #16
 8010dbc:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 8010dc0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8010dc4:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8010dc8:	2100      	movs	r1, #0
 8010dca:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  while (num_newnz > 0)
 8010dce:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8010dd2:	2b00      	cmp	r3, #0
 8010dd4:	dceb      	bgt.n	8010dae <decode_mcu_AC_refine+0x49a>

  return FALSE;
 8010dd6:	2300      	movs	r3, #0
}
 8010dd8:	4618      	mov	r0, r3
 8010dda:	f507 77a8 	add.w	r7, r7, #336	; 0x150
 8010dde:	46bd      	mov	sp, r7
 8010de0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010de4:	0802a90c 	.word	0x0802a90c

08010de8 <decode_mcu_sub>:
 * partial blocks.
 */

METHODDEF(boolean)
decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 8010de8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010dec:	b097      	sub	sp, #92	; 0x5c
 8010dee:	af02      	add	r7, sp, #8
 8010df0:	6078      	str	r0, [r7, #4]
 8010df2:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 8010df4:	687b      	ldr	r3, [r7, #4]
 8010df6:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8010dfa:	64bb      	str	r3, [r7, #72]	; 0x48
  int Se, blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 8010dfc:	687b      	ldr	r3, [r7, #4]
 8010dfe:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d00b      	beq.n	8010e1e <decode_mcu_sub+0x36>
    if (entropy->restarts_to_go == 0)
 8010e06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010e0a:	2b00      	cmp	r3, #0
 8010e0c:	d107      	bne.n	8010e1e <decode_mcu_sub+0x36>
      if (! process_restart(cinfo))
 8010e0e:	6878      	ldr	r0, [r7, #4]
 8010e10:	f7ff faa4 	bl	801035c <process_restart>
 8010e14:	4603      	mov	r3, r0
 8010e16:	2b00      	cmp	r3, #0
 8010e18:	d101      	bne.n	8010e1e <decode_mcu_sub+0x36>
	return FALSE;
 8010e1a:	2300      	movs	r3, #0
 8010e1c:	e1d4      	b.n	80111c8 <decode_mcu_sub+0x3e0>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 8010e1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010e22:	2b00      	cmp	r3, #0
 8010e24:	f040 81ca 	bne.w	80111bc <decode_mcu_sub+0x3d4>

    natural_order = cinfo->natural_order;
 8010e28:	687b      	ldr	r3, [r7, #4]
 8010e2a:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 8010e2e:	647b      	str	r3, [r7, #68]	; 0x44
    Se = cinfo->lim_Se;
 8010e30:	687b      	ldr	r3, [r7, #4]
 8010e32:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 8010e36:	643b      	str	r3, [r7, #64]	; 0x40

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8010e38:	687b      	ldr	r3, [r7, #4]
 8010e3a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010e3c:	687b      	ldr	r3, [r7, #4]
 8010e3e:	699b      	ldr	r3, [r3, #24]
 8010e40:	681b      	ldr	r3, [r3, #0]
 8010e42:	61fb      	str	r3, [r7, #28]
 8010e44:	687b      	ldr	r3, [r7, #4]
 8010e46:	699b      	ldr	r3, [r3, #24]
 8010e48:	685b      	ldr	r3, [r3, #4]
 8010e4a:	623b      	str	r3, [r7, #32]
 8010e4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e4e:	689e      	ldr	r6, [r3, #8]
 8010e50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e52:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 8010e54:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e56:	f107 0508 	add.w	r5, r7, #8
 8010e5a:	f103 0c10 	add.w	ip, r3, #16
 8010e5e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010e62:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8010e64:	f8dc 3000 	ldr.w	r3, [ip]
 8010e68:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8010e6a:	2300      	movs	r3, #0
 8010e6c:	64fb      	str	r3, [r7, #76]	; 0x4c
 8010e6e:	e189      	b.n	8011184 <decode_mcu_sub+0x39c>
      JBLOCKROW block = MCU_data[blkn];
 8010e70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010e72:	009b      	lsls	r3, r3, #2
 8010e74:	683a      	ldr	r2, [r7, #0]
 8010e76:	4413      	add	r3, r2
 8010e78:	681b      	ldr	r3, [r3, #0]
 8010e7a:	63fb      	str	r3, [r7, #60]	; 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 8010e7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010e7e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010e80:	3218      	adds	r2, #24
 8010e82:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010e86:	63bb      	str	r3, [r7, #56]	; 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 8010e88:	2c07      	cmp	r4, #7
 8010e8a:	dc11      	bgt.n	8010eb0 <decode_mcu_sub+0xc8>
 8010e8c:	f107 001c 	add.w	r0, r7, #28
 8010e90:	2300      	movs	r3, #0
 8010e92:	4622      	mov	r2, r4
 8010e94:	4631      	mov	r1, r6
 8010e96:	f7ff f977 	bl	8010188 <jpeg_fill_bit_buffer>
 8010e9a:	4603      	mov	r3, r0
 8010e9c:	2b00      	cmp	r3, #0
 8010e9e:	d101      	bne.n	8010ea4 <decode_mcu_sub+0xbc>
 8010ea0:	2300      	movs	r3, #0
 8010ea2:	e191      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 8010ea4:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8010ea6:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8010ea8:	2c07      	cmp	r4, #7
 8010eaa:	dc01      	bgt.n	8010eb0 <decode_mcu_sub+0xc8>
 8010eac:	2501      	movs	r5, #1
 8010eae:	e015      	b.n	8010edc <decode_mcu_sub+0xf4>
 8010eb0:	f1a4 0308 	sub.w	r3, r4, #8
 8010eb4:	fa46 f303 	asr.w	r3, r6, r3
 8010eb8:	22ff      	movs	r2, #255	; 0xff
 8010eba:	ea03 0802 	and.w	r8, r3, r2
 8010ebe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ec0:	f108 0224 	add.w	r2, r8, #36	; 0x24
 8010ec4:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8010ec8:	2d00      	cmp	r5, #0
 8010eca:	d006      	beq.n	8010eda <decode_mcu_sub+0xf2>
 8010ecc:	1b64      	subs	r4, r4, r5
 8010ece:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ed0:	4443      	add	r3, r8
 8010ed2:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 8010ed6:	461d      	mov	r5, r3
 8010ed8:	e00f      	b.n	8010efa <decode_mcu_sub+0x112>
 8010eda:	2509      	movs	r5, #9
 8010edc:	f107 001c 	add.w	r0, r7, #28
 8010ee0:	9500      	str	r5, [sp, #0]
 8010ee2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ee4:	4622      	mov	r2, r4
 8010ee6:	4631      	mov	r1, r6
 8010ee8:	f7ff f9d4 	bl	8010294 <jpeg_huff_decode>
 8010eec:	4605      	mov	r5, r0
 8010eee:	2d00      	cmp	r5, #0
 8010ef0:	da01      	bge.n	8010ef6 <decode_mcu_sub+0x10e>
 8010ef2:	2300      	movs	r3, #0
 8010ef4:	e168      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 8010ef6:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8010ef8:	6abc      	ldr	r4, [r7, #40]	; 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 8010efa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010efc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010efe:	3222      	adds	r2, #34	; 0x22
 8010f00:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010f04:	63bb      	str	r3, [r7, #56]	; 0x38
      k = 1;
 8010f06:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 8010f0a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010f0c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010f0e:	322c      	adds	r2, #44	; 0x2c
 8010f10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010f14:	637b      	str	r3, [r7, #52]	; 0x34
      if (coef_limit) {
 8010f16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010f18:	2b00      	cmp	r3, #0
 8010f1a:	f000 80bc 	beq.w	8011096 <decode_mcu_sub+0x2ae>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 8010f1e:	2d00      	cmp	r5, #0
 8010f20:	d025      	beq.n	8010f6e <decode_mcu_sub+0x186>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8010f22:	42ac      	cmp	r4, r5
 8010f24:	da0d      	bge.n	8010f42 <decode_mcu_sub+0x15a>
 8010f26:	f107 001c 	add.w	r0, r7, #28
 8010f2a:	462b      	mov	r3, r5
 8010f2c:	4622      	mov	r2, r4
 8010f2e:	4631      	mov	r1, r6
 8010f30:	f7ff f92a 	bl	8010188 <jpeg_fill_bit_buffer>
 8010f34:	4603      	mov	r3, r0
 8010f36:	2b00      	cmp	r3, #0
 8010f38:	d101      	bne.n	8010f3e <decode_mcu_sub+0x156>
 8010f3a:	2300      	movs	r3, #0
 8010f3c:	e144      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 8010f3e:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8010f40:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  r = GET_BITS(s);
 8010f42:	1b64      	subs	r4, r4, r5
 8010f44:	fa46 f204 	asr.w	r2, r6, r4
 8010f48:	4ba2      	ldr	r3, [pc, #648]	; (80111d4 <decode_mcu_sub+0x3ec>)
 8010f4a:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8010f4e:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 8010f52:	1e6b      	subs	r3, r5, #1
 8010f54:	4a9f      	ldr	r2, [pc, #636]	; (80111d4 <decode_mcu_sub+0x3ec>)
 8010f56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010f5a:	4599      	cmp	r9, r3
 8010f5c:	dc05      	bgt.n	8010f6a <decode_mcu_sub+0x182>
 8010f5e:	4b9d      	ldr	r3, [pc, #628]	; (80111d4 <decode_mcu_sub+0x3ec>)
 8010f60:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8010f64:	eba9 0303 	sub.w	r3, r9, r3
 8010f68:	e000      	b.n	8010f6c <decode_mcu_sub+0x184>
 8010f6a:	464b      	mov	r3, r9
 8010f6c:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 8010f6e:	687b      	ldr	r3, [r7, #4]
 8010f70:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010f72:	325c      	adds	r2, #92	; 0x5c
 8010f74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010f78:	633b      	str	r3, [r7, #48]	; 0x30
	s += state.last_dc_val[ci];
 8010f7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010f7c:	009b      	lsls	r3, r3, #2
 8010f7e:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8010f82:	4413      	add	r3, r2
 8010f84:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8010f88:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 8010f8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010f8c:	009b      	lsls	r3, r3, #2
 8010f8e:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8010f92:	4413      	add	r3, r2
 8010f94:	f843 5c44 	str.w	r5, [r3, #-68]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 8010f98:	b22a      	sxth	r2, r5
 8010f9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010f9c:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 8010f9e:	e076      	b.n	801108e <decode_mcu_sub+0x2a6>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8010fa0:	2c07      	cmp	r4, #7
 8010fa2:	dc11      	bgt.n	8010fc8 <decode_mcu_sub+0x1e0>
 8010fa4:	f107 001c 	add.w	r0, r7, #28
 8010fa8:	2300      	movs	r3, #0
 8010faa:	4622      	mov	r2, r4
 8010fac:	4631      	mov	r1, r6
 8010fae:	f7ff f8eb 	bl	8010188 <jpeg_fill_bit_buffer>
 8010fb2:	4603      	mov	r3, r0
 8010fb4:	2b00      	cmp	r3, #0
 8010fb6:	d101      	bne.n	8010fbc <decode_mcu_sub+0x1d4>
 8010fb8:	2300      	movs	r3, #0
 8010fba:	e105      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 8010fbc:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8010fbe:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8010fc0:	2c07      	cmp	r4, #7
 8010fc2:	dc01      	bgt.n	8010fc8 <decode_mcu_sub+0x1e0>
 8010fc4:	2501      	movs	r5, #1
 8010fc6:	e015      	b.n	8010ff4 <decode_mcu_sub+0x20c>
 8010fc8:	f1a4 0308 	sub.w	r3, r4, #8
 8010fcc:	fa46 f303 	asr.w	r3, r6, r3
 8010fd0:	22ff      	movs	r2, #255	; 0xff
 8010fd2:	ea03 0902 	and.w	r9, r3, r2
 8010fd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010fd8:	f109 0224 	add.w	r2, r9, #36	; 0x24
 8010fdc:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8010fe0:	2d00      	cmp	r5, #0
 8010fe2:	d006      	beq.n	8010ff2 <decode_mcu_sub+0x20a>
 8010fe4:	1b64      	subs	r4, r4, r5
 8010fe6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010fe8:	444b      	add	r3, r9
 8010fea:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 8010fee:	461d      	mov	r5, r3
 8010ff0:	e00f      	b.n	8011012 <decode_mcu_sub+0x22a>
 8010ff2:	2509      	movs	r5, #9
 8010ff4:	f107 001c 	add.w	r0, r7, #28
 8010ff8:	9500      	str	r5, [sp, #0]
 8010ffa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ffc:	4622      	mov	r2, r4
 8010ffe:	4631      	mov	r1, r6
 8011000:	f7ff f948 	bl	8010294 <jpeg_huff_decode>
 8011004:	4605      	mov	r5, r0
 8011006:	2d00      	cmp	r5, #0
 8011008:	da01      	bge.n	801100e <decode_mcu_sub+0x226>
 801100a:	2300      	movs	r3, #0
 801100c:	e0dc      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 801100e:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8011010:	6abc      	ldr	r4, [r7, #40]	; 0x28

	  r = s >> 4;
 8011012:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 8011016:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 801101a:	2d00      	cmp	r5, #0
 801101c:	d030      	beq.n	8011080 <decode_mcu_sub+0x298>
	    k += r;
 801101e:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8011020:	42ac      	cmp	r4, r5
 8011022:	da0d      	bge.n	8011040 <decode_mcu_sub+0x258>
 8011024:	f107 001c 	add.w	r0, r7, #28
 8011028:	462b      	mov	r3, r5
 801102a:	4622      	mov	r2, r4
 801102c:	4631      	mov	r1, r6
 801102e:	f7ff f8ab 	bl	8010188 <jpeg_fill_bit_buffer>
 8011032:	4603      	mov	r3, r0
 8011034:	2b00      	cmp	r3, #0
 8011036:	d101      	bne.n	801103c <decode_mcu_sub+0x254>
 8011038:	2300      	movs	r3, #0
 801103a:	e0c5      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 801103c:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801103e:	6abc      	ldr	r4, [r7, #40]	; 0x28
	    r = GET_BITS(s);
 8011040:	1b64      	subs	r4, r4, r5
 8011042:	fa46 f204 	asr.w	r2, r6, r4
 8011046:	4b63      	ldr	r3, [pc, #396]	; (80111d4 <decode_mcu_sub+0x3ec>)
 8011048:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 801104c:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 8011050:	1e6b      	subs	r3, r5, #1
 8011052:	4a60      	ldr	r2, [pc, #384]	; (80111d4 <decode_mcu_sub+0x3ec>)
 8011054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011058:	4599      	cmp	r9, r3
 801105a:	dc05      	bgt.n	8011068 <decode_mcu_sub+0x280>
 801105c:	4b5d      	ldr	r3, [pc, #372]	; (80111d4 <decode_mcu_sub+0x3ec>)
 801105e:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8011062:	eba9 0303 	sub.w	r3, r9, r3
 8011066:	e000      	b.n	801106a <decode_mcu_sub+0x282>
 8011068:	464b      	mov	r3, r9
 801106a:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in natural_order[] will save us
	     * if k > Se, which could happen if the data is corrupted.
	     */
	    (*block)[natural_order[k]] = (JCOEF) s;
 801106c:	4643      	mov	r3, r8
 801106e:	009b      	lsls	r3, r3, #2
 8011070:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011072:	4413      	add	r3, r2
 8011074:	681a      	ldr	r2, [r3, #0]
 8011076:	b229      	sxth	r1, r5
 8011078:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801107a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 801107e:	e004      	b.n	801108a <decode_mcu_sub+0x2a2>
	  } else {
	    if (r != 15)
 8011080:	f1b9 0f0f 	cmp.w	r9, #15
 8011084:	d178      	bne.n	8011178 <decode_mcu_sub+0x390>
	      goto EndOfBlock;
	    k += 15;
 8011086:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 801108a:	f108 0801 	add.w	r8, r8, #1
 801108e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011090:	4598      	cmp	r8, r3
 8011092:	db85      	blt.n	8010fa0 <decode_mcu_sub+0x1b8>
 8011094:	e06c      	b.n	8011170 <decode_mcu_sub+0x388>
	  }
	}
      } else {
	if (s) {
 8011096:	2d00      	cmp	r5, #0
 8011098:	d06a      	beq.n	8011170 <decode_mcu_sub+0x388>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801109a:	42ac      	cmp	r4, r5
 801109c:	da0d      	bge.n	80110ba <decode_mcu_sub+0x2d2>
 801109e:	f107 001c 	add.w	r0, r7, #28
 80110a2:	462b      	mov	r3, r5
 80110a4:	4622      	mov	r2, r4
 80110a6:	4631      	mov	r1, r6
 80110a8:	f7ff f86e 	bl	8010188 <jpeg_fill_bit_buffer>
 80110ac:	4603      	mov	r3, r0
 80110ae:	2b00      	cmp	r3, #0
 80110b0:	d101      	bne.n	80110b6 <decode_mcu_sub+0x2ce>
 80110b2:	2300      	movs	r3, #0
 80110b4:	e088      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 80110b6:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80110b8:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  DROP_BITS(s);
 80110ba:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k <= Se; k++) {
 80110bc:	e058      	b.n	8011170 <decode_mcu_sub+0x388>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 80110be:	2c07      	cmp	r4, #7
 80110c0:	dc11      	bgt.n	80110e6 <decode_mcu_sub+0x2fe>
 80110c2:	f107 001c 	add.w	r0, r7, #28
 80110c6:	2300      	movs	r3, #0
 80110c8:	4622      	mov	r2, r4
 80110ca:	4631      	mov	r1, r6
 80110cc:	f7ff f85c 	bl	8010188 <jpeg_fill_bit_buffer>
 80110d0:	4603      	mov	r3, r0
 80110d2:	2b00      	cmp	r3, #0
 80110d4:	d101      	bne.n	80110da <decode_mcu_sub+0x2f2>
 80110d6:	2300      	movs	r3, #0
 80110d8:	e076      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 80110da:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80110dc:	6abc      	ldr	r4, [r7, #40]	; 0x28
 80110de:	2c07      	cmp	r4, #7
 80110e0:	dc01      	bgt.n	80110e6 <decode_mcu_sub+0x2fe>
 80110e2:	2501      	movs	r5, #1
 80110e4:	e015      	b.n	8011112 <decode_mcu_sub+0x32a>
 80110e6:	f1a4 0308 	sub.w	r3, r4, #8
 80110ea:	fa46 f303 	asr.w	r3, r6, r3
 80110ee:	22ff      	movs	r2, #255	; 0xff
 80110f0:	ea03 0902 	and.w	r9, r3, r2
 80110f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80110f6:	f109 0224 	add.w	r2, r9, #36	; 0x24
 80110fa:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80110fe:	2d00      	cmp	r5, #0
 8011100:	d006      	beq.n	8011110 <decode_mcu_sub+0x328>
 8011102:	1b64      	subs	r4, r4, r5
 8011104:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011106:	444b      	add	r3, r9
 8011108:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 801110c:	461d      	mov	r5, r3
 801110e:	e00f      	b.n	8011130 <decode_mcu_sub+0x348>
 8011110:	2509      	movs	r5, #9
 8011112:	f107 001c 	add.w	r0, r7, #28
 8011116:	9500      	str	r5, [sp, #0]
 8011118:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801111a:	4622      	mov	r2, r4
 801111c:	4631      	mov	r1, r6
 801111e:	f7ff f8b9 	bl	8010294 <jpeg_huff_decode>
 8011122:	4605      	mov	r5, r0
 8011124:	2d00      	cmp	r5, #0
 8011126:	da01      	bge.n	801112c <decode_mcu_sub+0x344>
 8011128:	2300      	movs	r3, #0
 801112a:	e04d      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 801112c:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801112e:	6abc      	ldr	r4, [r7, #40]	; 0x28

	r = s >> 4;
 8011130:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 8011134:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 8011138:	2d00      	cmp	r5, #0
 801113a:	d012      	beq.n	8011162 <decode_mcu_sub+0x37a>
	  k += r;
 801113c:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801113e:	42ac      	cmp	r4, r5
 8011140:	da0d      	bge.n	801115e <decode_mcu_sub+0x376>
 8011142:	f107 001c 	add.w	r0, r7, #28
 8011146:	462b      	mov	r3, r5
 8011148:	4622      	mov	r2, r4
 801114a:	4631      	mov	r1, r6
 801114c:	f7ff f81c 	bl	8010188 <jpeg_fill_bit_buffer>
 8011150:	4603      	mov	r3, r0
 8011152:	2b00      	cmp	r3, #0
 8011154:	d101      	bne.n	801115a <decode_mcu_sub+0x372>
 8011156:	2300      	movs	r3, #0
 8011158:	e036      	b.n	80111c8 <decode_mcu_sub+0x3e0>
 801115a:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801115c:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  DROP_BITS(s);
 801115e:	1b64      	subs	r4, r4, r5
 8011160:	e004      	b.n	801116c <decode_mcu_sub+0x384>
	} else {
	  if (r != 15)
 8011162:	f1b9 0f0f 	cmp.w	r9, #15
 8011166:	d109      	bne.n	801117c <decode_mcu_sub+0x394>
	    break;
	  k += 15;
 8011168:	f108 080f 	add.w	r8, r8, #15
      for (; k <= Se; k++) {
 801116c:	f108 0801 	add.w	r8, r8, #1
 8011170:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011172:	4598      	cmp	r8, r3
 8011174:	dda3      	ble.n	80110be <decode_mcu_sub+0x2d6>
	}
      }

      EndOfBlock: ;
 8011176:	e002      	b.n	801117e <decode_mcu_sub+0x396>
	      goto EndOfBlock;
 8011178:	bf00      	nop
 801117a:	e000      	b.n	801117e <decode_mcu_sub+0x396>
	    break;
 801117c:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801117e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011180:	3301      	adds	r3, #1
 8011182:	64fb      	str	r3, [r7, #76]	; 0x4c
 8011184:	687b      	ldr	r3, [r7, #4]
 8011186:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 801118a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801118c:	429a      	cmp	r2, r3
 801118e:	f6ff ae6f 	blt.w	8010e70 <decode_mcu_sub+0x88>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 8011192:	687b      	ldr	r3, [r7, #4]
 8011194:	699b      	ldr	r3, [r3, #24]
 8011196:	69fa      	ldr	r2, [r7, #28]
 8011198:	601a      	str	r2, [r3, #0]
 801119a:	687b      	ldr	r3, [r7, #4]
 801119c:	699b      	ldr	r3, [r3, #24]
 801119e:	6a3a      	ldr	r2, [r7, #32]
 80111a0:	605a      	str	r2, [r3, #4]
 80111a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80111a4:	609e      	str	r6, [r3, #8]
 80111a6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80111a8:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 80111aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80111ac:	f103 0410 	add.w	r4, r3, #16
 80111b0:	f107 0508 	add.w	r5, r7, #8
 80111b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80111b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80111b8:	682b      	ldr	r3, [r5, #0]
 80111ba:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 80111bc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80111be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80111c0:	1e5a      	subs	r2, r3, #1
 80111c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80111c4:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 80111c6:	2301      	movs	r3, #1
}
 80111c8:	4618      	mov	r0, r3
 80111ca:	3754      	adds	r7, #84	; 0x54
 80111cc:	46bd      	mov	sp, r7
 80111ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80111d2:	bf00      	nop
 80111d4:	0802a90c 	.word	0x0802a90c

080111d8 <decode_mcu>:
 * full-size blocks.
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
 80111d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80111dc:	b095      	sub	sp, #84	; 0x54
 80111de:	af02      	add	r7, sp, #8
 80111e0:	6078      	str	r0, [r7, #4]
 80111e2:	6039      	str	r1, [r7, #0]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 80111e4:	687b      	ldr	r3, [r7, #4]
 80111e6:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 80111ea:	643b      	str	r3, [r7, #64]	; 0x40
  int blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
 80111ec:	687b      	ldr	r3, [r7, #4]
 80111ee:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 80111f2:	2b00      	cmp	r3, #0
 80111f4:	d00b      	beq.n	801120e <decode_mcu+0x36>
    if (entropy->restarts_to_go == 0)
 80111f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80111f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80111fa:	2b00      	cmp	r3, #0
 80111fc:	d107      	bne.n	801120e <decode_mcu+0x36>
      if (! process_restart(cinfo))
 80111fe:	6878      	ldr	r0, [r7, #4]
 8011200:	f7ff f8ac 	bl	801035c <process_restart>
 8011204:	4603      	mov	r3, r0
 8011206:	2b00      	cmp	r3, #0
 8011208:	d101      	bne.n	801120e <decode_mcu+0x36>
	return FALSE;
 801120a:	2300      	movs	r3, #0
 801120c:	e1ca      	b.n	80115a4 <decode_mcu+0x3cc>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->insufficient_data) {
 801120e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011210:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011212:	2b00      	cmp	r3, #0
 8011214:	f040 81c0 	bne.w	8011598 <decode_mcu+0x3c0>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
 8011218:	687b      	ldr	r3, [r7, #4]
 801121a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801121c:	687b      	ldr	r3, [r7, #4]
 801121e:	699b      	ldr	r3, [r3, #24]
 8011220:	681b      	ldr	r3, [r3, #0]
 8011222:	61fb      	str	r3, [r7, #28]
 8011224:	687b      	ldr	r3, [r7, #4]
 8011226:	699b      	ldr	r3, [r3, #24]
 8011228:	685b      	ldr	r3, [r3, #4]
 801122a:	623b      	str	r3, [r7, #32]
 801122c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801122e:	689e      	ldr	r6, [r3, #8]
 8011230:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011232:	68dc      	ldr	r4, [r3, #12]
    ASSIGN_STATE(state, entropy->saved);
 8011234:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011236:	f107 0508 	add.w	r5, r7, #8
 801123a:	f103 0c10 	add.w	ip, r3, #16
 801123e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011242:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8011244:	f8dc 3000 	ldr.w	r3, [ip]
 8011248:	602b      	str	r3, [r5, #0]

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801124a:	2300      	movs	r3, #0
 801124c:	647b      	str	r3, [r7, #68]	; 0x44
 801124e:	e187      	b.n	8011560 <decode_mcu+0x388>
      JBLOCKROW block = MCU_data[blkn];
 8011250:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011252:	009b      	lsls	r3, r3, #2
 8011254:	683a      	ldr	r2, [r7, #0]
 8011256:	4413      	add	r3, r2
 8011258:	681b      	ldr	r3, [r3, #0]
 801125a:	63fb      	str	r3, [r7, #60]	; 0x3c
      int coef_limit, ci;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      htbl = entropy->dc_cur_tbls[blkn];
 801125c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801125e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011260:	3218      	adds	r2, #24
 8011262:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011266:	63bb      	str	r3, [r7, #56]	; 0x38
      HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
 8011268:	2c07      	cmp	r4, #7
 801126a:	dc11      	bgt.n	8011290 <decode_mcu+0xb8>
 801126c:	f107 001c 	add.w	r0, r7, #28
 8011270:	2300      	movs	r3, #0
 8011272:	4622      	mov	r2, r4
 8011274:	4631      	mov	r1, r6
 8011276:	f7fe ff87 	bl	8010188 <jpeg_fill_bit_buffer>
 801127a:	4603      	mov	r3, r0
 801127c:	2b00      	cmp	r3, #0
 801127e:	d101      	bne.n	8011284 <decode_mcu+0xac>
 8011280:	2300      	movs	r3, #0
 8011282:	e18f      	b.n	80115a4 <decode_mcu+0x3cc>
 8011284:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8011286:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8011288:	2c07      	cmp	r4, #7
 801128a:	dc01      	bgt.n	8011290 <decode_mcu+0xb8>
 801128c:	2501      	movs	r5, #1
 801128e:	e015      	b.n	80112bc <decode_mcu+0xe4>
 8011290:	f1a4 0308 	sub.w	r3, r4, #8
 8011294:	fa46 f303 	asr.w	r3, r6, r3
 8011298:	22ff      	movs	r2, #255	; 0xff
 801129a:	ea03 0802 	and.w	r8, r3, r2
 801129e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80112a0:	f108 0224 	add.w	r2, r8, #36	; 0x24
 80112a4:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80112a8:	2d00      	cmp	r5, #0
 80112aa:	d006      	beq.n	80112ba <decode_mcu+0xe2>
 80112ac:	1b64      	subs	r4, r4, r5
 80112ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80112b0:	4443      	add	r3, r8
 80112b2:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 80112b6:	461d      	mov	r5, r3
 80112b8:	e00f      	b.n	80112da <decode_mcu+0x102>
 80112ba:	2509      	movs	r5, #9
 80112bc:	f107 001c 	add.w	r0, r7, #28
 80112c0:	9500      	str	r5, [sp, #0]
 80112c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80112c4:	4622      	mov	r2, r4
 80112c6:	4631      	mov	r1, r6
 80112c8:	f7fe ffe4 	bl	8010294 <jpeg_huff_decode>
 80112cc:	4605      	mov	r5, r0
 80112ce:	2d00      	cmp	r5, #0
 80112d0:	da01      	bge.n	80112d6 <decode_mcu+0xfe>
 80112d2:	2300      	movs	r3, #0
 80112d4:	e166      	b.n	80115a4 <decode_mcu+0x3cc>
 80112d6:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80112d8:	6abc      	ldr	r4, [r7, #40]	; 0x28

      htbl = entropy->ac_cur_tbls[blkn];
 80112da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80112dc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80112de:	3222      	adds	r2, #34	; 0x22
 80112e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80112e4:	63bb      	str	r3, [r7, #56]	; 0x38
      k = 1;
 80112e6:	f04f 0801 	mov.w	r8, #1
      coef_limit = entropy->coef_limit[blkn];
 80112ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80112ec:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80112ee:	322c      	adds	r2, #44	; 0x2c
 80112f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80112f4:	637b      	str	r3, [r7, #52]	; 0x34
      if (coef_limit) {
 80112f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80112f8:	2b00      	cmp	r3, #0
 80112fa:	f000 80ba 	beq.w	8011472 <decode_mcu+0x29a>
	/* Convert DC difference to actual value, update last_dc_val */
	if (s) {
 80112fe:	2d00      	cmp	r5, #0
 8011300:	d025      	beq.n	801134e <decode_mcu+0x176>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8011302:	42ac      	cmp	r4, r5
 8011304:	da0d      	bge.n	8011322 <decode_mcu+0x14a>
 8011306:	f107 001c 	add.w	r0, r7, #28
 801130a:	462b      	mov	r3, r5
 801130c:	4622      	mov	r2, r4
 801130e:	4631      	mov	r1, r6
 8011310:	f7fe ff3a 	bl	8010188 <jpeg_fill_bit_buffer>
 8011314:	4603      	mov	r3, r0
 8011316:	2b00      	cmp	r3, #0
 8011318:	d101      	bne.n	801131e <decode_mcu+0x146>
 801131a:	2300      	movs	r3, #0
 801131c:	e142      	b.n	80115a4 <decode_mcu+0x3cc>
 801131e:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8011320:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  r = GET_BITS(s);
 8011322:	1b64      	subs	r4, r4, r5
 8011324:	fa46 f204 	asr.w	r2, r6, r4
 8011328:	4ba1      	ldr	r3, [pc, #644]	; (80115b0 <decode_mcu+0x3d8>)
 801132a:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 801132e:	ea02 0903 	and.w	r9, r2, r3
	  s = HUFF_EXTEND(r, s);
 8011332:	1e6b      	subs	r3, r5, #1
 8011334:	4a9e      	ldr	r2, [pc, #632]	; (80115b0 <decode_mcu+0x3d8>)
 8011336:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801133a:	4599      	cmp	r9, r3
 801133c:	dc05      	bgt.n	801134a <decode_mcu+0x172>
 801133e:	4b9c      	ldr	r3, [pc, #624]	; (80115b0 <decode_mcu+0x3d8>)
 8011340:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8011344:	eba9 0303 	sub.w	r3, r9, r3
 8011348:	e000      	b.n	801134c <decode_mcu+0x174>
 801134a:	464b      	mov	r3, r9
 801134c:	461d      	mov	r5, r3
	}
	ci = cinfo->MCU_membership[blkn];
 801134e:	687b      	ldr	r3, [r7, #4]
 8011350:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011352:	325c      	adds	r2, #92	; 0x5c
 8011354:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011358:	633b      	str	r3, [r7, #48]	; 0x30
	s += state.last_dc_val[ci];
 801135a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801135c:	009b      	lsls	r3, r3, #2
 801135e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8011362:	4413      	add	r3, r2
 8011364:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8011368:	441d      	add	r5, r3
	state.last_dc_val[ci] = s;
 801136a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801136c:	009b      	lsls	r3, r3, #2
 801136e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8011372:	4413      	add	r3, r2
 8011374:	f843 5c3c 	str.w	r5, [r3, #-60]
	/* Output the DC coefficient */
	(*block)[0] = (JCOEF) s;
 8011378:	b22a      	sxth	r2, r5
 801137a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801137c:	801a      	strh	r2, [r3, #0]

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (; k < coef_limit; k++) {
 801137e:	e074      	b.n	801146a <decode_mcu+0x292>
	  HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
 8011380:	2c07      	cmp	r4, #7
 8011382:	dc11      	bgt.n	80113a8 <decode_mcu+0x1d0>
 8011384:	f107 001c 	add.w	r0, r7, #28
 8011388:	2300      	movs	r3, #0
 801138a:	4622      	mov	r2, r4
 801138c:	4631      	mov	r1, r6
 801138e:	f7fe fefb 	bl	8010188 <jpeg_fill_bit_buffer>
 8011392:	4603      	mov	r3, r0
 8011394:	2b00      	cmp	r3, #0
 8011396:	d101      	bne.n	801139c <decode_mcu+0x1c4>
 8011398:	2300      	movs	r3, #0
 801139a:	e103      	b.n	80115a4 <decode_mcu+0x3cc>
 801139c:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801139e:	6abc      	ldr	r4, [r7, #40]	; 0x28
 80113a0:	2c07      	cmp	r4, #7
 80113a2:	dc01      	bgt.n	80113a8 <decode_mcu+0x1d0>
 80113a4:	2501      	movs	r5, #1
 80113a6:	e015      	b.n	80113d4 <decode_mcu+0x1fc>
 80113a8:	f1a4 0308 	sub.w	r3, r4, #8
 80113ac:	fa46 f303 	asr.w	r3, r6, r3
 80113b0:	22ff      	movs	r2, #255	; 0xff
 80113b2:	ea03 0902 	and.w	r9, r3, r2
 80113b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80113b8:	f109 0224 	add.w	r2, r9, #36	; 0x24
 80113bc:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80113c0:	2d00      	cmp	r5, #0
 80113c2:	d006      	beq.n	80113d2 <decode_mcu+0x1fa>
 80113c4:	1b64      	subs	r4, r4, r5
 80113c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80113c8:	444b      	add	r3, r9
 80113ca:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 80113ce:	461d      	mov	r5, r3
 80113d0:	e00f      	b.n	80113f2 <decode_mcu+0x21a>
 80113d2:	2509      	movs	r5, #9
 80113d4:	f107 001c 	add.w	r0, r7, #28
 80113d8:	9500      	str	r5, [sp, #0]
 80113da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80113dc:	4622      	mov	r2, r4
 80113de:	4631      	mov	r1, r6
 80113e0:	f7fe ff58 	bl	8010294 <jpeg_huff_decode>
 80113e4:	4605      	mov	r5, r0
 80113e6:	2d00      	cmp	r5, #0
 80113e8:	da01      	bge.n	80113ee <decode_mcu+0x216>
 80113ea:	2300      	movs	r3, #0
 80113ec:	e0da      	b.n	80115a4 <decode_mcu+0x3cc>
 80113ee:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80113f0:	6abc      	ldr	r4, [r7, #40]	; 0x28

	  r = s >> 4;
 80113f2:	ea4f 1925 	mov.w	r9, r5, asr #4
	  s &= 15;
 80113f6:	f005 050f 	and.w	r5, r5, #15

	  if (s) {
 80113fa:	2d00      	cmp	r5, #0
 80113fc:	d02e      	beq.n	801145c <decode_mcu+0x284>
	    k += r;
 80113fe:	44c8      	add	r8, r9
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8011400:	42ac      	cmp	r4, r5
 8011402:	da0d      	bge.n	8011420 <decode_mcu+0x248>
 8011404:	f107 001c 	add.w	r0, r7, #28
 8011408:	462b      	mov	r3, r5
 801140a:	4622      	mov	r2, r4
 801140c:	4631      	mov	r1, r6
 801140e:	f7fe febb 	bl	8010188 <jpeg_fill_bit_buffer>
 8011412:	4603      	mov	r3, r0
 8011414:	2b00      	cmp	r3, #0
 8011416:	d101      	bne.n	801141c <decode_mcu+0x244>
 8011418:	2300      	movs	r3, #0
 801141a:	e0c3      	b.n	80115a4 <decode_mcu+0x3cc>
 801141c:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801141e:	6abc      	ldr	r4, [r7, #40]	; 0x28
	    r = GET_BITS(s);
 8011420:	1b64      	subs	r4, r4, r5
 8011422:	fa46 f204 	asr.w	r2, r6, r4
 8011426:	4b62      	ldr	r3, [pc, #392]	; (80115b0 <decode_mcu+0x3d8>)
 8011428:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 801142c:	ea02 0903 	and.w	r9, r2, r3
	    s = HUFF_EXTEND(r, s);
 8011430:	1e6b      	subs	r3, r5, #1
 8011432:	4a5f      	ldr	r2, [pc, #380]	; (80115b0 <decode_mcu+0x3d8>)
 8011434:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011438:	4599      	cmp	r9, r3
 801143a:	dc05      	bgt.n	8011448 <decode_mcu+0x270>
 801143c:	4b5c      	ldr	r3, [pc, #368]	; (80115b0 <decode_mcu+0x3d8>)
 801143e:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8011442:	eba9 0303 	sub.w	r3, r9, r3
 8011446:	e000      	b.n	801144a <decode_mcu+0x272>
 8011448:	464b      	mov	r3, r9
 801144a:	461d      	mov	r5, r3
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
 801144c:	4b59      	ldr	r3, [pc, #356]	; (80115b4 <decode_mcu+0x3dc>)
 801144e:	f853 2028 	ldr.w	r2, [r3, r8, lsl #2]
 8011452:	b229      	sxth	r1, r5
 8011454:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011456:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 801145a:	e004      	b.n	8011466 <decode_mcu+0x28e>
	  } else {
	    if (r != 15)
 801145c:	f1b9 0f0f 	cmp.w	r9, #15
 8011460:	d178      	bne.n	8011554 <decode_mcu+0x37c>
	      goto EndOfBlock;
	    k += 15;
 8011462:	f108 080f 	add.w	r8, r8, #15
	for (; k < coef_limit; k++) {
 8011466:	f108 0801 	add.w	r8, r8, #1
 801146a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801146c:	4598      	cmp	r8, r3
 801146e:	db87      	blt.n	8011380 <decode_mcu+0x1a8>
 8011470:	e06c      	b.n	801154c <decode_mcu+0x374>
	  }
	}
      } else {
	if (s) {
 8011472:	2d00      	cmp	r5, #0
 8011474:	d06a      	beq.n	801154c <decode_mcu+0x374>
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 8011476:	42ac      	cmp	r4, r5
 8011478:	da0d      	bge.n	8011496 <decode_mcu+0x2be>
 801147a:	f107 001c 	add.w	r0, r7, #28
 801147e:	462b      	mov	r3, r5
 8011480:	4622      	mov	r2, r4
 8011482:	4631      	mov	r1, r6
 8011484:	f7fe fe80 	bl	8010188 <jpeg_fill_bit_buffer>
 8011488:	4603      	mov	r3, r0
 801148a:	2b00      	cmp	r3, #0
 801148c:	d101      	bne.n	8011492 <decode_mcu+0x2ba>
 801148e:	2300      	movs	r3, #0
 8011490:	e088      	b.n	80115a4 <decode_mcu+0x3cc>
 8011492:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8011494:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  DROP_BITS(s);
 8011496:	1b64      	subs	r4, r4, r5
	}
      }

      /* Section F.2.2.2: decode the AC coefficients */
      /* In this path we just discard the values */
      for (; k < DCTSIZE2; k++) {
 8011498:	e058      	b.n	801154c <decode_mcu+0x374>
	HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
 801149a:	2c07      	cmp	r4, #7
 801149c:	dc11      	bgt.n	80114c2 <decode_mcu+0x2ea>
 801149e:	f107 001c 	add.w	r0, r7, #28
 80114a2:	2300      	movs	r3, #0
 80114a4:	4622      	mov	r2, r4
 80114a6:	4631      	mov	r1, r6
 80114a8:	f7fe fe6e 	bl	8010188 <jpeg_fill_bit_buffer>
 80114ac:	4603      	mov	r3, r0
 80114ae:	2b00      	cmp	r3, #0
 80114b0:	d101      	bne.n	80114b6 <decode_mcu+0x2de>
 80114b2:	2300      	movs	r3, #0
 80114b4:	e076      	b.n	80115a4 <decode_mcu+0x3cc>
 80114b6:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80114b8:	6abc      	ldr	r4, [r7, #40]	; 0x28
 80114ba:	2c07      	cmp	r4, #7
 80114bc:	dc01      	bgt.n	80114c2 <decode_mcu+0x2ea>
 80114be:	2501      	movs	r5, #1
 80114c0:	e015      	b.n	80114ee <decode_mcu+0x316>
 80114c2:	f1a4 0308 	sub.w	r3, r4, #8
 80114c6:	fa46 f303 	asr.w	r3, r6, r3
 80114ca:	22ff      	movs	r2, #255	; 0xff
 80114cc:	ea03 0902 	and.w	r9, r3, r2
 80114d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114d2:	f109 0224 	add.w	r2, r9, #36	; 0x24
 80114d6:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 80114da:	2d00      	cmp	r5, #0
 80114dc:	d006      	beq.n	80114ec <decode_mcu+0x314>
 80114de:	1b64      	subs	r4, r4, r5
 80114e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114e2:	444b      	add	r3, r9
 80114e4:	f893 3490 	ldrb.w	r3, [r3, #1168]	; 0x490
 80114e8:	461d      	mov	r5, r3
 80114ea:	e00f      	b.n	801150c <decode_mcu+0x334>
 80114ec:	2509      	movs	r5, #9
 80114ee:	f107 001c 	add.w	r0, r7, #28
 80114f2:	9500      	str	r5, [sp, #0]
 80114f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80114f6:	4622      	mov	r2, r4
 80114f8:	4631      	mov	r1, r6
 80114fa:	f7fe fecb 	bl	8010294 <jpeg_huff_decode>
 80114fe:	4605      	mov	r5, r0
 8011500:	2d00      	cmp	r5, #0
 8011502:	da01      	bge.n	8011508 <decode_mcu+0x330>
 8011504:	2300      	movs	r3, #0
 8011506:	e04d      	b.n	80115a4 <decode_mcu+0x3cc>
 8011508:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 801150a:	6abc      	ldr	r4, [r7, #40]	; 0x28

	r = s >> 4;
 801150c:	ea4f 1925 	mov.w	r9, r5, asr #4
	s &= 15;
 8011510:	f005 050f 	and.w	r5, r5, #15

	if (s) {
 8011514:	2d00      	cmp	r5, #0
 8011516:	d012      	beq.n	801153e <decode_mcu+0x366>
	  k += r;
 8011518:	44c8      	add	r8, r9
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
 801151a:	42ac      	cmp	r4, r5
 801151c:	da0d      	bge.n	801153a <decode_mcu+0x362>
 801151e:	f107 001c 	add.w	r0, r7, #28
 8011522:	462b      	mov	r3, r5
 8011524:	4622      	mov	r2, r4
 8011526:	4631      	mov	r1, r6
 8011528:	f7fe fe2e 	bl	8010188 <jpeg_fill_bit_buffer>
 801152c:	4603      	mov	r3, r0
 801152e:	2b00      	cmp	r3, #0
 8011530:	d101      	bne.n	8011536 <decode_mcu+0x35e>
 8011532:	2300      	movs	r3, #0
 8011534:	e036      	b.n	80115a4 <decode_mcu+0x3cc>
 8011536:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8011538:	6abc      	ldr	r4, [r7, #40]	; 0x28
	  DROP_BITS(s);
 801153a:	1b64      	subs	r4, r4, r5
 801153c:	e004      	b.n	8011548 <decode_mcu+0x370>
	} else {
	  if (r != 15)
 801153e:	f1b9 0f0f 	cmp.w	r9, #15
 8011542:	d109      	bne.n	8011558 <decode_mcu+0x380>
	    break;
	  k += 15;
 8011544:	f108 080f 	add.w	r8, r8, #15
      for (; k < DCTSIZE2; k++) {
 8011548:	f108 0801 	add.w	r8, r8, #1
 801154c:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
 8011550:	dda3      	ble.n	801149a <decode_mcu+0x2c2>
	}
      }

      EndOfBlock: ;
 8011552:	e002      	b.n	801155a <decode_mcu+0x382>
	      goto EndOfBlock;
 8011554:	bf00      	nop
 8011556:	e000      	b.n	801155a <decode_mcu+0x382>
	    break;
 8011558:	bf00      	nop
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801155a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801155c:	3301      	adds	r3, #1
 801155e:	647b      	str	r3, [r7, #68]	; 0x44
 8011560:	687b      	ldr	r3, [r7, #4]
 8011562:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 8011566:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011568:	429a      	cmp	r2, r3
 801156a:	f6ff ae71 	blt.w	8011250 <decode_mcu+0x78>
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
 801156e:	687b      	ldr	r3, [r7, #4]
 8011570:	699b      	ldr	r3, [r3, #24]
 8011572:	69fa      	ldr	r2, [r7, #28]
 8011574:	601a      	str	r2, [r3, #0]
 8011576:	687b      	ldr	r3, [r7, #4]
 8011578:	699b      	ldr	r3, [r3, #24]
 801157a:	6a3a      	ldr	r2, [r7, #32]
 801157c:	605a      	str	r2, [r3, #4]
 801157e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011580:	609e      	str	r6, [r3, #8]
 8011582:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011584:	60dc      	str	r4, [r3, #12]
    ASSIGN_STATE(entropy->saved, state);
 8011586:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011588:	f103 0410 	add.w	r4, r3, #16
 801158c:	f107 0508 	add.w	r5, r7, #8
 8011590:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8011592:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011594:	682b      	ldr	r3, [r5, #0]
 8011596:	6023      	str	r3, [r4, #0]
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
 8011598:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801159a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801159c:	1e5a      	subs	r2, r3, #1
 801159e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80115a0:	629a      	str	r2, [r3, #40]	; 0x28

  return TRUE;
 80115a2:	2301      	movs	r3, #1
}
 80115a4:	4618      	mov	r0, r3
 80115a6:	374c      	adds	r7, #76	; 0x4c
 80115a8:	46bd      	mov	sp, r7
 80115aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80115ae:	bf00      	nop
 80115b0:	0802a90c 	.word	0x0802a90c
 80115b4:	0802ac68 	.word	0x0802ac68

080115b8 <start_pass_huff_decoder>:
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
 80115b8:	b580      	push	{r7, lr}
 80115ba:	b08c      	sub	sp, #48	; 0x30
 80115bc:	af00      	add	r7, sp, #0
 80115be:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
 80115c0:	687b      	ldr	r3, [r7, #4]
 80115c2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 80115c6:	61fb      	str	r3, [r7, #28]
  int ci, blkn, tbl, i;
  jpeg_component_info * compptr;

  if (cinfo->progressive_mode) {
 80115c8:	687b      	ldr	r3, [r7, #4]
 80115ca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80115ce:	2b00      	cmp	r3, #0
 80115d0:	f000 8133 	beq.w	801183a <start_pass_huff_decoder+0x282>
    /* Validate progressive scan parameters */
    if (cinfo->Ss == 0) {
 80115d4:	687b      	ldr	r3, [r7, #4]
 80115d6:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80115da:	2b00      	cmp	r3, #0
 80115dc:	d105      	bne.n	80115ea <start_pass_huff_decoder+0x32>
      if (cinfo->Se != 0)
 80115de:	687b      	ldr	r3, [r7, #4]
 80115e0:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 80115e4:	2b00      	cmp	r3, #0
 80115e6:	d015      	beq.n	8011614 <start_pass_huff_decoder+0x5c>
	goto bad;
 80115e8:	e02d      	b.n	8011646 <start_pass_huff_decoder+0x8e>
    } else {
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Se < cinfo->Ss || cinfo->Se > cinfo->lim_Se)
 80115ea:	687b      	ldr	r3, [r7, #4]
 80115ec:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 80115f0:	687b      	ldr	r3, [r7, #4]
 80115f2:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80115f6:	429a      	cmp	r2, r3
 80115f8:	db20      	blt.n	801163c <start_pass_huff_decoder+0x84>
 80115fa:	687b      	ldr	r3, [r7, #4]
 80115fc:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 8011600:	687b      	ldr	r3, [r7, #4]
 8011602:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 8011606:	429a      	cmp	r2, r3
 8011608:	dc18      	bgt.n	801163c <start_pass_huff_decoder+0x84>
	goto bad;
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan != 1)
 801160a:	687b      	ldr	r3, [r7, #4]
 801160c:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8011610:	2b01      	cmp	r3, #1
 8011612:	d115      	bne.n	8011640 <start_pass_huff_decoder+0x88>
	goto bad;
    }
    if (cinfo->Ah != 0) {
 8011614:	687b      	ldr	r3, [r7, #4]
 8011616:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801161a:	2b00      	cmp	r3, #0
 801161c:	d008      	beq.n	8011630 <start_pass_huff_decoder+0x78>
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Ah-1 != cinfo->Al)
 801161e:	687b      	ldr	r3, [r7, #4]
 8011620:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8011624:	1e5a      	subs	r2, r3, #1
 8011626:	687b      	ldr	r3, [r7, #4]
 8011628:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 801162c:	429a      	cmp	r2, r3
 801162e:	d109      	bne.n	8011644 <start_pass_huff_decoder+0x8c>
	goto bad;
    }
    if (cinfo->Al > 13) {	/* need not check for < 0 */
 8011630:	687b      	ldr	r3, [r7, #4]
 8011632:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8011636:	2b0d      	cmp	r3, #13
 8011638:	dd26      	ble.n	8011688 <start_pass_huff_decoder+0xd0>
       * but the spec doesn't say so, and we try to be liberal about what we
       * accept.  Note: large Al values could result in out-of-range DC
       * coefficients during early scans, leading to bizarre displays due to
       * overflows in the IDCT math.  But we won't crash.
       */
      bad:
 801163a:	e004      	b.n	8011646 <start_pass_huff_decoder+0x8e>
	goto bad;
 801163c:	bf00      	nop
 801163e:	e002      	b.n	8011646 <start_pass_huff_decoder+0x8e>
	goto bad;
 8011640:	bf00      	nop
 8011642:	e000      	b.n	8011646 <start_pass_huff_decoder+0x8e>
	goto bad;
 8011644:	bf00      	nop
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	681b      	ldr	r3, [r3, #0]
 801164a:	2211      	movs	r2, #17
 801164c:	615a      	str	r2, [r3, #20]
 801164e:	687b      	ldr	r3, [r7, #4]
 8011650:	681b      	ldr	r3, [r3, #0]
 8011652:	687a      	ldr	r2, [r7, #4]
 8011654:	f8d2 2198 	ldr.w	r2, [r2, #408]	; 0x198
 8011658:	619a      	str	r2, [r3, #24]
 801165a:	687b      	ldr	r3, [r7, #4]
 801165c:	681b      	ldr	r3, [r3, #0]
 801165e:	687a      	ldr	r2, [r7, #4]
 8011660:	f8d2 219c 	ldr.w	r2, [r2, #412]	; 0x19c
 8011664:	61da      	str	r2, [r3, #28]
 8011666:	687b      	ldr	r3, [r7, #4]
 8011668:	681b      	ldr	r3, [r3, #0]
 801166a:	687a      	ldr	r2, [r7, #4]
 801166c:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
 8011670:	621a      	str	r2, [r3, #32]
 8011672:	687b      	ldr	r3, [r7, #4]
 8011674:	681b      	ldr	r3, [r3, #0]
 8011676:	687a      	ldr	r2, [r7, #4]
 8011678:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 801167c:	625a      	str	r2, [r3, #36]	; 0x24
 801167e:	687b      	ldr	r3, [r7, #4]
 8011680:	681b      	ldr	r3, [r3, #0]
 8011682:	681b      	ldr	r3, [r3, #0]
 8011684:	6878      	ldr	r0, [r7, #4]
 8011686:	4798      	blx	r3
    }
    /* Update progression status, and verify that scan order is legal.
     * Note that inter-scan inconsistencies are treated as warnings
     * not fatal errors ... not clear if this is right way to behave.
     */
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8011688:	2300      	movs	r3, #0
 801168a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801168c:	e064      	b.n	8011758 <start_pass_huff_decoder+0x1a0>
      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;
 801168e:	687a      	ldr	r2, [r7, #4]
 8011690:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011692:	3354      	adds	r3, #84	; 0x54
 8011694:	009b      	lsls	r3, r3, #2
 8011696:	4413      	add	r3, r2
 8011698:	685b      	ldr	r3, [r3, #4]
 801169a:	685b      	ldr	r3, [r3, #4]
 801169c:	613b      	str	r3, [r7, #16]
      int *coef_bit_ptr = & cinfo->coef_bits[cindex][0];
 801169e:	687b      	ldr	r3, [r7, #4]
 80116a0:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 80116a4:	693b      	ldr	r3, [r7, #16]
 80116a6:	021b      	lsls	r3, r3, #8
 80116a8:	4413      	add	r3, r2
 80116aa:	60fb      	str	r3, [r7, #12]
      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
 80116ac:	687b      	ldr	r3, [r7, #4]
 80116ae:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80116b2:	2b00      	cmp	r3, #0
 80116b4:	d016      	beq.n	80116e4 <start_pass_huff_decoder+0x12c>
 80116b6:	68fb      	ldr	r3, [r7, #12]
 80116b8:	681b      	ldr	r3, [r3, #0]
 80116ba:	2b00      	cmp	r3, #0
 80116bc:	da12      	bge.n	80116e4 <start_pass_huff_decoder+0x12c>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
 80116be:	687b      	ldr	r3, [r7, #4]
 80116c0:	681b      	ldr	r3, [r3, #0]
 80116c2:	2276      	movs	r2, #118	; 0x76
 80116c4:	615a      	str	r2, [r3, #20]
 80116c6:	687b      	ldr	r3, [r7, #4]
 80116c8:	681b      	ldr	r3, [r3, #0]
 80116ca:	693a      	ldr	r2, [r7, #16]
 80116cc:	619a      	str	r2, [r3, #24]
 80116ce:	687b      	ldr	r3, [r7, #4]
 80116d0:	681b      	ldr	r3, [r3, #0]
 80116d2:	2200      	movs	r2, #0
 80116d4:	61da      	str	r2, [r3, #28]
 80116d6:	687b      	ldr	r3, [r7, #4]
 80116d8:	681b      	ldr	r3, [r3, #0]
 80116da:	685b      	ldr	r3, [r3, #4]
 80116dc:	f04f 31ff 	mov.w	r1, #4294967295
 80116e0:	6878      	ldr	r0, [r7, #4]
 80116e2:	4798      	blx	r3
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 80116e4:	687b      	ldr	r3, [r7, #4]
 80116e6:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80116ea:	623b      	str	r3, [r7, #32]
 80116ec:	e02b      	b.n	8011746 <start_pass_huff_decoder+0x18e>
	int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
 80116ee:	6a3b      	ldr	r3, [r7, #32]
 80116f0:	009b      	lsls	r3, r3, #2
 80116f2:	68fa      	ldr	r2, [r7, #12]
 80116f4:	4413      	add	r3, r2
 80116f6:	681b      	ldr	r3, [r3, #0]
 80116f8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80116fc:	60bb      	str	r3, [r7, #8]
	if (cinfo->Ah != expected)
 80116fe:	687b      	ldr	r3, [r7, #4]
 8011700:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8011704:	68ba      	ldr	r2, [r7, #8]
 8011706:	429a      	cmp	r2, r3
 8011708:	d012      	beq.n	8011730 <start_pass_huff_decoder+0x178>
	  WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
 801170a:	687b      	ldr	r3, [r7, #4]
 801170c:	681b      	ldr	r3, [r3, #0]
 801170e:	2276      	movs	r2, #118	; 0x76
 8011710:	615a      	str	r2, [r3, #20]
 8011712:	687b      	ldr	r3, [r7, #4]
 8011714:	681b      	ldr	r3, [r3, #0]
 8011716:	693a      	ldr	r2, [r7, #16]
 8011718:	619a      	str	r2, [r3, #24]
 801171a:	687b      	ldr	r3, [r7, #4]
 801171c:	681b      	ldr	r3, [r3, #0]
 801171e:	6a3a      	ldr	r2, [r7, #32]
 8011720:	61da      	str	r2, [r3, #28]
 8011722:	687b      	ldr	r3, [r7, #4]
 8011724:	681b      	ldr	r3, [r3, #0]
 8011726:	685b      	ldr	r3, [r3, #4]
 8011728:	f04f 31ff 	mov.w	r1, #4294967295
 801172c:	6878      	ldr	r0, [r7, #4]
 801172e:	4798      	blx	r3
	coef_bit_ptr[coefi] = cinfo->Al;
 8011730:	6a3b      	ldr	r3, [r7, #32]
 8011732:	009b      	lsls	r3, r3, #2
 8011734:	68fa      	ldr	r2, [r7, #12]
 8011736:	4413      	add	r3, r2
 8011738:	687a      	ldr	r2, [r7, #4]
 801173a:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 801173e:	601a      	str	r2, [r3, #0]
      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
 8011740:	6a3b      	ldr	r3, [r7, #32]
 8011742:	3301      	adds	r3, #1
 8011744:	623b      	str	r3, [r7, #32]
 8011746:	687b      	ldr	r3, [r7, #4]
 8011748:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 801174c:	6a3a      	ldr	r2, [r7, #32]
 801174e:	429a      	cmp	r2, r3
 8011750:	ddcd      	ble.n	80116ee <start_pass_huff_decoder+0x136>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8011752:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011754:	3301      	adds	r3, #1
 8011756:	62fb      	str	r3, [r7, #44]	; 0x2c
 8011758:	687b      	ldr	r3, [r7, #4]
 801175a:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 801175e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011760:	429a      	cmp	r2, r3
 8011762:	db94      	blt.n	801168e <start_pass_huff_decoder+0xd6>
      }
    }

    /* Select MCU decoding routine */
    if (cinfo->Ah == 0) {
 8011764:	687b      	ldr	r3, [r7, #4]
 8011766:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801176a:	2b00      	cmp	r3, #0
 801176c:	d10c      	bne.n	8011788 <start_pass_huff_decoder+0x1d0>
      if (cinfo->Ss == 0)
 801176e:	687b      	ldr	r3, [r7, #4]
 8011770:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8011774:	2b00      	cmp	r3, #0
 8011776:	d103      	bne.n	8011780 <start_pass_huff_decoder+0x1c8>
	entropy->pub.decode_mcu = decode_mcu_DC_first;
 8011778:	69fb      	ldr	r3, [r7, #28]
 801177a:	4a6a      	ldr	r2, [pc, #424]	; (8011924 <start_pass_huff_decoder+0x36c>)
 801177c:	605a      	str	r2, [r3, #4]
 801177e:	e00f      	b.n	80117a0 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_first;
 8011780:	69fb      	ldr	r3, [r7, #28]
 8011782:	4a69      	ldr	r2, [pc, #420]	; (8011928 <start_pass_huff_decoder+0x370>)
 8011784:	605a      	str	r2, [r3, #4]
 8011786:	e00b      	b.n	80117a0 <start_pass_huff_decoder+0x1e8>
    } else {
      if (cinfo->Ss == 0)
 8011788:	687b      	ldr	r3, [r7, #4]
 801178a:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 801178e:	2b00      	cmp	r3, #0
 8011790:	d103      	bne.n	801179a <start_pass_huff_decoder+0x1e2>
	entropy->pub.decode_mcu = decode_mcu_DC_refine;
 8011792:	69fb      	ldr	r3, [r7, #28]
 8011794:	4a65      	ldr	r2, [pc, #404]	; (801192c <start_pass_huff_decoder+0x374>)
 8011796:	605a      	str	r2, [r3, #4]
 8011798:	e002      	b.n	80117a0 <start_pass_huff_decoder+0x1e8>
      else
	entropy->pub.decode_mcu = decode_mcu_AC_refine;
 801179a:	69fb      	ldr	r3, [r7, #28]
 801179c:	4a64      	ldr	r2, [pc, #400]	; (8011930 <start_pass_huff_decoder+0x378>)
 801179e:	605a      	str	r2, [r3, #4]
    }

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80117a0:	2300      	movs	r3, #0
 80117a2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80117a4:	e03f      	b.n	8011826 <start_pass_huff_decoder+0x26e>
      compptr = cinfo->cur_comp_info[ci];
 80117a6:	687a      	ldr	r2, [r7, #4]
 80117a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117aa:	3354      	adds	r3, #84	; 0x54
 80117ac:	009b      	lsls	r3, r3, #2
 80117ae:	4413      	add	r3, r2
 80117b0:	685b      	ldr	r3, [r3, #4]
 80117b2:	61bb      	str	r3, [r7, #24]
      /* Make sure requested tables are present, and compute derived tables.
       * We may build same derived table more than once, but it's not expensive.
       */
      if (cinfo->Ss == 0) {
 80117b4:	687b      	ldr	r3, [r7, #4]
 80117b6:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80117ba:	2b00      	cmp	r3, #0
 80117bc:	d113      	bne.n	80117e6 <start_pass_huff_decoder+0x22e>
	if (cinfo->Ah == 0) {	/* DC refinement needs no table */
 80117be:	687b      	ldr	r3, [r7, #4]
 80117c0:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 80117c4:	2b00      	cmp	r3, #0
 80117c6:	d124      	bne.n	8011812 <start_pass_huff_decoder+0x25a>
	  tbl = compptr->dc_tbl_no;
 80117c8:	69bb      	ldr	r3, [r7, #24]
 80117ca:	695b      	ldr	r3, [r3, #20]
 80117cc:	617b      	str	r3, [r7, #20]
	  jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 80117ce:	697b      	ldr	r3, [r7, #20]
 80117d0:	330a      	adds	r3, #10
 80117d2:	009b      	lsls	r3, r3, #2
 80117d4:	69fa      	ldr	r2, [r7, #28]
 80117d6:	4413      	add	r3, r2
 80117d8:	3304      	adds	r3, #4
 80117da:	697a      	ldr	r2, [r7, #20]
 80117dc:	2101      	movs	r1, #1
 80117de:	6878      	ldr	r0, [r7, #4]
 80117e0:	f7fe fab4 	bl	800fd4c <jpeg_make_d_derived_tbl>
 80117e4:	e015      	b.n	8011812 <start_pass_huff_decoder+0x25a>
				  & entropy->derived_tbls[tbl]);
	}
      } else {
	tbl = compptr->ac_tbl_no;
 80117e6:	69bb      	ldr	r3, [r7, #24]
 80117e8:	699b      	ldr	r3, [r3, #24]
 80117ea:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 80117ec:	697b      	ldr	r3, [r7, #20]
 80117ee:	330a      	adds	r3, #10
 80117f0:	009b      	lsls	r3, r3, #2
 80117f2:	69fa      	ldr	r2, [r7, #28]
 80117f4:	4413      	add	r3, r2
 80117f6:	3304      	adds	r3, #4
 80117f8:	697a      	ldr	r2, [r7, #20]
 80117fa:	2100      	movs	r1, #0
 80117fc:	6878      	ldr	r0, [r7, #4]
 80117fe:	f7fe faa5 	bl	800fd4c <jpeg_make_d_derived_tbl>
				& entropy->derived_tbls[tbl]);
	/* remember the single active table */
	entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
 8011802:	69fa      	ldr	r2, [r7, #28]
 8011804:	697b      	ldr	r3, [r7, #20]
 8011806:	330a      	adds	r3, #10
 8011808:	009b      	lsls	r3, r3, #2
 801180a:	4413      	add	r3, r2
 801180c:	685a      	ldr	r2, [r3, #4]
 801180e:	69fb      	ldr	r3, [r7, #28]
 8011810:	63da      	str	r2, [r3, #60]	; 0x3c
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 8011812:	69fa      	ldr	r2, [r7, #28]
 8011814:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011816:	3304      	adds	r3, #4
 8011818:	009b      	lsls	r3, r3, #2
 801181a:	4413      	add	r3, r2
 801181c:	2200      	movs	r2, #0
 801181e:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8011820:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011822:	3301      	adds	r3, #1
 8011824:	62fb      	str	r3, [r7, #44]	; 0x2c
 8011826:	687b      	ldr	r3, [r7, #4]
 8011828:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 801182c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801182e:	429a      	cmp	r2, r3
 8011830:	dbb9      	blt.n	80117a6 <start_pass_huff_decoder+0x1ee>
    }

    /* Initialize private state variables */
    entropy->saved.EOBRUN = 0;
 8011832:	69fb      	ldr	r3, [r7, #28]
 8011834:	2200      	movs	r2, #0
 8011836:	611a      	str	r2, [r3, #16]
 8011838:	e21a      	b.n	8011c70 <start_pass_huff_decoder+0x6b8>
  } else {
    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
     * This ought to be an error condition, but we make it a warning because
     * there are some baseline files out there with all zeroes in these bytes.
     */
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 801183a:	687b      	ldr	r3, [r7, #4]
 801183c:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8011840:	2b00      	cmp	r3, #0
 8011842:	d11b      	bne.n	801187c <start_pass_huff_decoder+0x2c4>
 8011844:	687b      	ldr	r3, [r7, #4]
 8011846:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 801184a:	2b00      	cmp	r3, #0
 801184c:	d116      	bne.n	801187c <start_pass_huff_decoder+0x2c4>
 801184e:	687b      	ldr	r3, [r7, #4]
 8011850:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8011854:	2b00      	cmp	r3, #0
 8011856:	d111      	bne.n	801187c <start_pass_huff_decoder+0x2c4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 8011858:	687b      	ldr	r3, [r7, #4]
 801185a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
    if (cinfo->Ss != 0 || cinfo->Ah != 0 || cinfo->Al != 0 ||
 801185e:	2b00      	cmp	r3, #0
 8011860:	d104      	bne.n	801186c <start_pass_huff_decoder+0x2b4>
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 8011862:	687b      	ldr	r3, [r7, #4]
 8011864:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 8011868:	2b3f      	cmp	r3, #63	; 0x3f
 801186a:	dc12      	bgt.n	8011892 <start_pass_huff_decoder+0x2da>
	cinfo->Se != cinfo->lim_Se))
 801186c:	687b      	ldr	r3, [r7, #4]
 801186e:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 8011872:	687b      	ldr	r3, [r7, #4]
 8011874:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
	((cinfo->is_baseline || cinfo->Se < DCTSIZE2) &&
 8011878:	429a      	cmp	r2, r3
 801187a:	d00a      	beq.n	8011892 <start_pass_huff_decoder+0x2da>
      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
 801187c:	687b      	ldr	r3, [r7, #4]
 801187e:	681b      	ldr	r3, [r3, #0]
 8011880:	227d      	movs	r2, #125	; 0x7d
 8011882:	615a      	str	r2, [r3, #20]
 8011884:	687b      	ldr	r3, [r7, #4]
 8011886:	681b      	ldr	r3, [r3, #0]
 8011888:	685b      	ldr	r3, [r3, #4]
 801188a:	f04f 31ff 	mov.w	r1, #4294967295
 801188e:	6878      	ldr	r0, [r7, #4]
 8011890:	4798      	blx	r3
     * This is not necessary, but it appears that this version is slightly
     * more performant in the given implementation.
     * With an improved implementation we would prefer a single optimized
     * function.
     */
    if (cinfo->lim_Se != DCTSIZE2-1)
 8011892:	687b      	ldr	r3, [r7, #4]
 8011894:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 8011898:	2b3f      	cmp	r3, #63	; 0x3f
 801189a:	d003      	beq.n	80118a4 <start_pass_huff_decoder+0x2ec>
      entropy->pub.decode_mcu = decode_mcu_sub;
 801189c:	69fb      	ldr	r3, [r7, #28]
 801189e:	4a25      	ldr	r2, [pc, #148]	; (8011934 <start_pass_huff_decoder+0x37c>)
 80118a0:	605a      	str	r2, [r3, #4]
 80118a2:	e002      	b.n	80118aa <start_pass_huff_decoder+0x2f2>
    else
      entropy->pub.decode_mcu = decode_mcu;
 80118a4:	69fb      	ldr	r3, [r7, #28]
 80118a6:	4a24      	ldr	r2, [pc, #144]	; (8011938 <start_pass_huff_decoder+0x380>)
 80118a8:	605a      	str	r2, [r3, #4]

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 80118aa:	2300      	movs	r3, #0
 80118ac:	62fb      	str	r3, [r7, #44]	; 0x2c
 80118ae:	e02f      	b.n	8011910 <start_pass_huff_decoder+0x358>
      compptr = cinfo->cur_comp_info[ci];
 80118b0:	687a      	ldr	r2, [r7, #4]
 80118b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80118b4:	3354      	adds	r3, #84	; 0x54
 80118b6:	009b      	lsls	r3, r3, #2
 80118b8:	4413      	add	r3, r2
 80118ba:	685b      	ldr	r3, [r3, #4]
 80118bc:	61bb      	str	r3, [r7, #24]
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      tbl = compptr->dc_tbl_no;
 80118be:	69bb      	ldr	r3, [r7, #24]
 80118c0:	695b      	ldr	r3, [r3, #20]
 80118c2:	617b      	str	r3, [r7, #20]
      jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
 80118c4:	697b      	ldr	r3, [r7, #20]
 80118c6:	3310      	adds	r3, #16
 80118c8:	009b      	lsls	r3, r3, #2
 80118ca:	69fa      	ldr	r2, [r7, #28]
 80118cc:	4413      	add	r3, r2
 80118ce:	697a      	ldr	r2, [r7, #20]
 80118d0:	2101      	movs	r1, #1
 80118d2:	6878      	ldr	r0, [r7, #4]
 80118d4:	f7fe fa3a 	bl	800fd4c <jpeg_make_d_derived_tbl>
			      & entropy->dc_derived_tbls[tbl]);
      if (cinfo->lim_Se) {	/* AC needs no table when not present */
 80118d8:	687b      	ldr	r3, [r7, #4]
 80118da:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 80118de:	2b00      	cmp	r3, #0
 80118e0:	d00c      	beq.n	80118fc <start_pass_huff_decoder+0x344>
	tbl = compptr->ac_tbl_no;
 80118e2:	69bb      	ldr	r3, [r7, #24]
 80118e4:	699b      	ldr	r3, [r3, #24]
 80118e6:	617b      	str	r3, [r7, #20]
	jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
 80118e8:	697b      	ldr	r3, [r7, #20]
 80118ea:	3314      	adds	r3, #20
 80118ec:	009b      	lsls	r3, r3, #2
 80118ee:	69fa      	ldr	r2, [r7, #28]
 80118f0:	4413      	add	r3, r2
 80118f2:	697a      	ldr	r2, [r7, #20]
 80118f4:	2100      	movs	r1, #0
 80118f6:	6878      	ldr	r0, [r7, #4]
 80118f8:	f7fe fa28 	bl	800fd4c <jpeg_make_d_derived_tbl>
				& entropy->ac_derived_tbls[tbl]);
      }
      /* Initialize DC predictions to 0 */
      entropy->saved.last_dc_val[ci] = 0;
 80118fc:	69fa      	ldr	r2, [r7, #28]
 80118fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011900:	3304      	adds	r3, #4
 8011902:	009b      	lsls	r3, r3, #2
 8011904:	4413      	add	r3, r2
 8011906:	2200      	movs	r2, #0
 8011908:	605a      	str	r2, [r3, #4]
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 801190a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801190c:	3301      	adds	r3, #1
 801190e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8011910:	687b      	ldr	r3, [r7, #4]
 8011912:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8011916:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011918:	429a      	cmp	r2, r3
 801191a:	dbc9      	blt.n	80118b0 <start_pass_huff_decoder+0x2f8>
    }

    /* Precalculate decoding info for each block in an MCU of this scan */
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 801191c:	2300      	movs	r3, #0
 801191e:	62bb      	str	r3, [r7, #40]	; 0x28
 8011920:	e19f      	b.n	8011c62 <start_pass_huff_decoder+0x6aa>
 8011922:	bf00      	nop
 8011924:	080103f9 	.word	0x080103f9
 8011928:	080105f5 	.word	0x080105f5
 801192c:	08010825 	.word	0x08010825
 8011930:	08010915 	.word	0x08010915
 8011934:	08010de9 	.word	0x08010de9
 8011938:	080111d9 	.word	0x080111d9
      ci = cinfo->MCU_membership[blkn];
 801193c:	687b      	ldr	r3, [r7, #4]
 801193e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011940:	325c      	adds	r2, #92	; 0x5c
 8011942:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011946:	62fb      	str	r3, [r7, #44]	; 0x2c
      compptr = cinfo->cur_comp_info[ci];
 8011948:	687a      	ldr	r2, [r7, #4]
 801194a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801194c:	3354      	adds	r3, #84	; 0x54
 801194e:	009b      	lsls	r3, r3, #2
 8011950:	4413      	add	r3, r2
 8011952:	685b      	ldr	r3, [r3, #4]
 8011954:	61bb      	str	r3, [r7, #24]
      /* Precalculate which table to use for each block */
      entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
 8011956:	69bb      	ldr	r3, [r7, #24]
 8011958:	695a      	ldr	r2, [r3, #20]
 801195a:	69fb      	ldr	r3, [r7, #28]
 801195c:	3210      	adds	r2, #16
 801195e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011962:	69fb      	ldr	r3, [r7, #28]
 8011964:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011966:	3218      	adds	r2, #24
 8011968:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
 801196c:	69bb      	ldr	r3, [r7, #24]
 801196e:	699a      	ldr	r2, [r3, #24]
 8011970:	69fb      	ldr	r3, [r7, #28]
 8011972:	3214      	adds	r2, #20
 8011974:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011978:	69fb      	ldr	r3, [r7, #28]
 801197a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801197c:	3222      	adds	r2, #34	; 0x22
 801197e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      /* Decide whether we really care about the coefficient values */
      if (compptr->component_needed) {
 8011982:	69bb      	ldr	r3, [r7, #24]
 8011984:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011986:	2b00      	cmp	r3, #0
 8011988:	f000 8162 	beq.w	8011c50 <start_pass_huff_decoder+0x698>
	ci = compptr->DCT_v_scaled_size;
 801198c:	69bb      	ldr	r3, [r7, #24]
 801198e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011990:	62fb      	str	r3, [r7, #44]	; 0x2c
	i = compptr->DCT_h_scaled_size;
 8011992:	69bb      	ldr	r3, [r7, #24]
 8011994:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011996:	627b      	str	r3, [r7, #36]	; 0x24
	switch (cinfo->lim_Se) {
 8011998:	687b      	ldr	r3, [r7, #4]
 801199a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 801199e:	2b30      	cmp	r3, #48	; 0x30
 80119a0:	f200 8136 	bhi.w	8011c10 <start_pass_huff_decoder+0x658>
 80119a4:	a201      	add	r2, pc, #4	; (adr r2, 80119ac <start_pass_huff_decoder+0x3f4>)
 80119a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80119aa:	bf00      	nop
 80119ac:	08011a71 	.word	0x08011a71
 80119b0:	08011c11 	.word	0x08011c11
 80119b4:	08011c11 	.word	0x08011c11
 80119b8:	08011a7f 	.word	0x08011a7f
 80119bc:	08011c11 	.word	0x08011c11
 80119c0:	08011c11 	.word	0x08011c11
 80119c4:	08011c11 	.word	0x08011c11
 80119c8:	08011c11 	.word	0x08011c11
 80119cc:	08011abf 	.word	0x08011abf
 80119d0:	08011c11 	.word	0x08011c11
 80119d4:	08011c11 	.word	0x08011c11
 80119d8:	08011c11 	.word	0x08011c11
 80119dc:	08011c11 	.word	0x08011c11
 80119e0:	08011c11 	.word	0x08011c11
 80119e4:	08011c11 	.word	0x08011c11
 80119e8:	08011b03 	.word	0x08011b03
 80119ec:	08011c11 	.word	0x08011c11
 80119f0:	08011c11 	.word	0x08011c11
 80119f4:	08011c11 	.word	0x08011c11
 80119f8:	08011c11 	.word	0x08011c11
 80119fc:	08011c11 	.word	0x08011c11
 8011a00:	08011c11 	.word	0x08011c11
 8011a04:	08011c11 	.word	0x08011c11
 8011a08:	08011c11 	.word	0x08011c11
 8011a0c:	08011b43 	.word	0x08011b43
 8011a10:	08011c11 	.word	0x08011c11
 8011a14:	08011c11 	.word	0x08011c11
 8011a18:	08011c11 	.word	0x08011c11
 8011a1c:	08011c11 	.word	0x08011c11
 8011a20:	08011c11 	.word	0x08011c11
 8011a24:	08011c11 	.word	0x08011c11
 8011a28:	08011c11 	.word	0x08011c11
 8011a2c:	08011c11 	.word	0x08011c11
 8011a30:	08011c11 	.word	0x08011c11
 8011a34:	08011c11 	.word	0x08011c11
 8011a38:	08011b87 	.word	0x08011b87
 8011a3c:	08011c11 	.word	0x08011c11
 8011a40:	08011c11 	.word	0x08011c11
 8011a44:	08011c11 	.word	0x08011c11
 8011a48:	08011c11 	.word	0x08011c11
 8011a4c:	08011c11 	.word	0x08011c11
 8011a50:	08011c11 	.word	0x08011c11
 8011a54:	08011c11 	.word	0x08011c11
 8011a58:	08011c11 	.word	0x08011c11
 8011a5c:	08011c11 	.word	0x08011c11
 8011a60:	08011c11 	.word	0x08011c11
 8011a64:	08011c11 	.word	0x08011c11
 8011a68:	08011c11 	.word	0x08011c11
 8011a6c:	08011bcd 	.word	0x08011bcd
	case (1*1-1):
	  entropy->coef_limit[blkn] = 1;
 8011a70:	69fb      	ldr	r3, [r7, #28]
 8011a72:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011a74:	322c      	adds	r2, #44	; 0x2c
 8011a76:	2101      	movs	r1, #1
 8011a78:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011a7c:	e0ee      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (2*2-1):
	  if (ci <= 0 || ci > 2) ci = 2;
 8011a7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011a80:	2b00      	cmp	r3, #0
 8011a82:	dd02      	ble.n	8011a8a <start_pass_huff_decoder+0x4d2>
 8011a84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011a86:	2b02      	cmp	r3, #2
 8011a88:	dd01      	ble.n	8011a8e <start_pass_huff_decoder+0x4d6>
 8011a8a:	2302      	movs	r3, #2
 8011a8c:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 2) i = 2;
 8011a8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011a90:	2b00      	cmp	r3, #0
 8011a92:	dd02      	ble.n	8011a9a <start_pass_huff_decoder+0x4e2>
 8011a94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011a96:	2b02      	cmp	r3, #2
 8011a98:	dd01      	ble.n	8011a9e <start_pass_huff_decoder+0x4e6>
 8011a9a:	2302      	movs	r3, #2
 8011a9c:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
 8011a9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011aa0:	1e5a      	subs	r2, r3, #1
 8011aa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011aa4:	3b01      	subs	r3, #1
 8011aa6:	497b      	ldr	r1, [pc, #492]	; (8011c94 <start_pass_huff_decoder+0x6dc>)
 8011aa8:	0052      	lsls	r2, r2, #1
 8011aaa:	4413      	add	r3, r2
 8011aac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011ab0:	1c59      	adds	r1, r3, #1
 8011ab2:	69fb      	ldr	r3, [r7, #28]
 8011ab4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011ab6:	322c      	adds	r2, #44	; 0x2c
 8011ab8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011abc:	e0ce      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (3*3-1):
	  if (ci <= 0 || ci > 3) ci = 3;
 8011abe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ac0:	2b00      	cmp	r3, #0
 8011ac2:	dd02      	ble.n	8011aca <start_pass_huff_decoder+0x512>
 8011ac4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ac6:	2b03      	cmp	r3, #3
 8011ac8:	dd01      	ble.n	8011ace <start_pass_huff_decoder+0x516>
 8011aca:	2303      	movs	r3, #3
 8011acc:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 3) i = 3;
 8011ace:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ad0:	2b00      	cmp	r3, #0
 8011ad2:	dd02      	ble.n	8011ada <start_pass_huff_decoder+0x522>
 8011ad4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ad6:	2b03      	cmp	r3, #3
 8011ad8:	dd01      	ble.n	8011ade <start_pass_huff_decoder+0x526>
 8011ada:	2303      	movs	r3, #3
 8011adc:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
 8011ade:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ae0:	1e5a      	subs	r2, r3, #1
 8011ae2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ae4:	1e59      	subs	r1, r3, #1
 8011ae6:	486c      	ldr	r0, [pc, #432]	; (8011c98 <start_pass_huff_decoder+0x6e0>)
 8011ae8:	4613      	mov	r3, r2
 8011aea:	005b      	lsls	r3, r3, #1
 8011aec:	4413      	add	r3, r2
 8011aee:	440b      	add	r3, r1
 8011af0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8011af4:	1c59      	adds	r1, r3, #1
 8011af6:	69fb      	ldr	r3, [r7, #28]
 8011af8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011afa:	322c      	adds	r2, #44	; 0x2c
 8011afc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011b00:	e0ac      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (4*4-1):
	  if (ci <= 0 || ci > 4) ci = 4;
 8011b02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b04:	2b00      	cmp	r3, #0
 8011b06:	dd02      	ble.n	8011b0e <start_pass_huff_decoder+0x556>
 8011b08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b0a:	2b04      	cmp	r3, #4
 8011b0c:	dd01      	ble.n	8011b12 <start_pass_huff_decoder+0x55a>
 8011b0e:	2304      	movs	r3, #4
 8011b10:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 4) i = 4;
 8011b12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b14:	2b00      	cmp	r3, #0
 8011b16:	dd02      	ble.n	8011b1e <start_pass_huff_decoder+0x566>
 8011b18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b1a:	2b04      	cmp	r3, #4
 8011b1c:	dd01      	ble.n	8011b22 <start_pass_huff_decoder+0x56a>
 8011b1e:	2304      	movs	r3, #4
 8011b20:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];
 8011b22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b24:	1e5a      	subs	r2, r3, #1
 8011b26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b28:	3b01      	subs	r3, #1
 8011b2a:	495c      	ldr	r1, [pc, #368]	; (8011c9c <start_pass_huff_decoder+0x6e4>)
 8011b2c:	0092      	lsls	r2, r2, #2
 8011b2e:	4413      	add	r3, r2
 8011b30:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011b34:	1c59      	adds	r1, r3, #1
 8011b36:	69fb      	ldr	r3, [r7, #28]
 8011b38:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011b3a:	322c      	adds	r2, #44	; 0x2c
 8011b3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011b40:	e08c      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (5*5-1):
	  if (ci <= 0 || ci > 5) ci = 5;
 8011b42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b44:	2b00      	cmp	r3, #0
 8011b46:	dd02      	ble.n	8011b4e <start_pass_huff_decoder+0x596>
 8011b48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b4a:	2b05      	cmp	r3, #5
 8011b4c:	dd01      	ble.n	8011b52 <start_pass_huff_decoder+0x59a>
 8011b4e:	2305      	movs	r3, #5
 8011b50:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 5) i = 5;
 8011b52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b54:	2b00      	cmp	r3, #0
 8011b56:	dd02      	ble.n	8011b5e <start_pass_huff_decoder+0x5a6>
 8011b58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b5a:	2b05      	cmp	r3, #5
 8011b5c:	dd01      	ble.n	8011b62 <start_pass_huff_decoder+0x5aa>
 8011b5e:	2305      	movs	r3, #5
 8011b60:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
 8011b62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b64:	1e5a      	subs	r2, r3, #1
 8011b66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b68:	1e59      	subs	r1, r3, #1
 8011b6a:	484d      	ldr	r0, [pc, #308]	; (8011ca0 <start_pass_huff_decoder+0x6e8>)
 8011b6c:	4613      	mov	r3, r2
 8011b6e:	009b      	lsls	r3, r3, #2
 8011b70:	4413      	add	r3, r2
 8011b72:	440b      	add	r3, r1
 8011b74:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8011b78:	1c59      	adds	r1, r3, #1
 8011b7a:	69fb      	ldr	r3, [r7, #28]
 8011b7c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011b7e:	322c      	adds	r2, #44	; 0x2c
 8011b80:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011b84:	e06a      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (6*6-1):
	  if (ci <= 0 || ci > 6) ci = 6;
 8011b86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b88:	2b00      	cmp	r3, #0
 8011b8a:	dd02      	ble.n	8011b92 <start_pass_huff_decoder+0x5da>
 8011b8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b8e:	2b06      	cmp	r3, #6
 8011b90:	dd01      	ble.n	8011b96 <start_pass_huff_decoder+0x5de>
 8011b92:	2306      	movs	r3, #6
 8011b94:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 6) i = 6;
 8011b96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b98:	2b00      	cmp	r3, #0
 8011b9a:	dd02      	ble.n	8011ba2 <start_pass_huff_decoder+0x5ea>
 8011b9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b9e:	2b06      	cmp	r3, #6
 8011ba0:	dd01      	ble.n	8011ba6 <start_pass_huff_decoder+0x5ee>
 8011ba2:	2306      	movs	r3, #6
 8011ba4:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
 8011ba6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ba8:	1e5a      	subs	r2, r3, #1
 8011baa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011bac:	1e59      	subs	r1, r3, #1
 8011bae:	483d      	ldr	r0, [pc, #244]	; (8011ca4 <start_pass_huff_decoder+0x6ec>)
 8011bb0:	4613      	mov	r3, r2
 8011bb2:	005b      	lsls	r3, r3, #1
 8011bb4:	4413      	add	r3, r2
 8011bb6:	005b      	lsls	r3, r3, #1
 8011bb8:	440b      	add	r3, r1
 8011bba:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8011bbe:	1c59      	adds	r1, r3, #1
 8011bc0:	69fb      	ldr	r3, [r7, #28]
 8011bc2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011bc4:	322c      	adds	r2, #44	; 0x2c
 8011bc6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011bca:	e047      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	case (7*7-1):
	  if (ci <= 0 || ci > 7) ci = 7;
 8011bcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011bce:	2b00      	cmp	r3, #0
 8011bd0:	dd02      	ble.n	8011bd8 <start_pass_huff_decoder+0x620>
 8011bd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011bd4:	2b07      	cmp	r3, #7
 8011bd6:	dd01      	ble.n	8011bdc <start_pass_huff_decoder+0x624>
 8011bd8:	2307      	movs	r3, #7
 8011bda:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 7) i = 7;
 8011bdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011bde:	2b00      	cmp	r3, #0
 8011be0:	dd02      	ble.n	8011be8 <start_pass_huff_decoder+0x630>
 8011be2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011be4:	2b07      	cmp	r3, #7
 8011be6:	dd01      	ble.n	8011bec <start_pass_huff_decoder+0x634>
 8011be8:	2307      	movs	r3, #7
 8011bea:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
 8011bec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011bee:	1e5a      	subs	r2, r3, #1
 8011bf0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011bf2:	1e59      	subs	r1, r3, #1
 8011bf4:	482c      	ldr	r0, [pc, #176]	; (8011ca8 <start_pass_huff_decoder+0x6f0>)
 8011bf6:	4613      	mov	r3, r2
 8011bf8:	00db      	lsls	r3, r3, #3
 8011bfa:	1a9b      	subs	r3, r3, r2
 8011bfc:	440b      	add	r3, r1
 8011bfe:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8011c02:	1c59      	adds	r1, r3, #1
 8011c04:	69fb      	ldr	r3, [r7, #28]
 8011c06:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c08:	322c      	adds	r2, #44	; 0x2c
 8011c0a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011c0e:	e025      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	default:
	  if (ci <= 0 || ci > 8) ci = 8;
 8011c10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c12:	2b00      	cmp	r3, #0
 8011c14:	dd02      	ble.n	8011c1c <start_pass_huff_decoder+0x664>
 8011c16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c18:	2b08      	cmp	r3, #8
 8011c1a:	dd01      	ble.n	8011c20 <start_pass_huff_decoder+0x668>
 8011c1c:	2308      	movs	r3, #8
 8011c1e:	62fb      	str	r3, [r7, #44]	; 0x2c
	  if (i <= 0 || i > 8) i = 8;
 8011c20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011c22:	2b00      	cmp	r3, #0
 8011c24:	dd02      	ble.n	8011c2c <start_pass_huff_decoder+0x674>
 8011c26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011c28:	2b08      	cmp	r3, #8
 8011c2a:	dd01      	ble.n	8011c30 <start_pass_huff_decoder+0x678>
 8011c2c:	2308      	movs	r3, #8
 8011c2e:	627b      	str	r3, [r7, #36]	; 0x24
	  entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
 8011c30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c32:	1e5a      	subs	r2, r3, #1
 8011c34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011c36:	3b01      	subs	r3, #1
 8011c38:	491c      	ldr	r1, [pc, #112]	; (8011cac <start_pass_huff_decoder+0x6f4>)
 8011c3a:	00d2      	lsls	r2, r2, #3
 8011c3c:	4413      	add	r3, r2
 8011c3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8011c42:	1c59      	adds	r1, r3, #1
 8011c44:	69fb      	ldr	r3, [r7, #28]
 8011c46:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c48:	322c      	adds	r2, #44	; 0x2c
 8011c4a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	  break;
 8011c4e:	e005      	b.n	8011c5c <start_pass_huff_decoder+0x6a4>
	}
      } else {
	entropy->coef_limit[blkn] = 0;
 8011c50:	69fb      	ldr	r3, [r7, #28]
 8011c52:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c54:	322c      	adds	r2, #44	; 0x2c
 8011c56:	2100      	movs	r1, #0
 8011c58:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
 8011c5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011c5e:	3301      	adds	r3, #1
 8011c60:	62bb      	str	r3, [r7, #40]	; 0x28
 8011c62:	687b      	ldr	r3, [r7, #4]
 8011c64:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 8011c68:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011c6a:	429a      	cmp	r2, r3
 8011c6c:	f6ff ae66 	blt.w	801193c <start_pass_huff_decoder+0x384>
      }
    }
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
 8011c70:	69fb      	ldr	r3, [r7, #28]
 8011c72:	2200      	movs	r2, #0
 8011c74:	60da      	str	r2, [r3, #12]
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
 8011c76:	69fb      	ldr	r3, [r7, #28]
 8011c78:	2200      	movs	r2, #0
 8011c7a:	609a      	str	r2, [r3, #8]
  entropy->insufficient_data = FALSE;
 8011c7c:	69fb      	ldr	r3, [r7, #28]
 8011c7e:	2200      	movs	r2, #0
 8011c80:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
 8011c82:	687b      	ldr	r3, [r7, #4]
 8011c84:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8011c88:	69fb      	ldr	r3, [r7, #28]
 8011c8a:	629a      	str	r2, [r3, #40]	; 0x28
}
 8011c8c:	bf00      	nop
 8011c8e:	3730      	adds	r7, #48	; 0x30
 8011c90:	46bd      	mov	sp, r7
 8011c92:	bd80      	pop	{r7, pc}
 8011c94:	0802a8fc 	.word	0x0802a8fc
 8011c98:	0802a8d8 	.word	0x0802a8d8
 8011c9c:	0802a898 	.word	0x0802a898
 8011ca0:	0802a834 	.word	0x0802a834
 8011ca4:	0802a7a4 	.word	0x0802a7a4
 8011ca8:	0802a6e0 	.word	0x0802a6e0
 8011cac:	0802a5e0 	.word	0x0802a5e0

08011cb0 <jinit_huff_decoder>:
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
 8011cb0:	b580      	push	{r7, lr}
 8011cb2:	b086      	sub	sp, #24
 8011cb4:	af00      	add	r7, sp, #0
 8011cb6:	6078      	str	r0, [r7, #4]
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8011cb8:	687b      	ldr	r3, [r7, #4]
 8011cba:	685b      	ldr	r3, [r3, #4]
 8011cbc:	681b      	ldr	r3, [r3, #0]
 8011cbe:	22d8      	movs	r2, #216	; 0xd8
 8011cc0:	2101      	movs	r1, #1
 8011cc2:	6878      	ldr	r0, [r7, #4]
 8011cc4:	4798      	blx	r3
 8011cc6:	60b8      	str	r0, [r7, #8]
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
 8011cc8:	687b      	ldr	r3, [r7, #4]
 8011cca:	68ba      	ldr	r2, [r7, #8]
 8011ccc:	f8c3 21d0 	str.w	r2, [r3, #464]	; 0x1d0
  entropy->pub.start_pass = start_pass_huff_decoder;
 8011cd0:	68bb      	ldr	r3, [r7, #8]
 8011cd2:	4a30      	ldr	r2, [pc, #192]	; (8011d94 <jinit_huff_decoder+0xe4>)
 8011cd4:	601a      	str	r2, [r3, #0]

  if (cinfo->progressive_mode) {
 8011cd6:	687b      	ldr	r3, [r7, #4]
 8011cd8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011cdc:	2b00      	cmp	r3, #0
 8011cde:	d03b      	beq.n	8011d58 <jinit_huff_decoder+0xa8>
    /* Create progression status table */
    int *coef_bit_ptr, ci;
    cinfo->coef_bits = (int (*)[DCTSIZE2])
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	685b      	ldr	r3, [r3, #4]
 8011ce4:	681b      	ldr	r3, [r3, #0]
				  cinfo->num_components*DCTSIZE2*SIZEOF(int));
 8011ce6:	687a      	ldr	r2, [r7, #4]
 8011ce8:	6a52      	ldr	r2, [r2, #36]	; 0x24
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8011cea:	0212      	lsls	r2, r2, #8
 8011cec:	2101      	movs	r1, #1
 8011cee:	6878      	ldr	r0, [r7, #4]
 8011cf0:	4798      	blx	r3
 8011cf2:	4602      	mov	r2, r0
    cinfo->coef_bits = (int (*)[DCTSIZE2])
 8011cf4:	687b      	ldr	r3, [r7, #4]
 8011cf6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    coef_bit_ptr = & cinfo->coef_bits[0][0];
 8011cfa:	687b      	ldr	r3, [r7, #4]
 8011cfc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8011d00:	613b      	str	r3, [r7, #16]
    for (ci = 0; ci < cinfo->num_components; ci++)
 8011d02:	2300      	movs	r3, #0
 8011d04:	60fb      	str	r3, [r7, #12]
 8011d06:	e011      	b.n	8011d2c <jinit_huff_decoder+0x7c>
      for (i = 0; i < DCTSIZE2; i++)
 8011d08:	2300      	movs	r3, #0
 8011d0a:	617b      	str	r3, [r7, #20]
 8011d0c:	e008      	b.n	8011d20 <jinit_huff_decoder+0x70>
	*coef_bit_ptr++ = -1;
 8011d0e:	693b      	ldr	r3, [r7, #16]
 8011d10:	1d1a      	adds	r2, r3, #4
 8011d12:	613a      	str	r2, [r7, #16]
 8011d14:	f04f 32ff 	mov.w	r2, #4294967295
 8011d18:	601a      	str	r2, [r3, #0]
      for (i = 0; i < DCTSIZE2; i++)
 8011d1a:	697b      	ldr	r3, [r7, #20]
 8011d1c:	3301      	adds	r3, #1
 8011d1e:	617b      	str	r3, [r7, #20]
 8011d20:	697b      	ldr	r3, [r7, #20]
 8011d22:	2b3f      	cmp	r3, #63	; 0x3f
 8011d24:	ddf3      	ble.n	8011d0e <jinit_huff_decoder+0x5e>
    for (ci = 0; ci < cinfo->num_components; ci++)
 8011d26:	68fb      	ldr	r3, [r7, #12]
 8011d28:	3301      	adds	r3, #1
 8011d2a:	60fb      	str	r3, [r7, #12]
 8011d2c:	687b      	ldr	r3, [r7, #4]
 8011d2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011d30:	68fa      	ldr	r2, [r7, #12]
 8011d32:	429a      	cmp	r2, r3
 8011d34:	dbe8      	blt.n	8011d08 <jinit_huff_decoder+0x58>

    /* Mark derived tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8011d36:	2300      	movs	r3, #0
 8011d38:	617b      	str	r3, [r7, #20]
 8011d3a:	e009      	b.n	8011d50 <jinit_huff_decoder+0xa0>
      entropy->derived_tbls[i] = NULL;
 8011d3c:	68ba      	ldr	r2, [r7, #8]
 8011d3e:	697b      	ldr	r3, [r7, #20]
 8011d40:	330a      	adds	r3, #10
 8011d42:	009b      	lsls	r3, r3, #2
 8011d44:	4413      	add	r3, r2
 8011d46:	2200      	movs	r2, #0
 8011d48:	605a      	str	r2, [r3, #4]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8011d4a:	697b      	ldr	r3, [r7, #20]
 8011d4c:	3301      	adds	r3, #1
 8011d4e:	617b      	str	r3, [r7, #20]
 8011d50:	697b      	ldr	r3, [r7, #20]
 8011d52:	2b03      	cmp	r3, #3
 8011d54:	ddf2      	ble.n	8011d3c <jinit_huff_decoder+0x8c>
    /* Mark tables unallocated */
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
    }
  }
}
 8011d56:	e018      	b.n	8011d8a <jinit_huff_decoder+0xda>
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8011d58:	2300      	movs	r3, #0
 8011d5a:	617b      	str	r3, [r7, #20]
 8011d5c:	e012      	b.n	8011d84 <jinit_huff_decoder+0xd4>
      entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
 8011d5e:	68bb      	ldr	r3, [r7, #8]
 8011d60:	697a      	ldr	r2, [r7, #20]
 8011d62:	3214      	adds	r2, #20
 8011d64:	2100      	movs	r1, #0
 8011d66:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8011d6a:	68bb      	ldr	r3, [r7, #8]
 8011d6c:	697a      	ldr	r2, [r7, #20]
 8011d6e:	3214      	adds	r2, #20
 8011d70:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8011d74:	68bb      	ldr	r3, [r7, #8]
 8011d76:	697a      	ldr	r2, [r7, #20]
 8011d78:	3210      	adds	r2, #16
 8011d7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < NUM_HUFF_TBLS; i++) {
 8011d7e:	697b      	ldr	r3, [r7, #20]
 8011d80:	3301      	adds	r3, #1
 8011d82:	617b      	str	r3, [r7, #20]
 8011d84:	697b      	ldr	r3, [r7, #20]
 8011d86:	2b03      	cmp	r3, #3
 8011d88:	dde9      	ble.n	8011d5e <jinit_huff_decoder+0xae>
}
 8011d8a:	bf00      	nop
 8011d8c:	3718      	adds	r7, #24
 8011d8e:	46bd      	mov	sp, r7
 8011d90:	bd80      	pop	{r7, pc}
 8011d92:	bf00      	nop
 8011d94:	080115b9 	.word	0x080115b9

08011d98 <jpeg_core_output_dimensions>:
GLOBAL(void)
jpeg_core_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for transcoding and full decompression.
 */
{
 8011d98:	b580      	push	{r7, lr}
 8011d9a:	b084      	sub	sp, #16
 8011d9c:	af00      	add	r7, sp, #0
 8011d9e:	6078      	str	r0, [r7, #4]
#ifdef IDCT_SCALING_SUPPORTED
  int ci;
  jpeg_component_info *compptr;

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom) {
 8011da0:	687b      	ldr	r3, [r7, #4]
 8011da2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011da4:	687a      	ldr	r2, [r7, #4]
 8011da6:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011daa:	fb02 f203 	mul.w	r2, r2, r3
 8011dae:	687b      	ldr	r3, [r7, #4]
 8011db0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011db2:	429a      	cmp	r2, r3
 8011db4:	d824      	bhi.n	8011e00 <jpeg_core_output_dimensions+0x68>
    /* Provide 1/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width, (long) cinfo->block_size);
 8011db6:	687b      	ldr	r3, [r7, #4]
 8011db8:	69db      	ldr	r3, [r3, #28]
 8011dba:	461a      	mov	r2, r3
 8011dbc:	687b      	ldr	r3, [r7, #4]
 8011dbe:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011dc2:	4619      	mov	r1, r3
 8011dc4:	4610      	mov	r0, r2
 8011dc6:	f015 fea9 	bl	8027b1c <jdiv_round_up>
 8011dca:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011dcc:	461a      	mov	r2, r3
 8011dce:	687b      	ldr	r3, [r7, #4]
 8011dd0:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height, (long) cinfo->block_size);
 8011dd2:	687b      	ldr	r3, [r7, #4]
 8011dd4:	6a1b      	ldr	r3, [r3, #32]
 8011dd6:	461a      	mov	r2, r3
 8011dd8:	687b      	ldr	r3, [r7, #4]
 8011dda:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011dde:	4619      	mov	r1, r3
 8011de0:	4610      	mov	r0, r2
 8011de2:	f015 fe9b 	bl	8027b1c <jdiv_round_up>
 8011de6:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8011de8:	461a      	mov	r2, r3
 8011dea:	687b      	ldr	r3, [r7, #4]
 8011dec:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 1;
 8011dee:	687b      	ldr	r3, [r7, #4]
 8011df0:	2201      	movs	r2, #1
 8011df2:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 1;
 8011df6:	687b      	ldr	r3, [r7, #4]
 8011df8:	2201      	movs	r2, #1
 8011dfa:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8011dfe:	e349      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 2) {
 8011e00:	687b      	ldr	r3, [r7, #4]
 8011e02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011e04:	687a      	ldr	r2, [r7, #4]
 8011e06:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011e0a:	fb02 f203 	mul.w	r2, r2, r3
 8011e0e:	687b      	ldr	r3, [r7, #4]
 8011e10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011e12:	005b      	lsls	r3, r3, #1
 8011e14:	429a      	cmp	r2, r3
 8011e16:	d824      	bhi.n	8011e62 <jpeg_core_output_dimensions+0xca>
    /* Provide 2/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 2L, (long) cinfo->block_size);
 8011e18:	687b      	ldr	r3, [r7, #4]
 8011e1a:	69db      	ldr	r3, [r3, #28]
 8011e1c:	005a      	lsls	r2, r3, #1
 8011e1e:	687b      	ldr	r3, [r7, #4]
 8011e20:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011e24:	4619      	mov	r1, r3
 8011e26:	4610      	mov	r0, r2
 8011e28:	f015 fe78 	bl	8027b1c <jdiv_round_up>
 8011e2c:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011e2e:	461a      	mov	r2, r3
 8011e30:	687b      	ldr	r3, [r7, #4]
 8011e32:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 2L, (long) cinfo->block_size);
 8011e34:	687b      	ldr	r3, [r7, #4]
 8011e36:	6a1b      	ldr	r3, [r3, #32]
 8011e38:	005a      	lsls	r2, r3, #1
 8011e3a:	687b      	ldr	r3, [r7, #4]
 8011e3c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011e40:	4619      	mov	r1, r3
 8011e42:	4610      	mov	r0, r2
 8011e44:	f015 fe6a 	bl	8027b1c <jdiv_round_up>
 8011e48:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8011e4a:	461a      	mov	r2, r3
 8011e4c:	687b      	ldr	r3, [r7, #4]
 8011e4e:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 2;
 8011e50:	687b      	ldr	r3, [r7, #4]
 8011e52:	2202      	movs	r2, #2
 8011e54:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 2;
 8011e58:	687b      	ldr	r3, [r7, #4]
 8011e5a:	2202      	movs	r2, #2
 8011e5c:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8011e60:	e318      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 3) {
 8011e62:	687b      	ldr	r3, [r7, #4]
 8011e64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011e66:	687a      	ldr	r2, [r7, #4]
 8011e68:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011e6c:	fb02 f103 	mul.w	r1, r2, r3
 8011e70:	687b      	ldr	r3, [r7, #4]
 8011e72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8011e74:	4613      	mov	r3, r2
 8011e76:	005b      	lsls	r3, r3, #1
 8011e78:	4413      	add	r3, r2
 8011e7a:	4299      	cmp	r1, r3
 8011e7c:	d82a      	bhi.n	8011ed4 <jpeg_core_output_dimensions+0x13c>
    /* Provide 3/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 3L, (long) cinfo->block_size);
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	69db      	ldr	r3, [r3, #28]
 8011e82:	461a      	mov	r2, r3
 8011e84:	4613      	mov	r3, r2
 8011e86:	005b      	lsls	r3, r3, #1
 8011e88:	441a      	add	r2, r3
 8011e8a:	687b      	ldr	r3, [r7, #4]
 8011e8c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011e90:	4619      	mov	r1, r3
 8011e92:	4610      	mov	r0, r2
 8011e94:	f015 fe42 	bl	8027b1c <jdiv_round_up>
 8011e98:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011e9a:	461a      	mov	r2, r3
 8011e9c:	687b      	ldr	r3, [r7, #4]
 8011e9e:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 3L, (long) cinfo->block_size);
 8011ea0:	687b      	ldr	r3, [r7, #4]
 8011ea2:	6a1b      	ldr	r3, [r3, #32]
 8011ea4:	461a      	mov	r2, r3
 8011ea6:	4613      	mov	r3, r2
 8011ea8:	005b      	lsls	r3, r3, #1
 8011eaa:	441a      	add	r2, r3
 8011eac:	687b      	ldr	r3, [r7, #4]
 8011eae:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011eb2:	4619      	mov	r1, r3
 8011eb4:	4610      	mov	r0, r2
 8011eb6:	f015 fe31 	bl	8027b1c <jdiv_round_up>
 8011eba:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8011ebc:	461a      	mov	r2, r3
 8011ebe:	687b      	ldr	r3, [r7, #4]
 8011ec0:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 3;
 8011ec2:	687b      	ldr	r3, [r7, #4]
 8011ec4:	2203      	movs	r2, #3
 8011ec6:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 3;
 8011eca:	687b      	ldr	r3, [r7, #4]
 8011ecc:	2203      	movs	r2, #3
 8011ece:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8011ed2:	e2df      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 4) {
 8011ed4:	687b      	ldr	r3, [r7, #4]
 8011ed6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011ed8:	687a      	ldr	r2, [r7, #4]
 8011eda:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011ede:	fb02 f203 	mul.w	r2, r2, r3
 8011ee2:	687b      	ldr	r3, [r7, #4]
 8011ee4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011ee6:	009b      	lsls	r3, r3, #2
 8011ee8:	429a      	cmp	r2, r3
 8011eea:	d824      	bhi.n	8011f36 <jpeg_core_output_dimensions+0x19e>
    /* Provide 4/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 4L, (long) cinfo->block_size);
 8011eec:	687b      	ldr	r3, [r7, #4]
 8011eee:	69db      	ldr	r3, [r3, #28]
 8011ef0:	009a      	lsls	r2, r3, #2
 8011ef2:	687b      	ldr	r3, [r7, #4]
 8011ef4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011ef8:	4619      	mov	r1, r3
 8011efa:	4610      	mov	r0, r2
 8011efc:	f015 fe0e 	bl	8027b1c <jdiv_round_up>
 8011f00:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011f02:	461a      	mov	r2, r3
 8011f04:	687b      	ldr	r3, [r7, #4]
 8011f06:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 4L, (long) cinfo->block_size);
 8011f08:	687b      	ldr	r3, [r7, #4]
 8011f0a:	6a1b      	ldr	r3, [r3, #32]
 8011f0c:	009a      	lsls	r2, r3, #2
 8011f0e:	687b      	ldr	r3, [r7, #4]
 8011f10:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011f14:	4619      	mov	r1, r3
 8011f16:	4610      	mov	r0, r2
 8011f18:	f015 fe00 	bl	8027b1c <jdiv_round_up>
 8011f1c:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8011f1e:	461a      	mov	r2, r3
 8011f20:	687b      	ldr	r3, [r7, #4]
 8011f22:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 4;
 8011f24:	687b      	ldr	r3, [r7, #4]
 8011f26:	2204      	movs	r2, #4
 8011f28:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 4;
 8011f2c:	687b      	ldr	r3, [r7, #4]
 8011f2e:	2204      	movs	r2, #4
 8011f30:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8011f34:	e2ae      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 5) {
 8011f36:	687b      	ldr	r3, [r7, #4]
 8011f38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011f3a:	687a      	ldr	r2, [r7, #4]
 8011f3c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011f40:	fb02 f103 	mul.w	r1, r2, r3
 8011f44:	687b      	ldr	r3, [r7, #4]
 8011f46:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8011f48:	4613      	mov	r3, r2
 8011f4a:	009b      	lsls	r3, r3, #2
 8011f4c:	4413      	add	r3, r2
 8011f4e:	4299      	cmp	r1, r3
 8011f50:	d82a      	bhi.n	8011fa8 <jpeg_core_output_dimensions+0x210>
    /* Provide 5/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 5L, (long) cinfo->block_size);
 8011f52:	687b      	ldr	r3, [r7, #4]
 8011f54:	69db      	ldr	r3, [r3, #28]
 8011f56:	461a      	mov	r2, r3
 8011f58:	4613      	mov	r3, r2
 8011f5a:	009b      	lsls	r3, r3, #2
 8011f5c:	441a      	add	r2, r3
 8011f5e:	687b      	ldr	r3, [r7, #4]
 8011f60:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011f64:	4619      	mov	r1, r3
 8011f66:	4610      	mov	r0, r2
 8011f68:	f015 fdd8 	bl	8027b1c <jdiv_round_up>
 8011f6c:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011f6e:	461a      	mov	r2, r3
 8011f70:	687b      	ldr	r3, [r7, #4]
 8011f72:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 5L, (long) cinfo->block_size);
 8011f74:	687b      	ldr	r3, [r7, #4]
 8011f76:	6a1b      	ldr	r3, [r3, #32]
 8011f78:	461a      	mov	r2, r3
 8011f7a:	4613      	mov	r3, r2
 8011f7c:	009b      	lsls	r3, r3, #2
 8011f7e:	441a      	add	r2, r3
 8011f80:	687b      	ldr	r3, [r7, #4]
 8011f82:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011f86:	4619      	mov	r1, r3
 8011f88:	4610      	mov	r0, r2
 8011f8a:	f015 fdc7 	bl	8027b1c <jdiv_round_up>
 8011f8e:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8011f90:	461a      	mov	r2, r3
 8011f92:	687b      	ldr	r3, [r7, #4]
 8011f94:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 5;
 8011f96:	687b      	ldr	r3, [r7, #4]
 8011f98:	2205      	movs	r2, #5
 8011f9a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 5;
 8011f9e:	687b      	ldr	r3, [r7, #4]
 8011fa0:	2205      	movs	r2, #5
 8011fa2:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8011fa6:	e275      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 6) {
 8011fa8:	687b      	ldr	r3, [r7, #4]
 8011faa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011fac:	687a      	ldr	r2, [r7, #4]
 8011fae:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8011fb2:	fb02 f103 	mul.w	r1, r2, r3
 8011fb6:	687b      	ldr	r3, [r7, #4]
 8011fb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8011fba:	4613      	mov	r3, r2
 8011fbc:	005b      	lsls	r3, r3, #1
 8011fbe:	4413      	add	r3, r2
 8011fc0:	005b      	lsls	r3, r3, #1
 8011fc2:	4299      	cmp	r1, r3
 8011fc4:	d82e      	bhi.n	8012024 <jpeg_core_output_dimensions+0x28c>
    /* Provide 6/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 6L, (long) cinfo->block_size);
 8011fc6:	687b      	ldr	r3, [r7, #4]
 8011fc8:	69db      	ldr	r3, [r3, #28]
 8011fca:	461a      	mov	r2, r3
 8011fcc:	4613      	mov	r3, r2
 8011fce:	005b      	lsls	r3, r3, #1
 8011fd0:	4413      	add	r3, r2
 8011fd2:	005b      	lsls	r3, r3, #1
 8011fd4:	461a      	mov	r2, r3
 8011fd6:	687b      	ldr	r3, [r7, #4]
 8011fd8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8011fdc:	4619      	mov	r1, r3
 8011fde:	4610      	mov	r0, r2
 8011fe0:	f015 fd9c 	bl	8027b1c <jdiv_round_up>
 8011fe4:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8011fe6:	461a      	mov	r2, r3
 8011fe8:	687b      	ldr	r3, [r7, #4]
 8011fea:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 6L, (long) cinfo->block_size);
 8011fec:	687b      	ldr	r3, [r7, #4]
 8011fee:	6a1b      	ldr	r3, [r3, #32]
 8011ff0:	461a      	mov	r2, r3
 8011ff2:	4613      	mov	r3, r2
 8011ff4:	005b      	lsls	r3, r3, #1
 8011ff6:	4413      	add	r3, r2
 8011ff8:	005b      	lsls	r3, r3, #1
 8011ffa:	461a      	mov	r2, r3
 8011ffc:	687b      	ldr	r3, [r7, #4]
 8011ffe:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012002:	4619      	mov	r1, r3
 8012004:	4610      	mov	r0, r2
 8012006:	f015 fd89 	bl	8027b1c <jdiv_round_up>
 801200a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801200c:	461a      	mov	r2, r3
 801200e:	687b      	ldr	r3, [r7, #4]
 8012010:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 6;
 8012012:	687b      	ldr	r3, [r7, #4]
 8012014:	2206      	movs	r2, #6
 8012016:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 6;
 801201a:	687b      	ldr	r3, [r7, #4]
 801201c:	2206      	movs	r2, #6
 801201e:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8012022:	e237      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 7) {
 8012024:	687b      	ldr	r3, [r7, #4]
 8012026:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012028:	687a      	ldr	r2, [r7, #4]
 801202a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 801202e:	fb02 f103 	mul.w	r1, r2, r3
 8012032:	687b      	ldr	r3, [r7, #4]
 8012034:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012036:	4613      	mov	r3, r2
 8012038:	00db      	lsls	r3, r3, #3
 801203a:	1a9b      	subs	r3, r3, r2
 801203c:	4299      	cmp	r1, r3
 801203e:	d82a      	bhi.n	8012096 <jpeg_core_output_dimensions+0x2fe>
    /* Provide 7/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 7L, (long) cinfo->block_size);
 8012040:	687b      	ldr	r3, [r7, #4]
 8012042:	69db      	ldr	r3, [r3, #28]
 8012044:	461a      	mov	r2, r3
 8012046:	4613      	mov	r3, r2
 8012048:	00db      	lsls	r3, r3, #3
 801204a:	1a9a      	subs	r2, r3, r2
 801204c:	687b      	ldr	r3, [r7, #4]
 801204e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012052:	4619      	mov	r1, r3
 8012054:	4610      	mov	r0, r2
 8012056:	f015 fd61 	bl	8027b1c <jdiv_round_up>
 801205a:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 801205c:	461a      	mov	r2, r3
 801205e:	687b      	ldr	r3, [r7, #4]
 8012060:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 7L, (long) cinfo->block_size);
 8012062:	687b      	ldr	r3, [r7, #4]
 8012064:	6a1b      	ldr	r3, [r3, #32]
 8012066:	461a      	mov	r2, r3
 8012068:	4613      	mov	r3, r2
 801206a:	00db      	lsls	r3, r3, #3
 801206c:	1a9a      	subs	r2, r3, r2
 801206e:	687b      	ldr	r3, [r7, #4]
 8012070:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012074:	4619      	mov	r1, r3
 8012076:	4610      	mov	r0, r2
 8012078:	f015 fd50 	bl	8027b1c <jdiv_round_up>
 801207c:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801207e:	461a      	mov	r2, r3
 8012080:	687b      	ldr	r3, [r7, #4]
 8012082:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 7;
 8012084:	687b      	ldr	r3, [r7, #4]
 8012086:	2207      	movs	r2, #7
 8012088:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 7;
 801208c:	687b      	ldr	r3, [r7, #4]
 801208e:	2207      	movs	r2, #7
 8012090:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8012094:	e1fe      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 8) {
 8012096:	687b      	ldr	r3, [r7, #4]
 8012098:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801209a:	687a      	ldr	r2, [r7, #4]
 801209c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 80120a0:	fb02 f203 	mul.w	r2, r2, r3
 80120a4:	687b      	ldr	r3, [r7, #4]
 80120a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80120a8:	00db      	lsls	r3, r3, #3
 80120aa:	429a      	cmp	r2, r3
 80120ac:	d824      	bhi.n	80120f8 <jpeg_core_output_dimensions+0x360>
    /* Provide 8/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 8L, (long) cinfo->block_size);
 80120ae:	687b      	ldr	r3, [r7, #4]
 80120b0:	69db      	ldr	r3, [r3, #28]
 80120b2:	00da      	lsls	r2, r3, #3
 80120b4:	687b      	ldr	r3, [r7, #4]
 80120b6:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80120ba:	4619      	mov	r1, r3
 80120bc:	4610      	mov	r0, r2
 80120be:	f015 fd2d 	bl	8027b1c <jdiv_round_up>
 80120c2:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80120c4:	461a      	mov	r2, r3
 80120c6:	687b      	ldr	r3, [r7, #4]
 80120c8:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 8L, (long) cinfo->block_size);
 80120ca:	687b      	ldr	r3, [r7, #4]
 80120cc:	6a1b      	ldr	r3, [r3, #32]
 80120ce:	00da      	lsls	r2, r3, #3
 80120d0:	687b      	ldr	r3, [r7, #4]
 80120d2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80120d6:	4619      	mov	r1, r3
 80120d8:	4610      	mov	r0, r2
 80120da:	f015 fd1f 	bl	8027b1c <jdiv_round_up>
 80120de:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80120e0:	461a      	mov	r2, r3
 80120e2:	687b      	ldr	r3, [r7, #4]
 80120e4:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 8;
 80120e6:	687b      	ldr	r3, [r7, #4]
 80120e8:	2208      	movs	r2, #8
 80120ea:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 8;
 80120ee:	687b      	ldr	r3, [r7, #4]
 80120f0:	2208      	movs	r2, #8
 80120f2:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 80120f6:	e1cd      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 9) {
 80120f8:	687b      	ldr	r3, [r7, #4]
 80120fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80120fc:	687a      	ldr	r2, [r7, #4]
 80120fe:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012102:	fb02 f103 	mul.w	r1, r2, r3
 8012106:	687b      	ldr	r3, [r7, #4]
 8012108:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801210a:	4613      	mov	r3, r2
 801210c:	00db      	lsls	r3, r3, #3
 801210e:	4413      	add	r3, r2
 8012110:	4299      	cmp	r1, r3
 8012112:	d82a      	bhi.n	801216a <jpeg_core_output_dimensions+0x3d2>
    /* Provide 9/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 9L, (long) cinfo->block_size);
 8012114:	687b      	ldr	r3, [r7, #4]
 8012116:	69db      	ldr	r3, [r3, #28]
 8012118:	461a      	mov	r2, r3
 801211a:	4613      	mov	r3, r2
 801211c:	00db      	lsls	r3, r3, #3
 801211e:	441a      	add	r2, r3
 8012120:	687b      	ldr	r3, [r7, #4]
 8012122:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012126:	4619      	mov	r1, r3
 8012128:	4610      	mov	r0, r2
 801212a:	f015 fcf7 	bl	8027b1c <jdiv_round_up>
 801212e:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8012130:	461a      	mov	r2, r3
 8012132:	687b      	ldr	r3, [r7, #4]
 8012134:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 9L, (long) cinfo->block_size);
 8012136:	687b      	ldr	r3, [r7, #4]
 8012138:	6a1b      	ldr	r3, [r3, #32]
 801213a:	461a      	mov	r2, r3
 801213c:	4613      	mov	r3, r2
 801213e:	00db      	lsls	r3, r3, #3
 8012140:	441a      	add	r2, r3
 8012142:	687b      	ldr	r3, [r7, #4]
 8012144:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012148:	4619      	mov	r1, r3
 801214a:	4610      	mov	r0, r2
 801214c:	f015 fce6 	bl	8027b1c <jdiv_round_up>
 8012150:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8012152:	461a      	mov	r2, r3
 8012154:	687b      	ldr	r3, [r7, #4]
 8012156:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 9;
 8012158:	687b      	ldr	r3, [r7, #4]
 801215a:	2209      	movs	r2, #9
 801215c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 9;
 8012160:	687b      	ldr	r3, [r7, #4]
 8012162:	2209      	movs	r2, #9
 8012164:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8012168:	e194      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 10) {
 801216a:	687b      	ldr	r3, [r7, #4]
 801216c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801216e:	687a      	ldr	r2, [r7, #4]
 8012170:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012174:	fb02 f103 	mul.w	r1, r2, r3
 8012178:	687b      	ldr	r3, [r7, #4]
 801217a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801217c:	4613      	mov	r3, r2
 801217e:	009b      	lsls	r3, r3, #2
 8012180:	4413      	add	r3, r2
 8012182:	005b      	lsls	r3, r3, #1
 8012184:	4299      	cmp	r1, r3
 8012186:	d82e      	bhi.n	80121e6 <jpeg_core_output_dimensions+0x44e>
    /* Provide 10/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 10L, (long) cinfo->block_size);
 8012188:	687b      	ldr	r3, [r7, #4]
 801218a:	69db      	ldr	r3, [r3, #28]
 801218c:	461a      	mov	r2, r3
 801218e:	4613      	mov	r3, r2
 8012190:	009b      	lsls	r3, r3, #2
 8012192:	4413      	add	r3, r2
 8012194:	005b      	lsls	r3, r3, #1
 8012196:	461a      	mov	r2, r3
 8012198:	687b      	ldr	r3, [r7, #4]
 801219a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 801219e:	4619      	mov	r1, r3
 80121a0:	4610      	mov	r0, r2
 80121a2:	f015 fcbb 	bl	8027b1c <jdiv_round_up>
 80121a6:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80121a8:	461a      	mov	r2, r3
 80121aa:	687b      	ldr	r3, [r7, #4]
 80121ac:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 10L, (long) cinfo->block_size);
 80121ae:	687b      	ldr	r3, [r7, #4]
 80121b0:	6a1b      	ldr	r3, [r3, #32]
 80121b2:	461a      	mov	r2, r3
 80121b4:	4613      	mov	r3, r2
 80121b6:	009b      	lsls	r3, r3, #2
 80121b8:	4413      	add	r3, r2
 80121ba:	005b      	lsls	r3, r3, #1
 80121bc:	461a      	mov	r2, r3
 80121be:	687b      	ldr	r3, [r7, #4]
 80121c0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80121c4:	4619      	mov	r1, r3
 80121c6:	4610      	mov	r0, r2
 80121c8:	f015 fca8 	bl	8027b1c <jdiv_round_up>
 80121cc:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80121ce:	461a      	mov	r2, r3
 80121d0:	687b      	ldr	r3, [r7, #4]
 80121d2:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 10;
 80121d4:	687b      	ldr	r3, [r7, #4]
 80121d6:	220a      	movs	r2, #10
 80121d8:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 10;
 80121dc:	687b      	ldr	r3, [r7, #4]
 80121de:	220a      	movs	r2, #10
 80121e0:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 80121e4:	e156      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 11) {
 80121e6:	687b      	ldr	r3, [r7, #4]
 80121e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80121ea:	687a      	ldr	r2, [r7, #4]
 80121ec:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 80121f0:	fb02 f103 	mul.w	r1, r2, r3
 80121f4:	687b      	ldr	r3, [r7, #4]
 80121f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80121f8:	4613      	mov	r3, r2
 80121fa:	009b      	lsls	r3, r3, #2
 80121fc:	4413      	add	r3, r2
 80121fe:	005b      	lsls	r3, r3, #1
 8012200:	4413      	add	r3, r2
 8012202:	4299      	cmp	r1, r3
 8012204:	d82e      	bhi.n	8012264 <jpeg_core_output_dimensions+0x4cc>
    /* Provide 11/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 11L, (long) cinfo->block_size);
 8012206:	687b      	ldr	r3, [r7, #4]
 8012208:	69db      	ldr	r3, [r3, #28]
 801220a:	461a      	mov	r2, r3
 801220c:	4613      	mov	r3, r2
 801220e:	009b      	lsls	r3, r3, #2
 8012210:	4413      	add	r3, r2
 8012212:	005b      	lsls	r3, r3, #1
 8012214:	441a      	add	r2, r3
 8012216:	687b      	ldr	r3, [r7, #4]
 8012218:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 801221c:	4619      	mov	r1, r3
 801221e:	4610      	mov	r0, r2
 8012220:	f015 fc7c 	bl	8027b1c <jdiv_round_up>
 8012224:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8012226:	461a      	mov	r2, r3
 8012228:	687b      	ldr	r3, [r7, #4]
 801222a:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 11L, (long) cinfo->block_size);
 801222c:	687b      	ldr	r3, [r7, #4]
 801222e:	6a1b      	ldr	r3, [r3, #32]
 8012230:	461a      	mov	r2, r3
 8012232:	4613      	mov	r3, r2
 8012234:	009b      	lsls	r3, r3, #2
 8012236:	4413      	add	r3, r2
 8012238:	005b      	lsls	r3, r3, #1
 801223a:	441a      	add	r2, r3
 801223c:	687b      	ldr	r3, [r7, #4]
 801223e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012242:	4619      	mov	r1, r3
 8012244:	4610      	mov	r0, r2
 8012246:	f015 fc69 	bl	8027b1c <jdiv_round_up>
 801224a:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801224c:	461a      	mov	r2, r3
 801224e:	687b      	ldr	r3, [r7, #4]
 8012250:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 11;
 8012252:	687b      	ldr	r3, [r7, #4]
 8012254:	220b      	movs	r2, #11
 8012256:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 11;
 801225a:	687b      	ldr	r3, [r7, #4]
 801225c:	220b      	movs	r2, #11
 801225e:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 8012262:	e117      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 12) {
 8012264:	687b      	ldr	r3, [r7, #4]
 8012266:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012268:	687a      	ldr	r2, [r7, #4]
 801226a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 801226e:	fb02 f103 	mul.w	r1, r2, r3
 8012272:	687b      	ldr	r3, [r7, #4]
 8012274:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012276:	4613      	mov	r3, r2
 8012278:	005b      	lsls	r3, r3, #1
 801227a:	4413      	add	r3, r2
 801227c:	009b      	lsls	r3, r3, #2
 801227e:	4299      	cmp	r1, r3
 8012280:	d82e      	bhi.n	80122e0 <jpeg_core_output_dimensions+0x548>
    /* Provide 12/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 12L, (long) cinfo->block_size);
 8012282:	687b      	ldr	r3, [r7, #4]
 8012284:	69db      	ldr	r3, [r3, #28]
 8012286:	461a      	mov	r2, r3
 8012288:	4613      	mov	r3, r2
 801228a:	005b      	lsls	r3, r3, #1
 801228c:	4413      	add	r3, r2
 801228e:	009b      	lsls	r3, r3, #2
 8012290:	461a      	mov	r2, r3
 8012292:	687b      	ldr	r3, [r7, #4]
 8012294:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012298:	4619      	mov	r1, r3
 801229a:	4610      	mov	r0, r2
 801229c:	f015 fc3e 	bl	8027b1c <jdiv_round_up>
 80122a0:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 80122a2:	461a      	mov	r2, r3
 80122a4:	687b      	ldr	r3, [r7, #4]
 80122a6:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 12L, (long) cinfo->block_size);
 80122a8:	687b      	ldr	r3, [r7, #4]
 80122aa:	6a1b      	ldr	r3, [r3, #32]
 80122ac:	461a      	mov	r2, r3
 80122ae:	4613      	mov	r3, r2
 80122b0:	005b      	lsls	r3, r3, #1
 80122b2:	4413      	add	r3, r2
 80122b4:	009b      	lsls	r3, r3, #2
 80122b6:	461a      	mov	r2, r3
 80122b8:	687b      	ldr	r3, [r7, #4]
 80122ba:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80122be:	4619      	mov	r1, r3
 80122c0:	4610      	mov	r0, r2
 80122c2:	f015 fc2b 	bl	8027b1c <jdiv_round_up>
 80122c6:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80122c8:	461a      	mov	r2, r3
 80122ca:	687b      	ldr	r3, [r7, #4]
 80122cc:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 12;
 80122ce:	687b      	ldr	r3, [r7, #4]
 80122d0:	220c      	movs	r2, #12
 80122d2:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 12;
 80122d6:	687b      	ldr	r3, [r7, #4]
 80122d8:	220c      	movs	r2, #12
 80122da:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 80122de:	e0d9      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 13) {
 80122e0:	687b      	ldr	r3, [r7, #4]
 80122e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80122e4:	687a      	ldr	r2, [r7, #4]
 80122e6:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 80122ea:	fb02 f103 	mul.w	r1, r2, r3
 80122ee:	687b      	ldr	r3, [r7, #4]
 80122f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80122f2:	4613      	mov	r3, r2
 80122f4:	005b      	lsls	r3, r3, #1
 80122f6:	4413      	add	r3, r2
 80122f8:	009b      	lsls	r3, r3, #2
 80122fa:	4413      	add	r3, r2
 80122fc:	4299      	cmp	r1, r3
 80122fe:	d82e      	bhi.n	801235e <jpeg_core_output_dimensions+0x5c6>
    /* Provide 13/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 13L, (long) cinfo->block_size);
 8012300:	687b      	ldr	r3, [r7, #4]
 8012302:	69db      	ldr	r3, [r3, #28]
 8012304:	461a      	mov	r2, r3
 8012306:	4613      	mov	r3, r2
 8012308:	005b      	lsls	r3, r3, #1
 801230a:	4413      	add	r3, r2
 801230c:	009b      	lsls	r3, r3, #2
 801230e:	441a      	add	r2, r3
 8012310:	687b      	ldr	r3, [r7, #4]
 8012312:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012316:	4619      	mov	r1, r3
 8012318:	4610      	mov	r0, r2
 801231a:	f015 fbff 	bl	8027b1c <jdiv_round_up>
 801231e:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8012320:	461a      	mov	r2, r3
 8012322:	687b      	ldr	r3, [r7, #4]
 8012324:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 13L, (long) cinfo->block_size);
 8012326:	687b      	ldr	r3, [r7, #4]
 8012328:	6a1b      	ldr	r3, [r3, #32]
 801232a:	461a      	mov	r2, r3
 801232c:	4613      	mov	r3, r2
 801232e:	005b      	lsls	r3, r3, #1
 8012330:	4413      	add	r3, r2
 8012332:	009b      	lsls	r3, r3, #2
 8012334:	441a      	add	r2, r3
 8012336:	687b      	ldr	r3, [r7, #4]
 8012338:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 801233c:	4619      	mov	r1, r3
 801233e:	4610      	mov	r0, r2
 8012340:	f015 fbec 	bl	8027b1c <jdiv_round_up>
 8012344:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8012346:	461a      	mov	r2, r3
 8012348:	687b      	ldr	r3, [r7, #4]
 801234a:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 13;
 801234c:	687b      	ldr	r3, [r7, #4]
 801234e:	220d      	movs	r2, #13
 8012350:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 13;
 8012354:	687b      	ldr	r3, [r7, #4]
 8012356:	220d      	movs	r2, #13
 8012358:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 801235c:	e09a      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 14) {
 801235e:	687b      	ldr	r3, [r7, #4]
 8012360:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012362:	687a      	ldr	r2, [r7, #4]
 8012364:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012368:	fb02 f103 	mul.w	r1, r2, r3
 801236c:	687b      	ldr	r3, [r7, #4]
 801236e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012370:	4613      	mov	r3, r2
 8012372:	00db      	lsls	r3, r3, #3
 8012374:	1a9b      	subs	r3, r3, r2
 8012376:	005b      	lsls	r3, r3, #1
 8012378:	4299      	cmp	r1, r3
 801237a:	d82e      	bhi.n	80123da <jpeg_core_output_dimensions+0x642>
    /* Provide 14/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 14L, (long) cinfo->block_size);
 801237c:	687b      	ldr	r3, [r7, #4]
 801237e:	69db      	ldr	r3, [r3, #28]
 8012380:	461a      	mov	r2, r3
 8012382:	4613      	mov	r3, r2
 8012384:	00db      	lsls	r3, r3, #3
 8012386:	1a9b      	subs	r3, r3, r2
 8012388:	005b      	lsls	r3, r3, #1
 801238a:	461a      	mov	r2, r3
 801238c:	687b      	ldr	r3, [r7, #4]
 801238e:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012392:	4619      	mov	r1, r3
 8012394:	4610      	mov	r0, r2
 8012396:	f015 fbc1 	bl	8027b1c <jdiv_round_up>
 801239a:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 801239c:	461a      	mov	r2, r3
 801239e:	687b      	ldr	r3, [r7, #4]
 80123a0:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 14L, (long) cinfo->block_size);
 80123a2:	687b      	ldr	r3, [r7, #4]
 80123a4:	6a1b      	ldr	r3, [r3, #32]
 80123a6:	461a      	mov	r2, r3
 80123a8:	4613      	mov	r3, r2
 80123aa:	00db      	lsls	r3, r3, #3
 80123ac:	1a9b      	subs	r3, r3, r2
 80123ae:	005b      	lsls	r3, r3, #1
 80123b0:	461a      	mov	r2, r3
 80123b2:	687b      	ldr	r3, [r7, #4]
 80123b4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80123b8:	4619      	mov	r1, r3
 80123ba:	4610      	mov	r0, r2
 80123bc:	f015 fbae 	bl	8027b1c <jdiv_round_up>
 80123c0:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 80123c2:	461a      	mov	r2, r3
 80123c4:	687b      	ldr	r3, [r7, #4]
 80123c6:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 14;
 80123c8:	687b      	ldr	r3, [r7, #4]
 80123ca:	220e      	movs	r2, #14
 80123cc:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 14;
 80123d0:	687b      	ldr	r3, [r7, #4]
 80123d2:	220e      	movs	r2, #14
 80123d4:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 80123d8:	e05c      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else if (cinfo->scale_num * cinfo->block_size <= cinfo->scale_denom * 15) {
 80123da:	687b      	ldr	r3, [r7, #4]
 80123dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80123de:	687a      	ldr	r2, [r7, #4]
 80123e0:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 80123e4:	fb02 f103 	mul.w	r1, r2, r3
 80123e8:	687b      	ldr	r3, [r7, #4]
 80123ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80123ec:	4613      	mov	r3, r2
 80123ee:	011b      	lsls	r3, r3, #4
 80123f0:	1a9b      	subs	r3, r3, r2
 80123f2:	4299      	cmp	r1, r3
 80123f4:	d82a      	bhi.n	801244c <jpeg_core_output_dimensions+0x6b4>
    /* Provide 15/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 15L, (long) cinfo->block_size);
 80123f6:	687b      	ldr	r3, [r7, #4]
 80123f8:	69db      	ldr	r3, [r3, #28]
 80123fa:	461a      	mov	r2, r3
 80123fc:	4613      	mov	r3, r2
 80123fe:	011b      	lsls	r3, r3, #4
 8012400:	1a9a      	subs	r2, r3, r2
 8012402:	687b      	ldr	r3, [r7, #4]
 8012404:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012408:	4619      	mov	r1, r3
 801240a:	4610      	mov	r0, r2
 801240c:	f015 fb86 	bl	8027b1c <jdiv_round_up>
 8012410:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8012412:	461a      	mov	r2, r3
 8012414:	687b      	ldr	r3, [r7, #4]
 8012416:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 15L, (long) cinfo->block_size);
 8012418:	687b      	ldr	r3, [r7, #4]
 801241a:	6a1b      	ldr	r3, [r3, #32]
 801241c:	461a      	mov	r2, r3
 801241e:	4613      	mov	r3, r2
 8012420:	011b      	lsls	r3, r3, #4
 8012422:	1a9a      	subs	r2, r3, r2
 8012424:	687b      	ldr	r3, [r7, #4]
 8012426:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 801242a:	4619      	mov	r1, r3
 801242c:	4610      	mov	r0, r2
 801242e:	f015 fb75 	bl	8027b1c <jdiv_round_up>
 8012432:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 8012434:	461a      	mov	r2, r3
 8012436:	687b      	ldr	r3, [r7, #4]
 8012438:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 15;
 801243a:	687b      	ldr	r3, [r7, #4]
 801243c:	220f      	movs	r2, #15
 801243e:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 15;
 8012442:	687b      	ldr	r3, [r7, #4]
 8012444:	220f      	movs	r2, #15
 8012446:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
 801244a:	e023      	b.n	8012494 <jpeg_core_output_dimensions+0x6fc>
  } else {
    /* Provide 16/block_size scaling */
    cinfo->output_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * 16L, (long) cinfo->block_size);
 801244c:	687b      	ldr	r3, [r7, #4]
 801244e:	69db      	ldr	r3, [r3, #28]
 8012450:	011a      	lsls	r2, r3, #4
 8012452:	687b      	ldr	r3, [r7, #4]
 8012454:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012458:	4619      	mov	r1, r3
 801245a:	4610      	mov	r0, r2
 801245c:	f015 fb5e 	bl	8027b1c <jdiv_round_up>
 8012460:	4603      	mov	r3, r0
    cinfo->output_width = (JDIMENSION)
 8012462:	461a      	mov	r2, r3
 8012464:	687b      	ldr	r3, [r7, #4]
 8012466:	671a      	str	r2, [r3, #112]	; 0x70
    cinfo->output_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * 16L, (long) cinfo->block_size);
 8012468:	687b      	ldr	r3, [r7, #4]
 801246a:	6a1b      	ldr	r3, [r3, #32]
 801246c:	011a      	lsls	r2, r3, #4
 801246e:	687b      	ldr	r3, [r7, #4]
 8012470:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8012474:	4619      	mov	r1, r3
 8012476:	4610      	mov	r0, r2
 8012478:	f015 fb50 	bl	8027b1c <jdiv_round_up>
 801247c:	4603      	mov	r3, r0
    cinfo->output_height = (JDIMENSION)
 801247e:	461a      	mov	r2, r3
 8012480:	687b      	ldr	r3, [r7, #4]
 8012482:	675a      	str	r2, [r3, #116]	; 0x74
    cinfo->min_DCT_h_scaled_size = 16;
 8012484:	687b      	ldr	r3, [r7, #4]
 8012486:	2210      	movs	r2, #16
 8012488:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    cinfo->min_DCT_v_scaled_size = 16;
 801248c:	687b      	ldr	r3, [r7, #4]
 801248e:	2210      	movs	r2, #16
 8012490:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
  }

  /* Recompute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012494:	2300      	movs	r3, #0
 8012496:	60fb      	str	r3, [r7, #12]
 8012498:	687b      	ldr	r3, [r7, #4]
 801249a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 801249e:	60bb      	str	r3, [r7, #8]
 80124a0:	e00f      	b.n	80124c2 <jpeg_core_output_dimensions+0x72a>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size;
 80124a2:	687b      	ldr	r3, [r7, #4]
 80124a4:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 80124a8:	68bb      	ldr	r3, [r7, #8]
 80124aa:	625a      	str	r2, [r3, #36]	; 0x24
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size;
 80124ac:	687b      	ldr	r3, [r7, #4]
 80124ae:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
 80124b2:	68bb      	ldr	r3, [r7, #8]
 80124b4:	629a      	str	r2, [r3, #40]	; 0x28
       ci++, compptr++) {
 80124b6:	68fb      	ldr	r3, [r7, #12]
 80124b8:	3301      	adds	r3, #1
 80124ba:	60fb      	str	r3, [r7, #12]
 80124bc:	68bb      	ldr	r3, [r7, #8]
 80124be:	3358      	adds	r3, #88	; 0x58
 80124c0:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80124c2:	687b      	ldr	r3, [r7, #4]
 80124c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80124c6:	68fa      	ldr	r2, [r7, #12]
 80124c8:	429a      	cmp	r2, r3
 80124ca:	dbea      	blt.n	80124a2 <jpeg_core_output_dimensions+0x70a>
  /* jdinput.c has already initialized DCT_scaled_size,
   * and has computed unscaled downsampled_width and downsampled_height.
   */

#endif /* IDCT_SCALING_SUPPORTED */
}
 80124cc:	bf00      	nop
 80124ce:	bf00      	nop
 80124d0:	3710      	adds	r7, #16
 80124d2:	46bd      	mov	sp, r7
 80124d4:	bd80      	pop	{r7, pc}
	...

080124d8 <initial_setup>:


LOCAL(void)
initial_setup (j_decompress_ptr cinfo)
/* Called once, when first SOS marker is reached */
{
 80124d8:	b580      	push	{r7, lr}
 80124da:	b084      	sub	sp, #16
 80124dc:	af00      	add	r7, sp, #0
 80124de:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 80124e0:	687b      	ldr	r3, [r7, #4]
 80124e2:	6a1b      	ldr	r3, [r3, #32]
 80124e4:	461a      	mov	r2, r3
 80124e6:	f64f 73dc 	movw	r3, #65500	; 0xffdc
 80124ea:	429a      	cmp	r2, r3
 80124ec:	dc06      	bgt.n	80124fc <initial_setup+0x24>
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
 80124ee:	687b      	ldr	r3, [r7, #4]
 80124f0:	69db      	ldr	r3, [r3, #28]
 80124f2:	461a      	mov	r2, r3
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
 80124f4:	f64f 73dc 	movw	r3, #65500	; 0xffdc
 80124f8:	429a      	cmp	r2, r3
 80124fa:	dd0d      	ble.n	8012518 <initial_setup+0x40>
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
 80124fc:	687b      	ldr	r3, [r7, #4]
 80124fe:	681b      	ldr	r3, [r3, #0]
 8012500:	222a      	movs	r2, #42	; 0x2a
 8012502:	615a      	str	r2, [r3, #20]
 8012504:	687b      	ldr	r3, [r7, #4]
 8012506:	681b      	ldr	r3, [r3, #0]
 8012508:	f64f 72dc 	movw	r2, #65500	; 0xffdc
 801250c:	619a      	str	r2, [r3, #24]
 801250e:	687b      	ldr	r3, [r7, #4]
 8012510:	681b      	ldr	r3, [r3, #0]
 8012512:	681b      	ldr	r3, [r3, #0]
 8012514:	6878      	ldr	r0, [r7, #4]
 8012516:	4798      	blx	r3

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
 8012518:	687b      	ldr	r3, [r7, #4]
 801251a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801251e:	2b08      	cmp	r3, #8
 8012520:	d00e      	beq.n	8012540 <initial_setup+0x68>
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 8012522:	687b      	ldr	r3, [r7, #4]
 8012524:	681b      	ldr	r3, [r3, #0]
 8012526:	2210      	movs	r2, #16
 8012528:	615a      	str	r2, [r3, #20]
 801252a:	687b      	ldr	r3, [r7, #4]
 801252c:	681b      	ldr	r3, [r3, #0]
 801252e:	687a      	ldr	r2, [r7, #4]
 8012530:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
 8012534:	619a      	str	r2, [r3, #24]
 8012536:	687b      	ldr	r3, [r7, #4]
 8012538:	681b      	ldr	r3, [r3, #0]
 801253a:	681b      	ldr	r3, [r3, #0]
 801253c:	6878      	ldr	r0, [r7, #4]
 801253e:	4798      	blx	r3

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
 8012540:	687b      	ldr	r3, [r7, #4]
 8012542:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012544:	2b0a      	cmp	r3, #10
 8012546:	dd11      	ble.n	801256c <initial_setup+0x94>
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
 8012548:	687b      	ldr	r3, [r7, #4]
 801254a:	681b      	ldr	r3, [r3, #0]
 801254c:	221b      	movs	r2, #27
 801254e:	615a      	str	r2, [r3, #20]
 8012550:	687b      	ldr	r3, [r7, #4]
 8012552:	681b      	ldr	r3, [r3, #0]
 8012554:	687a      	ldr	r2, [r7, #4]
 8012556:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8012558:	619a      	str	r2, [r3, #24]
 801255a:	687b      	ldr	r3, [r7, #4]
 801255c:	681b      	ldr	r3, [r3, #0]
 801255e:	220a      	movs	r2, #10
 8012560:	61da      	str	r2, [r3, #28]
 8012562:	687b      	ldr	r3, [r7, #4]
 8012564:	681b      	ldr	r3, [r3, #0]
 8012566:	681b      	ldr	r3, [r3, #0]
 8012568:	6878      	ldr	r0, [r7, #4]
 801256a:	4798      	blx	r3
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
 801256c:	687b      	ldr	r3, [r7, #4]
 801256e:	2201      	movs	r2, #1
 8012570:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
  cinfo->max_v_samp_factor = 1;
 8012574:	687b      	ldr	r3, [r7, #4]
 8012576:	2201      	movs	r2, #1
 8012578:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801257c:	2300      	movs	r3, #0
 801257e:	60fb      	str	r3, [r7, #12]
 8012580:	687b      	ldr	r3, [r7, #4]
 8012582:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8012586:	60bb      	str	r3, [r7, #8]
 8012588:	e034      	b.n	80125f4 <initial_setup+0x11c>
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 801258a:	68bb      	ldr	r3, [r7, #8]
 801258c:	689b      	ldr	r3, [r3, #8]
 801258e:	2b00      	cmp	r3, #0
 8012590:	dd0b      	ble.n	80125aa <initial_setup+0xd2>
 8012592:	68bb      	ldr	r3, [r7, #8]
 8012594:	689b      	ldr	r3, [r3, #8]
 8012596:	2b04      	cmp	r3, #4
 8012598:	dc07      	bgt.n	80125aa <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 801259a:	68bb      	ldr	r3, [r7, #8]
 801259c:	68db      	ldr	r3, [r3, #12]
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
 801259e:	2b00      	cmp	r3, #0
 80125a0:	dd03      	ble.n	80125aa <initial_setup+0xd2>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
 80125a2:	68bb      	ldr	r3, [r7, #8]
 80125a4:	68db      	ldr	r3, [r3, #12]
 80125a6:	2b04      	cmp	r3, #4
 80125a8:	dd08      	ble.n	80125bc <initial_setup+0xe4>
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
 80125aa:	687b      	ldr	r3, [r7, #4]
 80125ac:	681b      	ldr	r3, [r3, #0]
 80125ae:	2213      	movs	r2, #19
 80125b0:	615a      	str	r2, [r3, #20]
 80125b2:	687b      	ldr	r3, [r7, #4]
 80125b4:	681b      	ldr	r3, [r3, #0]
 80125b6:	681b      	ldr	r3, [r3, #0]
 80125b8:	6878      	ldr	r0, [r7, #4]
 80125ba:	4798      	blx	r3
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
 80125bc:	68bb      	ldr	r3, [r7, #8]
 80125be:	689a      	ldr	r2, [r3, #8]
 80125c0:	687b      	ldr	r3, [r7, #4]
 80125c2:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 80125c6:	429a      	cmp	r2, r3
 80125c8:	bfb8      	it	lt
 80125ca:	461a      	movlt	r2, r3
 80125cc:	687b      	ldr	r3, [r7, #4]
 80125ce:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
 80125d2:	68bb      	ldr	r3, [r7, #8]
 80125d4:	68da      	ldr	r2, [r3, #12]
 80125d6:	687b      	ldr	r3, [r7, #4]
 80125d8:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 80125dc:	429a      	cmp	r2, r3
 80125de:	bfb8      	it	lt
 80125e0:	461a      	movlt	r2, r3
 80125e2:	687b      	ldr	r3, [r7, #4]
 80125e4:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
       ci++, compptr++) {
 80125e8:	68fb      	ldr	r3, [r7, #12]
 80125ea:	3301      	adds	r3, #1
 80125ec:	60fb      	str	r3, [r7, #12]
 80125ee:	68bb      	ldr	r3, [r7, #8]
 80125f0:	3358      	adds	r3, #88	; 0x58
 80125f2:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80125f4:	687b      	ldr	r3, [r7, #4]
 80125f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80125f8:	68fa      	ldr	r2, [r7, #12]
 80125fa:	429a      	cmp	r2, r3
 80125fc:	dbc5      	blt.n	801258a <initial_setup+0xb2>
				   compptr->v_samp_factor);
  }

  /* Derive block_size, natural_order, and lim_Se */
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 80125fe:	687b      	ldr	r3, [r7, #4]
 8012600:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8012604:	2b00      	cmp	r3, #0
 8012606:	d109      	bne.n	801261c <initial_setup+0x144>
 8012608:	687b      	ldr	r3, [r7, #4]
 801260a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801260e:	2b00      	cmp	r3, #0
 8012610:	d011      	beq.n	8012636 <initial_setup+0x15e>
      cinfo->comps_in_scan)) { /* no pseudo SOS marker */
 8012612:	687b      	ldr	r3, [r7, #4]
 8012614:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
  if (cinfo->is_baseline || (cinfo->progressive_mode &&
 8012618:	2b00      	cmp	r3, #0
 801261a:	d00c      	beq.n	8012636 <initial_setup+0x15e>
    cinfo->block_size = DCTSIZE;
 801261c:	687b      	ldr	r3, [r7, #4]
 801261e:	2208      	movs	r2, #8
 8012620:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
    cinfo->natural_order = jpeg_natural_order;
 8012624:	687b      	ldr	r3, [r7, #4]
 8012626:	4aca      	ldr	r2, [pc, #808]	; (8012950 <initial_setup+0x478>)
 8012628:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    cinfo->lim_Se = DCTSIZE2-1;
 801262c:	687b      	ldr	r3, [r7, #4]
 801262e:	223f      	movs	r2, #63	; 0x3f
 8012630:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
 8012634:	e1c9      	b.n	80129ca <initial_setup+0x4f2>
  } else
    switch (cinfo->Se) {
 8012636:	687b      	ldr	r3, [r7, #4]
 8012638:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 801263c:	2bff      	cmp	r3, #255	; 0xff
 801263e:	f000 8195 	beq.w	801296c <initial_setup+0x494>
 8012642:	2bff      	cmp	r3, #255	; 0xff
 8012644:	f300 819f 	bgt.w	8012986 <initial_setup+0x4ae>
 8012648:	2be0      	cmp	r3, #224	; 0xe0
 801264a:	f000 8174 	beq.w	8012936 <initial_setup+0x45e>
 801264e:	2be0      	cmp	r3, #224	; 0xe0
 8012650:	f300 8199 	bgt.w	8012986 <initial_setup+0x4ae>
 8012654:	2bc3      	cmp	r3, #195	; 0xc3
 8012656:	f000 8161 	beq.w	801291c <initial_setup+0x444>
 801265a:	2bc3      	cmp	r3, #195	; 0xc3
 801265c:	f300 8193 	bgt.w	8012986 <initial_setup+0x4ae>
 8012660:	2ba8      	cmp	r3, #168	; 0xa8
 8012662:	f000 814e 	beq.w	8012902 <initial_setup+0x42a>
 8012666:	2ba8      	cmp	r3, #168	; 0xa8
 8012668:	f300 818d 	bgt.w	8012986 <initial_setup+0x4ae>
 801266c:	2b8f      	cmp	r3, #143	; 0x8f
 801266e:	f000 813b 	beq.w	80128e8 <initial_setup+0x410>
 8012672:	2b8f      	cmp	r3, #143	; 0x8f
 8012674:	f300 8187 	bgt.w	8012986 <initial_setup+0x4ae>
 8012678:	2b78      	cmp	r3, #120	; 0x78
 801267a:	f000 8128 	beq.w	80128ce <initial_setup+0x3f6>
 801267e:	2b78      	cmp	r3, #120	; 0x78
 8012680:	f300 8181 	bgt.w	8012986 <initial_setup+0x4ae>
 8012684:	2b63      	cmp	r3, #99	; 0x63
 8012686:	f000 8115 	beq.w	80128b4 <initial_setup+0x3dc>
 801268a:	2b63      	cmp	r3, #99	; 0x63
 801268c:	f300 817b 	bgt.w	8012986 <initial_setup+0x4ae>
 8012690:	2b3f      	cmp	r3, #63	; 0x3f
 8012692:	f300 8089 	bgt.w	80127a8 <initial_setup+0x2d0>
 8012696:	2b00      	cmp	r3, #0
 8012698:	f2c0 8175 	blt.w	8012986 <initial_setup+0x4ae>
 801269c:	2b3f      	cmp	r3, #63	; 0x3f
 801269e:	f200 8172 	bhi.w	8012986 <initial_setup+0x4ae>
 80126a2:	a201      	add	r2, pc, #4	; (adr r2, 80126a8 <initial_setup+0x1d0>)
 80126a4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80126a8:	080127af 	.word	0x080127af
 80126ac:	08012987 	.word	0x08012987
 80126b0:	08012987 	.word	0x08012987
 80126b4:	080127cd 	.word	0x080127cd
 80126b8:	08012987 	.word	0x08012987
 80126bc:	08012987 	.word	0x08012987
 80126c0:	08012987 	.word	0x08012987
 80126c4:	08012987 	.word	0x08012987
 80126c8:	080127eb 	.word	0x080127eb
 80126cc:	08012987 	.word	0x08012987
 80126d0:	08012987 	.word	0x08012987
 80126d4:	08012987 	.word	0x08012987
 80126d8:	08012987 	.word	0x08012987
 80126dc:	08012987 	.word	0x08012987
 80126e0:	08012987 	.word	0x08012987
 80126e4:	08012809 	.word	0x08012809
 80126e8:	08012987 	.word	0x08012987
 80126ec:	08012987 	.word	0x08012987
 80126f0:	08012987 	.word	0x08012987
 80126f4:	08012987 	.word	0x08012987
 80126f8:	08012987 	.word	0x08012987
 80126fc:	08012987 	.word	0x08012987
 8012700:	08012987 	.word	0x08012987
 8012704:	08012987 	.word	0x08012987
 8012708:	08012827 	.word	0x08012827
 801270c:	08012987 	.word	0x08012987
 8012710:	08012987 	.word	0x08012987
 8012714:	08012987 	.word	0x08012987
 8012718:	08012987 	.word	0x08012987
 801271c:	08012987 	.word	0x08012987
 8012720:	08012987 	.word	0x08012987
 8012724:	08012987 	.word	0x08012987
 8012728:	08012987 	.word	0x08012987
 801272c:	08012987 	.word	0x08012987
 8012730:	08012987 	.word	0x08012987
 8012734:	08012845 	.word	0x08012845
 8012738:	08012987 	.word	0x08012987
 801273c:	08012987 	.word	0x08012987
 8012740:	08012987 	.word	0x08012987
 8012744:	08012987 	.word	0x08012987
 8012748:	08012987 	.word	0x08012987
 801274c:	08012987 	.word	0x08012987
 8012750:	08012987 	.word	0x08012987
 8012754:	08012987 	.word	0x08012987
 8012758:	08012987 	.word	0x08012987
 801275c:	08012987 	.word	0x08012987
 8012760:	08012987 	.word	0x08012987
 8012764:	08012987 	.word	0x08012987
 8012768:	08012863 	.word	0x08012863
 801276c:	08012987 	.word	0x08012987
 8012770:	08012987 	.word	0x08012987
 8012774:	08012987 	.word	0x08012987
 8012778:	08012987 	.word	0x08012987
 801277c:	08012987 	.word	0x08012987
 8012780:	08012987 	.word	0x08012987
 8012784:	08012987 	.word	0x08012987
 8012788:	08012987 	.word	0x08012987
 801278c:	08012987 	.word	0x08012987
 8012790:	08012987 	.word	0x08012987
 8012794:	08012987 	.word	0x08012987
 8012798:	08012987 	.word	0x08012987
 801279c:	08012987 	.word	0x08012987
 80127a0:	08012987 	.word	0x08012987
 80127a4:	08012881 	.word	0x08012881
 80127a8:	2b50      	cmp	r3, #80	; 0x50
 80127aa:	d076      	beq.n	801289a <initial_setup+0x3c2>
 80127ac:	e0eb      	b.n	8012986 <initial_setup+0x4ae>
    case (1*1-1):
      cinfo->block_size = 1;
 80127ae:	687b      	ldr	r3, [r7, #4]
 80127b0:	2201      	movs	r2, #1
 80127b2:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order; /* not needed */
 80127b6:	687b      	ldr	r3, [r7, #4]
 80127b8:	4a65      	ldr	r2, [pc, #404]	; (8012950 <initial_setup+0x478>)
 80127ba:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80127be:	687b      	ldr	r3, [r7, #4]
 80127c0:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 80127c4:	687b      	ldr	r3, [r7, #4]
 80127c6:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 80127ca:	e0fe      	b.n	80129ca <initial_setup+0x4f2>
    case (2*2-1):
      cinfo->block_size = 2;
 80127cc:	687b      	ldr	r3, [r7, #4]
 80127ce:	2202      	movs	r2, #2
 80127d0:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order2;
 80127d4:	687b      	ldr	r3, [r7, #4]
 80127d6:	4a5f      	ldr	r2, [pc, #380]	; (8012954 <initial_setup+0x47c>)
 80127d8:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80127dc:	687b      	ldr	r3, [r7, #4]
 80127de:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 80127e2:	687b      	ldr	r3, [r7, #4]
 80127e4:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 80127e8:	e0ef      	b.n	80129ca <initial_setup+0x4f2>
    case (3*3-1):
      cinfo->block_size = 3;
 80127ea:	687b      	ldr	r3, [r7, #4]
 80127ec:	2203      	movs	r2, #3
 80127ee:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order3;
 80127f2:	687b      	ldr	r3, [r7, #4]
 80127f4:	4a58      	ldr	r2, [pc, #352]	; (8012958 <initial_setup+0x480>)
 80127f6:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 80127fa:	687b      	ldr	r3, [r7, #4]
 80127fc:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 8012800:	687b      	ldr	r3, [r7, #4]
 8012802:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012806:	e0e0      	b.n	80129ca <initial_setup+0x4f2>
    case (4*4-1):
      cinfo->block_size = 4;
 8012808:	687b      	ldr	r3, [r7, #4]
 801280a:	2204      	movs	r2, #4
 801280c:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order4;
 8012810:	687b      	ldr	r3, [r7, #4]
 8012812:	4a52      	ldr	r2, [pc, #328]	; (801295c <initial_setup+0x484>)
 8012814:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8012818:	687b      	ldr	r3, [r7, #4]
 801281a:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 801281e:	687b      	ldr	r3, [r7, #4]
 8012820:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012824:	e0d1      	b.n	80129ca <initial_setup+0x4f2>
    case (5*5-1):
      cinfo->block_size = 5;
 8012826:	687b      	ldr	r3, [r7, #4]
 8012828:	2205      	movs	r2, #5
 801282a:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order5;
 801282e:	687b      	ldr	r3, [r7, #4]
 8012830:	4a4b      	ldr	r2, [pc, #300]	; (8012960 <initial_setup+0x488>)
 8012832:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8012836:	687b      	ldr	r3, [r7, #4]
 8012838:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 801283c:	687b      	ldr	r3, [r7, #4]
 801283e:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012842:	e0c2      	b.n	80129ca <initial_setup+0x4f2>
    case (6*6-1):
      cinfo->block_size = 6;
 8012844:	687b      	ldr	r3, [r7, #4]
 8012846:	2206      	movs	r2, #6
 8012848:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order6;
 801284c:	687b      	ldr	r3, [r7, #4]
 801284e:	4a45      	ldr	r2, [pc, #276]	; (8012964 <initial_setup+0x48c>)
 8012850:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8012854:	687b      	ldr	r3, [r7, #4]
 8012856:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 801285a:	687b      	ldr	r3, [r7, #4]
 801285c:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012860:	e0b3      	b.n	80129ca <initial_setup+0x4f2>
    case (7*7-1):
      cinfo->block_size = 7;
 8012862:	687b      	ldr	r3, [r7, #4]
 8012864:	2207      	movs	r2, #7
 8012866:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order7;
 801286a:	687b      	ldr	r3, [r7, #4]
 801286c:	4a3e      	ldr	r2, [pc, #248]	; (8012968 <initial_setup+0x490>)
 801286e:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = cinfo->Se;
 8012872:	687b      	ldr	r3, [r7, #4]
 8012874:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
 8012878:	687b      	ldr	r3, [r7, #4]
 801287a:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 801287e:	e0a4      	b.n	80129ca <initial_setup+0x4f2>
    case (8*8-1):
      cinfo->block_size = 8;
 8012880:	687b      	ldr	r3, [r7, #4]
 8012882:	2208      	movs	r2, #8
 8012884:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8012888:	687b      	ldr	r3, [r7, #4]
 801288a:	4a31      	ldr	r2, [pc, #196]	; (8012950 <initial_setup+0x478>)
 801288c:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8012890:	687b      	ldr	r3, [r7, #4]
 8012892:	223f      	movs	r2, #63	; 0x3f
 8012894:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012898:	e097      	b.n	80129ca <initial_setup+0x4f2>
    case (9*9-1):
      cinfo->block_size = 9;
 801289a:	687b      	ldr	r3, [r7, #4]
 801289c:	2209      	movs	r2, #9
 801289e:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80128a2:	687b      	ldr	r3, [r7, #4]
 80128a4:	4a2a      	ldr	r2, [pc, #168]	; (8012950 <initial_setup+0x478>)
 80128a6:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80128aa:	687b      	ldr	r3, [r7, #4]
 80128ac:	223f      	movs	r2, #63	; 0x3f
 80128ae:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 80128b2:	e08a      	b.n	80129ca <initial_setup+0x4f2>
    case (10*10-1):
      cinfo->block_size = 10;
 80128b4:	687b      	ldr	r3, [r7, #4]
 80128b6:	220a      	movs	r2, #10
 80128b8:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80128bc:	687b      	ldr	r3, [r7, #4]
 80128be:	4a24      	ldr	r2, [pc, #144]	; (8012950 <initial_setup+0x478>)
 80128c0:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80128c4:	687b      	ldr	r3, [r7, #4]
 80128c6:	223f      	movs	r2, #63	; 0x3f
 80128c8:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 80128cc:	e07d      	b.n	80129ca <initial_setup+0x4f2>
    case (11*11-1):
      cinfo->block_size = 11;
 80128ce:	687b      	ldr	r3, [r7, #4]
 80128d0:	220b      	movs	r2, #11
 80128d2:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80128d6:	687b      	ldr	r3, [r7, #4]
 80128d8:	4a1d      	ldr	r2, [pc, #116]	; (8012950 <initial_setup+0x478>)
 80128da:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80128de:	687b      	ldr	r3, [r7, #4]
 80128e0:	223f      	movs	r2, #63	; 0x3f
 80128e2:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 80128e6:	e070      	b.n	80129ca <initial_setup+0x4f2>
    case (12*12-1):
      cinfo->block_size = 12;
 80128e8:	687b      	ldr	r3, [r7, #4]
 80128ea:	220c      	movs	r2, #12
 80128ec:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 80128f0:	687b      	ldr	r3, [r7, #4]
 80128f2:	4a17      	ldr	r2, [pc, #92]	; (8012950 <initial_setup+0x478>)
 80128f4:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 80128f8:	687b      	ldr	r3, [r7, #4]
 80128fa:	223f      	movs	r2, #63	; 0x3f
 80128fc:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012900:	e063      	b.n	80129ca <initial_setup+0x4f2>
    case (13*13-1):
      cinfo->block_size = 13;
 8012902:	687b      	ldr	r3, [r7, #4]
 8012904:	220d      	movs	r2, #13
 8012906:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801290a:	687b      	ldr	r3, [r7, #4]
 801290c:	4a10      	ldr	r2, [pc, #64]	; (8012950 <initial_setup+0x478>)
 801290e:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8012912:	687b      	ldr	r3, [r7, #4]
 8012914:	223f      	movs	r2, #63	; 0x3f
 8012916:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 801291a:	e056      	b.n	80129ca <initial_setup+0x4f2>
    case (14*14-1):
      cinfo->block_size = 14;
 801291c:	687b      	ldr	r3, [r7, #4]
 801291e:	220e      	movs	r2, #14
 8012920:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8012924:	687b      	ldr	r3, [r7, #4]
 8012926:	4a0a      	ldr	r2, [pc, #40]	; (8012950 <initial_setup+0x478>)
 8012928:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801292c:	687b      	ldr	r3, [r7, #4]
 801292e:	223f      	movs	r2, #63	; 0x3f
 8012930:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012934:	e049      	b.n	80129ca <initial_setup+0x4f2>
    case (15*15-1):
      cinfo->block_size = 15;
 8012936:	687b      	ldr	r3, [r7, #4]
 8012938:	220f      	movs	r2, #15
 801293a:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 801293e:	687b      	ldr	r3, [r7, #4]
 8012940:	4a03      	ldr	r2, [pc, #12]	; (8012950 <initial_setup+0x478>)
 8012942:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 8012946:	687b      	ldr	r3, [r7, #4]
 8012948:	223f      	movs	r2, #63	; 0x3f
 801294a:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 801294e:	e03c      	b.n	80129ca <initial_setup+0x4f2>
 8012950:	0802ac68 	.word	0x0802ac68
 8012954:	0802b104 	.word	0x0802b104
 8012958:	0802b0a0 	.word	0x0802b0a0
 801295c:	0802b020 	.word	0x0802b020
 8012960:	0802af7c 	.word	0x0802af7c
 8012964:	0802aeac 	.word	0x0802aeac
 8012968:	0802ada8 	.word	0x0802ada8
    case (16*16-1):
      cinfo->block_size = 16;
 801296c:	687b      	ldr	r3, [r7, #4]
 801296e:	2210      	movs	r2, #16
 8012970:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
      cinfo->natural_order = jpeg_natural_order;
 8012974:	687b      	ldr	r3, [r7, #4]
 8012976:	4a6b      	ldr	r2, [pc, #428]	; (8012b24 <initial_setup+0x64c>)
 8012978:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
      cinfo->lim_Se = DCTSIZE2-1;
 801297c:	687b      	ldr	r3, [r7, #4]
 801297e:	223f      	movs	r2, #63	; 0x3f
 8012980:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
      break;
 8012984:	e021      	b.n	80129ca <initial_setup+0x4f2>
    default:
      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
 8012986:	687b      	ldr	r3, [r7, #4]
 8012988:	681b      	ldr	r3, [r3, #0]
 801298a:	2211      	movs	r2, #17
 801298c:	615a      	str	r2, [r3, #20]
 801298e:	687b      	ldr	r3, [r7, #4]
 8012990:	681b      	ldr	r3, [r3, #0]
 8012992:	687a      	ldr	r2, [r7, #4]
 8012994:	f8d2 2198 	ldr.w	r2, [r2, #408]	; 0x198
 8012998:	619a      	str	r2, [r3, #24]
 801299a:	687b      	ldr	r3, [r7, #4]
 801299c:	681b      	ldr	r3, [r3, #0]
 801299e:	687a      	ldr	r2, [r7, #4]
 80129a0:	f8d2 219c 	ldr.w	r2, [r2, #412]	; 0x19c
 80129a4:	61da      	str	r2, [r3, #28]
 80129a6:	687b      	ldr	r3, [r7, #4]
 80129a8:	681b      	ldr	r3, [r3, #0]
 80129aa:	687a      	ldr	r2, [r7, #4]
 80129ac:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
 80129b0:	621a      	str	r2, [r3, #32]
 80129b2:	687b      	ldr	r3, [r7, #4]
 80129b4:	681b      	ldr	r3, [r3, #0]
 80129b6:	687a      	ldr	r2, [r7, #4]
 80129b8:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 80129bc:	625a      	str	r2, [r3, #36]	; 0x24
 80129be:	687b      	ldr	r3, [r7, #4]
 80129c0:	681b      	ldr	r3, [r3, #0]
 80129c2:	681b      	ldr	r3, [r3, #0]
 80129c4:	6878      	ldr	r0, [r7, #4]
 80129c6:	4798      	blx	r3
	       cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
      break;
 80129c8:	bf00      	nop
   * In the full decompressor,
   * this will be overridden by jpeg_calc_output_dimensions in jdmaster.c;
   * but in the transcoder,
   * jpeg_calc_output_dimensions is not used, so we must do it here.
   */
  cinfo->min_DCT_h_scaled_size = cinfo->block_size;
 80129ca:	687b      	ldr	r3, [r7, #4]
 80129cc:	f8d3 21a8 	ldr.w	r2, [r3, #424]	; 0x1a8
 80129d0:	687b      	ldr	r3, [r7, #4]
 80129d2:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  cinfo->min_DCT_v_scaled_size = cinfo->block_size;
 80129d6:	687b      	ldr	r3, [r7, #4]
 80129d8:	f8d3 21a8 	ldr.w	r2, [r3, #424]	; 0x1a8
 80129dc:	687b      	ldr	r3, [r7, #4]
 80129de:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80129e2:	2300      	movs	r3, #0
 80129e4:	60fb      	str	r3, [r7, #12]
 80129e6:	687b      	ldr	r3, [r7, #4]
 80129e8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80129ec:	60bb      	str	r3, [r7, #8]
 80129ee:	e065      	b.n	8012abc <initial_setup+0x5e4>
       ci++, compptr++) {
    compptr->DCT_h_scaled_size = cinfo->block_size;
 80129f0:	687b      	ldr	r3, [r7, #4]
 80129f2:	f8d3 21a8 	ldr.w	r2, [r3, #424]	; 0x1a8
 80129f6:	68bb      	ldr	r3, [r7, #8]
 80129f8:	625a      	str	r2, [r3, #36]	; 0x24
    compptr->DCT_v_scaled_size = cinfo->block_size;
 80129fa:	687b      	ldr	r3, [r7, #4]
 80129fc:	f8d3 21a8 	ldr.w	r2, [r3, #424]	; 0x1a8
 8012a00:	68bb      	ldr	r3, [r7, #8]
 8012a02:	629a      	str	r2, [r3, #40]	; 0x28
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8012a04:	687b      	ldr	r3, [r7, #4]
 8012a06:	69db      	ldr	r3, [r3, #28]
 8012a08:	461a      	mov	r2, r3
 8012a0a:	68bb      	ldr	r3, [r7, #8]
 8012a0c:	689b      	ldr	r3, [r3, #8]
 8012a0e:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8012a12:	687b      	ldr	r3, [r7, #4]
 8012a14:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 8012a18:	687a      	ldr	r2, [r7, #4]
 8012a1a:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012a1e:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8012a22:	4619      	mov	r1, r3
 8012a24:	f015 f87a 	bl	8027b1c <jdiv_round_up>
 8012a28:	4603      	mov	r3, r0
    compptr->width_in_blocks = (JDIMENSION)
 8012a2a:	461a      	mov	r2, r3
 8012a2c:	68bb      	ldr	r3, [r7, #8]
 8012a2e:	61da      	str	r2, [r3, #28]
    compptr->height_in_blocks = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8012a30:	687b      	ldr	r3, [r7, #4]
 8012a32:	6a1b      	ldr	r3, [r3, #32]
 8012a34:	461a      	mov	r2, r3
 8012a36:	68bb      	ldr	r3, [r7, #8]
 8012a38:	68db      	ldr	r3, [r3, #12]
 8012a3a:	fb03 f002 	mul.w	r0, r3, r2
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8012a3e:	687b      	ldr	r3, [r7, #4]
 8012a40:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8012a44:	687a      	ldr	r2, [r7, #4]
 8012a46:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012a4a:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8012a4e:	4619      	mov	r1, r3
 8012a50:	f015 f864 	bl	8027b1c <jdiv_round_up>
 8012a54:	4603      	mov	r3, r0
    compptr->height_in_blocks = (JDIMENSION)
 8012a56:	461a      	mov	r2, r3
 8012a58:	68bb      	ldr	r3, [r7, #8]
 8012a5a:	621a      	str	r2, [r3, #32]
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8012a5c:	687b      	ldr	r3, [r7, #4]
 8012a5e:	69db      	ldr	r3, [r3, #28]
 8012a60:	461a      	mov	r2, r3
 8012a62:	68bb      	ldr	r3, [r7, #8]
 8012a64:	689b      	ldr	r3, [r3, #8]
 8012a66:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_h_samp_factor);
 8012a6a:	687b      	ldr	r3, [r7, #4]
 8012a6c:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
 8012a70:	4619      	mov	r1, r3
 8012a72:	4610      	mov	r0, r2
 8012a74:	f015 f852 	bl	8027b1c <jdiv_round_up>
 8012a78:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 8012a7a:	461a      	mov	r2, r3
 8012a7c:	68bb      	ldr	r3, [r7, #8]
 8012a7e:	62da      	str	r2, [r3, #44]	; 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8012a80:	687b      	ldr	r3, [r7, #4]
 8012a82:	6a1b      	ldr	r3, [r3, #32]
 8012a84:	461a      	mov	r2, r3
 8012a86:	68bb      	ldr	r3, [r7, #8]
 8012a88:	68db      	ldr	r3, [r3, #12]
 8012a8a:	fb03 f202 	mul.w	r2, r3, r2
		    (long) cinfo->max_v_samp_factor);
 8012a8e:	687b      	ldr	r3, [r7, #4]
 8012a90:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
 8012a94:	4619      	mov	r1, r3
 8012a96:	4610      	mov	r0, r2
 8012a98:	f015 f840 	bl	8027b1c <jdiv_round_up>
 8012a9c:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 8012a9e:	461a      	mov	r2, r3
 8012aa0:	68bb      	ldr	r3, [r7, #8]
 8012aa2:	631a      	str	r2, [r3, #48]	; 0x30
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
 8012aa4:	68bb      	ldr	r3, [r7, #8]
 8012aa6:	2201      	movs	r2, #1
 8012aa8:	635a      	str	r2, [r3, #52]	; 0x34
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
 8012aaa:	68bb      	ldr	r3, [r7, #8]
 8012aac:	2200      	movs	r2, #0
 8012aae:	651a      	str	r2, [r3, #80]	; 0x50
       ci++, compptr++) {
 8012ab0:	68fb      	ldr	r3, [r7, #12]
 8012ab2:	3301      	adds	r3, #1
 8012ab4:	60fb      	str	r3, [r7, #12]
 8012ab6:	68bb      	ldr	r3, [r7, #8]
 8012ab8:	3358      	adds	r3, #88	; 0x58
 8012aba:	60bb      	str	r3, [r7, #8]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8012abc:	687b      	ldr	r3, [r7, #4]
 8012abe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012ac0:	68fa      	ldr	r2, [r7, #12]
 8012ac2:	429a      	cmp	r2, r3
 8012ac4:	db94      	blt.n	80129f0 <initial_setup+0x518>
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
    jdiv_round_up((long) cinfo->image_height,
 8012ac6:	687b      	ldr	r3, [r7, #4]
 8012ac8:	6a1b      	ldr	r3, [r3, #32]
 8012aca:	4618      	mov	r0, r3
	          (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8012acc:	687b      	ldr	r3, [r7, #4]
 8012ace:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8012ad2:	687a      	ldr	r2, [r7, #4]
 8012ad4:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012ad8:	fb02 f303 	mul.w	r3, r2, r3
    jdiv_round_up((long) cinfo->image_height,
 8012adc:	4619      	mov	r1, r3
 8012ade:	f015 f81d 	bl	8027b1c <jdiv_round_up>
 8012ae2:	4603      	mov	r3, r0
  cinfo->total_iMCU_rows = (JDIMENSION)
 8012ae4:	461a      	mov	r2, r3
 8012ae6:	687b      	ldr	r3, [r7, #4]
 8012ae8:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
 8012aec:	687b      	ldr	r3, [r7, #4]
 8012aee:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 8012af2:	687b      	ldr	r3, [r7, #4]
 8012af4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012af6:	429a      	cmp	r2, r3
 8012af8:	db04      	blt.n	8012b04 <initial_setup+0x62c>
 8012afa:	687b      	ldr	r3, [r7, #4]
 8012afc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8012b00:	2b00      	cmp	r3, #0
 8012b02:	d005      	beq.n	8012b10 <initial_setup+0x638>
    cinfo->inputctl->has_multiple_scans = TRUE;
 8012b04:	687b      	ldr	r3, [r7, #4]
 8012b06:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012b0a:	2201      	movs	r2, #1
 8012b0c:	611a      	str	r2, [r3, #16]
 8012b0e:	e005      	b.n	8012b1c <initial_setup+0x644>
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
 8012b10:	687b      	ldr	r3, [r7, #4]
 8012b12:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012b16:	2200      	movs	r2, #0
 8012b18:	611a      	str	r2, [r3, #16]
}
 8012b1a:	bf00      	nop
 8012b1c:	bf00      	nop
 8012b1e:	3710      	adds	r7, #16
 8012b20:	46bd      	mov	sp, r7
 8012b22:	bd80      	pop	{r7, pc}
 8012b24:	0802ac68 	.word	0x0802ac68

08012b28 <per_scan_setup>:

LOCAL(void)
per_scan_setup (j_decompress_ptr cinfo)
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
 8012b28:	b580      	push	{r7, lr}
 8012b2a:	b086      	sub	sp, #24
 8012b2c:	af00      	add	r7, sp, #0
 8012b2e:	6078      	str	r0, [r7, #4]
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;
  
  if (cinfo->comps_in_scan == 1) {
 8012b30:	687b      	ldr	r3, [r7, #4]
 8012b32:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012b36:	2b01      	cmp	r3, #1
 8012b38:	d139      	bne.n	8012bae <per_scan_setup+0x86>
    
    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
 8012b3a:	687b      	ldr	r3, [r7, #4]
 8012b3c:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 8012b40:	60bb      	str	r3, [r7, #8]
    
    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
 8012b42:	68bb      	ldr	r3, [r7, #8]
 8012b44:	69da      	ldr	r2, [r3, #28]
 8012b46:	687b      	ldr	r3, [r7, #4]
 8012b48:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
 8012b4c:	68bb      	ldr	r3, [r7, #8]
 8012b4e:	6a1a      	ldr	r2, [r3, #32]
 8012b50:	687b      	ldr	r3, [r7, #4]
 8012b52:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
    
    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
 8012b56:	68bb      	ldr	r3, [r7, #8]
 8012b58:	2201      	movs	r2, #1
 8012b5a:	639a      	str	r2, [r3, #56]	; 0x38
    compptr->MCU_height = 1;
 8012b5c:	68bb      	ldr	r3, [r7, #8]
 8012b5e:	2201      	movs	r2, #1
 8012b60:	63da      	str	r2, [r3, #60]	; 0x3c
    compptr->MCU_blocks = 1;
 8012b62:	68bb      	ldr	r3, [r7, #8]
 8012b64:	2201      	movs	r2, #1
 8012b66:	641a      	str	r2, [r3, #64]	; 0x40
    compptr->MCU_sample_width = compptr->DCT_h_scaled_size;
 8012b68:	68bb      	ldr	r3, [r7, #8]
 8012b6a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8012b6c:	68bb      	ldr	r3, [r7, #8]
 8012b6e:	645a      	str	r2, [r3, #68]	; 0x44
    compptr->last_col_width = 1;
 8012b70:	68bb      	ldr	r3, [r7, #8]
 8012b72:	2201      	movs	r2, #1
 8012b74:	649a      	str	r2, [r3, #72]	; 0x48
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
 8012b76:	68bb      	ldr	r3, [r7, #8]
 8012b78:	6a1b      	ldr	r3, [r3, #32]
 8012b7a:	68ba      	ldr	r2, [r7, #8]
 8012b7c:	68d2      	ldr	r2, [r2, #12]
 8012b7e:	fbb3 f1f2 	udiv	r1, r3, r2
 8012b82:	fb02 f201 	mul.w	r2, r2, r1
 8012b86:	1a9b      	subs	r3, r3, r2
 8012b88:	60fb      	str	r3, [r7, #12]
    if (tmp == 0) tmp = compptr->v_samp_factor;
 8012b8a:	68fb      	ldr	r3, [r7, #12]
 8012b8c:	2b00      	cmp	r3, #0
 8012b8e:	d102      	bne.n	8012b96 <per_scan_setup+0x6e>
 8012b90:	68bb      	ldr	r3, [r7, #8]
 8012b92:	68db      	ldr	r3, [r3, #12]
 8012b94:	60fb      	str	r3, [r7, #12]
    compptr->last_row_height = tmp;
 8012b96:	68bb      	ldr	r3, [r7, #8]
 8012b98:	68fa      	ldr	r2, [r7, #12]
 8012b9a:	64da      	str	r2, [r3, #76]	; 0x4c
    
    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
 8012b9c:	687b      	ldr	r3, [r7, #4]
 8012b9e:	2201      	movs	r2, #1
 8012ba0:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
    cinfo->MCU_membership[0] = 0;
 8012ba4:	687b      	ldr	r3, [r7, #4]
 8012ba6:	2200      	movs	r2, #0
 8012ba8:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
      }
    }
    
  }
}
 8012bac:	e0bc      	b.n	8012d28 <per_scan_setup+0x200>
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
 8012bae:	687b      	ldr	r3, [r7, #4]
 8012bb0:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012bb4:	2b00      	cmp	r3, #0
 8012bb6:	dd04      	ble.n	8012bc2 <per_scan_setup+0x9a>
 8012bb8:	687b      	ldr	r3, [r7, #4]
 8012bba:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012bbe:	2b04      	cmp	r3, #4
 8012bc0:	dd12      	ble.n	8012be8 <per_scan_setup+0xc0>
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
 8012bc2:	687b      	ldr	r3, [r7, #4]
 8012bc4:	681b      	ldr	r3, [r3, #0]
 8012bc6:	221b      	movs	r2, #27
 8012bc8:	615a      	str	r2, [r3, #20]
 8012bca:	687b      	ldr	r3, [r7, #4]
 8012bcc:	681b      	ldr	r3, [r3, #0]
 8012bce:	687a      	ldr	r2, [r7, #4]
 8012bd0:	f8d2 2150 	ldr.w	r2, [r2, #336]	; 0x150
 8012bd4:	619a      	str	r2, [r3, #24]
 8012bd6:	687b      	ldr	r3, [r7, #4]
 8012bd8:	681b      	ldr	r3, [r3, #0]
 8012bda:	2204      	movs	r2, #4
 8012bdc:	61da      	str	r2, [r3, #28]
 8012bde:	687b      	ldr	r3, [r7, #4]
 8012be0:	681b      	ldr	r3, [r3, #0]
 8012be2:	681b      	ldr	r3, [r3, #0]
 8012be4:	6878      	ldr	r0, [r7, #4]
 8012be6:	4798      	blx	r3
      jdiv_round_up((long) cinfo->image_width,
 8012be8:	687b      	ldr	r3, [r7, #4]
 8012bea:	69db      	ldr	r3, [r3, #28]
 8012bec:	4618      	mov	r0, r3
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8012bee:	687b      	ldr	r3, [r7, #4]
 8012bf0:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 8012bf4:	687a      	ldr	r2, [r7, #4]
 8012bf6:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012bfa:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width,
 8012bfe:	4619      	mov	r1, r3
 8012c00:	f014 ff8c 	bl	8027b1c <jdiv_round_up>
 8012c04:	4603      	mov	r3, r0
    cinfo->MCUs_per_row = (JDIMENSION)
 8012c06:	461a      	mov	r2, r3
 8012c08:	687b      	ldr	r3, [r7, #4]
 8012c0a:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
      jdiv_round_up((long) cinfo->image_height,
 8012c0e:	687b      	ldr	r3, [r7, #4]
 8012c10:	6a1b      	ldr	r3, [r3, #32]
 8012c12:	4618      	mov	r0, r3
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8012c14:	687b      	ldr	r3, [r7, #4]
 8012c16:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8012c1a:	687a      	ldr	r2, [r7, #4]
 8012c1c:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8012c20:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height,
 8012c24:	4619      	mov	r1, r3
 8012c26:	f014 ff79 	bl	8027b1c <jdiv_round_up>
 8012c2a:	4603      	mov	r3, r0
    cinfo->MCU_rows_in_scan = (JDIMENSION)
 8012c2c:	461a      	mov	r2, r3
 8012c2e:	687b      	ldr	r3, [r7, #4]
 8012c30:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
    cinfo->blocks_in_MCU = 0;
 8012c34:	687b      	ldr	r3, [r7, #4]
 8012c36:	2200      	movs	r2, #0
 8012c38:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012c3c:	2300      	movs	r3, #0
 8012c3e:	617b      	str	r3, [r7, #20]
 8012c40:	e06c      	b.n	8012d1c <per_scan_setup+0x1f4>
      compptr = cinfo->cur_comp_info[ci];
 8012c42:	687a      	ldr	r2, [r7, #4]
 8012c44:	697b      	ldr	r3, [r7, #20]
 8012c46:	3354      	adds	r3, #84	; 0x54
 8012c48:	009b      	lsls	r3, r3, #2
 8012c4a:	4413      	add	r3, r2
 8012c4c:	685b      	ldr	r3, [r3, #4]
 8012c4e:	60bb      	str	r3, [r7, #8]
      compptr->MCU_width = compptr->h_samp_factor;
 8012c50:	68bb      	ldr	r3, [r7, #8]
 8012c52:	689a      	ldr	r2, [r3, #8]
 8012c54:	68bb      	ldr	r3, [r7, #8]
 8012c56:	639a      	str	r2, [r3, #56]	; 0x38
      compptr->MCU_height = compptr->v_samp_factor;
 8012c58:	68bb      	ldr	r3, [r7, #8]
 8012c5a:	68da      	ldr	r2, [r3, #12]
 8012c5c:	68bb      	ldr	r3, [r7, #8]
 8012c5e:	63da      	str	r2, [r3, #60]	; 0x3c
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
 8012c60:	68bb      	ldr	r3, [r7, #8]
 8012c62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012c64:	68ba      	ldr	r2, [r7, #8]
 8012c66:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8012c68:	fb02 f203 	mul.w	r2, r2, r3
 8012c6c:	68bb      	ldr	r3, [r7, #8]
 8012c6e:	641a      	str	r2, [r3, #64]	; 0x40
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_h_scaled_size;
 8012c70:	68bb      	ldr	r3, [r7, #8]
 8012c72:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012c74:	68ba      	ldr	r2, [r7, #8]
 8012c76:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8012c78:	fb02 f203 	mul.w	r2, r2, r3
 8012c7c:	68bb      	ldr	r3, [r7, #8]
 8012c7e:	645a      	str	r2, [r3, #68]	; 0x44
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
 8012c80:	68bb      	ldr	r3, [r7, #8]
 8012c82:	69db      	ldr	r3, [r3, #28]
 8012c84:	68ba      	ldr	r2, [r7, #8]
 8012c86:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8012c88:	fbb3 f1f2 	udiv	r1, r3, r2
 8012c8c:	fb02 f201 	mul.w	r2, r2, r1
 8012c90:	1a9b      	subs	r3, r3, r2
 8012c92:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_width;
 8012c94:	68fb      	ldr	r3, [r7, #12]
 8012c96:	2b00      	cmp	r3, #0
 8012c98:	d102      	bne.n	8012ca0 <per_scan_setup+0x178>
 8012c9a:	68bb      	ldr	r3, [r7, #8]
 8012c9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012c9e:	60fb      	str	r3, [r7, #12]
      compptr->last_col_width = tmp;
 8012ca0:	68bb      	ldr	r3, [r7, #8]
 8012ca2:	68fa      	ldr	r2, [r7, #12]
 8012ca4:	649a      	str	r2, [r3, #72]	; 0x48
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
 8012ca6:	68bb      	ldr	r3, [r7, #8]
 8012ca8:	6a1b      	ldr	r3, [r3, #32]
 8012caa:	68ba      	ldr	r2, [r7, #8]
 8012cac:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8012cae:	fbb3 f1f2 	udiv	r1, r3, r2
 8012cb2:	fb02 f201 	mul.w	r2, r2, r1
 8012cb6:	1a9b      	subs	r3, r3, r2
 8012cb8:	60fb      	str	r3, [r7, #12]
      if (tmp == 0) tmp = compptr->MCU_height;
 8012cba:	68fb      	ldr	r3, [r7, #12]
 8012cbc:	2b00      	cmp	r3, #0
 8012cbe:	d102      	bne.n	8012cc6 <per_scan_setup+0x19e>
 8012cc0:	68bb      	ldr	r3, [r7, #8]
 8012cc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012cc4:	60fb      	str	r3, [r7, #12]
      compptr->last_row_height = tmp;
 8012cc6:	68bb      	ldr	r3, [r7, #8]
 8012cc8:	68fa      	ldr	r2, [r7, #12]
 8012cca:	64da      	str	r2, [r3, #76]	; 0x4c
      mcublks = compptr->MCU_blocks;
 8012ccc:	68bb      	ldr	r3, [r7, #8]
 8012cce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012cd0:	613b      	str	r3, [r7, #16]
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
 8012cd2:	687b      	ldr	r3, [r7, #4]
 8012cd4:	f8d3 216c 	ldr.w	r2, [r3, #364]	; 0x16c
 8012cd8:	693b      	ldr	r3, [r7, #16]
 8012cda:	4413      	add	r3, r2
 8012cdc:	2b0a      	cmp	r3, #10
 8012cde:	dd15      	ble.n	8012d0c <per_scan_setup+0x1e4>
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
 8012ce0:	687b      	ldr	r3, [r7, #4]
 8012ce2:	681b      	ldr	r3, [r3, #0]
 8012ce4:	220e      	movs	r2, #14
 8012ce6:	615a      	str	r2, [r3, #20]
 8012ce8:	687b      	ldr	r3, [r7, #4]
 8012cea:	681b      	ldr	r3, [r3, #0]
 8012cec:	681b      	ldr	r3, [r3, #0]
 8012cee:	6878      	ldr	r0, [r7, #4]
 8012cf0:	4798      	blx	r3
      while (mcublks-- > 0) {
 8012cf2:	e00b      	b.n	8012d0c <per_scan_setup+0x1e4>
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
 8012cf4:	687b      	ldr	r3, [r7, #4]
 8012cf6:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
 8012cfa:	1c59      	adds	r1, r3, #1
 8012cfc:	687a      	ldr	r2, [r7, #4]
 8012cfe:	f8c2 116c 	str.w	r1, [r2, #364]	; 0x16c
 8012d02:	687a      	ldr	r2, [r7, #4]
 8012d04:	335c      	adds	r3, #92	; 0x5c
 8012d06:	6979      	ldr	r1, [r7, #20]
 8012d08:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      while (mcublks-- > 0) {
 8012d0c:	693b      	ldr	r3, [r7, #16]
 8012d0e:	1e5a      	subs	r2, r3, #1
 8012d10:	613a      	str	r2, [r7, #16]
 8012d12:	2b00      	cmp	r3, #0
 8012d14:	dcee      	bgt.n	8012cf4 <per_scan_setup+0x1cc>
    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012d16:	697b      	ldr	r3, [r7, #20]
 8012d18:	3301      	adds	r3, #1
 8012d1a:	617b      	str	r3, [r7, #20]
 8012d1c:	687b      	ldr	r3, [r7, #4]
 8012d1e:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012d22:	697a      	ldr	r2, [r7, #20]
 8012d24:	429a      	cmp	r2, r3
 8012d26:	db8c      	blt.n	8012c42 <per_scan_setup+0x11a>
}
 8012d28:	bf00      	nop
 8012d2a:	3718      	adds	r7, #24
 8012d2c:	46bd      	mov	sp, r7
 8012d2e:	bd80      	pop	{r7, pc}

08012d30 <latch_quant_tables>:
 * not at the current Q-table slots.
 */

LOCAL(void)
latch_quant_tables (j_decompress_ptr cinfo)
{
 8012d30:	b580      	push	{r7, lr}
 8012d32:	b086      	sub	sp, #24
 8012d34:	af00      	add	r7, sp, #0
 8012d36:	6078      	str	r0, [r7, #4]
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012d38:	2300      	movs	r3, #0
 8012d3a:	617b      	str	r3, [r7, #20]
 8012d3c:	e043      	b.n	8012dc6 <latch_quant_tables+0x96>
    compptr = cinfo->cur_comp_info[ci];
 8012d3e:	687a      	ldr	r2, [r7, #4]
 8012d40:	697b      	ldr	r3, [r7, #20]
 8012d42:	3354      	adds	r3, #84	; 0x54
 8012d44:	009b      	lsls	r3, r3, #2
 8012d46:	4413      	add	r3, r2
 8012d48:	685b      	ldr	r3, [r3, #4]
 8012d4a:	613b      	str	r3, [r7, #16]
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
 8012d4c:	693b      	ldr	r3, [r7, #16]
 8012d4e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8012d50:	2b00      	cmp	r3, #0
 8012d52:	d134      	bne.n	8012dbe <latch_quant_tables+0x8e>
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
 8012d54:	693b      	ldr	r3, [r7, #16]
 8012d56:	691b      	ldr	r3, [r3, #16]
 8012d58:	60fb      	str	r3, [r7, #12]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8012d5a:	68fb      	ldr	r3, [r7, #12]
 8012d5c:	2b00      	cmp	r3, #0
 8012d5e:	db0a      	blt.n	8012d76 <latch_quant_tables+0x46>
 8012d60:	68fb      	ldr	r3, [r7, #12]
 8012d62:	2b03      	cmp	r3, #3
 8012d64:	dc07      	bgt.n	8012d76 <latch_quant_tables+0x46>
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
 8012d66:	687a      	ldr	r2, [r7, #4]
 8012d68:	68fb      	ldr	r3, [r7, #12]
 8012d6a:	3328      	adds	r3, #40	; 0x28
 8012d6c:	009b      	lsls	r3, r3, #2
 8012d6e:	4413      	add	r3, r2
 8012d70:	685b      	ldr	r3, [r3, #4]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
 8012d72:	2b00      	cmp	r3, #0
 8012d74:	d10c      	bne.n	8012d90 <latch_quant_tables+0x60>
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
 8012d76:	687b      	ldr	r3, [r7, #4]
 8012d78:	681b      	ldr	r3, [r3, #0]
 8012d7a:	2236      	movs	r2, #54	; 0x36
 8012d7c:	615a      	str	r2, [r3, #20]
 8012d7e:	687b      	ldr	r3, [r7, #4]
 8012d80:	681b      	ldr	r3, [r3, #0]
 8012d82:	68fa      	ldr	r2, [r7, #12]
 8012d84:	619a      	str	r2, [r3, #24]
 8012d86:	687b      	ldr	r3, [r7, #4]
 8012d88:	681b      	ldr	r3, [r3, #0]
 8012d8a:	681b      	ldr	r3, [r3, #0]
 8012d8c:	6878      	ldr	r0, [r7, #4]
 8012d8e:	4798      	blx	r3
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8012d90:	687b      	ldr	r3, [r7, #4]
 8012d92:	685b      	ldr	r3, [r3, #4]
 8012d94:	681b      	ldr	r3, [r3, #0]
 8012d96:	2284      	movs	r2, #132	; 0x84
 8012d98:	2101      	movs	r1, #1
 8012d9a:	6878      	ldr	r0, [r7, #4]
 8012d9c:	4798      	blx	r3
 8012d9e:	60b8      	str	r0, [r7, #8]
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
 8012da0:	687a      	ldr	r2, [r7, #4]
 8012da2:	68fb      	ldr	r3, [r7, #12]
 8012da4:	3328      	adds	r3, #40	; 0x28
 8012da6:	009b      	lsls	r3, r3, #2
 8012da8:	4413      	add	r3, r2
 8012daa:	685b      	ldr	r3, [r3, #4]
 8012dac:	2284      	movs	r2, #132	; 0x84
 8012dae:	4619      	mov	r1, r3
 8012db0:	68b8      	ldr	r0, [r7, #8]
 8012db2:	f015 fa57 	bl	8028264 <memcpy>
    compptr->quant_table = qtbl;
 8012db6:	693b      	ldr	r3, [r7, #16]
 8012db8:	68ba      	ldr	r2, [r7, #8]
 8012dba:	651a      	str	r2, [r3, #80]	; 0x50
 8012dbc:	e000      	b.n	8012dc0 <latch_quant_tables+0x90>
      continue;
 8012dbe:	bf00      	nop
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
 8012dc0:	697b      	ldr	r3, [r7, #20]
 8012dc2:	3301      	adds	r3, #1
 8012dc4:	617b      	str	r3, [r7, #20]
 8012dc6:	687b      	ldr	r3, [r7, #4]
 8012dc8:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012dcc:	697a      	ldr	r2, [r7, #20]
 8012dce:	429a      	cmp	r2, r3
 8012dd0:	dbb5      	blt.n	8012d3e <latch_quant_tables+0xe>
  }
}
 8012dd2:	bf00      	nop
 8012dd4:	bf00      	nop
 8012dd6:	3718      	adds	r7, #24
 8012dd8:	46bd      	mov	sp, r7
 8012dda:	bd80      	pop	{r7, pc}

08012ddc <start_input_pass>:
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
 8012ddc:	b580      	push	{r7, lr}
 8012dde:	b082      	sub	sp, #8
 8012de0:	af00      	add	r7, sp, #0
 8012de2:	6078      	str	r0, [r7, #4]
  per_scan_setup(cinfo);
 8012de4:	6878      	ldr	r0, [r7, #4]
 8012de6:	f7ff fe9f 	bl	8012b28 <per_scan_setup>
  latch_quant_tables(cinfo);
 8012dea:	6878      	ldr	r0, [r7, #4]
 8012dec:	f7ff ffa0 	bl	8012d30 <latch_quant_tables>
  (*cinfo->entropy->start_pass) (cinfo);
 8012df0:	687b      	ldr	r3, [r7, #4]
 8012df2:	f8d3 31d0 	ldr.w	r3, [r3, #464]	; 0x1d0
 8012df6:	681b      	ldr	r3, [r3, #0]
 8012df8:	6878      	ldr	r0, [r7, #4]
 8012dfa:	4798      	blx	r3
  (*cinfo->coef->start_input_pass) (cinfo);
 8012dfc:	687b      	ldr	r3, [r7, #4]
 8012dfe:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 8012e02:	681b      	ldr	r3, [r3, #0]
 8012e04:	6878      	ldr	r0, [r7, #4]
 8012e06:	4798      	blx	r3
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
 8012e08:	687b      	ldr	r3, [r7, #4]
 8012e0a:	f8d3 21c0 	ldr.w	r2, [r3, #448]	; 0x1c0
 8012e0e:	687b      	ldr	r3, [r7, #4]
 8012e10:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012e14:	6852      	ldr	r2, [r2, #4]
 8012e16:	601a      	str	r2, [r3, #0]
}
 8012e18:	bf00      	nop
 8012e1a:	3708      	adds	r7, #8
 8012e1c:	46bd      	mov	sp, r7
 8012e1e:	bd80      	pop	{r7, pc}

08012e20 <finish_input_pass>:
 * the expected data of the scan.
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
 8012e20:	b480      	push	{r7}
 8012e22:	b083      	sub	sp, #12
 8012e24:	af00      	add	r7, sp, #0
 8012e26:	6078      	str	r0, [r7, #4]
  cinfo->inputctl->consume_input = consume_markers;
 8012e28:	687b      	ldr	r3, [r7, #4]
 8012e2a:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012e2e:	4a04      	ldr	r2, [pc, #16]	; (8012e40 <finish_input_pass+0x20>)
 8012e30:	601a      	str	r2, [r3, #0]
}
 8012e32:	bf00      	nop
 8012e34:	370c      	adds	r7, #12
 8012e36:	46bd      	mov	sp, r7
 8012e38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e3c:	4770      	bx	lr
 8012e3e:	bf00      	nop
 8012e40:	08012e45 	.word	0x08012e45

08012e44 <consume_markers>:
 * read_markers is processed and then skipped for other markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
 8012e44:	b580      	push	{r7, lr}
 8012e46:	b084      	sub	sp, #16
 8012e48:	af00      	add	r7, sp, #0
 8012e4a:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8012e4c:	687b      	ldr	r3, [r7, #4]
 8012e4e:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012e52:	60fb      	str	r3, [r7, #12]
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
 8012e54:	68fb      	ldr	r3, [r7, #12]
 8012e56:	695b      	ldr	r3, [r3, #20]
 8012e58:	2b00      	cmp	r3, #0
 8012e5a:	d001      	beq.n	8012e60 <consume_markers+0x1c>
    return JPEG_REACHED_EOI;
 8012e5c:	2302      	movs	r3, #2
 8012e5e:	e06e      	b.n	8012f3e <consume_markers+0xfa>

  for (;;) {			/* Loop to pass pseudo SOS marker */
    val = (*cinfo->marker->read_markers) (cinfo);
 8012e60:	687b      	ldr	r3, [r7, #4]
 8012e62:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8012e66:	685b      	ldr	r3, [r3, #4]
 8012e68:	6878      	ldr	r0, [r7, #4]
 8012e6a:	4798      	blx	r3
 8012e6c:	60b8      	str	r0, [r7, #8]

    switch (val) {
 8012e6e:	68bb      	ldr	r3, [r7, #8]
 8012e70:	2b02      	cmp	r3, #2
 8012e72:	d037      	beq.n	8012ee4 <consume_markers+0xa0>
 8012e74:	68bb      	ldr	r3, [r7, #8]
 8012e76:	2b02      	cmp	r3, #2
 8012e78:	dc5d      	bgt.n	8012f36 <consume_markers+0xf2>
 8012e7a:	68bb      	ldr	r3, [r7, #8]
 8012e7c:	2b00      	cmp	r3, #0
 8012e7e:	d058      	beq.n	8012f32 <consume_markers+0xee>
 8012e80:	68bb      	ldr	r3, [r7, #8]
 8012e82:	2b01      	cmp	r3, #1
 8012e84:	d157      	bne.n	8012f36 <consume_markers+0xf2>
    case JPEG_REACHED_SOS:	/* Found SOS */
      if (inputctl->inheaders) { /* 1st SOS */
 8012e86:	68fb      	ldr	r3, [r7, #12]
 8012e88:	699b      	ldr	r3, [r3, #24]
 8012e8a:	2b00      	cmp	r3, #0
 8012e8c:	d013      	beq.n	8012eb6 <consume_markers+0x72>
	if (inputctl->inheaders == 1)
 8012e8e:	68fb      	ldr	r3, [r7, #12]
 8012e90:	699b      	ldr	r3, [r3, #24]
 8012e92:	2b01      	cmp	r3, #1
 8012e94:	d102      	bne.n	8012e9c <consume_markers+0x58>
	  initial_setup(cinfo);
 8012e96:	6878      	ldr	r0, [r7, #4]
 8012e98:	f7ff fb1e 	bl	80124d8 <initial_setup>
	if (cinfo->comps_in_scan == 0) { /* pseudo SOS marker */
 8012e9c:	687b      	ldr	r3, [r7, #4]
 8012e9e:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012ea2:	2b00      	cmp	r3, #0
 8012ea4:	d103      	bne.n	8012eae <consume_markers+0x6a>
	  inputctl->inheaders = 2;
 8012ea6:	68fb      	ldr	r3, [r7, #12]
 8012ea8:	2202      	movs	r2, #2
 8012eaa:	619a      	str	r2, [r3, #24]
	  break;
 8012eac:	e046      	b.n	8012f3c <consume_markers+0xf8>
	}
	inputctl->inheaders = 0;
 8012eae:	68fb      	ldr	r3, [r7, #12]
 8012eb0:	2200      	movs	r2, #0
 8012eb2:	619a      	str	r2, [r3, #24]
 8012eb4:	e014      	b.n	8012ee0 <consume_markers+0x9c>
	/* Note: start_input_pass must be called by jdmaster.c
	 * before any more input can be consumed.  jdapimin.c is
	 * responsible for enforcing this sequencing.
	 */
      } else {			/* 2nd or later SOS marker */
	if (! inputctl->pub.has_multiple_scans)
 8012eb6:	68fb      	ldr	r3, [r7, #12]
 8012eb8:	691b      	ldr	r3, [r3, #16]
 8012eba:	2b00      	cmp	r3, #0
 8012ebc:	d108      	bne.n	8012ed0 <consume_markers+0x8c>
	  ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
 8012ebe:	687b      	ldr	r3, [r7, #4]
 8012ec0:	681b      	ldr	r3, [r3, #0]
 8012ec2:	2224      	movs	r2, #36	; 0x24
 8012ec4:	615a      	str	r2, [r3, #20]
 8012ec6:	687b      	ldr	r3, [r7, #4]
 8012ec8:	681b      	ldr	r3, [r3, #0]
 8012eca:	681b      	ldr	r3, [r3, #0]
 8012ecc:	6878      	ldr	r0, [r7, #4]
 8012ece:	4798      	blx	r3
	if (cinfo->comps_in_scan == 0) /* unexpected pseudo SOS marker */
 8012ed0:	687b      	ldr	r3, [r7, #4]
 8012ed2:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8012ed6:	2b00      	cmp	r3, #0
 8012ed8:	d02f      	beq.n	8012f3a <consume_markers+0xf6>
	  break;
	start_input_pass(cinfo);
 8012eda:	6878      	ldr	r0, [r7, #4]
 8012edc:	f7ff ff7e 	bl	8012ddc <start_input_pass>
      }
      return val;
 8012ee0:	68bb      	ldr	r3, [r7, #8]
 8012ee2:	e02c      	b.n	8012f3e <consume_markers+0xfa>
    case JPEG_REACHED_EOI:	/* Found EOI */
      inputctl->pub.eoi_reached = TRUE;
 8012ee4:	68fb      	ldr	r3, [r7, #12]
 8012ee6:	2201      	movs	r2, #1
 8012ee8:	615a      	str	r2, [r3, #20]
      if (inputctl->inheaders) { /* Tables-only datastream, apparently */
 8012eea:	68fb      	ldr	r3, [r7, #12]
 8012eec:	699b      	ldr	r3, [r3, #24]
 8012eee:	2b00      	cmp	r3, #0
 8012ef0:	d00f      	beq.n	8012f12 <consume_markers+0xce>
	if (cinfo->marker->saw_SOF)
 8012ef2:	687b      	ldr	r3, [r7, #4]
 8012ef4:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8012ef8:	691b      	ldr	r3, [r3, #16]
 8012efa:	2b00      	cmp	r3, #0
 8012efc:	d017      	beq.n	8012f2e <consume_markers+0xea>
	  ERREXIT(cinfo, JERR_SOF_NO_SOS);
 8012efe:	687b      	ldr	r3, [r7, #4]
 8012f00:	681b      	ldr	r3, [r3, #0]
 8012f02:	223d      	movs	r2, #61	; 0x3d
 8012f04:	615a      	str	r2, [r3, #20]
 8012f06:	687b      	ldr	r3, [r7, #4]
 8012f08:	681b      	ldr	r3, [r3, #0]
 8012f0a:	681b      	ldr	r3, [r3, #0]
 8012f0c:	6878      	ldr	r0, [r7, #4]
 8012f0e:	4798      	blx	r3
 8012f10:	e00d      	b.n	8012f2e <consume_markers+0xea>
      } else {
	/* Prevent infinite loop in coef ctlr's decompress_data routine
	 * if user set output_scan_number larger than number of scans.
	 */
	if (cinfo->output_scan_number > cinfo->input_scan_number)
 8012f12:	687b      	ldr	r3, [r7, #4]
 8012f14:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8012f18:	687b      	ldr	r3, [r7, #4]
 8012f1a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012f1e:	429a      	cmp	r2, r3
 8012f20:	dd05      	ble.n	8012f2e <consume_markers+0xea>
	  cinfo->output_scan_number = cinfo->input_scan_number;
 8012f22:	687b      	ldr	r3, [r7, #4]
 8012f24:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8012f28:	687b      	ldr	r3, [r7, #4]
 8012f2a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
      }
      return val;
 8012f2e:	68bb      	ldr	r3, [r7, #8]
 8012f30:	e005      	b.n	8012f3e <consume_markers+0xfa>
    case JPEG_SUSPENDED:
      return val;
 8012f32:	68bb      	ldr	r3, [r7, #8]
 8012f34:	e003      	b.n	8012f3e <consume_markers+0xfa>
    default:
      return val;
 8012f36:	68bb      	ldr	r3, [r7, #8]
 8012f38:	e001      	b.n	8012f3e <consume_markers+0xfa>
	  break;
 8012f3a:	bf00      	nop
    val = (*cinfo->marker->read_markers) (cinfo);
 8012f3c:	e790      	b.n	8012e60 <consume_markers+0x1c>
    }
  }
}
 8012f3e:	4618      	mov	r0, r3
 8012f40:	3710      	adds	r7, #16
 8012f42:	46bd      	mov	sp, r7
 8012f44:	bd80      	pop	{r7, pc}
	...

08012f48 <reset_input_controller>:
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
 8012f48:	b580      	push	{r7, lr}
 8012f4a:	b084      	sub	sp, #16
 8012f4c:	af00      	add	r7, sp, #0
 8012f4e:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
 8012f50:	687b      	ldr	r3, [r7, #4]
 8012f52:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8012f56:	60fb      	str	r3, [r7, #12]

  inputctl->pub.consume_input = consume_markers;
 8012f58:	68fb      	ldr	r3, [r7, #12]
 8012f5a:	4a0f      	ldr	r2, [pc, #60]	; (8012f98 <reset_input_controller+0x50>)
 8012f5c:	601a      	str	r2, [r3, #0]
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 8012f5e:	68fb      	ldr	r3, [r7, #12]
 8012f60:	2200      	movs	r2, #0
 8012f62:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 8012f64:	68fb      	ldr	r3, [r7, #12]
 8012f66:	2200      	movs	r2, #0
 8012f68:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 8012f6a:	68fb      	ldr	r3, [r7, #12]
 8012f6c:	2201      	movs	r2, #1
 8012f6e:	619a      	str	r2, [r3, #24]
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
 8012f70:	687b      	ldr	r3, [r7, #4]
 8012f72:	681b      	ldr	r3, [r3, #0]
 8012f74:	691b      	ldr	r3, [r3, #16]
 8012f76:	6878      	ldr	r0, [r7, #4]
 8012f78:	4798      	blx	r3
  (*cinfo->marker->reset_marker_reader) (cinfo);
 8012f7a:	687b      	ldr	r3, [r7, #4]
 8012f7c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8012f80:	681b      	ldr	r3, [r3, #0]
 8012f82:	6878      	ldr	r0, [r7, #4]
 8012f84:	4798      	blx	r3
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
 8012f86:	687b      	ldr	r3, [r7, #4]
 8012f88:	2200      	movs	r2, #0
 8012f8a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
 8012f8e:	bf00      	nop
 8012f90:	3710      	adds	r7, #16
 8012f92:	46bd      	mov	sp, r7
 8012f94:	bd80      	pop	{r7, pc}
 8012f96:	bf00      	nop
 8012f98:	08012e45 	.word	0x08012e45

08012f9c <jinit_input_controller>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
 8012f9c:	b580      	push	{r7, lr}
 8012f9e:	b084      	sub	sp, #16
 8012fa0:	af00      	add	r7, sp, #0
 8012fa2:	6078      	str	r0, [r7, #4]
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 8012fa4:	687b      	ldr	r3, [r7, #4]
 8012fa6:	685b      	ldr	r3, [r3, #4]
 8012fa8:	681b      	ldr	r3, [r3, #0]
 8012faa:	221c      	movs	r2, #28
 8012fac:	2100      	movs	r1, #0
 8012fae:	6878      	ldr	r0, [r7, #4]
 8012fb0:	4798      	blx	r3
 8012fb2:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
 8012fb4:	687b      	ldr	r3, [r7, #4]
 8012fb6:	68fa      	ldr	r2, [r7, #12]
 8012fb8:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
 8012fbc:	68fb      	ldr	r3, [r7, #12]
 8012fbe:	4a0c      	ldr	r2, [pc, #48]	; (8012ff0 <jinit_input_controller+0x54>)
 8012fc0:	601a      	str	r2, [r3, #0]
  inputctl->pub.reset_input_controller = reset_input_controller;
 8012fc2:	68fb      	ldr	r3, [r7, #12]
 8012fc4:	4a0b      	ldr	r2, [pc, #44]	; (8012ff4 <jinit_input_controller+0x58>)
 8012fc6:	605a      	str	r2, [r3, #4]
  inputctl->pub.start_input_pass = start_input_pass;
 8012fc8:	68fb      	ldr	r3, [r7, #12]
 8012fca:	4a0b      	ldr	r2, [pc, #44]	; (8012ff8 <jinit_input_controller+0x5c>)
 8012fcc:	609a      	str	r2, [r3, #8]
  inputctl->pub.finish_input_pass = finish_input_pass;
 8012fce:	68fb      	ldr	r3, [r7, #12]
 8012fd0:	4a0a      	ldr	r2, [pc, #40]	; (8012ffc <jinit_input_controller+0x60>)
 8012fd2:	60da      	str	r2, [r3, #12]
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
 8012fd4:	68fb      	ldr	r3, [r7, #12]
 8012fd6:	2200      	movs	r2, #0
 8012fd8:	611a      	str	r2, [r3, #16]
  inputctl->pub.eoi_reached = FALSE;
 8012fda:	68fb      	ldr	r3, [r7, #12]
 8012fdc:	2200      	movs	r2, #0
 8012fde:	615a      	str	r2, [r3, #20]
  inputctl->inheaders = 1;
 8012fe0:	68fb      	ldr	r3, [r7, #12]
 8012fe2:	2201      	movs	r2, #1
 8012fe4:	619a      	str	r2, [r3, #24]
}
 8012fe6:	bf00      	nop
 8012fe8:	3710      	adds	r7, #16
 8012fea:	46bd      	mov	sp, r7
 8012fec:	bd80      	pop	{r7, pc}
 8012fee:	bf00      	nop
 8012ff0:	08012e45 	.word	0x08012e45
 8012ff4:	08012f49 	.word	0x08012f49
 8012ff8:	08012ddd 	.word	0x08012ddd
 8012ffc:	08012e21 	.word	0x08012e21

08013000 <alloc_funny_pointers>:
LOCAL(void)
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
 8013000:	b580      	push	{r7, lr}
 8013002:	b088      	sub	sp, #32
 8013004:	af00      	add	r7, sp, #0
 8013006:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8013008:	687b      	ldr	r3, [r7, #4]
 801300a:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 801300e:	617b      	str	r3, [r7, #20]
  int ci, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 8013010:	687b      	ldr	r3, [r7, #4]
 8013012:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013016:	613b      	str	r3, [r7, #16]

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013018:	687b      	ldr	r3, [r7, #4]
 801301a:	685b      	ldr	r3, [r3, #4]
 801301c:	681b      	ldr	r3, [r3, #0]
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
 801301e:	687a      	ldr	r2, [r7, #4]
 8013020:	6a52      	ldr	r2, [r2, #36]	; 0x24
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013022:	00d2      	lsls	r2, r2, #3
 8013024:	2101      	movs	r1, #1
 8013026:	6878      	ldr	r0, [r7, #4]
 8013028:	4798      	blx	r3
 801302a:	4602      	mov	r2, r0
  main->xbuffer[0] = (JSAMPIMAGE)
 801302c:	697b      	ldr	r3, [r7, #20]
 801302e:	639a      	str	r2, [r3, #56]	; 0x38
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
 8013030:	697b      	ldr	r3, [r7, #20]
 8013032:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8013034:	687b      	ldr	r3, [r7, #4]
 8013036:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013038:	009b      	lsls	r3, r3, #2
 801303a:	441a      	add	r2, r3
 801303c:	697b      	ldr	r3, [r7, #20]
 801303e:	63da      	str	r2, [r3, #60]	; 0x3c

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013040:	2300      	movs	r3, #0
 8013042:	61fb      	str	r3, [r7, #28]
 8013044:	687b      	ldr	r3, [r7, #4]
 8013046:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 801304a:	61bb      	str	r3, [r7, #24]
 801304c:	e03a      	b.n	80130c4 <alloc_funny_pointers+0xc4>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801304e:	69bb      	ldr	r3, [r7, #24]
 8013050:	68db      	ldr	r3, [r3, #12]
 8013052:	69ba      	ldr	r2, [r7, #24]
 8013054:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8013056:	fb02 f203 	mul.w	r2, r2, r3
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801305a:	687b      	ldr	r3, [r7, #4]
 801305c:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8013060:	fb92 f3f3 	sdiv	r3, r2, r3
 8013064:	60fb      	str	r3, [r7, #12]
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013066:	687b      	ldr	r3, [r7, #4]
 8013068:	685b      	ldr	r3, [r3, #4]
 801306a:	681b      	ldr	r3, [r3, #0]
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
 801306c:	693a      	ldr	r2, [r7, #16]
 801306e:	3204      	adds	r2, #4
 8013070:	68f9      	ldr	r1, [r7, #12]
 8013072:	fb01 f202 	mul.w	r2, r1, r2
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8013076:	00d2      	lsls	r2, r2, #3
 8013078:	2101      	movs	r1, #1
 801307a:	6878      	ldr	r0, [r7, #4]
 801307c:	4798      	blx	r3
 801307e:	60b8      	str	r0, [r7, #8]
    xbuf += rgroup;		/* want one row group at negative offsets */
 8013080:	68fb      	ldr	r3, [r7, #12]
 8013082:	009b      	lsls	r3, r3, #2
 8013084:	68ba      	ldr	r2, [r7, #8]
 8013086:	4413      	add	r3, r2
 8013088:	60bb      	str	r3, [r7, #8]
    main->xbuffer[0][ci] = xbuf;
 801308a:	697b      	ldr	r3, [r7, #20]
 801308c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801308e:	69fb      	ldr	r3, [r7, #28]
 8013090:	009b      	lsls	r3, r3, #2
 8013092:	4413      	add	r3, r2
 8013094:	68ba      	ldr	r2, [r7, #8]
 8013096:	601a      	str	r2, [r3, #0]
    xbuf += rgroup * (M + 4);
 8013098:	693b      	ldr	r3, [r7, #16]
 801309a:	3304      	adds	r3, #4
 801309c:	68fa      	ldr	r2, [r7, #12]
 801309e:	fb02 f303 	mul.w	r3, r2, r3
 80130a2:	009b      	lsls	r3, r3, #2
 80130a4:	68ba      	ldr	r2, [r7, #8]
 80130a6:	4413      	add	r3, r2
 80130a8:	60bb      	str	r3, [r7, #8]
    main->xbuffer[1][ci] = xbuf;
 80130aa:	697b      	ldr	r3, [r7, #20]
 80130ac:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80130ae:	69fb      	ldr	r3, [r7, #28]
 80130b0:	009b      	lsls	r3, r3, #2
 80130b2:	4413      	add	r3, r2
 80130b4:	68ba      	ldr	r2, [r7, #8]
 80130b6:	601a      	str	r2, [r3, #0]
       ci++, compptr++) {
 80130b8:	69fb      	ldr	r3, [r7, #28]
 80130ba:	3301      	adds	r3, #1
 80130bc:	61fb      	str	r3, [r7, #28]
 80130be:	69bb      	ldr	r3, [r7, #24]
 80130c0:	3358      	adds	r3, #88	; 0x58
 80130c2:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80130c4:	687b      	ldr	r3, [r7, #4]
 80130c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80130c8:	69fa      	ldr	r2, [r7, #28]
 80130ca:	429a      	cmp	r2, r3
 80130cc:	dbbf      	blt.n	801304e <alloc_funny_pointers+0x4e>
  }
}
 80130ce:	bf00      	nop
 80130d0:	bf00      	nop
 80130d2:	3720      	adds	r7, #32
 80130d4:	46bd      	mov	sp, r7
 80130d6:	bd80      	pop	{r7, pc}

080130d8 <make_funny_pointers>:
 * The actual workspace is already allocated (in main->buffer),
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
 80130d8:	b480      	push	{r7}
 80130da:	b08d      	sub	sp, #52	; 0x34
 80130dc:	af00      	add	r7, sp, #0
 80130de:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 80130e0:	687b      	ldr	r3, [r7, #4]
 80130e2:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 80130e6:	623b      	str	r3, [r7, #32]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 80130e8:	687b      	ldr	r3, [r7, #4]
 80130ea:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 80130ee:	61fb      	str	r3, [r7, #28]
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80130f0:	2300      	movs	r3, #0
 80130f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80130f4:	687b      	ldr	r3, [r7, #4]
 80130f6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80130fa:	627b      	str	r3, [r7, #36]	; 0x24
 80130fc:	e08b      	b.n	8013216 <make_funny_pointers+0x13e>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 80130fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013100:	68db      	ldr	r3, [r3, #12]
 8013102:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013104:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8013106:	fb02 f203 	mul.w	r2, r2, r3
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 801310a:	687b      	ldr	r3, [r7, #4]
 801310c:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8013110:	fb92 f3f3 	sdiv	r3, r2, r3
 8013114:	61bb      	str	r3, [r7, #24]
    xbuf0 = main->xbuffer[0][ci];
 8013116:	6a3b      	ldr	r3, [r7, #32]
 8013118:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801311a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801311c:	009b      	lsls	r3, r3, #2
 801311e:	4413      	add	r3, r2
 8013120:	681b      	ldr	r3, [r3, #0]
 8013122:	617b      	str	r3, [r7, #20]
    xbuf1 = main->xbuffer[1][ci];
 8013124:	6a3b      	ldr	r3, [r7, #32]
 8013126:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8013128:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801312a:	009b      	lsls	r3, r3, #2
 801312c:	4413      	add	r3, r2
 801312e:	681b      	ldr	r3, [r3, #0]
 8013130:	613b      	str	r3, [r7, #16]
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
 8013132:	6a3b      	ldr	r3, [r7, #32]
 8013134:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013136:	3202      	adds	r2, #2
 8013138:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801313c:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < rgroup * (M + 2); i++) {
 801313e:	2300      	movs	r3, #0
 8013140:	62bb      	str	r3, [r7, #40]	; 0x28
 8013142:	e012      	b.n	801316a <make_funny_pointers+0x92>
      xbuf0[i] = xbuf1[i] = buf[i];
 8013144:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013146:	009b      	lsls	r3, r3, #2
 8013148:	68fa      	ldr	r2, [r7, #12]
 801314a:	441a      	add	r2, r3
 801314c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801314e:	009b      	lsls	r3, r3, #2
 8013150:	6939      	ldr	r1, [r7, #16]
 8013152:	440b      	add	r3, r1
 8013154:	6812      	ldr	r2, [r2, #0]
 8013156:	601a      	str	r2, [r3, #0]
 8013158:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801315a:	0092      	lsls	r2, r2, #2
 801315c:	6979      	ldr	r1, [r7, #20]
 801315e:	440a      	add	r2, r1
 8013160:	681b      	ldr	r3, [r3, #0]
 8013162:	6013      	str	r3, [r2, #0]
    for (i = 0; i < rgroup * (M + 2); i++) {
 8013164:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013166:	3301      	adds	r3, #1
 8013168:	62bb      	str	r3, [r7, #40]	; 0x28
 801316a:	69fb      	ldr	r3, [r7, #28]
 801316c:	3302      	adds	r3, #2
 801316e:	69ba      	ldr	r2, [r7, #24]
 8013170:	fb02 f303 	mul.w	r3, r2, r3
 8013174:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013176:	429a      	cmp	r2, r3
 8013178:	dbe4      	blt.n	8013144 <make_funny_pointers+0x6c>
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
 801317a:	2300      	movs	r3, #0
 801317c:	62bb      	str	r3, [r7, #40]	; 0x28
 801317e:	e02c      	b.n	80131da <make_funny_pointers+0x102>
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
 8013180:	69bb      	ldr	r3, [r7, #24]
 8013182:	69fa      	ldr	r2, [r7, #28]
 8013184:	fb02 f203 	mul.w	r2, r2, r3
 8013188:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801318a:	4413      	add	r3, r2
 801318c:	009b      	lsls	r3, r3, #2
 801318e:	68fa      	ldr	r2, [r7, #12]
 8013190:	441a      	add	r2, r3
 8013192:	69fb      	ldr	r3, [r7, #28]
 8013194:	3b02      	subs	r3, #2
 8013196:	69b9      	ldr	r1, [r7, #24]
 8013198:	fb01 f103 	mul.w	r1, r1, r3
 801319c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801319e:	440b      	add	r3, r1
 80131a0:	009b      	lsls	r3, r3, #2
 80131a2:	6939      	ldr	r1, [r7, #16]
 80131a4:	440b      	add	r3, r1
 80131a6:	6812      	ldr	r2, [r2, #0]
 80131a8:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
 80131aa:	69fb      	ldr	r3, [r7, #28]
 80131ac:	3b02      	subs	r3, #2
 80131ae:	69ba      	ldr	r2, [r7, #24]
 80131b0:	fb02 f203 	mul.w	r2, r2, r3
 80131b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80131b6:	4413      	add	r3, r2
 80131b8:	009b      	lsls	r3, r3, #2
 80131ba:	68fa      	ldr	r2, [r7, #12]
 80131bc:	441a      	add	r2, r3
 80131be:	69bb      	ldr	r3, [r7, #24]
 80131c0:	69f9      	ldr	r1, [r7, #28]
 80131c2:	fb01 f103 	mul.w	r1, r1, r3
 80131c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80131c8:	440b      	add	r3, r1
 80131ca:	009b      	lsls	r3, r3, #2
 80131cc:	6939      	ldr	r1, [r7, #16]
 80131ce:	440b      	add	r3, r1
 80131d0:	6812      	ldr	r2, [r2, #0]
 80131d2:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 80131d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80131d6:	3301      	adds	r3, #1
 80131d8:	62bb      	str	r3, [r7, #40]	; 0x28
 80131da:	69bb      	ldr	r3, [r7, #24]
 80131dc:	005b      	lsls	r3, r3, #1
 80131de:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80131e0:	429a      	cmp	r2, r3
 80131e2:	dbcd      	blt.n	8013180 <make_funny_pointers+0xa8>
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
 80131e4:	2300      	movs	r3, #0
 80131e6:	62bb      	str	r3, [r7, #40]	; 0x28
 80131e8:	e00b      	b.n	8013202 <make_funny_pointers+0x12a>
      xbuf0[i - rgroup] = xbuf0[0];
 80131ea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80131ec:	69bb      	ldr	r3, [r7, #24]
 80131ee:	1ad3      	subs	r3, r2, r3
 80131f0:	009b      	lsls	r3, r3, #2
 80131f2:	697a      	ldr	r2, [r7, #20]
 80131f4:	4413      	add	r3, r2
 80131f6:	697a      	ldr	r2, [r7, #20]
 80131f8:	6812      	ldr	r2, [r2, #0]
 80131fa:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 80131fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80131fe:	3301      	adds	r3, #1
 8013200:	62bb      	str	r3, [r7, #40]	; 0x28
 8013202:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013204:	69bb      	ldr	r3, [r7, #24]
 8013206:	429a      	cmp	r2, r3
 8013208:	dbef      	blt.n	80131ea <make_funny_pointers+0x112>
       ci++, compptr++) {
 801320a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801320c:	3301      	adds	r3, #1
 801320e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013210:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013212:	3358      	adds	r3, #88	; 0x58
 8013214:	627b      	str	r3, [r7, #36]	; 0x24
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013216:	687b      	ldr	r3, [r7, #4]
 8013218:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801321a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801321c:	429a      	cmp	r2, r3
 801321e:	f6ff af6e 	blt.w	80130fe <make_funny_pointers+0x26>
    }
  }
}
 8013222:	bf00      	nop
 8013224:	bf00      	nop
 8013226:	3734      	adds	r7, #52	; 0x34
 8013228:	46bd      	mov	sp, r7
 801322a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801322e:	4770      	bx	lr

08013230 <set_wraparound_pointers>:
LOCAL(void)
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
 8013230:	b480      	push	{r7}
 8013232:	b08b      	sub	sp, #44	; 0x2c
 8013234:	af00      	add	r7, sp, #0
 8013236:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8013238:	687b      	ldr	r3, [r7, #4]
 801323a:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 801323e:	61bb      	str	r3, [r7, #24]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_v_scaled_size;
 8013240:	687b      	ldr	r3, [r7, #4]
 8013242:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013246:	617b      	str	r3, [r7, #20]
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013248:	2300      	movs	r3, #0
 801324a:	627b      	str	r3, [r7, #36]	; 0x24
 801324c:	687b      	ldr	r3, [r7, #4]
 801324e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013252:	61fb      	str	r3, [r7, #28]
 8013254:	e06d      	b.n	8013332 <set_wraparound_pointers+0x102>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8013256:	69fb      	ldr	r3, [r7, #28]
 8013258:	68db      	ldr	r3, [r3, #12]
 801325a:	69fa      	ldr	r2, [r7, #28]
 801325c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801325e:	fb02 f203 	mul.w	r2, r2, r3
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8013262:	687b      	ldr	r3, [r7, #4]
 8013264:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 8013268:	fb92 f3f3 	sdiv	r3, r2, r3
 801326c:	613b      	str	r3, [r7, #16]
    xbuf0 = main->xbuffer[0][ci];
 801326e:	69bb      	ldr	r3, [r7, #24]
 8013270:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8013272:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013274:	009b      	lsls	r3, r3, #2
 8013276:	4413      	add	r3, r2
 8013278:	681b      	ldr	r3, [r3, #0]
 801327a:	60fb      	str	r3, [r7, #12]
    xbuf1 = main->xbuffer[1][ci];
 801327c:	69bb      	ldr	r3, [r7, #24]
 801327e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8013280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013282:	009b      	lsls	r3, r3, #2
 8013284:	4413      	add	r3, r2
 8013286:	681b      	ldr	r3, [r3, #0]
 8013288:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup; i++) {
 801328a:	2300      	movs	r3, #0
 801328c:	623b      	str	r3, [r7, #32]
 801328e:	e046      	b.n	801331e <set_wraparound_pointers+0xee>
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
 8013290:	697b      	ldr	r3, [r7, #20]
 8013292:	3301      	adds	r3, #1
 8013294:	693a      	ldr	r2, [r7, #16]
 8013296:	fb02 f203 	mul.w	r2, r2, r3
 801329a:	6a3b      	ldr	r3, [r7, #32]
 801329c:	4413      	add	r3, r2
 801329e:	009b      	lsls	r3, r3, #2
 80132a0:	68fa      	ldr	r2, [r7, #12]
 80132a2:	441a      	add	r2, r3
 80132a4:	6a39      	ldr	r1, [r7, #32]
 80132a6:	693b      	ldr	r3, [r7, #16]
 80132a8:	1acb      	subs	r3, r1, r3
 80132aa:	009b      	lsls	r3, r3, #2
 80132ac:	68f9      	ldr	r1, [r7, #12]
 80132ae:	440b      	add	r3, r1
 80132b0:	6812      	ldr	r2, [r2, #0]
 80132b2:	601a      	str	r2, [r3, #0]
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
 80132b4:	697b      	ldr	r3, [r7, #20]
 80132b6:	3301      	adds	r3, #1
 80132b8:	693a      	ldr	r2, [r7, #16]
 80132ba:	fb02 f203 	mul.w	r2, r2, r3
 80132be:	6a3b      	ldr	r3, [r7, #32]
 80132c0:	4413      	add	r3, r2
 80132c2:	009b      	lsls	r3, r3, #2
 80132c4:	68ba      	ldr	r2, [r7, #8]
 80132c6:	441a      	add	r2, r3
 80132c8:	6a39      	ldr	r1, [r7, #32]
 80132ca:	693b      	ldr	r3, [r7, #16]
 80132cc:	1acb      	subs	r3, r1, r3
 80132ce:	009b      	lsls	r3, r3, #2
 80132d0:	68b9      	ldr	r1, [r7, #8]
 80132d2:	440b      	add	r3, r1
 80132d4:	6812      	ldr	r2, [r2, #0]
 80132d6:	601a      	str	r2, [r3, #0]
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
 80132d8:	6a3b      	ldr	r3, [r7, #32]
 80132da:	009b      	lsls	r3, r3, #2
 80132dc:	68fa      	ldr	r2, [r7, #12]
 80132de:	441a      	add	r2, r3
 80132e0:	697b      	ldr	r3, [r7, #20]
 80132e2:	3302      	adds	r3, #2
 80132e4:	6939      	ldr	r1, [r7, #16]
 80132e6:	fb01 f103 	mul.w	r1, r1, r3
 80132ea:	6a3b      	ldr	r3, [r7, #32]
 80132ec:	440b      	add	r3, r1
 80132ee:	009b      	lsls	r3, r3, #2
 80132f0:	68f9      	ldr	r1, [r7, #12]
 80132f2:	440b      	add	r3, r1
 80132f4:	6812      	ldr	r2, [r2, #0]
 80132f6:	601a      	str	r2, [r3, #0]
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
 80132f8:	6a3b      	ldr	r3, [r7, #32]
 80132fa:	009b      	lsls	r3, r3, #2
 80132fc:	68ba      	ldr	r2, [r7, #8]
 80132fe:	441a      	add	r2, r3
 8013300:	697b      	ldr	r3, [r7, #20]
 8013302:	3302      	adds	r3, #2
 8013304:	6939      	ldr	r1, [r7, #16]
 8013306:	fb01 f103 	mul.w	r1, r1, r3
 801330a:	6a3b      	ldr	r3, [r7, #32]
 801330c:	440b      	add	r3, r1
 801330e:	009b      	lsls	r3, r3, #2
 8013310:	68b9      	ldr	r1, [r7, #8]
 8013312:	440b      	add	r3, r1
 8013314:	6812      	ldr	r2, [r2, #0]
 8013316:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup; i++) {
 8013318:	6a3b      	ldr	r3, [r7, #32]
 801331a:	3301      	adds	r3, #1
 801331c:	623b      	str	r3, [r7, #32]
 801331e:	6a3a      	ldr	r2, [r7, #32]
 8013320:	693b      	ldr	r3, [r7, #16]
 8013322:	429a      	cmp	r2, r3
 8013324:	dbb4      	blt.n	8013290 <set_wraparound_pointers+0x60>
       ci++, compptr++) {
 8013326:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013328:	3301      	adds	r3, #1
 801332a:	627b      	str	r3, [r7, #36]	; 0x24
 801332c:	69fb      	ldr	r3, [r7, #28]
 801332e:	3358      	adds	r3, #88	; 0x58
 8013330:	61fb      	str	r3, [r7, #28]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013332:	687b      	ldr	r3, [r7, #4]
 8013334:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013336:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013338:	429a      	cmp	r2, r3
 801333a:	db8c      	blt.n	8013256 <set_wraparound_pointers+0x26>
    }
  }
}
 801333c:	bf00      	nop
 801333e:	bf00      	nop
 8013340:	372c      	adds	r7, #44	; 0x2c
 8013342:	46bd      	mov	sp, r7
 8013344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013348:	4770      	bx	lr

0801334a <set_bottom_pointers>:
set_bottom_pointers (j_decompress_ptr cinfo)
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
 801334a:	b480      	push	{r7}
 801334c:	b08b      	sub	sp, #44	; 0x2c
 801334e:	af00      	add	r7, sp, #0
 8013350:	6078      	str	r0, [r7, #4]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8013352:	687b      	ldr	r3, [r7, #4]
 8013354:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 8013358:	617b      	str	r3, [r7, #20]
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801335a:	2300      	movs	r3, #0
 801335c:	627b      	str	r3, [r7, #36]	; 0x24
 801335e:	687b      	ldr	r3, [r7, #4]
 8013360:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013364:	61bb      	str	r3, [r7, #24]
 8013366:	e052      	b.n	801340e <set_bottom_pointers+0xc4>
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_v_scaled_size;
 8013368:	69bb      	ldr	r3, [r7, #24]
 801336a:	68db      	ldr	r3, [r3, #12]
 801336c:	69ba      	ldr	r2, [r7, #24]
 801336e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8013370:	fb02 f303 	mul.w	r3, r2, r3
 8013374:	613b      	str	r3, [r7, #16]
    rgroup = iMCUheight / cinfo->min_DCT_v_scaled_size;
 8013376:	687b      	ldr	r3, [r7, #4]
 8013378:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801337c:	693a      	ldr	r2, [r7, #16]
 801337e:	fb92 f3f3 	sdiv	r3, r2, r3
 8013382:	60fb      	str	r3, [r7, #12]
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
 8013384:	69bb      	ldr	r3, [r7, #24]
 8013386:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013388:	693a      	ldr	r2, [r7, #16]
 801338a:	fbb3 f1f2 	udiv	r1, r3, r2
 801338e:	fb02 f201 	mul.w	r2, r2, r1
 8013392:	1a9b      	subs	r3, r3, r2
 8013394:	61fb      	str	r3, [r7, #28]
    if (rows_left == 0) rows_left = iMCUheight;
 8013396:	69fb      	ldr	r3, [r7, #28]
 8013398:	2b00      	cmp	r3, #0
 801339a:	d101      	bne.n	80133a0 <set_bottom_pointers+0x56>
 801339c:	693b      	ldr	r3, [r7, #16]
 801339e:	61fb      	str	r3, [r7, #28]
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
 80133a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80133a2:	2b00      	cmp	r3, #0
 80133a4:	d108      	bne.n	80133b8 <set_bottom_pointers+0x6e>
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
 80133a6:	69fb      	ldr	r3, [r7, #28]
 80133a8:	1e5a      	subs	r2, r3, #1
 80133aa:	68fb      	ldr	r3, [r7, #12]
 80133ac:	fb92 f3f3 	sdiv	r3, r2, r3
 80133b0:	3301      	adds	r3, #1
 80133b2:	461a      	mov	r2, r3
 80133b4:	697b      	ldr	r3, [r7, #20]
 80133b6:	649a      	str	r2, [r3, #72]	; 0x48
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
 80133b8:	697b      	ldr	r3, [r7, #20]
 80133ba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80133bc:	697b      	ldr	r3, [r7, #20]
 80133be:	320e      	adds	r2, #14
 80133c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80133c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80133c6:	009b      	lsls	r3, r3, #2
 80133c8:	4413      	add	r3, r2
 80133ca:	681b      	ldr	r3, [r3, #0]
 80133cc:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < rgroup * 2; i++) {
 80133ce:	2300      	movs	r3, #0
 80133d0:	623b      	str	r3, [r7, #32]
 80133d2:	e011      	b.n	80133f8 <set_bottom_pointers+0xae>
      xbuf[rows_left + i] = xbuf[rows_left-1];
 80133d4:	69fb      	ldr	r3, [r7, #28]
 80133d6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80133da:	3b01      	subs	r3, #1
 80133dc:	009b      	lsls	r3, r3, #2
 80133de:	68ba      	ldr	r2, [r7, #8]
 80133e0:	441a      	add	r2, r3
 80133e2:	69f9      	ldr	r1, [r7, #28]
 80133e4:	6a3b      	ldr	r3, [r7, #32]
 80133e6:	440b      	add	r3, r1
 80133e8:	009b      	lsls	r3, r3, #2
 80133ea:	68b9      	ldr	r1, [r7, #8]
 80133ec:	440b      	add	r3, r1
 80133ee:	6812      	ldr	r2, [r2, #0]
 80133f0:	601a      	str	r2, [r3, #0]
    for (i = 0; i < rgroup * 2; i++) {
 80133f2:	6a3b      	ldr	r3, [r7, #32]
 80133f4:	3301      	adds	r3, #1
 80133f6:	623b      	str	r3, [r7, #32]
 80133f8:	68fb      	ldr	r3, [r7, #12]
 80133fa:	005b      	lsls	r3, r3, #1
 80133fc:	6a3a      	ldr	r2, [r7, #32]
 80133fe:	429a      	cmp	r2, r3
 8013400:	dbe8      	blt.n	80133d4 <set_bottom_pointers+0x8a>
       ci++, compptr++) {
 8013402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013404:	3301      	adds	r3, #1
 8013406:	627b      	str	r3, [r7, #36]	; 0x24
 8013408:	69bb      	ldr	r3, [r7, #24]
 801340a:	3358      	adds	r3, #88	; 0x58
 801340c:	61bb      	str	r3, [r7, #24]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801340e:	687b      	ldr	r3, [r7, #4]
 8013410:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013412:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013414:	429a      	cmp	r2, r3
 8013416:	dba7      	blt.n	8013368 <set_bottom_pointers+0x1e>
    }
  }
}
 8013418:	bf00      	nop
 801341a:	bf00      	nop
 801341c:	372c      	adds	r7, #44	; 0x2c
 801341e:	46bd      	mov	sp, r7
 8013420:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013424:	4770      	bx	lr
	...

08013428 <start_pass_main>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 8013428:	b580      	push	{r7, lr}
 801342a:	b084      	sub	sp, #16
 801342c:	af00      	add	r7, sp, #0
 801342e:	6078      	str	r0, [r7, #4]
 8013430:	460b      	mov	r3, r1
 8013432:	70fb      	strb	r3, [r7, #3]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8013434:	687b      	ldr	r3, [r7, #4]
 8013436:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 801343a:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 801343c:	78fb      	ldrb	r3, [r7, #3]
 801343e:	2b00      	cmp	r3, #0
 8013440:	d002      	beq.n	8013448 <start_pass_main+0x20>
 8013442:	2b02      	cmp	r3, #2
 8013444:	d020      	beq.n	8013488 <start_pass_main+0x60>
 8013446:	e023      	b.n	8013490 <start_pass_main+0x68>
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
 8013448:	687b      	ldr	r3, [r7, #4]
 801344a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 801344e:	689b      	ldr	r3, [r3, #8]
 8013450:	2b00      	cmp	r3, #0
 8013452:	d00f      	beq.n	8013474 <start_pass_main+0x4c>
      main->pub.process_data = process_data_context_main;
 8013454:	68fb      	ldr	r3, [r7, #12]
 8013456:	4a15      	ldr	r2, [pc, #84]	; (80134ac <start_pass_main+0x84>)
 8013458:	605a      	str	r2, [r3, #4]
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
 801345a:	6878      	ldr	r0, [r7, #4]
 801345c:	f7ff fe3c 	bl	80130d8 <make_funny_pointers>
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
 8013460:	68fb      	ldr	r3, [r7, #12]
 8013462:	2200      	movs	r2, #0
 8013464:	641a      	str	r2, [r3, #64]	; 0x40
      main->context_state = CTX_PREPARE_FOR_IMCU;
 8013466:	68fb      	ldr	r3, [r7, #12]
 8013468:	2200      	movs	r2, #0
 801346a:	645a      	str	r2, [r3, #68]	; 0x44
      main->iMCU_row_ctr = 0;
 801346c:	68fb      	ldr	r3, [r7, #12]
 801346e:	2200      	movs	r2, #0
 8013470:	64da      	str	r2, [r3, #76]	; 0x4c
 8013472:	e002      	b.n	801347a <start_pass_main+0x52>
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
 8013474:	68fb      	ldr	r3, [r7, #12]
 8013476:	4a0e      	ldr	r2, [pc, #56]	; (80134b0 <start_pass_main+0x88>)
 8013478:	605a      	str	r2, [r3, #4]
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
 801347a:	68fb      	ldr	r3, [r7, #12]
 801347c:	2200      	movs	r2, #0
 801347e:	631a      	str	r2, [r3, #48]	; 0x30
    main->rowgroup_ctr = 0;
 8013480:	68fb      	ldr	r3, [r7, #12]
 8013482:	2200      	movs	r2, #0
 8013484:	635a      	str	r2, [r3, #52]	; 0x34
    break;
 8013486:	e00d      	b.n	80134a4 <start_pass_main+0x7c>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
 8013488:	68fb      	ldr	r3, [r7, #12]
 801348a:	4a0a      	ldr	r2, [pc, #40]	; (80134b4 <start_pass_main+0x8c>)
 801348c:	605a      	str	r2, [r3, #4]
    break;
 801348e:	e009      	b.n	80134a4 <start_pass_main+0x7c>
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 8013490:	687b      	ldr	r3, [r7, #4]
 8013492:	681b      	ldr	r3, [r3, #0]
 8013494:	2203      	movs	r2, #3
 8013496:	615a      	str	r2, [r3, #20]
 8013498:	687b      	ldr	r3, [r7, #4]
 801349a:	681b      	ldr	r3, [r3, #0]
 801349c:	681b      	ldr	r3, [r3, #0]
 801349e:	6878      	ldr	r0, [r7, #4]
 80134a0:	4798      	blx	r3
    break;
 80134a2:	bf00      	nop
  }
}
 80134a4:	bf00      	nop
 80134a6:	3710      	adds	r7, #16
 80134a8:	46bd      	mov	sp, r7
 80134aa:	bd80      	pop	{r7, pc}
 80134ac:	08013543 	.word	0x08013543
 80134b0:	080134b9 	.word	0x080134b9
 80134b4:	080136b9 	.word	0x080136b9

080134b8 <process_data_simple_main>:

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
 80134b8:	b590      	push	{r4, r7, lr}
 80134ba:	b08b      	sub	sp, #44	; 0x2c
 80134bc:	af04      	add	r7, sp, #16
 80134be:	60f8      	str	r0, [r7, #12]
 80134c0:	60b9      	str	r1, [r7, #8]
 80134c2:	607a      	str	r2, [r7, #4]
 80134c4:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 80134c6:	68fb      	ldr	r3, [r7, #12]
 80134c8:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 80134cc:	617b      	str	r3, [r7, #20]
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 80134ce:	697b      	ldr	r3, [r7, #20]
 80134d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80134d2:	2b00      	cmp	r3, #0
 80134d4:	d10e      	bne.n	80134f4 <process_data_simple_main+0x3c>
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
 80134d6:	68fb      	ldr	r3, [r7, #12]
 80134d8:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 80134dc:	68db      	ldr	r3, [r3, #12]
 80134de:	697a      	ldr	r2, [r7, #20]
 80134e0:	3208      	adds	r2, #8
 80134e2:	4611      	mov	r1, r2
 80134e4:	68f8      	ldr	r0, [r7, #12]
 80134e6:	4798      	blx	r3
 80134e8:	4603      	mov	r3, r0
 80134ea:	2b00      	cmp	r3, #0
 80134ec:	d025      	beq.n	801353a <process_data_simple_main+0x82>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 80134ee:	697b      	ldr	r3, [r7, #20]
 80134f0:	2201      	movs	r2, #1
 80134f2:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_v_scaled_size;
 80134f4:	68fb      	ldr	r3, [r7, #12]
 80134f6:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 80134fa:	613b      	str	r3, [r7, #16]
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
 80134fc:	68fb      	ldr	r3, [r7, #12]
 80134fe:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8013502:	685c      	ldr	r4, [r3, #4]
 8013504:	697b      	ldr	r3, [r7, #20]
 8013506:	f103 0108 	add.w	r1, r3, #8
 801350a:	697b      	ldr	r3, [r7, #20]
 801350c:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013510:	683b      	ldr	r3, [r7, #0]
 8013512:	9302      	str	r3, [sp, #8]
 8013514:	687b      	ldr	r3, [r7, #4]
 8013516:	9301      	str	r3, [sp, #4]
 8013518:	68bb      	ldr	r3, [r7, #8]
 801351a:	9300      	str	r3, [sp, #0]
 801351c:	693b      	ldr	r3, [r7, #16]
 801351e:	68f8      	ldr	r0, [r7, #12]
 8013520:	47a0      	blx	r4
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
 8013522:	697b      	ldr	r3, [r7, #20]
 8013524:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8013526:	693a      	ldr	r2, [r7, #16]
 8013528:	429a      	cmp	r2, r3
 801352a:	d807      	bhi.n	801353c <process_data_simple_main+0x84>
    main->buffer_full = FALSE;
 801352c:	697b      	ldr	r3, [r7, #20]
 801352e:	2200      	movs	r2, #0
 8013530:	631a      	str	r2, [r3, #48]	; 0x30
    main->rowgroup_ctr = 0;
 8013532:	697b      	ldr	r3, [r7, #20]
 8013534:	2200      	movs	r2, #0
 8013536:	635a      	str	r2, [r3, #52]	; 0x34
 8013538:	e000      	b.n	801353c <process_data_simple_main+0x84>
      return;			/* suspension forced, can do nothing more */
 801353a:	bf00      	nop
  }
}
 801353c:	371c      	adds	r7, #28
 801353e:	46bd      	mov	sp, r7
 8013540:	bd90      	pop	{r4, r7, pc}

08013542 <process_data_context_main>:

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
 8013542:	b590      	push	{r4, r7, lr}
 8013544:	b08b      	sub	sp, #44	; 0x2c
 8013546:	af04      	add	r7, sp, #16
 8013548:	60f8      	str	r0, [r7, #12]
 801354a:	60b9      	str	r1, [r7, #8]
 801354c:	607a      	str	r2, [r7, #4]
 801354e:	603b      	str	r3, [r7, #0]
  my_main_ptr main = (my_main_ptr) cinfo->main;
 8013550:	68fb      	ldr	r3, [r7, #12]
 8013552:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 8013556:	617b      	str	r3, [r7, #20]

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
 8013558:	697b      	ldr	r3, [r7, #20]
 801355a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801355c:	2b00      	cmp	r3, #0
 801355e:	d118      	bne.n	8013592 <process_data_context_main+0x50>
    if (! (*cinfo->coef->decompress_data) (cinfo,
 8013560:	68fb      	ldr	r3, [r7, #12]
 8013562:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 8013566:	68db      	ldr	r3, [r3, #12]
					   main->xbuffer[main->whichptr]))
 8013568:	697a      	ldr	r2, [r7, #20]
 801356a:	6c11      	ldr	r1, [r2, #64]	; 0x40
    if (! (*cinfo->coef->decompress_data) (cinfo,
 801356c:	697a      	ldr	r2, [r7, #20]
 801356e:	310e      	adds	r1, #14
 8013570:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8013574:	4611      	mov	r1, r2
 8013576:	68f8      	ldr	r0, [r7, #12]
 8013578:	4798      	blx	r3
 801357a:	4603      	mov	r3, r0
 801357c:	2b00      	cmp	r3, #0
 801357e:	f000 8091 	beq.w	80136a4 <process_data_context_main+0x162>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
 8013582:	697b      	ldr	r3, [r7, #20]
 8013584:	2201      	movs	r2, #1
 8013586:	631a      	str	r2, [r3, #48]	; 0x30
    main->iMCU_row_ctr++;	/* count rows received */
 8013588:	697b      	ldr	r3, [r7, #20]
 801358a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801358c:	1c5a      	adds	r2, r3, #1
 801358e:	697b      	ldr	r3, [r7, #20]
 8013590:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
 8013592:	697b      	ldr	r3, [r7, #20]
 8013594:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013596:	2b02      	cmp	r3, #2
 8013598:	d007      	beq.n	80135aa <process_data_context_main+0x68>
 801359a:	2b02      	cmp	r3, #2
 801359c:	f300 8089 	bgt.w	80136b2 <process_data_context_main+0x170>
 80135a0:	2b00      	cmp	r3, #0
 80135a2:	d028      	beq.n	80135f6 <process_data_context_main+0xb4>
 80135a4:	2b01      	cmp	r3, #1
 80135a6:	d03d      	beq.n	8013624 <process_data_context_main+0xe2>
 80135a8:	e083      	b.n	80136b2 <process_data_context_main+0x170>
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 80135aa:	68fb      	ldr	r3, [r7, #12]
 80135ac:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 80135b0:	685c      	ldr	r4, [r3, #4]
 80135b2:	697b      	ldr	r3, [r7, #20]
 80135b4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80135b6:	697b      	ldr	r3, [r7, #20]
 80135b8:	320e      	adds	r2, #14
 80135ba:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80135be:	697b      	ldr	r3, [r7, #20]
 80135c0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80135c4:	697b      	ldr	r3, [r7, #20]
 80135c6:	6c98      	ldr	r0, [r3, #72]	; 0x48
 80135c8:	683b      	ldr	r3, [r7, #0]
 80135ca:	9302      	str	r3, [sp, #8]
 80135cc:	687b      	ldr	r3, [r7, #4]
 80135ce:	9301      	str	r3, [sp, #4]
 80135d0:	68bb      	ldr	r3, [r7, #8]
 80135d2:	9300      	str	r3, [sp, #0]
 80135d4:	4603      	mov	r3, r0
 80135d6:	68f8      	ldr	r0, [r7, #12]
 80135d8:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 80135da:	697b      	ldr	r3, [r7, #20]
 80135dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80135de:	697b      	ldr	r3, [r7, #20]
 80135e0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80135e2:	429a      	cmp	r2, r3
 80135e4:	d360      	bcc.n	80136a8 <process_data_context_main+0x166>
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
 80135e6:	697b      	ldr	r3, [r7, #20]
 80135e8:	2200      	movs	r2, #0
 80135ea:	645a      	str	r2, [r3, #68]	; 0x44
    if (*out_row_ctr >= out_rows_avail)
 80135ec:	687b      	ldr	r3, [r7, #4]
 80135ee:	681b      	ldr	r3, [r3, #0]
 80135f0:	683a      	ldr	r2, [r7, #0]
 80135f2:	429a      	cmp	r2, r3
 80135f4:	d95a      	bls.n	80136ac <process_data_context_main+0x16a>
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
 80135f6:	697b      	ldr	r3, [r7, #20]
 80135f8:	2200      	movs	r2, #0
 80135fa:	635a      	str	r2, [r3, #52]	; 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size - 1);
 80135fc:	68fb      	ldr	r3, [r7, #12]
 80135fe:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013602:	3b01      	subs	r3, #1
 8013604:	461a      	mov	r2, r3
 8013606:	697b      	ldr	r3, [r7, #20]
 8013608:	649a      	str	r2, [r3, #72]	; 0x48
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
 801360a:	697b      	ldr	r3, [r7, #20]
 801360c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801360e:	68fb      	ldr	r3, [r7, #12]
 8013610:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 8013614:	429a      	cmp	r2, r3
 8013616:	d102      	bne.n	801361e <process_data_context_main+0xdc>
      set_bottom_pointers(cinfo);
 8013618:	68f8      	ldr	r0, [r7, #12]
 801361a:	f7ff fe96 	bl	801334a <set_bottom_pointers>
    main->context_state = CTX_PROCESS_IMCU;
 801361e:	697b      	ldr	r3, [r7, #20]
 8013620:	2201      	movs	r2, #1
 8013622:	645a      	str	r2, [r3, #68]	; 0x44
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
 8013624:	68fb      	ldr	r3, [r7, #12]
 8013626:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 801362a:	685c      	ldr	r4, [r3, #4]
 801362c:	697b      	ldr	r3, [r7, #20]
 801362e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8013630:	697b      	ldr	r3, [r7, #20]
 8013632:	320e      	adds	r2, #14
 8013634:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013638:	697b      	ldr	r3, [r7, #20]
 801363a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801363e:	697b      	ldr	r3, [r7, #20]
 8013640:	6c98      	ldr	r0, [r3, #72]	; 0x48
 8013642:	683b      	ldr	r3, [r7, #0]
 8013644:	9302      	str	r3, [sp, #8]
 8013646:	687b      	ldr	r3, [r7, #4]
 8013648:	9301      	str	r3, [sp, #4]
 801364a:	68bb      	ldr	r3, [r7, #8]
 801364c:	9300      	str	r3, [sp, #0]
 801364e:	4603      	mov	r3, r0
 8013650:	68f8      	ldr	r0, [r7, #12]
 8013652:	47a0      	blx	r4
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
 8013654:	697b      	ldr	r3, [r7, #20]
 8013656:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8013658:	697b      	ldr	r3, [r7, #20]
 801365a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801365c:	429a      	cmp	r2, r3
 801365e:	d327      	bcc.n	80136b0 <process_data_context_main+0x16e>
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
 8013660:	697b      	ldr	r3, [r7, #20]
 8013662:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8013664:	2b01      	cmp	r3, #1
 8013666:	d102      	bne.n	801366e <process_data_context_main+0x12c>
      set_wraparound_pointers(cinfo);
 8013668:	68f8      	ldr	r0, [r7, #12]
 801366a:	f7ff fde1 	bl	8013230 <set_wraparound_pointers>
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
 801366e:	697b      	ldr	r3, [r7, #20]
 8013670:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013672:	f083 0201 	eor.w	r2, r3, #1
 8013676:	697b      	ldr	r3, [r7, #20]
 8013678:	641a      	str	r2, [r3, #64]	; 0x40
    main->buffer_full = FALSE;
 801367a:	697b      	ldr	r3, [r7, #20]
 801367c:	2200      	movs	r2, #0
 801367e:	631a      	str	r2, [r3, #48]	; 0x30
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 1);
 8013680:	68fb      	ldr	r3, [r7, #12]
 8013682:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013686:	3301      	adds	r3, #1
 8013688:	461a      	mov	r2, r3
 801368a:	697b      	ldr	r3, [r7, #20]
 801368c:	635a      	str	r2, [r3, #52]	; 0x34
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_v_scaled_size + 2);
 801368e:	68fb      	ldr	r3, [r7, #12]
 8013690:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013694:	3302      	adds	r3, #2
 8013696:	461a      	mov	r2, r3
 8013698:	697b      	ldr	r3, [r7, #20]
 801369a:	649a      	str	r2, [r3, #72]	; 0x48
    main->context_state = CTX_POSTPONED_ROW;
 801369c:	697b      	ldr	r3, [r7, #20]
 801369e:	2202      	movs	r2, #2
 80136a0:	645a      	str	r2, [r3, #68]	; 0x44
 80136a2:	e006      	b.n	80136b2 <process_data_context_main+0x170>
      return;			/* suspension forced, can do nothing more */
 80136a4:	bf00      	nop
 80136a6:	e004      	b.n	80136b2 <process_data_context_main+0x170>
      return;			/* Need to suspend */
 80136a8:	bf00      	nop
 80136aa:	e002      	b.n	80136b2 <process_data_context_main+0x170>
      return;			/* Postprocessor exactly filled output buf */
 80136ac:	bf00      	nop
 80136ae:	e000      	b.n	80136b2 <process_data_context_main+0x170>
      return;			/* Need to suspend */
 80136b0:	bf00      	nop
  }
}
 80136b2:	371c      	adds	r7, #28
 80136b4:	46bd      	mov	sp, r7
 80136b6:	bd90      	pop	{r4, r7, pc}

080136b8 <process_data_crank_post>:

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
 80136b8:	b590      	push	{r4, r7, lr}
 80136ba:	b089      	sub	sp, #36	; 0x24
 80136bc:	af04      	add	r7, sp, #16
 80136be:	60f8      	str	r0, [r7, #12]
 80136c0:	60b9      	str	r1, [r7, #8]
 80136c2:	607a      	str	r2, [r7, #4]
 80136c4:	603b      	str	r3, [r7, #0]
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
 80136c6:	68fb      	ldr	r3, [r7, #12]
 80136c8:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 80136cc:	685c      	ldr	r4, [r3, #4]
 80136ce:	683b      	ldr	r3, [r7, #0]
 80136d0:	9302      	str	r3, [sp, #8]
 80136d2:	687b      	ldr	r3, [r7, #4]
 80136d4:	9301      	str	r3, [sp, #4]
 80136d6:	68bb      	ldr	r3, [r7, #8]
 80136d8:	9300      	str	r3, [sp, #0]
 80136da:	2300      	movs	r3, #0
 80136dc:	2200      	movs	r2, #0
 80136de:	2100      	movs	r1, #0
 80136e0:	68f8      	ldr	r0, [r7, #12]
 80136e2:	47a0      	blx	r4
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}
 80136e4:	bf00      	nop
 80136e6:	3714      	adds	r7, #20
 80136e8:	46bd      	mov	sp, r7
 80136ea:	bd90      	pop	{r4, r7, pc}

080136ec <jinit_d_main_controller>:
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 80136ec:	b590      	push	{r4, r7, lr}
 80136ee:	b089      	sub	sp, #36	; 0x24
 80136f0:	af00      	add	r7, sp, #0
 80136f2:	6078      	str	r0, [r7, #4]
 80136f4:	6039      	str	r1, [r7, #0]
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80136f6:	687b      	ldr	r3, [r7, #4]
 80136f8:	685b      	ldr	r3, [r3, #4]
 80136fa:	681b      	ldr	r3, [r3, #0]
 80136fc:	2250      	movs	r2, #80	; 0x50
 80136fe:	2101      	movs	r1, #1
 8013700:	6878      	ldr	r0, [r7, #4]
 8013702:	4798      	blx	r3
 8013704:	6138      	str	r0, [r7, #16]
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
 8013706:	687b      	ldr	r3, [r7, #4]
 8013708:	693a      	ldr	r2, [r7, #16]
 801370a:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
  main->pub.start_pass = start_pass_main;
 801370e:	693b      	ldr	r3, [r7, #16]
 8013710:	4a34      	ldr	r2, [pc, #208]	; (80137e4 <jinit_d_main_controller+0xf8>)
 8013712:	601a      	str	r2, [r3, #0]

  if (need_full_buffer)		/* shouldn't happen */
 8013714:	683b      	ldr	r3, [r7, #0]
 8013716:	2b00      	cmp	r3, #0
 8013718:	d008      	beq.n	801372c <jinit_d_main_controller+0x40>
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 801371a:	687b      	ldr	r3, [r7, #4]
 801371c:	681b      	ldr	r3, [r3, #0]
 801371e:	2203      	movs	r2, #3
 8013720:	615a      	str	r2, [r3, #20]
 8013722:	687b      	ldr	r3, [r7, #4]
 8013724:	681b      	ldr	r3, [r3, #0]
 8013726:	681b      	ldr	r3, [r3, #0]
 8013728:	6878      	ldr	r0, [r7, #4]
 801372a:	4798      	blx	r3

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
 801372c:	687b      	ldr	r3, [r7, #4]
 801372e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8013732:	689b      	ldr	r3, [r3, #8]
 8013734:	2b00      	cmp	r3, #0
 8013736:	d016      	beq.n	8013766 <jinit_d_main_controller+0x7a>
    if (cinfo->min_DCT_v_scaled_size < 2) /* unsupported, see comments above */
 8013738:	687b      	ldr	r3, [r7, #4]
 801373a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801373e:	2b01      	cmp	r3, #1
 8013740:	dc08      	bgt.n	8013754 <jinit_d_main_controller+0x68>
      ERREXIT(cinfo, JERR_NOTIMPL);
 8013742:	687b      	ldr	r3, [r7, #4]
 8013744:	681b      	ldr	r3, [r3, #0]
 8013746:	2230      	movs	r2, #48	; 0x30
 8013748:	615a      	str	r2, [r3, #20]
 801374a:	687b      	ldr	r3, [r7, #4]
 801374c:	681b      	ldr	r3, [r3, #0]
 801374e:	681b      	ldr	r3, [r3, #0]
 8013750:	6878      	ldr	r0, [r7, #4]
 8013752:	4798      	blx	r3
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
 8013754:	6878      	ldr	r0, [r7, #4]
 8013756:	f7ff fc53 	bl	8013000 <alloc_funny_pointers>
    ngroups = cinfo->min_DCT_v_scaled_size + 2;
 801375a:	687b      	ldr	r3, [r7, #4]
 801375c:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8013760:	3302      	adds	r3, #2
 8013762:	61bb      	str	r3, [r7, #24]
 8013764:	e003      	b.n	801376e <jinit_d_main_controller+0x82>
  } else {
    ngroups = cinfo->min_DCT_v_scaled_size;
 8013766:	687b      	ldr	r3, [r7, #4]
 8013768:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801376c:	61bb      	str	r3, [r7, #24]
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 801376e:	2300      	movs	r3, #0
 8013770:	61fb      	str	r3, [r7, #28]
 8013772:	687b      	ldr	r3, [r7, #4]
 8013774:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013778:	617b      	str	r3, [r7, #20]
 801377a:	e028      	b.n	80137ce <jinit_d_main_controller+0xe2>
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801377c:	697b      	ldr	r3, [r7, #20]
 801377e:	68db      	ldr	r3, [r3, #12]
 8013780:	697a      	ldr	r2, [r7, #20]
 8013782:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8013784:	fb02 f203 	mul.w	r2, r2, r3
      cinfo->min_DCT_v_scaled_size; /* height of a row group of component */
 8013788:	687b      	ldr	r3, [r7, #4]
 801378a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
    rgroup = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801378e:	fb92 f3f3 	sdiv	r3, r2, r3
 8013792:	60fb      	str	r3, [r7, #12]
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 8013794:	687b      	ldr	r3, [r7, #4]
 8013796:	685b      	ldr	r3, [r3, #4]
 8013798:	689c      	ldr	r4, [r3, #8]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_h_scaled_size,
 801379a:	697b      	ldr	r3, [r7, #20]
 801379c:	69db      	ldr	r3, [r3, #28]
 801379e:	697a      	ldr	r2, [r7, #20]
 80137a0:	6a52      	ldr	r2, [r2, #36]	; 0x24
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 80137a2:	fb02 f103 	mul.w	r1, r2, r3
			 (JDIMENSION) (rgroup * ngroups));
 80137a6:	68fb      	ldr	r3, [r7, #12]
 80137a8:	69ba      	ldr	r2, [r7, #24]
 80137aa:	fb02 f303 	mul.w	r3, r2, r3
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
 80137ae:	460a      	mov	r2, r1
 80137b0:	2101      	movs	r1, #1
 80137b2:	6878      	ldr	r0, [r7, #4]
 80137b4:	47a0      	blx	r4
 80137b6:	4601      	mov	r1, r0
 80137b8:	693b      	ldr	r3, [r7, #16]
 80137ba:	69fa      	ldr	r2, [r7, #28]
 80137bc:	3202      	adds	r2, #2
 80137be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
       ci++, compptr++) {
 80137c2:	69fb      	ldr	r3, [r7, #28]
 80137c4:	3301      	adds	r3, #1
 80137c6:	61fb      	str	r3, [r7, #28]
 80137c8:	697b      	ldr	r3, [r7, #20]
 80137ca:	3358      	adds	r3, #88	; 0x58
 80137cc:	617b      	str	r3, [r7, #20]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80137ce:	687b      	ldr	r3, [r7, #4]
 80137d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80137d2:	69fa      	ldr	r2, [r7, #28]
 80137d4:	429a      	cmp	r2, r3
 80137d6:	dbd1      	blt.n	801377c <jinit_d_main_controller+0x90>
  }
}
 80137d8:	bf00      	nop
 80137da:	bf00      	nop
 80137dc:	3724      	adds	r7, #36	; 0x24
 80137de:	46bd      	mov	sp, r7
 80137e0:	bd90      	pop	{r4, r7, pc}
 80137e2:	bf00      	nop
 80137e4:	08013429 	.word	0x08013429

080137e8 <get_soi>:


LOCAL(boolean)
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
 80137e8:	b580      	push	{r7, lr}
 80137ea:	b084      	sub	sp, #16
 80137ec:	af00      	add	r7, sp, #0
 80137ee:	6078      	str	r0, [r7, #4]
  int i;
  
  TRACEMS(cinfo, 1, JTRC_SOI);
 80137f0:	687b      	ldr	r3, [r7, #4]
 80137f2:	681b      	ldr	r3, [r3, #0]
 80137f4:	2268      	movs	r2, #104	; 0x68
 80137f6:	615a      	str	r2, [r3, #20]
 80137f8:	687b      	ldr	r3, [r7, #4]
 80137fa:	681b      	ldr	r3, [r3, #0]
 80137fc:	685b      	ldr	r3, [r3, #4]
 80137fe:	2101      	movs	r1, #1
 8013800:	6878      	ldr	r0, [r7, #4]
 8013802:	4798      	blx	r3

  if (cinfo->marker->saw_SOI)
 8013804:	687b      	ldr	r3, [r7, #4]
 8013806:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801380a:	68db      	ldr	r3, [r3, #12]
 801380c:	2b00      	cmp	r3, #0
 801380e:	d008      	beq.n	8013822 <get_soi+0x3a>
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);
 8013810:	687b      	ldr	r3, [r7, #4]
 8013812:	681b      	ldr	r3, [r3, #0]
 8013814:	223f      	movs	r2, #63	; 0x3f
 8013816:	615a      	str	r2, [r3, #20]
 8013818:	687b      	ldr	r3, [r7, #4]
 801381a:	681b      	ldr	r3, [r3, #0]
 801381c:	681b      	ldr	r3, [r3, #0]
 801381e:	6878      	ldr	r0, [r7, #4]
 8013820:	4798      	blx	r3

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 8013822:	2300      	movs	r3, #0
 8013824:	60fb      	str	r3, [r7, #12]
 8013826:	e015      	b.n	8013854 <get_soi+0x6c>
    cinfo->arith_dc_L[i] = 0;
 8013828:	687a      	ldr	r2, [r7, #4]
 801382a:	68fb      	ldr	r3, [r7, #12]
 801382c:	4413      	add	r3, r2
 801382e:	33e8      	adds	r3, #232	; 0xe8
 8013830:	2200      	movs	r2, #0
 8013832:	701a      	strb	r2, [r3, #0]
    cinfo->arith_dc_U[i] = 1;
 8013834:	687a      	ldr	r2, [r7, #4]
 8013836:	68fb      	ldr	r3, [r7, #12]
 8013838:	4413      	add	r3, r2
 801383a:	33f8      	adds	r3, #248	; 0xf8
 801383c:	2201      	movs	r2, #1
 801383e:	701a      	strb	r2, [r3, #0]
    cinfo->arith_ac_K[i] = 5;
 8013840:	687a      	ldr	r2, [r7, #4]
 8013842:	68fb      	ldr	r3, [r7, #12]
 8013844:	4413      	add	r3, r2
 8013846:	f503 7384 	add.w	r3, r3, #264	; 0x108
 801384a:	2205      	movs	r2, #5
 801384c:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
 801384e:	68fb      	ldr	r3, [r7, #12]
 8013850:	3301      	adds	r3, #1
 8013852:	60fb      	str	r3, [r7, #12]
 8013854:	68fb      	ldr	r3, [r7, #12]
 8013856:	2b0f      	cmp	r3, #15
 8013858:	dde6      	ble.n	8013828 <get_soi+0x40>
  }
  cinfo->restart_interval = 0;
 801385a:	687b      	ldr	r3, [r7, #4]
 801385c:	2200      	movs	r2, #0
 801385e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
 8013862:	687b      	ldr	r3, [r7, #4]
 8013864:	2200      	movs	r2, #0
 8013866:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
 801386a:	687b      	ldr	r3, [r7, #4]
 801386c:	2200      	movs	r2, #0
 801386e:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130

  cinfo->saw_JFIF_marker = FALSE;
 8013872:	687b      	ldr	r3, [r7, #4]
 8013874:	2200      	movs	r2, #0
 8013876:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
 801387a:	687b      	ldr	r3, [r7, #4]
 801387c:	2201      	movs	r2, #1
 801387e:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
  cinfo->JFIF_minor_version = 1;
 8013882:	687b      	ldr	r3, [r7, #4]
 8013884:	2201      	movs	r2, #1
 8013886:	f883 2121 	strb.w	r2, [r3, #289]	; 0x121
  cinfo->density_unit = 0;
 801388a:	687b      	ldr	r3, [r7, #4]
 801388c:	2200      	movs	r2, #0
 801388e:	f883 2122 	strb.w	r2, [r3, #290]	; 0x122
  cinfo->X_density = 1;
 8013892:	687b      	ldr	r3, [r7, #4]
 8013894:	2201      	movs	r2, #1
 8013896:	f8a3 2124 	strh.w	r2, [r3, #292]	; 0x124
  cinfo->Y_density = 1;
 801389a:	687b      	ldr	r3, [r7, #4]
 801389c:	2201      	movs	r2, #1
 801389e:	f8a3 2126 	strh.w	r2, [r3, #294]	; 0x126
  cinfo->saw_Adobe_marker = FALSE;
 80138a2:	687b      	ldr	r3, [r7, #4]
 80138a4:	2200      	movs	r2, #0
 80138a6:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
  cinfo->Adobe_transform = 0;
 80138aa:	687b      	ldr	r3, [r7, #4]
 80138ac:	2200      	movs	r2, #0
 80138ae:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c

  cinfo->marker->saw_SOI = TRUE;
 80138b2:	687b      	ldr	r3, [r7, #4]
 80138b4:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 80138b8:	2201      	movs	r2, #1
 80138ba:	60da      	str	r2, [r3, #12]

  return TRUE;
 80138bc:	2301      	movs	r3, #1
}
 80138be:	4618      	mov	r0, r3
 80138c0:	3710      	adds	r7, #16
 80138c2:	46bd      	mov	sp, r7
 80138c4:	bd80      	pop	{r7, pc}

080138c6 <get_sof>:

LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_baseline, boolean is_prog,
	 boolean is_arith)
/* Process a SOFn marker */
{
 80138c6:	b580      	push	{r7, lr}
 80138c8:	b08e      	sub	sp, #56	; 0x38
 80138ca:	af00      	add	r7, sp, #0
 80138cc:	60f8      	str	r0, [r7, #12]
 80138ce:	60b9      	str	r1, [r7, #8]
 80138d0:	607a      	str	r2, [r7, #4]
 80138d2:	603b      	str	r3, [r7, #0]
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 80138d4:	68fb      	ldr	r3, [r7, #12]
 80138d6:	699b      	ldr	r3, [r3, #24]
 80138d8:	627b      	str	r3, [r7, #36]	; 0x24
 80138da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80138dc:	681b      	ldr	r3, [r3, #0]
 80138de:	62fb      	str	r3, [r7, #44]	; 0x2c
 80138e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80138e2:	685b      	ldr	r3, [r3, #4]
 80138e4:	62bb      	str	r3, [r7, #40]	; 0x28

  cinfo->is_baseline = is_baseline;
 80138e6:	68fb      	ldr	r3, [r7, #12]
 80138e8:	68ba      	ldr	r2, [r7, #8]
 80138ea:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
  cinfo->progressive_mode = is_prog;
 80138ee:	68fb      	ldr	r3, [r7, #12]
 80138f0:	687a      	ldr	r2, [r7, #4]
 80138f2:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  cinfo->arith_code = is_arith;
 80138f6:	68fb      	ldr	r3, [r7, #12]
 80138f8:	683a      	ldr	r2, [r7, #0]
 80138fa:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4

  INPUT_2BYTES(cinfo, length, return FALSE);
 80138fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013900:	2b00      	cmp	r3, #0
 8013902:	d10e      	bne.n	8013922 <get_sof+0x5c>
 8013904:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013906:	68db      	ldr	r3, [r3, #12]
 8013908:	68f8      	ldr	r0, [r7, #12]
 801390a:	4798      	blx	r3
 801390c:	4603      	mov	r3, r0
 801390e:	2b00      	cmp	r3, #0
 8013910:	d101      	bne.n	8013916 <get_sof+0x50>
 8013912:	2300      	movs	r3, #0
 8013914:	e1e7      	b.n	8013ce6 <get_sof+0x420>
 8013916:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013918:	681b      	ldr	r3, [r3, #0]
 801391a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801391c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801391e:	685b      	ldr	r3, [r3, #4]
 8013920:	62bb      	str	r3, [r7, #40]	; 0x28
 8013922:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013924:	3b01      	subs	r3, #1
 8013926:	62bb      	str	r3, [r7, #40]	; 0x28
 8013928:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801392a:	1c5a      	adds	r2, r3, #1
 801392c:	62fa      	str	r2, [r7, #44]	; 0x2c
 801392e:	781b      	ldrb	r3, [r3, #0]
 8013930:	021b      	lsls	r3, r3, #8
 8013932:	623b      	str	r3, [r7, #32]
 8013934:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013936:	2b00      	cmp	r3, #0
 8013938:	d10e      	bne.n	8013958 <get_sof+0x92>
 801393a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801393c:	68db      	ldr	r3, [r3, #12]
 801393e:	68f8      	ldr	r0, [r7, #12]
 8013940:	4798      	blx	r3
 8013942:	4603      	mov	r3, r0
 8013944:	2b00      	cmp	r3, #0
 8013946:	d101      	bne.n	801394c <get_sof+0x86>
 8013948:	2300      	movs	r3, #0
 801394a:	e1cc      	b.n	8013ce6 <get_sof+0x420>
 801394c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801394e:	681b      	ldr	r3, [r3, #0]
 8013950:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013952:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013954:	685b      	ldr	r3, [r3, #4]
 8013956:	62bb      	str	r3, [r7, #40]	; 0x28
 8013958:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801395a:	3b01      	subs	r3, #1
 801395c:	62bb      	str	r3, [r7, #40]	; 0x28
 801395e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013960:	1c5a      	adds	r2, r3, #1
 8013962:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013964:	781b      	ldrb	r3, [r3, #0]
 8013966:	461a      	mov	r2, r3
 8013968:	6a3b      	ldr	r3, [r7, #32]
 801396a:	4413      	add	r3, r2
 801396c:	623b      	str	r3, [r7, #32]

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
 801396e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013970:	2b00      	cmp	r3, #0
 8013972:	d10e      	bne.n	8013992 <get_sof+0xcc>
 8013974:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013976:	68db      	ldr	r3, [r3, #12]
 8013978:	68f8      	ldr	r0, [r7, #12]
 801397a:	4798      	blx	r3
 801397c:	4603      	mov	r3, r0
 801397e:	2b00      	cmp	r3, #0
 8013980:	d101      	bne.n	8013986 <get_sof+0xc0>
 8013982:	2300      	movs	r3, #0
 8013984:	e1af      	b.n	8013ce6 <get_sof+0x420>
 8013986:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013988:	681b      	ldr	r3, [r3, #0]
 801398a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801398c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801398e:	685b      	ldr	r3, [r3, #4]
 8013990:	62bb      	str	r3, [r7, #40]	; 0x28
 8013992:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013994:	3b01      	subs	r3, #1
 8013996:	62bb      	str	r3, [r7, #40]	; 0x28
 8013998:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801399a:	1c5a      	adds	r2, r3, #1
 801399c:	62fa      	str	r2, [r7, #44]	; 0x2c
 801399e:	781b      	ldrb	r3, [r3, #0]
 80139a0:	461a      	mov	r2, r3
 80139a2:	68fb      	ldr	r3, [r7, #12]
 80139a4:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
 80139a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139aa:	2b00      	cmp	r3, #0
 80139ac:	d10e      	bne.n	80139cc <get_sof+0x106>
 80139ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139b0:	68db      	ldr	r3, [r3, #12]
 80139b2:	68f8      	ldr	r0, [r7, #12]
 80139b4:	4798      	blx	r3
 80139b6:	4603      	mov	r3, r0
 80139b8:	2b00      	cmp	r3, #0
 80139ba:	d101      	bne.n	80139c0 <get_sof+0xfa>
 80139bc:	2300      	movs	r3, #0
 80139be:	e192      	b.n	8013ce6 <get_sof+0x420>
 80139c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139c2:	681b      	ldr	r3, [r3, #0]
 80139c4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80139c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139c8:	685b      	ldr	r3, [r3, #4]
 80139ca:	62bb      	str	r3, [r7, #40]	; 0x28
 80139cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139ce:	3b01      	subs	r3, #1
 80139d0:	62bb      	str	r3, [r7, #40]	; 0x28
 80139d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80139d4:	1c5a      	adds	r2, r3, #1
 80139d6:	62fa      	str	r2, [r7, #44]	; 0x2c
 80139d8:	781b      	ldrb	r3, [r3, #0]
 80139da:	021a      	lsls	r2, r3, #8
 80139dc:	68fb      	ldr	r3, [r7, #12]
 80139de:	621a      	str	r2, [r3, #32]
 80139e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80139e2:	2b00      	cmp	r3, #0
 80139e4:	d10e      	bne.n	8013a04 <get_sof+0x13e>
 80139e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139e8:	68db      	ldr	r3, [r3, #12]
 80139ea:	68f8      	ldr	r0, [r7, #12]
 80139ec:	4798      	blx	r3
 80139ee:	4603      	mov	r3, r0
 80139f0:	2b00      	cmp	r3, #0
 80139f2:	d101      	bne.n	80139f8 <get_sof+0x132>
 80139f4:	2300      	movs	r3, #0
 80139f6:	e176      	b.n	8013ce6 <get_sof+0x420>
 80139f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139fa:	681b      	ldr	r3, [r3, #0]
 80139fc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80139fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a00:	685b      	ldr	r3, [r3, #4]
 8013a02:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a06:	3b01      	subs	r3, #1
 8013a08:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013a0c:	1c5a      	adds	r2, r3, #1
 8013a0e:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013a10:	781a      	ldrb	r2, [r3, #0]
 8013a12:	68fb      	ldr	r3, [r7, #12]
 8013a14:	6a1b      	ldr	r3, [r3, #32]
 8013a16:	441a      	add	r2, r3
 8013a18:	68fb      	ldr	r3, [r7, #12]
 8013a1a:	621a      	str	r2, [r3, #32]
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
 8013a1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a1e:	2b00      	cmp	r3, #0
 8013a20:	d10e      	bne.n	8013a40 <get_sof+0x17a>
 8013a22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a24:	68db      	ldr	r3, [r3, #12]
 8013a26:	68f8      	ldr	r0, [r7, #12]
 8013a28:	4798      	blx	r3
 8013a2a:	4603      	mov	r3, r0
 8013a2c:	2b00      	cmp	r3, #0
 8013a2e:	d101      	bne.n	8013a34 <get_sof+0x16e>
 8013a30:	2300      	movs	r3, #0
 8013a32:	e158      	b.n	8013ce6 <get_sof+0x420>
 8013a34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a36:	681b      	ldr	r3, [r3, #0]
 8013a38:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013a3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a3c:	685b      	ldr	r3, [r3, #4]
 8013a3e:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a42:	3b01      	subs	r3, #1
 8013a44:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013a48:	1c5a      	adds	r2, r3, #1
 8013a4a:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013a4c:	781b      	ldrb	r3, [r3, #0]
 8013a4e:	021a      	lsls	r2, r3, #8
 8013a50:	68fb      	ldr	r3, [r7, #12]
 8013a52:	61da      	str	r2, [r3, #28]
 8013a54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a56:	2b00      	cmp	r3, #0
 8013a58:	d10e      	bne.n	8013a78 <get_sof+0x1b2>
 8013a5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a5c:	68db      	ldr	r3, [r3, #12]
 8013a5e:	68f8      	ldr	r0, [r7, #12]
 8013a60:	4798      	blx	r3
 8013a62:	4603      	mov	r3, r0
 8013a64:	2b00      	cmp	r3, #0
 8013a66:	d101      	bne.n	8013a6c <get_sof+0x1a6>
 8013a68:	2300      	movs	r3, #0
 8013a6a:	e13c      	b.n	8013ce6 <get_sof+0x420>
 8013a6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a6e:	681b      	ldr	r3, [r3, #0]
 8013a70:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013a72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a74:	685b      	ldr	r3, [r3, #4]
 8013a76:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a7a:	3b01      	subs	r3, #1
 8013a7c:	62bb      	str	r3, [r7, #40]	; 0x28
 8013a7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013a80:	1c5a      	adds	r2, r3, #1
 8013a82:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013a84:	781a      	ldrb	r2, [r3, #0]
 8013a86:	68fb      	ldr	r3, [r7, #12]
 8013a88:	69db      	ldr	r3, [r3, #28]
 8013a8a:	441a      	add	r2, r3
 8013a8c:	68fb      	ldr	r3, [r7, #12]
 8013a8e:	61da      	str	r2, [r3, #28]
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
 8013a90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a92:	2b00      	cmp	r3, #0
 8013a94:	d10e      	bne.n	8013ab4 <get_sof+0x1ee>
 8013a96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a98:	68db      	ldr	r3, [r3, #12]
 8013a9a:	68f8      	ldr	r0, [r7, #12]
 8013a9c:	4798      	blx	r3
 8013a9e:	4603      	mov	r3, r0
 8013aa0:	2b00      	cmp	r3, #0
 8013aa2:	d101      	bne.n	8013aa8 <get_sof+0x1e2>
 8013aa4:	2300      	movs	r3, #0
 8013aa6:	e11e      	b.n	8013ce6 <get_sof+0x420>
 8013aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013aaa:	681b      	ldr	r3, [r3, #0]
 8013aac:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013aae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013ab0:	685b      	ldr	r3, [r3, #4]
 8013ab2:	62bb      	str	r3, [r7, #40]	; 0x28
 8013ab4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ab6:	3b01      	subs	r3, #1
 8013ab8:	62bb      	str	r3, [r7, #40]	; 0x28
 8013aba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013abc:	1c5a      	adds	r2, r3, #1
 8013abe:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013ac0:	781b      	ldrb	r3, [r3, #0]
 8013ac2:	461a      	mov	r2, r3
 8013ac4:	68fb      	ldr	r3, [r7, #12]
 8013ac6:	625a      	str	r2, [r3, #36]	; 0x24

  length -= 8;
 8013ac8:	6a3b      	ldr	r3, [r7, #32]
 8013aca:	3b08      	subs	r3, #8
 8013acc:	623b      	str	r3, [r7, #32]

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
 8013ace:	68fb      	ldr	r3, [r7, #12]
 8013ad0:	681b      	ldr	r3, [r3, #0]
 8013ad2:	3318      	adds	r3, #24
 8013ad4:	61fb      	str	r3, [r7, #28]
 8013ad6:	68fb      	ldr	r3, [r7, #12]
 8013ad8:	f8d3 21b4 	ldr.w	r2, [r3, #436]	; 0x1b4
 8013adc:	69fb      	ldr	r3, [r7, #28]
 8013ade:	601a      	str	r2, [r3, #0]
 8013ae0:	68fb      	ldr	r3, [r7, #12]
 8013ae2:	69da      	ldr	r2, [r3, #28]
 8013ae4:	69fb      	ldr	r3, [r7, #28]
 8013ae6:	3304      	adds	r3, #4
 8013ae8:	601a      	str	r2, [r3, #0]
 8013aea:	68fb      	ldr	r3, [r7, #12]
 8013aec:	6a1a      	ldr	r2, [r3, #32]
 8013aee:	69fb      	ldr	r3, [r7, #28]
 8013af0:	3308      	adds	r3, #8
 8013af2:	601a      	str	r2, [r3, #0]
 8013af4:	69fb      	ldr	r3, [r7, #28]
 8013af6:	330c      	adds	r3, #12
 8013af8:	68fa      	ldr	r2, [r7, #12]
 8013afa:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8013afc:	601a      	str	r2, [r3, #0]
 8013afe:	68fb      	ldr	r3, [r7, #12]
 8013b00:	681b      	ldr	r3, [r3, #0]
 8013b02:	2266      	movs	r2, #102	; 0x66
 8013b04:	615a      	str	r2, [r3, #20]
 8013b06:	68fb      	ldr	r3, [r7, #12]
 8013b08:	681b      	ldr	r3, [r3, #0]
 8013b0a:	685b      	ldr	r3, [r3, #4]
 8013b0c:	2101      	movs	r1, #1
 8013b0e:	68f8      	ldr	r0, [r7, #12]
 8013b10:	4798      	blx	r3
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
 8013b12:	68fb      	ldr	r3, [r7, #12]
 8013b14:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8013b18:	691b      	ldr	r3, [r3, #16]
 8013b1a:	2b00      	cmp	r3, #0
 8013b1c:	d008      	beq.n	8013b30 <get_sof+0x26a>
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);
 8013b1e:	68fb      	ldr	r3, [r7, #12]
 8013b20:	681b      	ldr	r3, [r3, #0]
 8013b22:	223c      	movs	r2, #60	; 0x3c
 8013b24:	615a      	str	r2, [r3, #20]
 8013b26:	68fb      	ldr	r3, [r7, #12]
 8013b28:	681b      	ldr	r3, [r3, #0]
 8013b2a:	681b      	ldr	r3, [r3, #0]
 8013b2c:	68f8      	ldr	r0, [r7, #12]
 8013b2e:	4798      	blx	r3

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
 8013b30:	68fb      	ldr	r3, [r7, #12]
 8013b32:	6a1b      	ldr	r3, [r3, #32]
 8013b34:	2b00      	cmp	r3, #0
 8013b36:	d007      	beq.n	8013b48 <get_sof+0x282>
 8013b38:	68fb      	ldr	r3, [r7, #12]
 8013b3a:	69db      	ldr	r3, [r3, #28]
 8013b3c:	2b00      	cmp	r3, #0
 8013b3e:	d003      	beq.n	8013b48 <get_sof+0x282>
      || cinfo->num_components <= 0)
 8013b40:	68fb      	ldr	r3, [r7, #12]
 8013b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013b44:	2b00      	cmp	r3, #0
 8013b46:	dc08      	bgt.n	8013b5a <get_sof+0x294>
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);
 8013b48:	68fb      	ldr	r3, [r7, #12]
 8013b4a:	681b      	ldr	r3, [r3, #0]
 8013b4c:	2221      	movs	r2, #33	; 0x21
 8013b4e:	615a      	str	r2, [r3, #20]
 8013b50:	68fb      	ldr	r3, [r7, #12]
 8013b52:	681b      	ldr	r3, [r3, #0]
 8013b54:	681b      	ldr	r3, [r3, #0]
 8013b56:	68f8      	ldr	r0, [r7, #12]
 8013b58:	4798      	blx	r3

  if (length != (cinfo->num_components * 3))
 8013b5a:	68fb      	ldr	r3, [r7, #12]
 8013b5c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8013b5e:	4613      	mov	r3, r2
 8013b60:	005b      	lsls	r3, r3, #1
 8013b62:	4413      	add	r3, r2
 8013b64:	6a3a      	ldr	r2, [r7, #32]
 8013b66:	429a      	cmp	r2, r3
 8013b68:	d008      	beq.n	8013b7c <get_sof+0x2b6>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8013b6a:	68fb      	ldr	r3, [r7, #12]
 8013b6c:	681b      	ldr	r3, [r3, #0]
 8013b6e:	220c      	movs	r2, #12
 8013b70:	615a      	str	r2, [r3, #20]
 8013b72:	68fb      	ldr	r3, [r7, #12]
 8013b74:	681b      	ldr	r3, [r3, #0]
 8013b76:	681b      	ldr	r3, [r3, #0]
 8013b78:	68f8      	ldr	r0, [r7, #12]
 8013b7a:	4798      	blx	r3

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
 8013b7c:	68fb      	ldr	r3, [r7, #12]
 8013b7e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013b82:	2b00      	cmp	r3, #0
 8013b84:	d10f      	bne.n	8013ba6 <get_sof+0x2e0>
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 8013b86:	68fb      	ldr	r3, [r7, #12]
 8013b88:	685b      	ldr	r3, [r3, #4]
 8013b8a:	681b      	ldr	r3, [r3, #0]
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));
 8013b8c:	68fa      	ldr	r2, [r7, #12]
 8013b8e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8013b90:	4611      	mov	r1, r2
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
 8013b92:	2258      	movs	r2, #88	; 0x58
 8013b94:	fb02 f201 	mul.w	r2, r2, r1
 8013b98:	2101      	movs	r1, #1
 8013b9a:	68f8      	ldr	r0, [r7, #12]
 8013b9c:	4798      	blx	r3
 8013b9e:	4602      	mov	r2, r0
 8013ba0:	68fb      	ldr	r3, [r7, #12]
 8013ba2:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013ba6:	2300      	movs	r3, #0
 8013ba8:	637b      	str	r3, [r7, #52]	; 0x34
 8013baa:	68fb      	ldr	r3, [r7, #12]
 8013bac:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013bb0:	633b      	str	r3, [r7, #48]	; 0x30
 8013bb2:	e086      	b.n	8013cc2 <get_sof+0x3fc>
       ci++, compptr++) {
    compptr->component_index = ci;
 8013bb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013bb6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013bb8:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
 8013bba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013bbc:	2b00      	cmp	r3, #0
 8013bbe:	d10e      	bne.n	8013bde <get_sof+0x318>
 8013bc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013bc2:	68db      	ldr	r3, [r3, #12]
 8013bc4:	68f8      	ldr	r0, [r7, #12]
 8013bc6:	4798      	blx	r3
 8013bc8:	4603      	mov	r3, r0
 8013bca:	2b00      	cmp	r3, #0
 8013bcc:	d101      	bne.n	8013bd2 <get_sof+0x30c>
 8013bce:	2300      	movs	r3, #0
 8013bd0:	e089      	b.n	8013ce6 <get_sof+0x420>
 8013bd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013bd4:	681b      	ldr	r3, [r3, #0]
 8013bd6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013bd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013bda:	685b      	ldr	r3, [r3, #4]
 8013bdc:	62bb      	str	r3, [r7, #40]	; 0x28
 8013bde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013be0:	3b01      	subs	r3, #1
 8013be2:	62bb      	str	r3, [r7, #40]	; 0x28
 8013be4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013be6:	1c5a      	adds	r2, r3, #1
 8013be8:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013bea:	781b      	ldrb	r3, [r3, #0]
 8013bec:	461a      	mov	r2, r3
 8013bee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013bf0:	601a      	str	r2, [r3, #0]
    INPUT_BYTE(cinfo, c, return FALSE);
 8013bf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013bf4:	2b00      	cmp	r3, #0
 8013bf6:	d10e      	bne.n	8013c16 <get_sof+0x350>
 8013bf8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013bfa:	68db      	ldr	r3, [r3, #12]
 8013bfc:	68f8      	ldr	r0, [r7, #12]
 8013bfe:	4798      	blx	r3
 8013c00:	4603      	mov	r3, r0
 8013c02:	2b00      	cmp	r3, #0
 8013c04:	d101      	bne.n	8013c0a <get_sof+0x344>
 8013c06:	2300      	movs	r3, #0
 8013c08:	e06d      	b.n	8013ce6 <get_sof+0x420>
 8013c0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c0c:	681b      	ldr	r3, [r3, #0]
 8013c0e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013c10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c12:	685b      	ldr	r3, [r3, #4]
 8013c14:	62bb      	str	r3, [r7, #40]	; 0x28
 8013c16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013c18:	3b01      	subs	r3, #1
 8013c1a:	62bb      	str	r3, [r7, #40]	; 0x28
 8013c1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013c1e:	1c5a      	adds	r2, r3, #1
 8013c20:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013c22:	781b      	ldrb	r3, [r3, #0]
 8013c24:	61bb      	str	r3, [r7, #24]
    compptr->h_samp_factor = (c >> 4) & 15;
 8013c26:	69bb      	ldr	r3, [r7, #24]
 8013c28:	111b      	asrs	r3, r3, #4
 8013c2a:	f003 020f 	and.w	r2, r3, #15
 8013c2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013c30:	609a      	str	r2, [r3, #8]
    compptr->v_samp_factor = (c     ) & 15;
 8013c32:	69bb      	ldr	r3, [r7, #24]
 8013c34:	f003 020f 	and.w	r2, r3, #15
 8013c38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013c3a:	60da      	str	r2, [r3, #12]
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
 8013c3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013c3e:	2b00      	cmp	r3, #0
 8013c40:	d10e      	bne.n	8013c60 <get_sof+0x39a>
 8013c42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c44:	68db      	ldr	r3, [r3, #12]
 8013c46:	68f8      	ldr	r0, [r7, #12]
 8013c48:	4798      	blx	r3
 8013c4a:	4603      	mov	r3, r0
 8013c4c:	2b00      	cmp	r3, #0
 8013c4e:	d101      	bne.n	8013c54 <get_sof+0x38e>
 8013c50:	2300      	movs	r3, #0
 8013c52:	e048      	b.n	8013ce6 <get_sof+0x420>
 8013c54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c56:	681b      	ldr	r3, [r3, #0]
 8013c58:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013c5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c5c:	685b      	ldr	r3, [r3, #4]
 8013c5e:	62bb      	str	r3, [r7, #40]	; 0x28
 8013c60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013c62:	3b01      	subs	r3, #1
 8013c64:	62bb      	str	r3, [r7, #40]	; 0x28
 8013c66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013c68:	1c5a      	adds	r2, r3, #1
 8013c6a:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013c6c:	781b      	ldrb	r3, [r3, #0]
 8013c6e:	461a      	mov	r2, r3
 8013c70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013c72:	611a      	str	r2, [r3, #16]

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
 8013c74:	68fb      	ldr	r3, [r7, #12]
 8013c76:	681b      	ldr	r3, [r3, #0]
 8013c78:	3318      	adds	r3, #24
 8013c7a:	617b      	str	r3, [r7, #20]
 8013c7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013c7e:	681a      	ldr	r2, [r3, #0]
 8013c80:	697b      	ldr	r3, [r7, #20]
 8013c82:	601a      	str	r2, [r3, #0]
 8013c84:	697b      	ldr	r3, [r7, #20]
 8013c86:	3304      	adds	r3, #4
 8013c88:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013c8a:	6892      	ldr	r2, [r2, #8]
 8013c8c:	601a      	str	r2, [r3, #0]
 8013c8e:	697b      	ldr	r3, [r7, #20]
 8013c90:	3308      	adds	r3, #8
 8013c92:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013c94:	68d2      	ldr	r2, [r2, #12]
 8013c96:	601a      	str	r2, [r3, #0]
 8013c98:	697b      	ldr	r3, [r7, #20]
 8013c9a:	330c      	adds	r3, #12
 8013c9c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013c9e:	6912      	ldr	r2, [r2, #16]
 8013ca0:	601a      	str	r2, [r3, #0]
 8013ca2:	68fb      	ldr	r3, [r7, #12]
 8013ca4:	681b      	ldr	r3, [r3, #0]
 8013ca6:	2267      	movs	r2, #103	; 0x67
 8013ca8:	615a      	str	r2, [r3, #20]
 8013caa:	68fb      	ldr	r3, [r7, #12]
 8013cac:	681b      	ldr	r3, [r3, #0]
 8013cae:	685b      	ldr	r3, [r3, #4]
 8013cb0:	2101      	movs	r1, #1
 8013cb2:	68f8      	ldr	r0, [r7, #12]
 8013cb4:	4798      	blx	r3
       ci++, compptr++) {
 8013cb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013cb8:	3301      	adds	r3, #1
 8013cba:	637b      	str	r3, [r7, #52]	; 0x34
 8013cbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013cbe:	3358      	adds	r3, #88	; 0x58
 8013cc0:	633b      	str	r3, [r7, #48]	; 0x30
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013cc2:	68fb      	ldr	r3, [r7, #12]
 8013cc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013cc6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013cc8:	429a      	cmp	r2, r3
 8013cca:	f6ff af73 	blt.w	8013bb4 <get_sof+0x2ee>
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;
 8013cce:	68fb      	ldr	r3, [r7, #12]
 8013cd0:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8013cd4:	2201      	movs	r2, #1
 8013cd6:	611a      	str	r2, [r3, #16]

  INPUT_SYNC(cinfo);
 8013cd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013cda:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013cdc:	601a      	str	r2, [r3, #0]
 8013cde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013ce0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013ce2:	605a      	str	r2, [r3, #4]
  return TRUE;
 8013ce4:	2301      	movs	r3, #1
}
 8013ce6:	4618      	mov	r0, r3
 8013ce8:	3738      	adds	r7, #56	; 0x38
 8013cea:	46bd      	mov	sp, r7
 8013cec:	bd80      	pop	{r7, pc}

08013cee <get_sos>:


LOCAL(boolean)
get_sos (j_decompress_ptr cinfo)
/* Process a SOS marker */
{
 8013cee:	b580      	push	{r7, lr}
 8013cf0:	b08e      	sub	sp, #56	; 0x38
 8013cf2:	af00      	add	r7, sp, #0
 8013cf4:	6078      	str	r0, [r7, #4]
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
 8013cf6:	687b      	ldr	r3, [r7, #4]
 8013cf8:	699b      	ldr	r3, [r3, #24]
 8013cfa:	623b      	str	r3, [r7, #32]
 8013cfc:	6a3b      	ldr	r3, [r7, #32]
 8013cfe:	681b      	ldr	r3, [r3, #0]
 8013d00:	62bb      	str	r3, [r7, #40]	; 0x28
 8013d02:	6a3b      	ldr	r3, [r7, #32]
 8013d04:	685b      	ldr	r3, [r3, #4]
 8013d06:	627b      	str	r3, [r7, #36]	; 0x24

  if (! cinfo->marker->saw_SOF)
 8013d08:	687b      	ldr	r3, [r7, #4]
 8013d0a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8013d0e:	691b      	ldr	r3, [r3, #16]
 8013d10:	2b00      	cmp	r3, #0
 8013d12:	d108      	bne.n	8013d26 <get_sos+0x38>
    ERREXIT(cinfo, JERR_SOS_NO_SOF);
 8013d14:	687b      	ldr	r3, [r7, #4]
 8013d16:	681b      	ldr	r3, [r3, #0]
 8013d18:	2240      	movs	r2, #64	; 0x40
 8013d1a:	615a      	str	r2, [r3, #20]
 8013d1c:	687b      	ldr	r3, [r7, #4]
 8013d1e:	681b      	ldr	r3, [r3, #0]
 8013d20:	681b      	ldr	r3, [r3, #0]
 8013d22:	6878      	ldr	r0, [r7, #4]
 8013d24:	4798      	blx	r3

  INPUT_2BYTES(cinfo, length, return FALSE);
 8013d26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013d28:	2b00      	cmp	r3, #0
 8013d2a:	d10e      	bne.n	8013d4a <get_sos+0x5c>
 8013d2c:	6a3b      	ldr	r3, [r7, #32]
 8013d2e:	68db      	ldr	r3, [r3, #12]
 8013d30:	6878      	ldr	r0, [r7, #4]
 8013d32:	4798      	blx	r3
 8013d34:	4603      	mov	r3, r0
 8013d36:	2b00      	cmp	r3, #0
 8013d38:	d101      	bne.n	8013d3e <get_sos+0x50>
 8013d3a:	2300      	movs	r3, #0
 8013d3c:	e1a1      	b.n	8014082 <get_sos+0x394>
 8013d3e:	6a3b      	ldr	r3, [r7, #32]
 8013d40:	681b      	ldr	r3, [r3, #0]
 8013d42:	62bb      	str	r3, [r7, #40]	; 0x28
 8013d44:	6a3b      	ldr	r3, [r7, #32]
 8013d46:	685b      	ldr	r3, [r3, #4]
 8013d48:	627b      	str	r3, [r7, #36]	; 0x24
 8013d4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013d4c:	3b01      	subs	r3, #1
 8013d4e:	627b      	str	r3, [r7, #36]	; 0x24
 8013d50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013d52:	1c5a      	adds	r2, r3, #1
 8013d54:	62ba      	str	r2, [r7, #40]	; 0x28
 8013d56:	781b      	ldrb	r3, [r3, #0]
 8013d58:	021b      	lsls	r3, r3, #8
 8013d5a:	61fb      	str	r3, [r7, #28]
 8013d5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013d5e:	2b00      	cmp	r3, #0
 8013d60:	d10e      	bne.n	8013d80 <get_sos+0x92>
 8013d62:	6a3b      	ldr	r3, [r7, #32]
 8013d64:	68db      	ldr	r3, [r3, #12]
 8013d66:	6878      	ldr	r0, [r7, #4]
 8013d68:	4798      	blx	r3
 8013d6a:	4603      	mov	r3, r0
 8013d6c:	2b00      	cmp	r3, #0
 8013d6e:	d101      	bne.n	8013d74 <get_sos+0x86>
 8013d70:	2300      	movs	r3, #0
 8013d72:	e186      	b.n	8014082 <get_sos+0x394>
 8013d74:	6a3b      	ldr	r3, [r7, #32]
 8013d76:	681b      	ldr	r3, [r3, #0]
 8013d78:	62bb      	str	r3, [r7, #40]	; 0x28
 8013d7a:	6a3b      	ldr	r3, [r7, #32]
 8013d7c:	685b      	ldr	r3, [r3, #4]
 8013d7e:	627b      	str	r3, [r7, #36]	; 0x24
 8013d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013d82:	3b01      	subs	r3, #1
 8013d84:	627b      	str	r3, [r7, #36]	; 0x24
 8013d86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013d88:	1c5a      	adds	r2, r3, #1
 8013d8a:	62ba      	str	r2, [r7, #40]	; 0x28
 8013d8c:	781b      	ldrb	r3, [r3, #0]
 8013d8e:	461a      	mov	r2, r3
 8013d90:	69fb      	ldr	r3, [r7, #28]
 8013d92:	4413      	add	r3, r2
 8013d94:	61fb      	str	r3, [r7, #28]

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
 8013d96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013d98:	2b00      	cmp	r3, #0
 8013d9a:	d10e      	bne.n	8013dba <get_sos+0xcc>
 8013d9c:	6a3b      	ldr	r3, [r7, #32]
 8013d9e:	68db      	ldr	r3, [r3, #12]
 8013da0:	6878      	ldr	r0, [r7, #4]
 8013da2:	4798      	blx	r3
 8013da4:	4603      	mov	r3, r0
 8013da6:	2b00      	cmp	r3, #0
 8013da8:	d101      	bne.n	8013dae <get_sos+0xc0>
 8013daa:	2300      	movs	r3, #0
 8013dac:	e169      	b.n	8014082 <get_sos+0x394>
 8013dae:	6a3b      	ldr	r3, [r7, #32]
 8013db0:	681b      	ldr	r3, [r3, #0]
 8013db2:	62bb      	str	r3, [r7, #40]	; 0x28
 8013db4:	6a3b      	ldr	r3, [r7, #32]
 8013db6:	685b      	ldr	r3, [r3, #4]
 8013db8:	627b      	str	r3, [r7, #36]	; 0x24
 8013dba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013dbc:	3b01      	subs	r3, #1
 8013dbe:	627b      	str	r3, [r7, #36]	; 0x24
 8013dc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013dc2:	1c5a      	adds	r2, r3, #1
 8013dc4:	62ba      	str	r2, [r7, #40]	; 0x28
 8013dc6:	781b      	ldrb	r3, [r3, #0]
 8013dc8:	61bb      	str	r3, [r7, #24]

  TRACEMS1(cinfo, 1, JTRC_SOS, n);
 8013dca:	687b      	ldr	r3, [r7, #4]
 8013dcc:	681b      	ldr	r3, [r3, #0]
 8013dce:	2269      	movs	r2, #105	; 0x69
 8013dd0:	615a      	str	r2, [r3, #20]
 8013dd2:	687b      	ldr	r3, [r7, #4]
 8013dd4:	681b      	ldr	r3, [r3, #0]
 8013dd6:	69ba      	ldr	r2, [r7, #24]
 8013dd8:	619a      	str	r2, [r3, #24]
 8013dda:	687b      	ldr	r3, [r7, #4]
 8013ddc:	681b      	ldr	r3, [r3, #0]
 8013dde:	685b      	ldr	r3, [r3, #4]
 8013de0:	2101      	movs	r1, #1
 8013de2:	6878      	ldr	r0, [r7, #4]
 8013de4:	4798      	blx	r3

  if (length != (n * 2 + 6) || n > MAX_COMPS_IN_SCAN ||
 8013de6:	69bb      	ldr	r3, [r7, #24]
 8013de8:	3303      	adds	r3, #3
 8013dea:	005b      	lsls	r3, r3, #1
 8013dec:	69fa      	ldr	r2, [r7, #28]
 8013dee:	429a      	cmp	r2, r3
 8013df0:	d10a      	bne.n	8013e08 <get_sos+0x11a>
 8013df2:	69bb      	ldr	r3, [r7, #24]
 8013df4:	2b04      	cmp	r3, #4
 8013df6:	dc07      	bgt.n	8013e08 <get_sos+0x11a>
 8013df8:	69bb      	ldr	r3, [r7, #24]
 8013dfa:	2b00      	cmp	r3, #0
 8013dfc:	d10d      	bne.n	8013e1a <get_sos+0x12c>
      (n == 0 && !cinfo->progressive_mode))
 8013dfe:	687b      	ldr	r3, [r7, #4]
 8013e00:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8013e04:	2b00      	cmp	r3, #0
 8013e06:	d108      	bne.n	8013e1a <get_sos+0x12c>
      /* pseudo SOS marker only allowed in progressive mode */
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8013e08:	687b      	ldr	r3, [r7, #4]
 8013e0a:	681b      	ldr	r3, [r3, #0]
 8013e0c:	220c      	movs	r2, #12
 8013e0e:	615a      	str	r2, [r3, #20]
 8013e10:	687b      	ldr	r3, [r7, #4]
 8013e12:	681b      	ldr	r3, [r3, #0]
 8013e14:	681b      	ldr	r3, [r3, #0]
 8013e16:	6878      	ldr	r0, [r7, #4]
 8013e18:	4798      	blx	r3

  cinfo->comps_in_scan = n;
 8013e1a:	687b      	ldr	r3, [r7, #4]
 8013e1c:	69ba      	ldr	r2, [r7, #24]
 8013e1e:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
 8013e22:	2300      	movs	r3, #0
 8013e24:	637b      	str	r3, [r7, #52]	; 0x34
 8013e26:	e089      	b.n	8013f3c <get_sos+0x24e>
    INPUT_BYTE(cinfo, cc, return FALSE);
 8013e28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e2a:	2b00      	cmp	r3, #0
 8013e2c:	d10e      	bne.n	8013e4c <get_sos+0x15e>
 8013e2e:	6a3b      	ldr	r3, [r7, #32]
 8013e30:	68db      	ldr	r3, [r3, #12]
 8013e32:	6878      	ldr	r0, [r7, #4]
 8013e34:	4798      	blx	r3
 8013e36:	4603      	mov	r3, r0
 8013e38:	2b00      	cmp	r3, #0
 8013e3a:	d101      	bne.n	8013e40 <get_sos+0x152>
 8013e3c:	2300      	movs	r3, #0
 8013e3e:	e120      	b.n	8014082 <get_sos+0x394>
 8013e40:	6a3b      	ldr	r3, [r7, #32]
 8013e42:	681b      	ldr	r3, [r3, #0]
 8013e44:	62bb      	str	r3, [r7, #40]	; 0x28
 8013e46:	6a3b      	ldr	r3, [r7, #32]
 8013e48:	685b      	ldr	r3, [r3, #4]
 8013e4a:	627b      	str	r3, [r7, #36]	; 0x24
 8013e4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e4e:	3b01      	subs	r3, #1
 8013e50:	627b      	str	r3, [r7, #36]	; 0x24
 8013e52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013e54:	1c5a      	adds	r2, r3, #1
 8013e56:	62ba      	str	r2, [r7, #40]	; 0x28
 8013e58:	781b      	ldrb	r3, [r3, #0]
 8013e5a:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, c, return FALSE);
 8013e5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e5e:	2b00      	cmp	r3, #0
 8013e60:	d10e      	bne.n	8013e80 <get_sos+0x192>
 8013e62:	6a3b      	ldr	r3, [r7, #32]
 8013e64:	68db      	ldr	r3, [r3, #12]
 8013e66:	6878      	ldr	r0, [r7, #4]
 8013e68:	4798      	blx	r3
 8013e6a:	4603      	mov	r3, r0
 8013e6c:	2b00      	cmp	r3, #0
 8013e6e:	d101      	bne.n	8013e74 <get_sos+0x186>
 8013e70:	2300      	movs	r3, #0
 8013e72:	e106      	b.n	8014082 <get_sos+0x394>
 8013e74:	6a3b      	ldr	r3, [r7, #32]
 8013e76:	681b      	ldr	r3, [r3, #0]
 8013e78:	62bb      	str	r3, [r7, #40]	; 0x28
 8013e7a:	6a3b      	ldr	r3, [r7, #32]
 8013e7c:	685b      	ldr	r3, [r3, #4]
 8013e7e:	627b      	str	r3, [r7, #36]	; 0x24
 8013e80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013e82:	3b01      	subs	r3, #1
 8013e84:	627b      	str	r3, [r7, #36]	; 0x24
 8013e86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013e88:	1c5a      	adds	r2, r3, #1
 8013e8a:	62ba      	str	r2, [r7, #40]	; 0x28
 8013e8c:	781b      	ldrb	r3, [r3, #0]
 8013e8e:	617b      	str	r3, [r7, #20]
    
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013e90:	2300      	movs	r3, #0
 8013e92:	633b      	str	r3, [r7, #48]	; 0x30
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8013e9a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013e9c:	e00a      	b.n	8013eb4 <get_sos+0x1c6>
	 ci++, compptr++) {
      if (cc == compptr->component_id)
 8013e9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013ea0:	681b      	ldr	r3, [r3, #0]
 8013ea2:	68fa      	ldr	r2, [r7, #12]
 8013ea4:	429a      	cmp	r2, r3
 8013ea6:	d018      	beq.n	8013eda <get_sos+0x1ec>
	 ci++, compptr++) {
 8013ea8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013eaa:	3301      	adds	r3, #1
 8013eac:	633b      	str	r3, [r7, #48]	; 0x30
 8013eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013eb0:	3358      	adds	r3, #88	; 0x58
 8013eb2:	62fb      	str	r3, [r7, #44]	; 0x2c
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8013eb4:	687b      	ldr	r3, [r7, #4]
 8013eb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013eb8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013eba:	429a      	cmp	r2, r3
 8013ebc:	dbef      	blt.n	8013e9e <get_sos+0x1b0>
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
 8013ebe:	687b      	ldr	r3, [r7, #4]
 8013ec0:	681b      	ldr	r3, [r3, #0]
 8013ec2:	2204      	movs	r2, #4
 8013ec4:	615a      	str	r2, [r3, #20]
 8013ec6:	687b      	ldr	r3, [r7, #4]
 8013ec8:	681b      	ldr	r3, [r3, #0]
 8013eca:	68fa      	ldr	r2, [r7, #12]
 8013ecc:	619a      	str	r2, [r3, #24]
 8013ece:	687b      	ldr	r3, [r7, #4]
 8013ed0:	681b      	ldr	r3, [r3, #0]
 8013ed2:	681b      	ldr	r3, [r3, #0]
 8013ed4:	6878      	ldr	r0, [r7, #4]
 8013ed6:	4798      	blx	r3
 8013ed8:	e000      	b.n	8013edc <get_sos+0x1ee>
	goto id_found;
 8013eda:	bf00      	nop

  id_found:

    cinfo->cur_comp_info[i] = compptr;
 8013edc:	687a      	ldr	r2, [r7, #4]
 8013ede:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013ee0:	3354      	adds	r3, #84	; 0x54
 8013ee2:	009b      	lsls	r3, r3, #2
 8013ee4:	4413      	add	r3, r2
 8013ee6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013ee8:	605a      	str	r2, [r3, #4]
    compptr->dc_tbl_no = (c >> 4) & 15;
 8013eea:	697b      	ldr	r3, [r7, #20]
 8013eec:	111b      	asrs	r3, r3, #4
 8013eee:	f003 020f 	and.w	r2, r3, #15
 8013ef2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013ef4:	615a      	str	r2, [r3, #20]
    compptr->ac_tbl_no = (c     ) & 15;
 8013ef6:	697b      	ldr	r3, [r7, #20]
 8013ef8:	f003 020f 	and.w	r2, r3, #15
 8013efc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013efe:	619a      	str	r2, [r3, #24]
    
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
 8013f00:	687b      	ldr	r3, [r7, #4]
 8013f02:	681b      	ldr	r3, [r3, #0]
 8013f04:	3318      	adds	r3, #24
 8013f06:	60bb      	str	r3, [r7, #8]
 8013f08:	68bb      	ldr	r3, [r7, #8]
 8013f0a:	68fa      	ldr	r2, [r7, #12]
 8013f0c:	601a      	str	r2, [r3, #0]
 8013f0e:	68bb      	ldr	r3, [r7, #8]
 8013f10:	3304      	adds	r3, #4
 8013f12:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013f14:	6952      	ldr	r2, [r2, #20]
 8013f16:	601a      	str	r2, [r3, #0]
 8013f18:	68bb      	ldr	r3, [r7, #8]
 8013f1a:	3308      	adds	r3, #8
 8013f1c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013f1e:	6992      	ldr	r2, [r2, #24]
 8013f20:	601a      	str	r2, [r3, #0]
 8013f22:	687b      	ldr	r3, [r7, #4]
 8013f24:	681b      	ldr	r3, [r3, #0]
 8013f26:	226a      	movs	r2, #106	; 0x6a
 8013f28:	615a      	str	r2, [r3, #20]
 8013f2a:	687b      	ldr	r3, [r7, #4]
 8013f2c:	681b      	ldr	r3, [r3, #0]
 8013f2e:	685b      	ldr	r3, [r3, #4]
 8013f30:	2101      	movs	r1, #1
 8013f32:	6878      	ldr	r0, [r7, #4]
 8013f34:	4798      	blx	r3
  for (i = 0; i < n; i++) {
 8013f36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f38:	3301      	adds	r3, #1
 8013f3a:	637b      	str	r3, [r7, #52]	; 0x34
 8013f3c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013f3e:	69bb      	ldr	r3, [r7, #24]
 8013f40:	429a      	cmp	r2, r3
 8013f42:	f6ff af71 	blt.w	8013e28 <get_sos+0x13a>
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
 8013f46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013f48:	2b00      	cmp	r3, #0
 8013f4a:	d10e      	bne.n	8013f6a <get_sos+0x27c>
 8013f4c:	6a3b      	ldr	r3, [r7, #32]
 8013f4e:	68db      	ldr	r3, [r3, #12]
 8013f50:	6878      	ldr	r0, [r7, #4]
 8013f52:	4798      	blx	r3
 8013f54:	4603      	mov	r3, r0
 8013f56:	2b00      	cmp	r3, #0
 8013f58:	d101      	bne.n	8013f5e <get_sos+0x270>
 8013f5a:	2300      	movs	r3, #0
 8013f5c:	e091      	b.n	8014082 <get_sos+0x394>
 8013f5e:	6a3b      	ldr	r3, [r7, #32]
 8013f60:	681b      	ldr	r3, [r3, #0]
 8013f62:	62bb      	str	r3, [r7, #40]	; 0x28
 8013f64:	6a3b      	ldr	r3, [r7, #32]
 8013f66:	685b      	ldr	r3, [r3, #4]
 8013f68:	627b      	str	r3, [r7, #36]	; 0x24
 8013f6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013f6c:	3b01      	subs	r3, #1
 8013f6e:	627b      	str	r3, [r7, #36]	; 0x24
 8013f70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013f72:	1c5a      	adds	r2, r3, #1
 8013f74:	62ba      	str	r2, [r7, #40]	; 0x28
 8013f76:	781b      	ldrb	r3, [r3, #0]
 8013f78:	617b      	str	r3, [r7, #20]
  cinfo->Ss = c;
 8013f7a:	687b      	ldr	r3, [r7, #4]
 8013f7c:	697a      	ldr	r2, [r7, #20]
 8013f7e:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
  INPUT_BYTE(cinfo, c, return FALSE);
 8013f82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013f84:	2b00      	cmp	r3, #0
 8013f86:	d10e      	bne.n	8013fa6 <get_sos+0x2b8>
 8013f88:	6a3b      	ldr	r3, [r7, #32]
 8013f8a:	68db      	ldr	r3, [r3, #12]
 8013f8c:	6878      	ldr	r0, [r7, #4]
 8013f8e:	4798      	blx	r3
 8013f90:	4603      	mov	r3, r0
 8013f92:	2b00      	cmp	r3, #0
 8013f94:	d101      	bne.n	8013f9a <get_sos+0x2ac>
 8013f96:	2300      	movs	r3, #0
 8013f98:	e073      	b.n	8014082 <get_sos+0x394>
 8013f9a:	6a3b      	ldr	r3, [r7, #32]
 8013f9c:	681b      	ldr	r3, [r3, #0]
 8013f9e:	62bb      	str	r3, [r7, #40]	; 0x28
 8013fa0:	6a3b      	ldr	r3, [r7, #32]
 8013fa2:	685b      	ldr	r3, [r3, #4]
 8013fa4:	627b      	str	r3, [r7, #36]	; 0x24
 8013fa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013fa8:	3b01      	subs	r3, #1
 8013faa:	627b      	str	r3, [r7, #36]	; 0x24
 8013fac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013fae:	1c5a      	adds	r2, r3, #1
 8013fb0:	62ba      	str	r2, [r7, #40]	; 0x28
 8013fb2:	781b      	ldrb	r3, [r3, #0]
 8013fb4:	617b      	str	r3, [r7, #20]
  cinfo->Se = c;
 8013fb6:	687b      	ldr	r3, [r7, #4]
 8013fb8:	697a      	ldr	r2, [r7, #20]
 8013fba:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
  INPUT_BYTE(cinfo, c, return FALSE);
 8013fbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013fc0:	2b00      	cmp	r3, #0
 8013fc2:	d10e      	bne.n	8013fe2 <get_sos+0x2f4>
 8013fc4:	6a3b      	ldr	r3, [r7, #32]
 8013fc6:	68db      	ldr	r3, [r3, #12]
 8013fc8:	6878      	ldr	r0, [r7, #4]
 8013fca:	4798      	blx	r3
 8013fcc:	4603      	mov	r3, r0
 8013fce:	2b00      	cmp	r3, #0
 8013fd0:	d101      	bne.n	8013fd6 <get_sos+0x2e8>
 8013fd2:	2300      	movs	r3, #0
 8013fd4:	e055      	b.n	8014082 <get_sos+0x394>
 8013fd6:	6a3b      	ldr	r3, [r7, #32]
 8013fd8:	681b      	ldr	r3, [r3, #0]
 8013fda:	62bb      	str	r3, [r7, #40]	; 0x28
 8013fdc:	6a3b      	ldr	r3, [r7, #32]
 8013fde:	685b      	ldr	r3, [r3, #4]
 8013fe0:	627b      	str	r3, [r7, #36]	; 0x24
 8013fe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013fe4:	3b01      	subs	r3, #1
 8013fe6:	627b      	str	r3, [r7, #36]	; 0x24
 8013fe8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013fea:	1c5a      	adds	r2, r3, #1
 8013fec:	62ba      	str	r2, [r7, #40]	; 0x28
 8013fee:	781b      	ldrb	r3, [r3, #0]
 8013ff0:	617b      	str	r3, [r7, #20]
  cinfo->Ah = (c >> 4) & 15;
 8013ff2:	697b      	ldr	r3, [r7, #20]
 8013ff4:	111b      	asrs	r3, r3, #4
 8013ff6:	f003 020f 	and.w	r2, r3, #15
 8013ffa:	687b      	ldr	r3, [r7, #4]
 8013ffc:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
  cinfo->Al = (c     ) & 15;
 8014000:	697b      	ldr	r3, [r7, #20]
 8014002:	f003 020f 	and.w	r2, r3, #15
 8014006:	687b      	ldr	r3, [r7, #4]
 8014008:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
 801400c:	687b      	ldr	r3, [r7, #4]
 801400e:	681b      	ldr	r3, [r3, #0]
 8014010:	3318      	adds	r3, #24
 8014012:	613b      	str	r3, [r7, #16]
 8014014:	687b      	ldr	r3, [r7, #4]
 8014016:	f8d3 2198 	ldr.w	r2, [r3, #408]	; 0x198
 801401a:	693b      	ldr	r3, [r7, #16]
 801401c:	601a      	str	r2, [r3, #0]
 801401e:	693b      	ldr	r3, [r7, #16]
 8014020:	3304      	adds	r3, #4
 8014022:	687a      	ldr	r2, [r7, #4]
 8014024:	f8d2 219c 	ldr.w	r2, [r2, #412]	; 0x19c
 8014028:	601a      	str	r2, [r3, #0]
 801402a:	693b      	ldr	r3, [r7, #16]
 801402c:	3308      	adds	r3, #8
 801402e:	687a      	ldr	r2, [r7, #4]
 8014030:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
 8014034:	601a      	str	r2, [r3, #0]
 8014036:	693b      	ldr	r3, [r7, #16]
 8014038:	330c      	adds	r3, #12
 801403a:	687a      	ldr	r2, [r7, #4]
 801403c:	f8d2 21a4 	ldr.w	r2, [r2, #420]	; 0x1a4
 8014040:	601a      	str	r2, [r3, #0]
 8014042:	687b      	ldr	r3, [r7, #4]
 8014044:	681b      	ldr	r3, [r3, #0]
 8014046:	226b      	movs	r2, #107	; 0x6b
 8014048:	615a      	str	r2, [r3, #20]
 801404a:	687b      	ldr	r3, [r7, #4]
 801404c:	681b      	ldr	r3, [r3, #0]
 801404e:	685b      	ldr	r3, [r3, #4]
 8014050:	2101      	movs	r1, #1
 8014052:	6878      	ldr	r0, [r7, #4]
 8014054:	4798      	blx	r3
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;
 8014056:	687b      	ldr	r3, [r7, #4]
 8014058:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801405c:	2200      	movs	r2, #0
 801405e:	615a      	str	r2, [r3, #20]

  /* Count another (non-pseudo) SOS marker */
  if (n) cinfo->input_scan_number++;
 8014060:	69bb      	ldr	r3, [r7, #24]
 8014062:	2b00      	cmp	r3, #0
 8014064:	d006      	beq.n	8014074 <get_sos+0x386>
 8014066:	687b      	ldr	r3, [r7, #4]
 8014068:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801406c:	1c5a      	adds	r2, r3, #1
 801406e:	687b      	ldr	r3, [r7, #4]
 8014070:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  INPUT_SYNC(cinfo);
 8014074:	6a3b      	ldr	r3, [r7, #32]
 8014076:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014078:	601a      	str	r2, [r3, #0]
 801407a:	6a3b      	ldr	r3, [r7, #32]
 801407c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801407e:	605a      	str	r2, [r3, #4]
  return TRUE;
 8014080:	2301      	movs	r3, #1
}
 8014082:	4618      	mov	r0, r3
 8014084:	3738      	adds	r7, #56	; 0x38
 8014086:	46bd      	mov	sp, r7
 8014088:	bd80      	pop	{r7, pc}

0801408a <get_dac>:
#ifdef D_ARITH_CODING_SUPPORTED

LOCAL(boolean)
get_dac (j_decompress_ptr cinfo)
/* Process a DAC marker */
{
 801408a:	b580      	push	{r7, lr}
 801408c:	b088      	sub	sp, #32
 801408e:	af00      	add	r7, sp, #0
 8014090:	6078      	str	r0, [r7, #4]
  INT32 length;
  int index, val;
  INPUT_VARS(cinfo);
 8014092:	687b      	ldr	r3, [r7, #4]
 8014094:	699b      	ldr	r3, [r3, #24]
 8014096:	613b      	str	r3, [r7, #16]
 8014098:	693b      	ldr	r3, [r7, #16]
 801409a:	681b      	ldr	r3, [r3, #0]
 801409c:	61bb      	str	r3, [r7, #24]
 801409e:	693b      	ldr	r3, [r7, #16]
 80140a0:	685b      	ldr	r3, [r3, #4]
 80140a2:	617b      	str	r3, [r7, #20]

  INPUT_2BYTES(cinfo, length, return FALSE);
 80140a4:	697b      	ldr	r3, [r7, #20]
 80140a6:	2b00      	cmp	r3, #0
 80140a8:	d10e      	bne.n	80140c8 <get_dac+0x3e>
 80140aa:	693b      	ldr	r3, [r7, #16]
 80140ac:	68db      	ldr	r3, [r3, #12]
 80140ae:	6878      	ldr	r0, [r7, #4]
 80140b0:	4798      	blx	r3
 80140b2:	4603      	mov	r3, r0
 80140b4:	2b00      	cmp	r3, #0
 80140b6:	d101      	bne.n	80140bc <get_dac+0x32>
 80140b8:	2300      	movs	r3, #0
 80140ba:	e0dc      	b.n	8014276 <get_dac+0x1ec>
 80140bc:	693b      	ldr	r3, [r7, #16]
 80140be:	681b      	ldr	r3, [r3, #0]
 80140c0:	61bb      	str	r3, [r7, #24]
 80140c2:	693b      	ldr	r3, [r7, #16]
 80140c4:	685b      	ldr	r3, [r3, #4]
 80140c6:	617b      	str	r3, [r7, #20]
 80140c8:	697b      	ldr	r3, [r7, #20]
 80140ca:	3b01      	subs	r3, #1
 80140cc:	617b      	str	r3, [r7, #20]
 80140ce:	69bb      	ldr	r3, [r7, #24]
 80140d0:	1c5a      	adds	r2, r3, #1
 80140d2:	61ba      	str	r2, [r7, #24]
 80140d4:	781b      	ldrb	r3, [r3, #0]
 80140d6:	021b      	lsls	r3, r3, #8
 80140d8:	61fb      	str	r3, [r7, #28]
 80140da:	697b      	ldr	r3, [r7, #20]
 80140dc:	2b00      	cmp	r3, #0
 80140de:	d10e      	bne.n	80140fe <get_dac+0x74>
 80140e0:	693b      	ldr	r3, [r7, #16]
 80140e2:	68db      	ldr	r3, [r3, #12]
 80140e4:	6878      	ldr	r0, [r7, #4]
 80140e6:	4798      	blx	r3
 80140e8:	4603      	mov	r3, r0
 80140ea:	2b00      	cmp	r3, #0
 80140ec:	d101      	bne.n	80140f2 <get_dac+0x68>
 80140ee:	2300      	movs	r3, #0
 80140f0:	e0c1      	b.n	8014276 <get_dac+0x1ec>
 80140f2:	693b      	ldr	r3, [r7, #16]
 80140f4:	681b      	ldr	r3, [r3, #0]
 80140f6:	61bb      	str	r3, [r7, #24]
 80140f8:	693b      	ldr	r3, [r7, #16]
 80140fa:	685b      	ldr	r3, [r3, #4]
 80140fc:	617b      	str	r3, [r7, #20]
 80140fe:	697b      	ldr	r3, [r7, #20]
 8014100:	3b01      	subs	r3, #1
 8014102:	617b      	str	r3, [r7, #20]
 8014104:	69bb      	ldr	r3, [r7, #24]
 8014106:	1c5a      	adds	r2, r3, #1
 8014108:	61ba      	str	r2, [r7, #24]
 801410a:	781b      	ldrb	r3, [r3, #0]
 801410c:	461a      	mov	r2, r3
 801410e:	69fb      	ldr	r3, [r7, #28]
 8014110:	4413      	add	r3, r2
 8014112:	61fb      	str	r3, [r7, #28]
  length -= 2;
 8014114:	69fb      	ldr	r3, [r7, #28]
 8014116:	3b02      	subs	r3, #2
 8014118:	61fb      	str	r3, [r7, #28]
  
  while (length > 0) {
 801411a:	e095      	b.n	8014248 <get_dac+0x1be>
    INPUT_BYTE(cinfo, index, return FALSE);
 801411c:	697b      	ldr	r3, [r7, #20]
 801411e:	2b00      	cmp	r3, #0
 8014120:	d10e      	bne.n	8014140 <get_dac+0xb6>
 8014122:	693b      	ldr	r3, [r7, #16]
 8014124:	68db      	ldr	r3, [r3, #12]
 8014126:	6878      	ldr	r0, [r7, #4]
 8014128:	4798      	blx	r3
 801412a:	4603      	mov	r3, r0
 801412c:	2b00      	cmp	r3, #0
 801412e:	d101      	bne.n	8014134 <get_dac+0xaa>
 8014130:	2300      	movs	r3, #0
 8014132:	e0a0      	b.n	8014276 <get_dac+0x1ec>
 8014134:	693b      	ldr	r3, [r7, #16]
 8014136:	681b      	ldr	r3, [r3, #0]
 8014138:	61bb      	str	r3, [r7, #24]
 801413a:	693b      	ldr	r3, [r7, #16]
 801413c:	685b      	ldr	r3, [r3, #4]
 801413e:	617b      	str	r3, [r7, #20]
 8014140:	697b      	ldr	r3, [r7, #20]
 8014142:	3b01      	subs	r3, #1
 8014144:	617b      	str	r3, [r7, #20]
 8014146:	69bb      	ldr	r3, [r7, #24]
 8014148:	1c5a      	adds	r2, r3, #1
 801414a:	61ba      	str	r2, [r7, #24]
 801414c:	781b      	ldrb	r3, [r3, #0]
 801414e:	60fb      	str	r3, [r7, #12]
    INPUT_BYTE(cinfo, val, return FALSE);
 8014150:	697b      	ldr	r3, [r7, #20]
 8014152:	2b00      	cmp	r3, #0
 8014154:	d10e      	bne.n	8014174 <get_dac+0xea>
 8014156:	693b      	ldr	r3, [r7, #16]
 8014158:	68db      	ldr	r3, [r3, #12]
 801415a:	6878      	ldr	r0, [r7, #4]
 801415c:	4798      	blx	r3
 801415e:	4603      	mov	r3, r0
 8014160:	2b00      	cmp	r3, #0
 8014162:	d101      	bne.n	8014168 <get_dac+0xde>
 8014164:	2300      	movs	r3, #0
 8014166:	e086      	b.n	8014276 <get_dac+0x1ec>
 8014168:	693b      	ldr	r3, [r7, #16]
 801416a:	681b      	ldr	r3, [r3, #0]
 801416c:	61bb      	str	r3, [r7, #24]
 801416e:	693b      	ldr	r3, [r7, #16]
 8014170:	685b      	ldr	r3, [r3, #4]
 8014172:	617b      	str	r3, [r7, #20]
 8014174:	697b      	ldr	r3, [r7, #20]
 8014176:	3b01      	subs	r3, #1
 8014178:	617b      	str	r3, [r7, #20]
 801417a:	69bb      	ldr	r3, [r7, #24]
 801417c:	1c5a      	adds	r2, r3, #1
 801417e:	61ba      	str	r2, [r7, #24]
 8014180:	781b      	ldrb	r3, [r3, #0]
 8014182:	60bb      	str	r3, [r7, #8]

    length -= 2;
 8014184:	69fb      	ldr	r3, [r7, #28]
 8014186:	3b02      	subs	r3, #2
 8014188:	61fb      	str	r3, [r7, #28]

    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);
 801418a:	687b      	ldr	r3, [r7, #4]
 801418c:	681b      	ldr	r3, [r3, #0]
 801418e:	2251      	movs	r2, #81	; 0x51
 8014190:	615a      	str	r2, [r3, #20]
 8014192:	687b      	ldr	r3, [r7, #4]
 8014194:	681b      	ldr	r3, [r3, #0]
 8014196:	68fa      	ldr	r2, [r7, #12]
 8014198:	619a      	str	r2, [r3, #24]
 801419a:	687b      	ldr	r3, [r7, #4]
 801419c:	681b      	ldr	r3, [r3, #0]
 801419e:	68ba      	ldr	r2, [r7, #8]
 80141a0:	61da      	str	r2, [r3, #28]
 80141a2:	687b      	ldr	r3, [r7, #4]
 80141a4:	681b      	ldr	r3, [r3, #0]
 80141a6:	685b      	ldr	r3, [r3, #4]
 80141a8:	2101      	movs	r1, #1
 80141aa:	6878      	ldr	r0, [r7, #4]
 80141ac:	4798      	blx	r3

    if (index < 0 || index >= (2*NUM_ARITH_TBLS))
 80141ae:	68fb      	ldr	r3, [r7, #12]
 80141b0:	2b00      	cmp	r3, #0
 80141b2:	db02      	blt.n	80141ba <get_dac+0x130>
 80141b4:	68fb      	ldr	r3, [r7, #12]
 80141b6:	2b1f      	cmp	r3, #31
 80141b8:	dd0c      	ble.n	80141d4 <get_dac+0x14a>
      ERREXIT1(cinfo, JERR_DAC_INDEX, index);
 80141ba:	687b      	ldr	r3, [r7, #4]
 80141bc:	681b      	ldr	r3, [r3, #0]
 80141be:	221d      	movs	r2, #29
 80141c0:	615a      	str	r2, [r3, #20]
 80141c2:	687b      	ldr	r3, [r7, #4]
 80141c4:	681b      	ldr	r3, [r3, #0]
 80141c6:	68fa      	ldr	r2, [r7, #12]
 80141c8:	619a      	str	r2, [r3, #24]
 80141ca:	687b      	ldr	r3, [r7, #4]
 80141cc:	681b      	ldr	r3, [r3, #0]
 80141ce:	681b      	ldr	r3, [r3, #0]
 80141d0:	6878      	ldr	r0, [r7, #4]
 80141d2:	4798      	blx	r3

    if (index >= NUM_ARITH_TBLS) { /* define AC table */
 80141d4:	68fb      	ldr	r3, [r7, #12]
 80141d6:	2b0f      	cmp	r3, #15
 80141d8:	dd09      	ble.n	80141ee <get_dac+0x164>
      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
 80141da:	68fb      	ldr	r3, [r7, #12]
 80141dc:	3b10      	subs	r3, #16
 80141de:	68ba      	ldr	r2, [r7, #8]
 80141e0:	b2d1      	uxtb	r1, r2
 80141e2:	687a      	ldr	r2, [r7, #4]
 80141e4:	4413      	add	r3, r2
 80141e6:	460a      	mov	r2, r1
 80141e8:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
 80141ec:	e02c      	b.n	8014248 <get_dac+0x1be>
    } else {			/* define DC table */
      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
 80141ee:	68bb      	ldr	r3, [r7, #8]
 80141f0:	b2db      	uxtb	r3, r3
 80141f2:	f003 030f 	and.w	r3, r3, #15
 80141f6:	b2d9      	uxtb	r1, r3
 80141f8:	687a      	ldr	r2, [r7, #4]
 80141fa:	68fb      	ldr	r3, [r7, #12]
 80141fc:	4413      	add	r3, r2
 80141fe:	33e8      	adds	r3, #232	; 0xe8
 8014200:	460a      	mov	r2, r1
 8014202:	701a      	strb	r2, [r3, #0]
      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
 8014204:	68bb      	ldr	r3, [r7, #8]
 8014206:	111b      	asrs	r3, r3, #4
 8014208:	b2d9      	uxtb	r1, r3
 801420a:	687a      	ldr	r2, [r7, #4]
 801420c:	68fb      	ldr	r3, [r7, #12]
 801420e:	4413      	add	r3, r2
 8014210:	33f8      	adds	r3, #248	; 0xf8
 8014212:	460a      	mov	r2, r1
 8014214:	701a      	strb	r2, [r3, #0]
      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
 8014216:	687a      	ldr	r2, [r7, #4]
 8014218:	68fb      	ldr	r3, [r7, #12]
 801421a:	4413      	add	r3, r2
 801421c:	33e8      	adds	r3, #232	; 0xe8
 801421e:	781a      	ldrb	r2, [r3, #0]
 8014220:	6879      	ldr	r1, [r7, #4]
 8014222:	68fb      	ldr	r3, [r7, #12]
 8014224:	440b      	add	r3, r1
 8014226:	33f8      	adds	r3, #248	; 0xf8
 8014228:	781b      	ldrb	r3, [r3, #0]
 801422a:	429a      	cmp	r2, r3
 801422c:	d90c      	bls.n	8014248 <get_dac+0x1be>
	ERREXIT1(cinfo, JERR_DAC_VALUE, val);
 801422e:	687b      	ldr	r3, [r7, #4]
 8014230:	681b      	ldr	r3, [r3, #0]
 8014232:	221e      	movs	r2, #30
 8014234:	615a      	str	r2, [r3, #20]
 8014236:	687b      	ldr	r3, [r7, #4]
 8014238:	681b      	ldr	r3, [r3, #0]
 801423a:	68ba      	ldr	r2, [r7, #8]
 801423c:	619a      	str	r2, [r3, #24]
 801423e:	687b      	ldr	r3, [r7, #4]
 8014240:	681b      	ldr	r3, [r3, #0]
 8014242:	681b      	ldr	r3, [r3, #0]
 8014244:	6878      	ldr	r0, [r7, #4]
 8014246:	4798      	blx	r3
  while (length > 0) {
 8014248:	69fb      	ldr	r3, [r7, #28]
 801424a:	2b00      	cmp	r3, #0
 801424c:	f73f af66 	bgt.w	801411c <get_dac+0x92>
    }
  }

  if (length != 0)
 8014250:	69fb      	ldr	r3, [r7, #28]
 8014252:	2b00      	cmp	r3, #0
 8014254:	d008      	beq.n	8014268 <get_dac+0x1de>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8014256:	687b      	ldr	r3, [r7, #4]
 8014258:	681b      	ldr	r3, [r3, #0]
 801425a:	220c      	movs	r2, #12
 801425c:	615a      	str	r2, [r3, #20]
 801425e:	687b      	ldr	r3, [r7, #4]
 8014260:	681b      	ldr	r3, [r3, #0]
 8014262:	681b      	ldr	r3, [r3, #0]
 8014264:	6878      	ldr	r0, [r7, #4]
 8014266:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 8014268:	693b      	ldr	r3, [r7, #16]
 801426a:	69ba      	ldr	r2, [r7, #24]
 801426c:	601a      	str	r2, [r3, #0]
 801426e:	693b      	ldr	r3, [r7, #16]
 8014270:	697a      	ldr	r2, [r7, #20]
 8014272:	605a      	str	r2, [r3, #4]
  return TRUE;
 8014274:	2301      	movs	r3, #1
}
 8014276:	4618      	mov	r0, r3
 8014278:	3720      	adds	r7, #32
 801427a:	46bd      	mov	sp, r7
 801427c:	bd80      	pop	{r7, pc}

0801427e <get_dht>:


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
 801427e:	b5b0      	push	{r4, r5, r7, lr}
 8014280:	b0d2      	sub	sp, #328	; 0x148
 8014282:	af00      	add	r7, sp, #0
 8014284:	1d3b      	adds	r3, r7, #4
 8014286:	6018      	str	r0, [r3, #0]
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);
 8014288:	1d3b      	adds	r3, r7, #4
 801428a:	681b      	ldr	r3, [r3, #0]
 801428c:	699b      	ldr	r3, [r3, #24]
 801428e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8014292:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014296:	681b      	ldr	r3, [r3, #0]
 8014298:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 801429c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80142a0:	685b      	ldr	r3, [r3, #4]
 80142a2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c

  INPUT_2BYTES(cinfo, length, return FALSE);
 80142a6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80142aa:	2b00      	cmp	r3, #0
 80142ac:	d114      	bne.n	80142d8 <get_dht+0x5a>
 80142ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80142b2:	68db      	ldr	r3, [r3, #12]
 80142b4:	1d3a      	adds	r2, r7, #4
 80142b6:	6810      	ldr	r0, [r2, #0]
 80142b8:	4798      	blx	r3
 80142ba:	4603      	mov	r3, r0
 80142bc:	2b00      	cmp	r3, #0
 80142be:	d101      	bne.n	80142c4 <get_dht+0x46>
 80142c0:	2300      	movs	r3, #0
 80142c2:	e22f      	b.n	8014724 <get_dht+0x4a6>
 80142c4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80142c8:	681b      	ldr	r3, [r3, #0]
 80142ca:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 80142ce:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80142d2:	685b      	ldr	r3, [r3, #4]
 80142d4:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 80142d8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80142dc:	3b01      	subs	r3, #1
 80142de:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 80142e2:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80142e6:	1c5a      	adds	r2, r3, #1
 80142e8:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
 80142ec:	781b      	ldrb	r3, [r3, #0]
 80142ee:	021b      	lsls	r3, r3, #8
 80142f0:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
 80142f4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80142f8:	2b00      	cmp	r3, #0
 80142fa:	d114      	bne.n	8014326 <get_dht+0xa8>
 80142fc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014300:	68db      	ldr	r3, [r3, #12]
 8014302:	1d3a      	adds	r2, r7, #4
 8014304:	6810      	ldr	r0, [r2, #0]
 8014306:	4798      	blx	r3
 8014308:	4603      	mov	r3, r0
 801430a:	2b00      	cmp	r3, #0
 801430c:	d101      	bne.n	8014312 <get_dht+0x94>
 801430e:	2300      	movs	r3, #0
 8014310:	e208      	b.n	8014724 <get_dht+0x4a6>
 8014312:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014316:	681b      	ldr	r3, [r3, #0]
 8014318:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 801431c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014320:	685b      	ldr	r3, [r3, #4]
 8014322:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8014326:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801432a:	3b01      	subs	r3, #1
 801432c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8014330:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8014334:	1c5a      	adds	r2, r3, #1
 8014336:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
 801433a:	781b      	ldrb	r3, [r3, #0]
 801433c:	461a      	mov	r2, r3
 801433e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8014342:	4413      	add	r3, r2
 8014344:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  length -= 2;
 8014348:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801434c:	3b02      	subs	r3, #2
 801434e:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  
  while (length > 16) {
 8014352:	e1c7      	b.n	80146e4 <get_dht+0x466>
    INPUT_BYTE(cinfo, index, return FALSE);
 8014354:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8014358:	2b00      	cmp	r3, #0
 801435a:	d114      	bne.n	8014386 <get_dht+0x108>
 801435c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014360:	68db      	ldr	r3, [r3, #12]
 8014362:	1d3a      	adds	r2, r7, #4
 8014364:	6810      	ldr	r0, [r2, #0]
 8014366:	4798      	blx	r3
 8014368:	4603      	mov	r3, r0
 801436a:	2b00      	cmp	r3, #0
 801436c:	d101      	bne.n	8014372 <get_dht+0xf4>
 801436e:	2300      	movs	r3, #0
 8014370:	e1d8      	b.n	8014724 <get_dht+0x4a6>
 8014372:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014376:	681b      	ldr	r3, [r3, #0]
 8014378:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 801437c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014380:	685b      	ldr	r3, [r3, #4]
 8014382:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8014386:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801438a:	3b01      	subs	r3, #1
 801438c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8014390:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8014394:	1c5a      	adds	r2, r3, #1
 8014396:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
 801439a:	781b      	ldrb	r3, [r3, #0]
 801439c:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
 80143a0:	1d3b      	adds	r3, r7, #4
 80143a2:	681b      	ldr	r3, [r3, #0]
 80143a4:	681b      	ldr	r3, [r3, #0]
 80143a6:	2252      	movs	r2, #82	; 0x52
 80143a8:	615a      	str	r2, [r3, #20]
 80143aa:	1d3b      	adds	r3, r7, #4
 80143ac:	681b      	ldr	r3, [r3, #0]
 80143ae:	681b      	ldr	r3, [r3, #0]
 80143b0:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80143b4:	619a      	str	r2, [r3, #24]
 80143b6:	1d3b      	adds	r3, r7, #4
 80143b8:	681b      	ldr	r3, [r3, #0]
 80143ba:	681b      	ldr	r3, [r3, #0]
 80143bc:	685b      	ldr	r3, [r3, #4]
 80143be:	1d3a      	adds	r2, r7, #4
 80143c0:	2101      	movs	r1, #1
 80143c2:	6810      	ldr	r0, [r2, #0]
 80143c4:	4798      	blx	r3
      
    bits[0] = 0;
 80143c6:	2300      	movs	r3, #0
 80143c8:	f887 310c 	strb.w	r3, [r7, #268]	; 0x10c
    count = 0;
 80143cc:	2300      	movs	r3, #0
 80143ce:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    for (i = 1; i <= 16; i++) {
 80143d2:	2301      	movs	r3, #1
 80143d4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 80143d8:	e03b      	b.n	8014452 <get_dht+0x1d4>
      INPUT_BYTE(cinfo, bits[i], return FALSE);
 80143da:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80143de:	2b00      	cmp	r3, #0
 80143e0:	d114      	bne.n	801440c <get_dht+0x18e>
 80143e2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80143e6:	68db      	ldr	r3, [r3, #12]
 80143e8:	1d3a      	adds	r2, r7, #4
 80143ea:	6810      	ldr	r0, [r2, #0]
 80143ec:	4798      	blx	r3
 80143ee:	4603      	mov	r3, r0
 80143f0:	2b00      	cmp	r3, #0
 80143f2:	d101      	bne.n	80143f8 <get_dht+0x17a>
 80143f4:	2300      	movs	r3, #0
 80143f6:	e195      	b.n	8014724 <get_dht+0x4a6>
 80143f8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80143fc:	681b      	ldr	r3, [r3, #0]
 80143fe:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 8014402:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014406:	685b      	ldr	r3, [r3, #4]
 8014408:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 801440c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8014410:	3b01      	subs	r3, #1
 8014412:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8014416:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801441a:	1c5a      	adds	r2, r3, #1
 801441c:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
 8014420:	7819      	ldrb	r1, [r3, #0]
 8014422:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8014426:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801442a:	4413      	add	r3, r2
 801442c:	460a      	mov	r2, r1
 801442e:	701a      	strb	r2, [r3, #0]
      count += bits[i];
 8014430:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8014434:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8014438:	4413      	add	r3, r2
 801443a:	781b      	ldrb	r3, [r3, #0]
 801443c:	461a      	mov	r2, r3
 801443e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8014442:	4413      	add	r3, r2
 8014444:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    for (i = 1; i <= 16; i++) {
 8014448:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801444c:	3301      	adds	r3, #1
 801444e:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 8014452:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8014456:	2b10      	cmp	r3, #16
 8014458:	ddbf      	ble.n	80143da <get_dht+0x15c>
    }

    length -= 1 + 16;
 801445a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801445e:	3b11      	subs	r3, #17
 8014460:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 8014464:	1d3b      	adds	r3, r7, #4
 8014466:	681b      	ldr	r3, [r3, #0]
 8014468:	681b      	ldr	r3, [r3, #0]
 801446a:	3318      	adds	r3, #24
 801446c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 8014470:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8014474:	461a      	mov	r2, r3
 8014476:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801447a:	601a      	str	r2, [r3, #0]
 801447c:	f897 210e 	ldrb.w	r2, [r7, #270]	; 0x10e
 8014480:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8014484:	3304      	adds	r3, #4
 8014486:	601a      	str	r2, [r3, #0]
 8014488:	f897 210f 	ldrb.w	r2, [r7, #271]	; 0x10f
 801448c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8014490:	3308      	adds	r3, #8
 8014492:	601a      	str	r2, [r3, #0]
 8014494:	f897 2110 	ldrb.w	r2, [r7, #272]	; 0x110
 8014498:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801449c:	330c      	adds	r3, #12
 801449e:	601a      	str	r2, [r3, #0]
 80144a0:	f897 2111 	ldrb.w	r2, [r7, #273]	; 0x111
 80144a4:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80144a8:	3310      	adds	r3, #16
 80144aa:	601a      	str	r2, [r3, #0]
 80144ac:	f897 2112 	ldrb.w	r2, [r7, #274]	; 0x112
 80144b0:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80144b4:	3314      	adds	r3, #20
 80144b6:	601a      	str	r2, [r3, #0]
 80144b8:	f897 2113 	ldrb.w	r2, [r7, #275]	; 0x113
 80144bc:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80144c0:	3318      	adds	r3, #24
 80144c2:	601a      	str	r2, [r3, #0]
 80144c4:	f897 2114 	ldrb.w	r2, [r7, #276]	; 0x114
 80144c8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80144cc:	331c      	adds	r3, #28
 80144ce:	601a      	str	r2, [r3, #0]
 80144d0:	1d3b      	adds	r3, r7, #4
 80144d2:	681b      	ldr	r3, [r3, #0]
 80144d4:	681b      	ldr	r3, [r3, #0]
 80144d6:	2258      	movs	r2, #88	; 0x58
 80144d8:	615a      	str	r2, [r3, #20]
 80144da:	1d3b      	adds	r3, r7, #4
 80144dc:	681b      	ldr	r3, [r3, #0]
 80144de:	681b      	ldr	r3, [r3, #0]
 80144e0:	685b      	ldr	r3, [r3, #4]
 80144e2:	1d3a      	adds	r2, r7, #4
 80144e4:	2102      	movs	r1, #2
 80144e6:	6810      	ldr	r0, [r2, #0]
 80144e8:	4798      	blx	r3
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 80144ea:	1d3b      	adds	r3, r7, #4
 80144ec:	681b      	ldr	r3, [r3, #0]
 80144ee:	681b      	ldr	r3, [r3, #0]
 80144f0:	3318      	adds	r3, #24
 80144f2:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 80144f6:	f897 3115 	ldrb.w	r3, [r7, #277]	; 0x115
 80144fa:	461a      	mov	r2, r3
 80144fc:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8014500:	601a      	str	r2, [r3, #0]
 8014502:	f897 2116 	ldrb.w	r2, [r7, #278]	; 0x116
 8014506:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 801450a:	3304      	adds	r3, #4
 801450c:	601a      	str	r2, [r3, #0]
 801450e:	f897 2117 	ldrb.w	r2, [r7, #279]	; 0x117
 8014512:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8014516:	3308      	adds	r3, #8
 8014518:	601a      	str	r2, [r3, #0]
 801451a:	f897 2118 	ldrb.w	r2, [r7, #280]	; 0x118
 801451e:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8014522:	330c      	adds	r3, #12
 8014524:	601a      	str	r2, [r3, #0]
 8014526:	f897 2119 	ldrb.w	r2, [r7, #281]	; 0x119
 801452a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 801452e:	3310      	adds	r3, #16
 8014530:	601a      	str	r2, [r3, #0]
 8014532:	f897 211a 	ldrb.w	r2, [r7, #282]	; 0x11a
 8014536:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 801453a:	3314      	adds	r3, #20
 801453c:	601a      	str	r2, [r3, #0]
 801453e:	f897 211b 	ldrb.w	r2, [r7, #283]	; 0x11b
 8014542:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8014546:	3318      	adds	r3, #24
 8014548:	601a      	str	r2, [r3, #0]
 801454a:	f897 211c 	ldrb.w	r2, [r7, #284]	; 0x11c
 801454e:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8014552:	331c      	adds	r3, #28
 8014554:	601a      	str	r2, [r3, #0]
 8014556:	1d3b      	adds	r3, r7, #4
 8014558:	681b      	ldr	r3, [r3, #0]
 801455a:	681b      	ldr	r3, [r3, #0]
 801455c:	2258      	movs	r2, #88	; 0x58
 801455e:	615a      	str	r2, [r3, #20]
 8014560:	1d3b      	adds	r3, r7, #4
 8014562:	681b      	ldr	r3, [r3, #0]
 8014564:	681b      	ldr	r3, [r3, #0]
 8014566:	685b      	ldr	r3, [r3, #4]
 8014568:	1d3a      	adds	r2, r7, #4
 801456a:	2102      	movs	r1, #2
 801456c:	6810      	ldr	r0, [r2, #0]
 801456e:	4798      	blx	r3
	     bits[13], bits[14], bits[15], bits[16]);

    /* Here we just do minimal validation of the counts to avoid walking
     * off the end of our table space.  jdhuff.c will check more carefully.
     */
    if (count > 256 || ((INT32) count) > length)
 8014570:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8014574:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8014578:	dc05      	bgt.n	8014586 <get_dht+0x308>
 801457a:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801457e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8014582:	429a      	cmp	r2, r3
 8014584:	dd0b      	ble.n	801459e <get_dht+0x320>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 8014586:	1d3b      	adds	r3, r7, #4
 8014588:	681b      	ldr	r3, [r3, #0]
 801458a:	681b      	ldr	r3, [r3, #0]
 801458c:	2209      	movs	r2, #9
 801458e:	615a      	str	r2, [r3, #20]
 8014590:	1d3b      	adds	r3, r7, #4
 8014592:	681b      	ldr	r3, [r3, #0]
 8014594:	681b      	ldr	r3, [r3, #0]
 8014596:	681b      	ldr	r3, [r3, #0]
 8014598:	1d3a      	adds	r2, r7, #4
 801459a:	6810      	ldr	r0, [r2, #0]
 801459c:	4798      	blx	r3

    for (i = 0; i < count; i++)
 801459e:	2300      	movs	r3, #0
 80145a0:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 80145a4:	e02f      	b.n	8014606 <get_dht+0x388>
      INPUT_BYTE(cinfo, huffval[i], return FALSE);
 80145a6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80145aa:	2b00      	cmp	r3, #0
 80145ac:	d114      	bne.n	80145d8 <get_dht+0x35a>
 80145ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80145b2:	68db      	ldr	r3, [r3, #12]
 80145b4:	1d3a      	adds	r2, r7, #4
 80145b6:	6810      	ldr	r0, [r2, #0]
 80145b8:	4798      	blx	r3
 80145ba:	4603      	mov	r3, r0
 80145bc:	2b00      	cmp	r3, #0
 80145be:	d101      	bne.n	80145c4 <get_dht+0x346>
 80145c0:	2300      	movs	r3, #0
 80145c2:	e0af      	b.n	8014724 <get_dht+0x4a6>
 80145c4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80145c8:	681b      	ldr	r3, [r3, #0]
 80145ca:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 80145ce:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80145d2:	685b      	ldr	r3, [r3, #4]
 80145d4:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 80145d8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80145dc:	3b01      	subs	r3, #1
 80145de:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 80145e2:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80145e6:	1c5a      	adds	r2, r3, #1
 80145e8:	f8c7 2130 	str.w	r2, [r7, #304]	; 0x130
 80145ec:	7819      	ldrb	r1, [r3, #0]
 80145ee:	f107 020c 	add.w	r2, r7, #12
 80145f2:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 80145f6:	4413      	add	r3, r2
 80145f8:	460a      	mov	r2, r1
 80145fa:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < count; i++)
 80145fc:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8014600:	3301      	adds	r3, #1
 8014602:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 8014606:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801460a:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801460e:	429a      	cmp	r2, r3
 8014610:	dbc9      	blt.n	80145a6 <get_dht+0x328>

    length -= count;
 8014612:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 8014616:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801461a:	1ad3      	subs	r3, r2, r3
 801461c:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    if (index & 0x10) {		/* AC table definition */
 8014620:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8014624:	f003 0310 	and.w	r3, r3, #16
 8014628:	2b00      	cmp	r3, #0
 801462a:	d00f      	beq.n	801464c <get_dht+0x3ce>
      index -= 0x10;
 801462c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8014630:	3b10      	subs	r3, #16
 8014632:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
 8014636:	1d3a      	adds	r2, r7, #4
 8014638:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801463c:	3330      	adds	r3, #48	; 0x30
 801463e:	009b      	lsls	r3, r3, #2
 8014640:	6812      	ldr	r2, [r2, #0]
 8014642:	4413      	add	r3, r2
 8014644:	3304      	adds	r3, #4
 8014646:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 801464a:	e009      	b.n	8014660 <get_dht+0x3e2>
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
 801464c:	1d3a      	adds	r2, r7, #4
 801464e:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8014652:	332c      	adds	r3, #44	; 0x2c
 8014654:	009b      	lsls	r3, r3, #2
 8014656:	6812      	ldr	r2, [r2, #0]
 8014658:	4413      	add	r3, r2
 801465a:	3304      	adds	r3, #4
 801465c:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
 8014660:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8014664:	2b00      	cmp	r3, #0
 8014666:	db03      	blt.n	8014670 <get_dht+0x3f2>
 8014668:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801466c:	2b03      	cmp	r3, #3
 801466e:	dd11      	ble.n	8014694 <get_dht+0x416>
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);
 8014670:	1d3b      	adds	r3, r7, #4
 8014672:	681b      	ldr	r3, [r3, #0]
 8014674:	681b      	ldr	r3, [r3, #0]
 8014676:	221f      	movs	r2, #31
 8014678:	615a      	str	r2, [r3, #20]
 801467a:	1d3b      	adds	r3, r7, #4
 801467c:	681b      	ldr	r3, [r3, #0]
 801467e:	681b      	ldr	r3, [r3, #0]
 8014680:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8014684:	619a      	str	r2, [r3, #24]
 8014686:	1d3b      	adds	r3, r7, #4
 8014688:	681b      	ldr	r3, [r3, #0]
 801468a:	681b      	ldr	r3, [r3, #0]
 801468c:	681b      	ldr	r3, [r3, #0]
 801468e:	1d3a      	adds	r2, r7, #4
 8014690:	6810      	ldr	r0, [r2, #0]
 8014692:	4798      	blx	r3

    if (*htblptr == NULL)
 8014694:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8014698:	681b      	ldr	r3, [r3, #0]
 801469a:	2b00      	cmp	r3, #0
 801469c:	d107      	bne.n	80146ae <get_dht+0x430>
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 801469e:	1d3b      	adds	r3, r7, #4
 80146a0:	6818      	ldr	r0, [r3, #0]
 80146a2:	f7f7 fcc0 	bl	800c026 <jpeg_alloc_huff_table>
 80146a6:	4602      	mov	r2, r0
 80146a8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80146ac:	601a      	str	r2, [r3, #0]
  
    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
 80146ae:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80146b2:	681b      	ldr	r3, [r3, #0]
 80146b4:	461d      	mov	r5, r3
 80146b6:	f507 7486 	add.w	r4, r7, #268	; 0x10c
 80146ba:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80146bc:	6028      	str	r0, [r5, #0]
 80146be:	6069      	str	r1, [r5, #4]
 80146c0:	60aa      	str	r2, [r5, #8]
 80146c2:	60eb      	str	r3, [r5, #12]
 80146c4:	7823      	ldrb	r3, [r4, #0]
 80146c6:	742b      	strb	r3, [r5, #16]
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
 80146c8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80146cc:	681b      	ldr	r3, [r3, #0]
 80146ce:	f103 0211 	add.w	r2, r3, #17
 80146d2:	f107 030c 	add.w	r3, r7, #12
 80146d6:	4610      	mov	r0, r2
 80146d8:	4619      	mov	r1, r3
 80146da:	f44f 7380 	mov.w	r3, #256	; 0x100
 80146de:	461a      	mov	r2, r3
 80146e0:	f013 fdc0 	bl	8028264 <memcpy>
  while (length > 16) {
 80146e4:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80146e8:	2b10      	cmp	r3, #16
 80146ea:	f73f ae33 	bgt.w	8014354 <get_dht+0xd6>
  }

  if (length != 0)
 80146ee:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80146f2:	2b00      	cmp	r3, #0
 80146f4:	d00b      	beq.n	801470e <get_dht+0x490>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 80146f6:	1d3b      	adds	r3, r7, #4
 80146f8:	681b      	ldr	r3, [r3, #0]
 80146fa:	681b      	ldr	r3, [r3, #0]
 80146fc:	220c      	movs	r2, #12
 80146fe:	615a      	str	r2, [r3, #20]
 8014700:	1d3b      	adds	r3, r7, #4
 8014702:	681b      	ldr	r3, [r3, #0]
 8014704:	681b      	ldr	r3, [r3, #0]
 8014706:	681b      	ldr	r3, [r3, #0]
 8014708:	1d3a      	adds	r2, r7, #4
 801470a:	6810      	ldr	r0, [r2, #0]
 801470c:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 801470e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8014712:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8014716:	601a      	str	r2, [r3, #0]
 8014718:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801471c:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8014720:	605a      	str	r2, [r3, #4]
  return TRUE;
 8014722:	2301      	movs	r3, #1
}
 8014724:	4618      	mov	r0, r3
 8014726:	f507 77a4 	add.w	r7, r7, #328	; 0x148
 801472a:	46bd      	mov	sp, r7
 801472c:	bdb0      	pop	{r4, r5, r7, pc}
	...

08014730 <get_dqt>:


LOCAL(boolean)
get_dqt (j_decompress_ptr cinfo)
/* Process a DQT marker */
{
 8014730:	b580      	push	{r7, lr}
 8014732:	b08e      	sub	sp, #56	; 0x38
 8014734:	af00      	add	r7, sp, #0
 8014736:	6078      	str	r0, [r7, #4]
  INT32 length, count, i;
  int n, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  const int *natural_order;
  INPUT_VARS(cinfo);
 8014738:	687b      	ldr	r3, [r7, #4]
 801473a:	699b      	ldr	r3, [r3, #24]
 801473c:	61bb      	str	r3, [r7, #24]
 801473e:	69bb      	ldr	r3, [r7, #24]
 8014740:	681b      	ldr	r3, [r3, #0]
 8014742:	623b      	str	r3, [r7, #32]
 8014744:	69bb      	ldr	r3, [r7, #24]
 8014746:	685b      	ldr	r3, [r3, #4]
 8014748:	61fb      	str	r3, [r7, #28]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801474a:	69fb      	ldr	r3, [r7, #28]
 801474c:	2b00      	cmp	r3, #0
 801474e:	d10e      	bne.n	801476e <get_dqt+0x3e>
 8014750:	69bb      	ldr	r3, [r7, #24]
 8014752:	68db      	ldr	r3, [r3, #12]
 8014754:	6878      	ldr	r0, [r7, #4]
 8014756:	4798      	blx	r3
 8014758:	4603      	mov	r3, r0
 801475a:	2b00      	cmp	r3, #0
 801475c:	d101      	bne.n	8014762 <get_dqt+0x32>
 801475e:	2300      	movs	r3, #0
 8014760:	e21e      	b.n	8014ba0 <get_dqt+0x470>
 8014762:	69bb      	ldr	r3, [r7, #24]
 8014764:	681b      	ldr	r3, [r3, #0]
 8014766:	623b      	str	r3, [r7, #32]
 8014768:	69bb      	ldr	r3, [r7, #24]
 801476a:	685b      	ldr	r3, [r3, #4]
 801476c:	61fb      	str	r3, [r7, #28]
 801476e:	69fb      	ldr	r3, [r7, #28]
 8014770:	3b01      	subs	r3, #1
 8014772:	61fb      	str	r3, [r7, #28]
 8014774:	6a3b      	ldr	r3, [r7, #32]
 8014776:	1c5a      	adds	r2, r3, #1
 8014778:	623a      	str	r2, [r7, #32]
 801477a:	781b      	ldrb	r3, [r3, #0]
 801477c:	021b      	lsls	r3, r3, #8
 801477e:	637b      	str	r3, [r7, #52]	; 0x34
 8014780:	69fb      	ldr	r3, [r7, #28]
 8014782:	2b00      	cmp	r3, #0
 8014784:	d10e      	bne.n	80147a4 <get_dqt+0x74>
 8014786:	69bb      	ldr	r3, [r7, #24]
 8014788:	68db      	ldr	r3, [r3, #12]
 801478a:	6878      	ldr	r0, [r7, #4]
 801478c:	4798      	blx	r3
 801478e:	4603      	mov	r3, r0
 8014790:	2b00      	cmp	r3, #0
 8014792:	d101      	bne.n	8014798 <get_dqt+0x68>
 8014794:	2300      	movs	r3, #0
 8014796:	e203      	b.n	8014ba0 <get_dqt+0x470>
 8014798:	69bb      	ldr	r3, [r7, #24]
 801479a:	681b      	ldr	r3, [r3, #0]
 801479c:	623b      	str	r3, [r7, #32]
 801479e:	69bb      	ldr	r3, [r7, #24]
 80147a0:	685b      	ldr	r3, [r3, #4]
 80147a2:	61fb      	str	r3, [r7, #28]
 80147a4:	69fb      	ldr	r3, [r7, #28]
 80147a6:	3b01      	subs	r3, #1
 80147a8:	61fb      	str	r3, [r7, #28]
 80147aa:	6a3b      	ldr	r3, [r7, #32]
 80147ac:	1c5a      	adds	r2, r3, #1
 80147ae:	623a      	str	r2, [r7, #32]
 80147b0:	781b      	ldrb	r3, [r3, #0]
 80147b2:	461a      	mov	r2, r3
 80147b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80147b6:	4413      	add	r3, r2
 80147b8:	637b      	str	r3, [r7, #52]	; 0x34
  length -= 2;
 80147ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80147bc:	3b02      	subs	r3, #2
 80147be:	637b      	str	r3, [r7, #52]	; 0x34

  while (length > 0) {
 80147c0:	e1d7      	b.n	8014b72 <get_dqt+0x442>
    length--;
 80147c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80147c4:	3b01      	subs	r3, #1
 80147c6:	637b      	str	r3, [r7, #52]	; 0x34
    INPUT_BYTE(cinfo, n, return FALSE);
 80147c8:	69fb      	ldr	r3, [r7, #28]
 80147ca:	2b00      	cmp	r3, #0
 80147cc:	d10e      	bne.n	80147ec <get_dqt+0xbc>
 80147ce:	69bb      	ldr	r3, [r7, #24]
 80147d0:	68db      	ldr	r3, [r3, #12]
 80147d2:	6878      	ldr	r0, [r7, #4]
 80147d4:	4798      	blx	r3
 80147d6:	4603      	mov	r3, r0
 80147d8:	2b00      	cmp	r3, #0
 80147da:	d101      	bne.n	80147e0 <get_dqt+0xb0>
 80147dc:	2300      	movs	r3, #0
 80147de:	e1df      	b.n	8014ba0 <get_dqt+0x470>
 80147e0:	69bb      	ldr	r3, [r7, #24]
 80147e2:	681b      	ldr	r3, [r3, #0]
 80147e4:	623b      	str	r3, [r7, #32]
 80147e6:	69bb      	ldr	r3, [r7, #24]
 80147e8:	685b      	ldr	r3, [r3, #4]
 80147ea:	61fb      	str	r3, [r7, #28]
 80147ec:	69fb      	ldr	r3, [r7, #28]
 80147ee:	3b01      	subs	r3, #1
 80147f0:	61fb      	str	r3, [r7, #28]
 80147f2:	6a3b      	ldr	r3, [r7, #32]
 80147f4:	1c5a      	adds	r2, r3, #1
 80147f6:	623a      	str	r2, [r7, #32]
 80147f8:	781b      	ldrb	r3, [r3, #0]
 80147fa:	617b      	str	r3, [r7, #20]
    prec = n >> 4;
 80147fc:	697b      	ldr	r3, [r7, #20]
 80147fe:	111b      	asrs	r3, r3, #4
 8014800:	613b      	str	r3, [r7, #16]
    n &= 0x0F;
 8014802:	697b      	ldr	r3, [r7, #20]
 8014804:	f003 030f 	and.w	r3, r3, #15
 8014808:	617b      	str	r3, [r7, #20]

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);
 801480a:	687b      	ldr	r3, [r7, #4]
 801480c:	681b      	ldr	r3, [r3, #0]
 801480e:	2253      	movs	r2, #83	; 0x53
 8014810:	615a      	str	r2, [r3, #20]
 8014812:	687b      	ldr	r3, [r7, #4]
 8014814:	681b      	ldr	r3, [r3, #0]
 8014816:	697a      	ldr	r2, [r7, #20]
 8014818:	619a      	str	r2, [r3, #24]
 801481a:	687b      	ldr	r3, [r7, #4]
 801481c:	681b      	ldr	r3, [r3, #0]
 801481e:	693a      	ldr	r2, [r7, #16]
 8014820:	61da      	str	r2, [r3, #28]
 8014822:	687b      	ldr	r3, [r7, #4]
 8014824:	681b      	ldr	r3, [r3, #0]
 8014826:	685b      	ldr	r3, [r3, #4]
 8014828:	2101      	movs	r1, #1
 801482a:	6878      	ldr	r0, [r7, #4]
 801482c:	4798      	blx	r3

    if (n >= NUM_QUANT_TBLS)
 801482e:	697b      	ldr	r3, [r7, #20]
 8014830:	2b03      	cmp	r3, #3
 8014832:	dd0c      	ble.n	801484e <get_dqt+0x11e>
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
 8014834:	687b      	ldr	r3, [r7, #4]
 8014836:	681b      	ldr	r3, [r3, #0]
 8014838:	2220      	movs	r2, #32
 801483a:	615a      	str	r2, [r3, #20]
 801483c:	687b      	ldr	r3, [r7, #4]
 801483e:	681b      	ldr	r3, [r3, #0]
 8014840:	697a      	ldr	r2, [r7, #20]
 8014842:	619a      	str	r2, [r3, #24]
 8014844:	687b      	ldr	r3, [r7, #4]
 8014846:	681b      	ldr	r3, [r3, #0]
 8014848:	681b      	ldr	r3, [r3, #0]
 801484a:	6878      	ldr	r0, [r7, #4]
 801484c:	4798      	blx	r3
      
    if (cinfo->quant_tbl_ptrs[n] == NULL)
 801484e:	687a      	ldr	r2, [r7, #4]
 8014850:	697b      	ldr	r3, [r7, #20]
 8014852:	3328      	adds	r3, #40	; 0x28
 8014854:	009b      	lsls	r3, r3, #2
 8014856:	4413      	add	r3, r2
 8014858:	685b      	ldr	r3, [r3, #4]
 801485a:	2b00      	cmp	r3, #0
 801485c:	d109      	bne.n	8014872 <get_dqt+0x142>
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
 801485e:	6878      	ldr	r0, [r7, #4]
 8014860:	f7f7 fbcc 	bl	800bffc <jpeg_alloc_quant_table>
 8014864:	4601      	mov	r1, r0
 8014866:	687a      	ldr	r2, [r7, #4]
 8014868:	697b      	ldr	r3, [r7, #20]
 801486a:	3328      	adds	r3, #40	; 0x28
 801486c:	009b      	lsls	r3, r3, #2
 801486e:	4413      	add	r3, r2
 8014870:	6059      	str	r1, [r3, #4]
    quant_ptr = cinfo->quant_tbl_ptrs[n];
 8014872:	687a      	ldr	r2, [r7, #4]
 8014874:	697b      	ldr	r3, [r7, #20]
 8014876:	3328      	adds	r3, #40	; 0x28
 8014878:	009b      	lsls	r3, r3, #2
 801487a:	4413      	add	r3, r2
 801487c:	685b      	ldr	r3, [r3, #4]
 801487e:	60fb      	str	r3, [r7, #12]

    if (prec) {
 8014880:	693b      	ldr	r3, [r7, #16]
 8014882:	2b00      	cmp	r3, #0
 8014884:	d017      	beq.n	80148b6 <get_dqt+0x186>
      if (length < DCTSIZE2 * 2) {
 8014886:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014888:	2b7f      	cmp	r3, #127	; 0x7f
 801488a:	dc11      	bgt.n	80148b0 <get_dqt+0x180>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 801488c:	2300      	movs	r3, #0
 801488e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014890:	e007      	b.n	80148a2 <get_dqt+0x172>
	  quant_ptr->quantval[i] = 1;
 8014892:	68fb      	ldr	r3, [r7, #12]
 8014894:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014896:	2101      	movs	r1, #1
 8014898:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 801489c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801489e:	3301      	adds	r3, #1
 80148a0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80148a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80148a4:	2b3f      	cmp	r3, #63	; 0x3f
 80148a6:	ddf4      	ble.n	8014892 <get_dqt+0x162>
	}
	count = length >> 1;
 80148a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80148aa:	105b      	asrs	r3, r3, #1
 80148ac:	633b      	str	r3, [r7, #48]	; 0x30
 80148ae:	e018      	b.n	80148e2 <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 80148b0:	2340      	movs	r3, #64	; 0x40
 80148b2:	633b      	str	r3, [r7, #48]	; 0x30
 80148b4:	e015      	b.n	80148e2 <get_dqt+0x1b2>
    } else {
      if (length < DCTSIZE2) {
 80148b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80148b8:	2b3f      	cmp	r3, #63	; 0x3f
 80148ba:	dc10      	bgt.n	80148de <get_dqt+0x1ae>
	/* Initialize full table for safety. */
	for (i = 0; i < DCTSIZE2; i++) {
 80148bc:	2300      	movs	r3, #0
 80148be:	62fb      	str	r3, [r7, #44]	; 0x2c
 80148c0:	e007      	b.n	80148d2 <get_dqt+0x1a2>
	  quant_ptr->quantval[i] = 1;
 80148c2:	68fb      	ldr	r3, [r7, #12]
 80148c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80148c6:	2101      	movs	r1, #1
 80148c8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
	for (i = 0; i < DCTSIZE2; i++) {
 80148cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80148ce:	3301      	adds	r3, #1
 80148d0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80148d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80148d4:	2b3f      	cmp	r3, #63	; 0x3f
 80148d6:	ddf4      	ble.n	80148c2 <get_dqt+0x192>
	}
	count = length;
 80148d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80148da:	633b      	str	r3, [r7, #48]	; 0x30
 80148dc:	e001      	b.n	80148e2 <get_dqt+0x1b2>
      } else
	count = DCTSIZE2;
 80148de:	2340      	movs	r3, #64	; 0x40
 80148e0:	633b      	str	r3, [r7, #48]	; 0x30
 80148e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80148e4:	3b04      	subs	r3, #4
 80148e6:	2b2d      	cmp	r3, #45	; 0x2d
 80148e8:	d870      	bhi.n	80149cc <get_dqt+0x29c>
 80148ea:	a201      	add	r2, pc, #4	; (adr r2, 80148f0 <get_dqt+0x1c0>)
 80148ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80148f0:	080149a9 	.word	0x080149a9
 80148f4:	080149cd 	.word	0x080149cd
 80148f8:	080149cd 	.word	0x080149cd
 80148fc:	080149cd 	.word	0x080149cd
 8014900:	080149cd 	.word	0x080149cd
 8014904:	080149af 	.word	0x080149af
 8014908:	080149cd 	.word	0x080149cd
 801490c:	080149cd 	.word	0x080149cd
 8014910:	080149cd 	.word	0x080149cd
 8014914:	080149cd 	.word	0x080149cd
 8014918:	080149cd 	.word	0x080149cd
 801491c:	080149cd 	.word	0x080149cd
 8014920:	080149b5 	.word	0x080149b5
 8014924:	080149cd 	.word	0x080149cd
 8014928:	080149cd 	.word	0x080149cd
 801492c:	080149cd 	.word	0x080149cd
 8014930:	080149cd 	.word	0x080149cd
 8014934:	080149cd 	.word	0x080149cd
 8014938:	080149cd 	.word	0x080149cd
 801493c:	080149cd 	.word	0x080149cd
 8014940:	080149cd 	.word	0x080149cd
 8014944:	080149bb 	.word	0x080149bb
 8014948:	080149cd 	.word	0x080149cd
 801494c:	080149cd 	.word	0x080149cd
 8014950:	080149cd 	.word	0x080149cd
 8014954:	080149cd 	.word	0x080149cd
 8014958:	080149cd 	.word	0x080149cd
 801495c:	080149cd 	.word	0x080149cd
 8014960:	080149cd 	.word	0x080149cd
 8014964:	080149cd 	.word	0x080149cd
 8014968:	080149cd 	.word	0x080149cd
 801496c:	080149cd 	.word	0x080149cd
 8014970:	080149c1 	.word	0x080149c1
 8014974:	080149cd 	.word	0x080149cd
 8014978:	080149cd 	.word	0x080149cd
 801497c:	080149cd 	.word	0x080149cd
 8014980:	080149cd 	.word	0x080149cd
 8014984:	080149cd 	.word	0x080149cd
 8014988:	080149cd 	.word	0x080149cd
 801498c:	080149cd 	.word	0x080149cd
 8014990:	080149cd 	.word	0x080149cd
 8014994:	080149cd 	.word	0x080149cd
 8014998:	080149cd 	.word	0x080149cd
 801499c:	080149cd 	.word	0x080149cd
 80149a0:	080149cd 	.word	0x080149cd
 80149a4:	080149c7 	.word	0x080149c7
    }

    switch (count) {
    case (2*2): natural_order = jpeg_natural_order2; break;
 80149a8:	4b7f      	ldr	r3, [pc, #508]	; (8014ba8 <get_dqt+0x478>)
 80149aa:	627b      	str	r3, [r7, #36]	; 0x24
 80149ac:	e011      	b.n	80149d2 <get_dqt+0x2a2>
    case (3*3): natural_order = jpeg_natural_order3; break;
 80149ae:	4b7f      	ldr	r3, [pc, #508]	; (8014bac <get_dqt+0x47c>)
 80149b0:	627b      	str	r3, [r7, #36]	; 0x24
 80149b2:	e00e      	b.n	80149d2 <get_dqt+0x2a2>
    case (4*4): natural_order = jpeg_natural_order4; break;
 80149b4:	4b7e      	ldr	r3, [pc, #504]	; (8014bb0 <get_dqt+0x480>)
 80149b6:	627b      	str	r3, [r7, #36]	; 0x24
 80149b8:	e00b      	b.n	80149d2 <get_dqt+0x2a2>
    case (5*5): natural_order = jpeg_natural_order5; break;
 80149ba:	4b7e      	ldr	r3, [pc, #504]	; (8014bb4 <get_dqt+0x484>)
 80149bc:	627b      	str	r3, [r7, #36]	; 0x24
 80149be:	e008      	b.n	80149d2 <get_dqt+0x2a2>
    case (6*6): natural_order = jpeg_natural_order6; break;
 80149c0:	4b7d      	ldr	r3, [pc, #500]	; (8014bb8 <get_dqt+0x488>)
 80149c2:	627b      	str	r3, [r7, #36]	; 0x24
 80149c4:	e005      	b.n	80149d2 <get_dqt+0x2a2>
    case (7*7): natural_order = jpeg_natural_order7; break;
 80149c6:	4b7d      	ldr	r3, [pc, #500]	; (8014bbc <get_dqt+0x48c>)
 80149c8:	627b      	str	r3, [r7, #36]	; 0x24
 80149ca:	e002      	b.n	80149d2 <get_dqt+0x2a2>
    default:    natural_order = jpeg_natural_order;  break;
 80149cc:	4b7c      	ldr	r3, [pc, #496]	; (8014bc0 <get_dqt+0x490>)
 80149ce:	627b      	str	r3, [r7, #36]	; 0x24
 80149d0:	bf00      	nop
    }

    for (i = 0; i < count; i++) {
 80149d2:	2300      	movs	r3, #0
 80149d4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80149d6:	e062      	b.n	8014a9e <get_dqt+0x36e>
      if (prec)
 80149d8:	693b      	ldr	r3, [r7, #16]
 80149da:	2b00      	cmp	r3, #0
 80149dc:	d038      	beq.n	8014a50 <get_dqt+0x320>
	INPUT_2BYTES(cinfo, tmp, return FALSE);
 80149de:	69fb      	ldr	r3, [r7, #28]
 80149e0:	2b00      	cmp	r3, #0
 80149e2:	d10e      	bne.n	8014a02 <get_dqt+0x2d2>
 80149e4:	69bb      	ldr	r3, [r7, #24]
 80149e6:	68db      	ldr	r3, [r3, #12]
 80149e8:	6878      	ldr	r0, [r7, #4]
 80149ea:	4798      	blx	r3
 80149ec:	4603      	mov	r3, r0
 80149ee:	2b00      	cmp	r3, #0
 80149f0:	d101      	bne.n	80149f6 <get_dqt+0x2c6>
 80149f2:	2300      	movs	r3, #0
 80149f4:	e0d4      	b.n	8014ba0 <get_dqt+0x470>
 80149f6:	69bb      	ldr	r3, [r7, #24]
 80149f8:	681b      	ldr	r3, [r3, #0]
 80149fa:	623b      	str	r3, [r7, #32]
 80149fc:	69bb      	ldr	r3, [r7, #24]
 80149fe:	685b      	ldr	r3, [r3, #4]
 8014a00:	61fb      	str	r3, [r7, #28]
 8014a02:	69fb      	ldr	r3, [r7, #28]
 8014a04:	3b01      	subs	r3, #1
 8014a06:	61fb      	str	r3, [r7, #28]
 8014a08:	6a3b      	ldr	r3, [r7, #32]
 8014a0a:	1c5a      	adds	r2, r3, #1
 8014a0c:	623a      	str	r2, [r7, #32]
 8014a0e:	781b      	ldrb	r3, [r3, #0]
 8014a10:	021b      	lsls	r3, r3, #8
 8014a12:	62bb      	str	r3, [r7, #40]	; 0x28
 8014a14:	69fb      	ldr	r3, [r7, #28]
 8014a16:	2b00      	cmp	r3, #0
 8014a18:	d10e      	bne.n	8014a38 <get_dqt+0x308>
 8014a1a:	69bb      	ldr	r3, [r7, #24]
 8014a1c:	68db      	ldr	r3, [r3, #12]
 8014a1e:	6878      	ldr	r0, [r7, #4]
 8014a20:	4798      	blx	r3
 8014a22:	4603      	mov	r3, r0
 8014a24:	2b00      	cmp	r3, #0
 8014a26:	d101      	bne.n	8014a2c <get_dqt+0x2fc>
 8014a28:	2300      	movs	r3, #0
 8014a2a:	e0b9      	b.n	8014ba0 <get_dqt+0x470>
 8014a2c:	69bb      	ldr	r3, [r7, #24]
 8014a2e:	681b      	ldr	r3, [r3, #0]
 8014a30:	623b      	str	r3, [r7, #32]
 8014a32:	69bb      	ldr	r3, [r7, #24]
 8014a34:	685b      	ldr	r3, [r3, #4]
 8014a36:	61fb      	str	r3, [r7, #28]
 8014a38:	69fb      	ldr	r3, [r7, #28]
 8014a3a:	3b01      	subs	r3, #1
 8014a3c:	61fb      	str	r3, [r7, #28]
 8014a3e:	6a3b      	ldr	r3, [r7, #32]
 8014a40:	1c5a      	adds	r2, r3, #1
 8014a42:	623a      	str	r2, [r7, #32]
 8014a44:	781b      	ldrb	r3, [r3, #0]
 8014a46:	461a      	mov	r2, r3
 8014a48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014a4a:	4413      	add	r3, r2
 8014a4c:	62bb      	str	r3, [r7, #40]	; 0x28
 8014a4e:	e019      	b.n	8014a84 <get_dqt+0x354>
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
 8014a50:	69fb      	ldr	r3, [r7, #28]
 8014a52:	2b00      	cmp	r3, #0
 8014a54:	d10e      	bne.n	8014a74 <get_dqt+0x344>
 8014a56:	69bb      	ldr	r3, [r7, #24]
 8014a58:	68db      	ldr	r3, [r3, #12]
 8014a5a:	6878      	ldr	r0, [r7, #4]
 8014a5c:	4798      	blx	r3
 8014a5e:	4603      	mov	r3, r0
 8014a60:	2b00      	cmp	r3, #0
 8014a62:	d101      	bne.n	8014a68 <get_dqt+0x338>
 8014a64:	2300      	movs	r3, #0
 8014a66:	e09b      	b.n	8014ba0 <get_dqt+0x470>
 8014a68:	69bb      	ldr	r3, [r7, #24]
 8014a6a:	681b      	ldr	r3, [r3, #0]
 8014a6c:	623b      	str	r3, [r7, #32]
 8014a6e:	69bb      	ldr	r3, [r7, #24]
 8014a70:	685b      	ldr	r3, [r3, #4]
 8014a72:	61fb      	str	r3, [r7, #28]
 8014a74:	69fb      	ldr	r3, [r7, #28]
 8014a76:	3b01      	subs	r3, #1
 8014a78:	61fb      	str	r3, [r7, #28]
 8014a7a:	6a3b      	ldr	r3, [r7, #32]
 8014a7c:	1c5a      	adds	r2, r3, #1
 8014a7e:	623a      	str	r2, [r7, #32]
 8014a80:	781b      	ldrb	r3, [r3, #0]
 8014a82:	62bb      	str	r3, [r7, #40]	; 0x28
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[natural_order[i]] = (UINT16) tmp;
 8014a84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a86:	009b      	lsls	r3, r3, #2
 8014a88:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014a8a:	4413      	add	r3, r2
 8014a8c:	681a      	ldr	r2, [r3, #0]
 8014a8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014a90:	b299      	uxth	r1, r3
 8014a92:	68fb      	ldr	r3, [r7, #12]
 8014a94:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < count; i++) {
 8014a98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a9a:	3301      	adds	r3, #1
 8014a9c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014a9e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014aa0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014aa2:	429a      	cmp	r2, r3
 8014aa4:	db98      	blt.n	80149d8 <get_dqt+0x2a8>
    }

    if (cinfo->err->trace_level >= 2) {
 8014aa6:	687b      	ldr	r3, [r7, #4]
 8014aa8:	681b      	ldr	r3, [r3, #0]
 8014aaa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8014aac:	2b01      	cmp	r3, #1
 8014aae:	dd55      	ble.n	8014b5c <get_dqt+0x42c>
      for (i = 0; i < DCTSIZE2; i += 8) {
 8014ab0:	2300      	movs	r3, #0
 8014ab2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014ab4:	e04f      	b.n	8014b56 <get_dqt+0x426>
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
 8014ab6:	687b      	ldr	r3, [r7, #4]
 8014ab8:	681b      	ldr	r3, [r3, #0]
 8014aba:	3318      	adds	r3, #24
 8014abc:	60bb      	str	r3, [r7, #8]
 8014abe:	68fb      	ldr	r3, [r7, #12]
 8014ac0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014ac2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8014ac6:	461a      	mov	r2, r3
 8014ac8:	68bb      	ldr	r3, [r7, #8]
 8014aca:	601a      	str	r2, [r3, #0]
 8014acc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014ace:	1c5a      	adds	r2, r3, #1
 8014ad0:	68fb      	ldr	r3, [r7, #12]
 8014ad2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014ad6:	68bb      	ldr	r3, [r7, #8]
 8014ad8:	3304      	adds	r3, #4
 8014ada:	601a      	str	r2, [r3, #0]
 8014adc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014ade:	1c9a      	adds	r2, r3, #2
 8014ae0:	68fb      	ldr	r3, [r7, #12]
 8014ae2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014ae6:	68bb      	ldr	r3, [r7, #8]
 8014ae8:	3308      	adds	r3, #8
 8014aea:	601a      	str	r2, [r3, #0]
 8014aec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014aee:	1cda      	adds	r2, r3, #3
 8014af0:	68fb      	ldr	r3, [r7, #12]
 8014af2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014af6:	68bb      	ldr	r3, [r7, #8]
 8014af8:	330c      	adds	r3, #12
 8014afa:	601a      	str	r2, [r3, #0]
 8014afc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014afe:	1d1a      	adds	r2, r3, #4
 8014b00:	68fb      	ldr	r3, [r7, #12]
 8014b02:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014b06:	68bb      	ldr	r3, [r7, #8]
 8014b08:	3310      	adds	r3, #16
 8014b0a:	601a      	str	r2, [r3, #0]
 8014b0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014b0e:	1d5a      	adds	r2, r3, #5
 8014b10:	68fb      	ldr	r3, [r7, #12]
 8014b12:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014b16:	68bb      	ldr	r3, [r7, #8]
 8014b18:	3314      	adds	r3, #20
 8014b1a:	601a      	str	r2, [r3, #0]
 8014b1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014b1e:	1d9a      	adds	r2, r3, #6
 8014b20:	68fb      	ldr	r3, [r7, #12]
 8014b22:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014b26:	68bb      	ldr	r3, [r7, #8]
 8014b28:	3318      	adds	r3, #24
 8014b2a:	601a      	str	r2, [r3, #0]
 8014b2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014b2e:	1dda      	adds	r2, r3, #7
 8014b30:	68fb      	ldr	r3, [r7, #12]
 8014b32:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8014b36:	68bb      	ldr	r3, [r7, #8]
 8014b38:	331c      	adds	r3, #28
 8014b3a:	601a      	str	r2, [r3, #0]
 8014b3c:	687b      	ldr	r3, [r7, #4]
 8014b3e:	681b      	ldr	r3, [r3, #0]
 8014b40:	225f      	movs	r2, #95	; 0x5f
 8014b42:	615a      	str	r2, [r3, #20]
 8014b44:	687b      	ldr	r3, [r7, #4]
 8014b46:	681b      	ldr	r3, [r3, #0]
 8014b48:	685b      	ldr	r3, [r3, #4]
 8014b4a:	2102      	movs	r1, #2
 8014b4c:	6878      	ldr	r0, [r7, #4]
 8014b4e:	4798      	blx	r3
      for (i = 0; i < DCTSIZE2; i += 8) {
 8014b50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014b52:	3308      	adds	r3, #8
 8014b54:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014b56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014b58:	2b3f      	cmp	r3, #63	; 0x3f
 8014b5a:	ddac      	ble.n	8014ab6 <get_dqt+0x386>
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= count;
 8014b5c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014b5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014b60:	1ad3      	subs	r3, r2, r3
 8014b62:	637b      	str	r3, [r7, #52]	; 0x34
    if (prec) length -= count;
 8014b64:	693b      	ldr	r3, [r7, #16]
 8014b66:	2b00      	cmp	r3, #0
 8014b68:	d003      	beq.n	8014b72 <get_dqt+0x442>
 8014b6a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014b6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014b6e:	1ad3      	subs	r3, r2, r3
 8014b70:	637b      	str	r3, [r7, #52]	; 0x34
  while (length > 0) {
 8014b72:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014b74:	2b00      	cmp	r3, #0
 8014b76:	f73f ae24 	bgt.w	80147c2 <get_dqt+0x92>
  }

  if (length != 0)
 8014b7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014b7c:	2b00      	cmp	r3, #0
 8014b7e:	d008      	beq.n	8014b92 <get_dqt+0x462>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8014b80:	687b      	ldr	r3, [r7, #4]
 8014b82:	681b      	ldr	r3, [r3, #0]
 8014b84:	220c      	movs	r2, #12
 8014b86:	615a      	str	r2, [r3, #20]
 8014b88:	687b      	ldr	r3, [r7, #4]
 8014b8a:	681b      	ldr	r3, [r3, #0]
 8014b8c:	681b      	ldr	r3, [r3, #0]
 8014b8e:	6878      	ldr	r0, [r7, #4]
 8014b90:	4798      	blx	r3

  INPUT_SYNC(cinfo);
 8014b92:	69bb      	ldr	r3, [r7, #24]
 8014b94:	6a3a      	ldr	r2, [r7, #32]
 8014b96:	601a      	str	r2, [r3, #0]
 8014b98:	69bb      	ldr	r3, [r7, #24]
 8014b9a:	69fa      	ldr	r2, [r7, #28]
 8014b9c:	605a      	str	r2, [r3, #4]
  return TRUE;
 8014b9e:	2301      	movs	r3, #1
}
 8014ba0:	4618      	mov	r0, r3
 8014ba2:	3738      	adds	r7, #56	; 0x38
 8014ba4:	46bd      	mov	sp, r7
 8014ba6:	bd80      	pop	{r7, pc}
 8014ba8:	0802b104 	.word	0x0802b104
 8014bac:	0802b0a0 	.word	0x0802b0a0
 8014bb0:	0802b020 	.word	0x0802b020
 8014bb4:	0802af7c 	.word	0x0802af7c
 8014bb8:	0802aeac 	.word	0x0802aeac
 8014bbc:	0802ada8 	.word	0x0802ada8
 8014bc0:	0802ac68 	.word	0x0802ac68

08014bc4 <get_dri>:


LOCAL(boolean)
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
 8014bc4:	b580      	push	{r7, lr}
 8014bc6:	b088      	sub	sp, #32
 8014bc8:	af00      	add	r7, sp, #0
 8014bca:	6078      	str	r0, [r7, #4]
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);
 8014bcc:	687b      	ldr	r3, [r7, #4]
 8014bce:	699b      	ldr	r3, [r3, #24]
 8014bd0:	617b      	str	r3, [r7, #20]
 8014bd2:	697b      	ldr	r3, [r7, #20]
 8014bd4:	681b      	ldr	r3, [r3, #0]
 8014bd6:	61fb      	str	r3, [r7, #28]
 8014bd8:	697b      	ldr	r3, [r7, #20]
 8014bda:	685b      	ldr	r3, [r3, #4]
 8014bdc:	61bb      	str	r3, [r7, #24]

  INPUT_2BYTES(cinfo, length, return FALSE);
 8014bde:	69bb      	ldr	r3, [r7, #24]
 8014be0:	2b00      	cmp	r3, #0
 8014be2:	d10e      	bne.n	8014c02 <get_dri+0x3e>
 8014be4:	697b      	ldr	r3, [r7, #20]
 8014be6:	68db      	ldr	r3, [r3, #12]
 8014be8:	6878      	ldr	r0, [r7, #4]
 8014bea:	4798      	blx	r3
 8014bec:	4603      	mov	r3, r0
 8014bee:	2b00      	cmp	r3, #0
 8014bf0:	d101      	bne.n	8014bf6 <get_dri+0x32>
 8014bf2:	2300      	movs	r3, #0
 8014bf4:	e088      	b.n	8014d08 <get_dri+0x144>
 8014bf6:	697b      	ldr	r3, [r7, #20]
 8014bf8:	681b      	ldr	r3, [r3, #0]
 8014bfa:	61fb      	str	r3, [r7, #28]
 8014bfc:	697b      	ldr	r3, [r7, #20]
 8014bfe:	685b      	ldr	r3, [r3, #4]
 8014c00:	61bb      	str	r3, [r7, #24]
 8014c02:	69bb      	ldr	r3, [r7, #24]
 8014c04:	3b01      	subs	r3, #1
 8014c06:	61bb      	str	r3, [r7, #24]
 8014c08:	69fb      	ldr	r3, [r7, #28]
 8014c0a:	1c5a      	adds	r2, r3, #1
 8014c0c:	61fa      	str	r2, [r7, #28]
 8014c0e:	781b      	ldrb	r3, [r3, #0]
 8014c10:	021b      	lsls	r3, r3, #8
 8014c12:	613b      	str	r3, [r7, #16]
 8014c14:	69bb      	ldr	r3, [r7, #24]
 8014c16:	2b00      	cmp	r3, #0
 8014c18:	d10e      	bne.n	8014c38 <get_dri+0x74>
 8014c1a:	697b      	ldr	r3, [r7, #20]
 8014c1c:	68db      	ldr	r3, [r3, #12]
 8014c1e:	6878      	ldr	r0, [r7, #4]
 8014c20:	4798      	blx	r3
 8014c22:	4603      	mov	r3, r0
 8014c24:	2b00      	cmp	r3, #0
 8014c26:	d101      	bne.n	8014c2c <get_dri+0x68>
 8014c28:	2300      	movs	r3, #0
 8014c2a:	e06d      	b.n	8014d08 <get_dri+0x144>
 8014c2c:	697b      	ldr	r3, [r7, #20]
 8014c2e:	681b      	ldr	r3, [r3, #0]
 8014c30:	61fb      	str	r3, [r7, #28]
 8014c32:	697b      	ldr	r3, [r7, #20]
 8014c34:	685b      	ldr	r3, [r3, #4]
 8014c36:	61bb      	str	r3, [r7, #24]
 8014c38:	69bb      	ldr	r3, [r7, #24]
 8014c3a:	3b01      	subs	r3, #1
 8014c3c:	61bb      	str	r3, [r7, #24]
 8014c3e:	69fb      	ldr	r3, [r7, #28]
 8014c40:	1c5a      	adds	r2, r3, #1
 8014c42:	61fa      	str	r2, [r7, #28]
 8014c44:	781b      	ldrb	r3, [r3, #0]
 8014c46:	461a      	mov	r2, r3
 8014c48:	693b      	ldr	r3, [r7, #16]
 8014c4a:	4413      	add	r3, r2
 8014c4c:	613b      	str	r3, [r7, #16]
  
  if (length != 4)
 8014c4e:	693b      	ldr	r3, [r7, #16]
 8014c50:	2b04      	cmp	r3, #4
 8014c52:	d008      	beq.n	8014c66 <get_dri+0xa2>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
 8014c54:	687b      	ldr	r3, [r7, #4]
 8014c56:	681b      	ldr	r3, [r3, #0]
 8014c58:	220c      	movs	r2, #12
 8014c5a:	615a      	str	r2, [r3, #20]
 8014c5c:	687b      	ldr	r3, [r7, #4]
 8014c5e:	681b      	ldr	r3, [r3, #0]
 8014c60:	681b      	ldr	r3, [r3, #0]
 8014c62:	6878      	ldr	r0, [r7, #4]
 8014c64:	4798      	blx	r3

  INPUT_2BYTES(cinfo, tmp, return FALSE);
 8014c66:	69bb      	ldr	r3, [r7, #24]
 8014c68:	2b00      	cmp	r3, #0
 8014c6a:	d10e      	bne.n	8014c8a <get_dri+0xc6>
 8014c6c:	697b      	ldr	r3, [r7, #20]
 8014c6e:	68db      	ldr	r3, [r3, #12]
 8014c70:	6878      	ldr	r0, [r7, #4]
 8014c72:	4798      	blx	r3
 8014c74:	4603      	mov	r3, r0
 8014c76:	2b00      	cmp	r3, #0
 8014c78:	d101      	bne.n	8014c7e <get_dri+0xba>
 8014c7a:	2300      	movs	r3, #0
 8014c7c:	e044      	b.n	8014d08 <get_dri+0x144>
 8014c7e:	697b      	ldr	r3, [r7, #20]
 8014c80:	681b      	ldr	r3, [r3, #0]
 8014c82:	61fb      	str	r3, [r7, #28]
 8014c84:	697b      	ldr	r3, [r7, #20]
 8014c86:	685b      	ldr	r3, [r3, #4]
 8014c88:	61bb      	str	r3, [r7, #24]
 8014c8a:	69bb      	ldr	r3, [r7, #24]
 8014c8c:	3b01      	subs	r3, #1
 8014c8e:	61bb      	str	r3, [r7, #24]
 8014c90:	69fb      	ldr	r3, [r7, #28]
 8014c92:	1c5a      	adds	r2, r3, #1
 8014c94:	61fa      	str	r2, [r7, #28]
 8014c96:	781b      	ldrb	r3, [r3, #0]
 8014c98:	021b      	lsls	r3, r3, #8
 8014c9a:	60fb      	str	r3, [r7, #12]
 8014c9c:	69bb      	ldr	r3, [r7, #24]
 8014c9e:	2b00      	cmp	r3, #0
 8014ca0:	d10e      	bne.n	8014cc0 <get_dri+0xfc>
 8014ca2:	697b      	ldr	r3, [r7, #20]
 8014ca4:	68db      	ldr	r3, [r3, #12]
 8014ca6:	6878      	ldr	r0, [r7, #4]
 8014ca8:	4798      	blx	r3
 8014caa:	4603      	mov	r3, r0
 8014cac:	2b00      	cmp	r3, #0
 8014cae:	d101      	bne.n	8014cb4 <get_dri+0xf0>
 8014cb0:	2300      	movs	r3, #0
 8014cb2:	e029      	b.n	8014d08 <get_dri+0x144>
 8014cb4:	697b      	ldr	r3, [r7, #20]
 8014cb6:	681b      	ldr	r3, [r3, #0]
 8014cb8:	61fb      	str	r3, [r7, #28]
 8014cba:	697b      	ldr	r3, [r7, #20]
 8014cbc:	685b      	ldr	r3, [r3, #4]
 8014cbe:	61bb      	str	r3, [r7, #24]
 8014cc0:	69bb      	ldr	r3, [r7, #24]
 8014cc2:	3b01      	subs	r3, #1
 8014cc4:	61bb      	str	r3, [r7, #24]
 8014cc6:	69fb      	ldr	r3, [r7, #28]
 8014cc8:	1c5a      	adds	r2, r3, #1
 8014cca:	61fa      	str	r2, [r7, #28]
 8014ccc:	781b      	ldrb	r3, [r3, #0]
 8014cce:	461a      	mov	r2, r3
 8014cd0:	68fb      	ldr	r3, [r7, #12]
 8014cd2:	4413      	add	r3, r2
 8014cd4:	60fb      	str	r3, [r7, #12]

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);
 8014cd6:	687b      	ldr	r3, [r7, #4]
 8014cd8:	681b      	ldr	r3, [r3, #0]
 8014cda:	2254      	movs	r2, #84	; 0x54
 8014cdc:	615a      	str	r2, [r3, #20]
 8014cde:	687b      	ldr	r3, [r7, #4]
 8014ce0:	681b      	ldr	r3, [r3, #0]
 8014ce2:	68fa      	ldr	r2, [r7, #12]
 8014ce4:	619a      	str	r2, [r3, #24]
 8014ce6:	687b      	ldr	r3, [r7, #4]
 8014ce8:	681b      	ldr	r3, [r3, #0]
 8014cea:	685b      	ldr	r3, [r3, #4]
 8014cec:	2101      	movs	r1, #1
 8014cee:	6878      	ldr	r0, [r7, #4]
 8014cf0:	4798      	blx	r3

  cinfo->restart_interval = tmp;
 8014cf2:	687b      	ldr	r3, [r7, #4]
 8014cf4:	68fa      	ldr	r2, [r7, #12]
 8014cf6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118

  INPUT_SYNC(cinfo);
 8014cfa:	697b      	ldr	r3, [r7, #20]
 8014cfc:	69fa      	ldr	r2, [r7, #28]
 8014cfe:	601a      	str	r2, [r3, #0]
 8014d00:	697b      	ldr	r3, [r7, #20]
 8014d02:	69ba      	ldr	r2, [r7, #24]
 8014d04:	605a      	str	r2, [r3, #4]
  return TRUE;
 8014d06:	2301      	movs	r3, #1
}
 8014d08:	4618      	mov	r0, r3
 8014d0a:	3720      	adds	r7, #32
 8014d0c:	46bd      	mov	sp, r7
 8014d0e:	bd80      	pop	{r7, pc}

08014d10 <examine_app0>:
	      unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP0.
 * Take appropriate action if it is a JFIF marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 8014d10:	b580      	push	{r7, lr}
 8014d12:	b086      	sub	sp, #24
 8014d14:	af00      	add	r7, sp, #0
 8014d16:	60f8      	str	r0, [r7, #12]
 8014d18:	60b9      	str	r1, [r7, #8]
 8014d1a:	607a      	str	r2, [r7, #4]
 8014d1c:	603b      	str	r3, [r7, #0]
  INT32 totallen = (INT32) datalen + remaining;
 8014d1e:	687b      	ldr	r3, [r7, #4]
 8014d20:	683a      	ldr	r2, [r7, #0]
 8014d22:	4413      	add	r3, r2
 8014d24:	617b      	str	r3, [r7, #20]

  if (datalen >= APP0_DATA_LEN &&
 8014d26:	687b      	ldr	r3, [r7, #4]
 8014d28:	2b0d      	cmp	r3, #13
 8014d2a:	f240 80d8 	bls.w	8014ede <examine_app0+0x1ce>
      GETJOCTET(data[0]) == 0x4A &&
 8014d2e:	68bb      	ldr	r3, [r7, #8]
 8014d30:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP0_DATA_LEN &&
 8014d32:	2b4a      	cmp	r3, #74	; 0x4a
 8014d34:	f040 80d3 	bne.w	8014ede <examine_app0+0x1ce>
      GETJOCTET(data[1]) == 0x46 &&
 8014d38:	68bb      	ldr	r3, [r7, #8]
 8014d3a:	3301      	adds	r3, #1
 8014d3c:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 8014d3e:	2b46      	cmp	r3, #70	; 0x46
 8014d40:	f040 80cd 	bne.w	8014ede <examine_app0+0x1ce>
      GETJOCTET(data[2]) == 0x49 &&
 8014d44:	68bb      	ldr	r3, [r7, #8]
 8014d46:	3302      	adds	r3, #2
 8014d48:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 8014d4a:	2b49      	cmp	r3, #73	; 0x49
 8014d4c:	f040 80c7 	bne.w	8014ede <examine_app0+0x1ce>
      GETJOCTET(data[3]) == 0x46 &&
 8014d50:	68bb      	ldr	r3, [r7, #8]
 8014d52:	3303      	adds	r3, #3
 8014d54:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x49 &&
 8014d56:	2b46      	cmp	r3, #70	; 0x46
 8014d58:	f040 80c1 	bne.w	8014ede <examine_app0+0x1ce>
      GETJOCTET(data[4]) == 0) {
 8014d5c:	68bb      	ldr	r3, [r7, #8]
 8014d5e:	3304      	adds	r3, #4
 8014d60:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x46 &&
 8014d62:	2b00      	cmp	r3, #0
 8014d64:	f040 80bb 	bne.w	8014ede <examine_app0+0x1ce>
    /* Found JFIF APP0 marker: save info */
    cinfo->saw_JFIF_marker = TRUE;
 8014d68:	68fb      	ldr	r3, [r7, #12]
 8014d6a:	2201      	movs	r2, #1
 8014d6c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    cinfo->JFIF_major_version = GETJOCTET(data[5]);
 8014d70:	68bb      	ldr	r3, [r7, #8]
 8014d72:	795a      	ldrb	r2, [r3, #5]
 8014d74:	68fb      	ldr	r3, [r7, #12]
 8014d76:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
 8014d7a:	68bb      	ldr	r3, [r7, #8]
 8014d7c:	799a      	ldrb	r2, [r3, #6]
 8014d7e:	68fb      	ldr	r3, [r7, #12]
 8014d80:	f883 2121 	strb.w	r2, [r3, #289]	; 0x121
    cinfo->density_unit = GETJOCTET(data[7]);
 8014d84:	68bb      	ldr	r3, [r7, #8]
 8014d86:	79da      	ldrb	r2, [r3, #7]
 8014d88:	68fb      	ldr	r3, [r7, #12]
 8014d8a:	f883 2122 	strb.w	r2, [r3, #290]	; 0x122
    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
 8014d8e:	68bb      	ldr	r3, [r7, #8]
 8014d90:	3308      	adds	r3, #8
 8014d92:	781b      	ldrb	r3, [r3, #0]
 8014d94:	b29b      	uxth	r3, r3
 8014d96:	021b      	lsls	r3, r3, #8
 8014d98:	b29a      	uxth	r2, r3
 8014d9a:	68bb      	ldr	r3, [r7, #8]
 8014d9c:	3309      	adds	r3, #9
 8014d9e:	781b      	ldrb	r3, [r3, #0]
 8014da0:	b29b      	uxth	r3, r3
 8014da2:	4413      	add	r3, r2
 8014da4:	b29a      	uxth	r2, r3
 8014da6:	68fb      	ldr	r3, [r7, #12]
 8014da8:	f8a3 2124 	strh.w	r2, [r3, #292]	; 0x124
    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
 8014dac:	68bb      	ldr	r3, [r7, #8]
 8014dae:	330a      	adds	r3, #10
 8014db0:	781b      	ldrb	r3, [r3, #0]
 8014db2:	b29b      	uxth	r3, r3
 8014db4:	021b      	lsls	r3, r3, #8
 8014db6:	b29a      	uxth	r2, r3
 8014db8:	68bb      	ldr	r3, [r7, #8]
 8014dba:	330b      	adds	r3, #11
 8014dbc:	781b      	ldrb	r3, [r3, #0]
 8014dbe:	b29b      	uxth	r3, r3
 8014dc0:	4413      	add	r3, r2
 8014dc2:	b29a      	uxth	r2, r3
 8014dc4:	68fb      	ldr	r3, [r7, #12]
 8014dc6:	f8a3 2126 	strh.w	r2, [r3, #294]	; 0x126
     * Major version must be 1, anything else signals an incompatible change.
     * (We used to treat this as an error, but now it's a nonfatal warning,
     * because some bozo at Hijaak couldn't read the spec.)
     * Minor version should be 0..2, but process anyway if newer.
     */
    if (cinfo->JFIF_major_version != 1)
 8014dca:	68fb      	ldr	r3, [r7, #12]
 8014dcc:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
 8014dd0:	2b01      	cmp	r3, #1
 8014dd2:	d016      	beq.n	8014e02 <examine_app0+0xf2>
      WARNMS2(cinfo, JWRN_JFIF_MAJOR,
 8014dd4:	68fb      	ldr	r3, [r7, #12]
 8014dd6:	681b      	ldr	r3, [r3, #0]
 8014dd8:	227a      	movs	r2, #122	; 0x7a
 8014dda:	615a      	str	r2, [r3, #20]
 8014ddc:	68fb      	ldr	r3, [r7, #12]
 8014dde:	f893 2120 	ldrb.w	r2, [r3, #288]	; 0x120
 8014de2:	68fb      	ldr	r3, [r7, #12]
 8014de4:	681b      	ldr	r3, [r3, #0]
 8014de6:	619a      	str	r2, [r3, #24]
 8014de8:	68fb      	ldr	r3, [r7, #12]
 8014dea:	f893 2121 	ldrb.w	r2, [r3, #289]	; 0x121
 8014dee:	68fb      	ldr	r3, [r7, #12]
 8014df0:	681b      	ldr	r3, [r3, #0]
 8014df2:	61da      	str	r2, [r3, #28]
 8014df4:	68fb      	ldr	r3, [r7, #12]
 8014df6:	681b      	ldr	r3, [r3, #0]
 8014df8:	685b      	ldr	r3, [r3, #4]
 8014dfa:	f04f 31ff 	mov.w	r1, #4294967295
 8014dfe:	68f8      	ldr	r0, [r7, #12]
 8014e00:	4798      	blx	r3
	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
    /* Generate trace messages */
    TRACEMS5(cinfo, 1, JTRC_JFIF,
 8014e02:	68fb      	ldr	r3, [r7, #12]
 8014e04:	681b      	ldr	r3, [r3, #0]
 8014e06:	3318      	adds	r3, #24
 8014e08:	613b      	str	r3, [r7, #16]
 8014e0a:	68fb      	ldr	r3, [r7, #12]
 8014e0c:	f893 3120 	ldrb.w	r3, [r3, #288]	; 0x120
 8014e10:	461a      	mov	r2, r3
 8014e12:	693b      	ldr	r3, [r7, #16]
 8014e14:	601a      	str	r2, [r3, #0]
 8014e16:	68fb      	ldr	r3, [r7, #12]
 8014e18:	f893 2121 	ldrb.w	r2, [r3, #289]	; 0x121
 8014e1c:	693b      	ldr	r3, [r7, #16]
 8014e1e:	3304      	adds	r3, #4
 8014e20:	601a      	str	r2, [r3, #0]
 8014e22:	68fb      	ldr	r3, [r7, #12]
 8014e24:	f8b3 2124 	ldrh.w	r2, [r3, #292]	; 0x124
 8014e28:	693b      	ldr	r3, [r7, #16]
 8014e2a:	3308      	adds	r3, #8
 8014e2c:	601a      	str	r2, [r3, #0]
 8014e2e:	68fb      	ldr	r3, [r7, #12]
 8014e30:	f8b3 2126 	ldrh.w	r2, [r3, #294]	; 0x126
 8014e34:	693b      	ldr	r3, [r7, #16]
 8014e36:	330c      	adds	r3, #12
 8014e38:	601a      	str	r2, [r3, #0]
 8014e3a:	68fb      	ldr	r3, [r7, #12]
 8014e3c:	f893 2122 	ldrb.w	r2, [r3, #290]	; 0x122
 8014e40:	693b      	ldr	r3, [r7, #16]
 8014e42:	3310      	adds	r3, #16
 8014e44:	601a      	str	r2, [r3, #0]
 8014e46:	68fb      	ldr	r3, [r7, #12]
 8014e48:	681b      	ldr	r3, [r3, #0]
 8014e4a:	2259      	movs	r2, #89	; 0x59
 8014e4c:	615a      	str	r2, [r3, #20]
 8014e4e:	68fb      	ldr	r3, [r7, #12]
 8014e50:	681b      	ldr	r3, [r3, #0]
 8014e52:	685b      	ldr	r3, [r3, #4]
 8014e54:	2101      	movs	r1, #1
 8014e56:	68f8      	ldr	r0, [r7, #12]
 8014e58:	4798      	blx	r3
	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
    /* Validate thumbnail dimensions and issue appropriate messages */
    if (GETJOCTET(data[12]) | GETJOCTET(data[13]))
 8014e5a:	68bb      	ldr	r3, [r7, #8]
 8014e5c:	330c      	adds	r3, #12
 8014e5e:	781a      	ldrb	r2, [r3, #0]
 8014e60:	68bb      	ldr	r3, [r7, #8]
 8014e62:	330d      	adds	r3, #13
 8014e64:	781b      	ldrb	r3, [r3, #0]
 8014e66:	4313      	orrs	r3, r2
 8014e68:	b2db      	uxtb	r3, r3
 8014e6a:	2b00      	cmp	r3, #0
 8014e6c:	d015      	beq.n	8014e9a <examine_app0+0x18a>
      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,
 8014e6e:	68fb      	ldr	r3, [r7, #12]
 8014e70:	681b      	ldr	r3, [r3, #0]
 8014e72:	225c      	movs	r2, #92	; 0x5c
 8014e74:	615a      	str	r2, [r3, #20]
 8014e76:	68bb      	ldr	r3, [r7, #8]
 8014e78:	330c      	adds	r3, #12
 8014e7a:	781a      	ldrb	r2, [r3, #0]
 8014e7c:	68fb      	ldr	r3, [r7, #12]
 8014e7e:	681b      	ldr	r3, [r3, #0]
 8014e80:	619a      	str	r2, [r3, #24]
 8014e82:	68bb      	ldr	r3, [r7, #8]
 8014e84:	330d      	adds	r3, #13
 8014e86:	781a      	ldrb	r2, [r3, #0]
 8014e88:	68fb      	ldr	r3, [r7, #12]
 8014e8a:	681b      	ldr	r3, [r3, #0]
 8014e8c:	61da      	str	r2, [r3, #28]
 8014e8e:	68fb      	ldr	r3, [r7, #12]
 8014e90:	681b      	ldr	r3, [r3, #0]
 8014e92:	685b      	ldr	r3, [r3, #4]
 8014e94:	2101      	movs	r1, #1
 8014e96:	68f8      	ldr	r0, [r7, #12]
 8014e98:	4798      	blx	r3
	       GETJOCTET(data[12]), GETJOCTET(data[13]));
    totallen -= APP0_DATA_LEN;
 8014e9a:	697b      	ldr	r3, [r7, #20]
 8014e9c:	3b0e      	subs	r3, #14
 8014e9e:	617b      	str	r3, [r7, #20]
    if (totallen !=
	((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))
 8014ea0:	68bb      	ldr	r3, [r7, #8]
 8014ea2:	330c      	adds	r3, #12
 8014ea4:	781b      	ldrb	r3, [r3, #0]
 8014ea6:	461a      	mov	r2, r3
 8014ea8:	68bb      	ldr	r3, [r7, #8]
 8014eaa:	330d      	adds	r3, #13
 8014eac:	781b      	ldrb	r3, [r3, #0]
 8014eae:	fb03 f202 	mul.w	r2, r3, r2
 8014eb2:	4613      	mov	r3, r2
 8014eb4:	005b      	lsls	r3, r3, #1
 8014eb6:	4413      	add	r3, r2
    if (totallen !=
 8014eb8:	697a      	ldr	r2, [r7, #20]
 8014eba:	429a      	cmp	r2, r3
 8014ebc:	f000 8088 	beq.w	8014fd0 <examine_app0+0x2c0>
      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);
 8014ec0:	68fb      	ldr	r3, [r7, #12]
 8014ec2:	681b      	ldr	r3, [r3, #0]
 8014ec4:	225a      	movs	r2, #90	; 0x5a
 8014ec6:	615a      	str	r2, [r3, #20]
 8014ec8:	68fb      	ldr	r3, [r7, #12]
 8014eca:	681b      	ldr	r3, [r3, #0]
 8014ecc:	697a      	ldr	r2, [r7, #20]
 8014ece:	619a      	str	r2, [r3, #24]
 8014ed0:	68fb      	ldr	r3, [r7, #12]
 8014ed2:	681b      	ldr	r3, [r3, #0]
 8014ed4:	685b      	ldr	r3, [r3, #4]
 8014ed6:	2101      	movs	r1, #1
 8014ed8:	68f8      	ldr	r0, [r7, #12]
 8014eda:	4798      	blx	r3
    if (totallen !=
 8014edc:	e078      	b.n	8014fd0 <examine_app0+0x2c0>
  } else if (datalen >= 6 &&
 8014ede:	687b      	ldr	r3, [r7, #4]
 8014ee0:	2b05      	cmp	r3, #5
 8014ee2:	d966      	bls.n	8014fb2 <examine_app0+0x2a2>
      GETJOCTET(data[0]) == 0x4A &&
 8014ee4:	68bb      	ldr	r3, [r7, #8]
 8014ee6:	781b      	ldrb	r3, [r3, #0]
  } else if (datalen >= 6 &&
 8014ee8:	2b4a      	cmp	r3, #74	; 0x4a
 8014eea:	d162      	bne.n	8014fb2 <examine_app0+0x2a2>
      GETJOCTET(data[1]) == 0x46 &&
 8014eec:	68bb      	ldr	r3, [r7, #8]
 8014eee:	3301      	adds	r3, #1
 8014ef0:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x4A &&
 8014ef2:	2b46      	cmp	r3, #70	; 0x46
 8014ef4:	d15d      	bne.n	8014fb2 <examine_app0+0x2a2>
      GETJOCTET(data[2]) == 0x58 &&
 8014ef6:	68bb      	ldr	r3, [r7, #8]
 8014ef8:	3302      	adds	r3, #2
 8014efa:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x46 &&
 8014efc:	2b58      	cmp	r3, #88	; 0x58
 8014efe:	d158      	bne.n	8014fb2 <examine_app0+0x2a2>
      GETJOCTET(data[3]) == 0x58 &&
 8014f00:	68bb      	ldr	r3, [r7, #8]
 8014f02:	3303      	adds	r3, #3
 8014f04:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x58 &&
 8014f06:	2b58      	cmp	r3, #88	; 0x58
 8014f08:	d153      	bne.n	8014fb2 <examine_app0+0x2a2>
      GETJOCTET(data[4]) == 0) {
 8014f0a:	68bb      	ldr	r3, [r7, #8]
 8014f0c:	3304      	adds	r3, #4
 8014f0e:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x58 &&
 8014f10:	2b00      	cmp	r3, #0
 8014f12:	d14e      	bne.n	8014fb2 <examine_app0+0x2a2>
    /* Found JFIF "JFXX" extension APP0 marker */
    /* The library doesn't actually do anything with these,
     * but we try to produce a helpful trace message.
     */
    switch (GETJOCTET(data[5])) {
 8014f14:	68bb      	ldr	r3, [r7, #8]
 8014f16:	3305      	adds	r3, #5
 8014f18:	781b      	ldrb	r3, [r3, #0]
 8014f1a:	2b13      	cmp	r3, #19
 8014f1c:	d024      	beq.n	8014f68 <examine_app0+0x258>
 8014f1e:	2b13      	cmp	r3, #19
 8014f20:	dc31      	bgt.n	8014f86 <examine_app0+0x276>
 8014f22:	2b10      	cmp	r3, #16
 8014f24:	d002      	beq.n	8014f2c <examine_app0+0x21c>
 8014f26:	2b11      	cmp	r3, #17
 8014f28:	d00f      	beq.n	8014f4a <examine_app0+0x23a>
 8014f2a:	e02c      	b.n	8014f86 <examine_app0+0x276>
    case 0x10:
      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
 8014f2c:	68fb      	ldr	r3, [r7, #12]
 8014f2e:	681b      	ldr	r3, [r3, #0]
 8014f30:	226e      	movs	r2, #110	; 0x6e
 8014f32:	615a      	str	r2, [r3, #20]
 8014f34:	68fb      	ldr	r3, [r7, #12]
 8014f36:	681b      	ldr	r3, [r3, #0]
 8014f38:	697a      	ldr	r2, [r7, #20]
 8014f3a:	619a      	str	r2, [r3, #24]
 8014f3c:	68fb      	ldr	r3, [r7, #12]
 8014f3e:	681b      	ldr	r3, [r3, #0]
 8014f40:	685b      	ldr	r3, [r3, #4]
 8014f42:	2101      	movs	r1, #1
 8014f44:	68f8      	ldr	r0, [r7, #12]
 8014f46:	4798      	blx	r3
      break;
 8014f48:	e032      	b.n	8014fb0 <examine_app0+0x2a0>
    case 0x11:
      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
 8014f4a:	68fb      	ldr	r3, [r7, #12]
 8014f4c:	681b      	ldr	r3, [r3, #0]
 8014f4e:	226f      	movs	r2, #111	; 0x6f
 8014f50:	615a      	str	r2, [r3, #20]
 8014f52:	68fb      	ldr	r3, [r7, #12]
 8014f54:	681b      	ldr	r3, [r3, #0]
 8014f56:	697a      	ldr	r2, [r7, #20]
 8014f58:	619a      	str	r2, [r3, #24]
 8014f5a:	68fb      	ldr	r3, [r7, #12]
 8014f5c:	681b      	ldr	r3, [r3, #0]
 8014f5e:	685b      	ldr	r3, [r3, #4]
 8014f60:	2101      	movs	r1, #1
 8014f62:	68f8      	ldr	r0, [r7, #12]
 8014f64:	4798      	blx	r3
      break;
 8014f66:	e023      	b.n	8014fb0 <examine_app0+0x2a0>
    case 0x13:
      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
 8014f68:	68fb      	ldr	r3, [r7, #12]
 8014f6a:	681b      	ldr	r3, [r3, #0]
 8014f6c:	2270      	movs	r2, #112	; 0x70
 8014f6e:	615a      	str	r2, [r3, #20]
 8014f70:	68fb      	ldr	r3, [r7, #12]
 8014f72:	681b      	ldr	r3, [r3, #0]
 8014f74:	697a      	ldr	r2, [r7, #20]
 8014f76:	619a      	str	r2, [r3, #24]
 8014f78:	68fb      	ldr	r3, [r7, #12]
 8014f7a:	681b      	ldr	r3, [r3, #0]
 8014f7c:	685b      	ldr	r3, [r3, #4]
 8014f7e:	2101      	movs	r1, #1
 8014f80:	68f8      	ldr	r0, [r7, #12]
 8014f82:	4798      	blx	r3
      break;
 8014f84:	e014      	b.n	8014fb0 <examine_app0+0x2a0>
    default:
      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
 8014f86:	68fb      	ldr	r3, [r7, #12]
 8014f88:	681b      	ldr	r3, [r3, #0]
 8014f8a:	225b      	movs	r2, #91	; 0x5b
 8014f8c:	615a      	str	r2, [r3, #20]
 8014f8e:	68bb      	ldr	r3, [r7, #8]
 8014f90:	3305      	adds	r3, #5
 8014f92:	781a      	ldrb	r2, [r3, #0]
 8014f94:	68fb      	ldr	r3, [r7, #12]
 8014f96:	681b      	ldr	r3, [r3, #0]
 8014f98:	619a      	str	r2, [r3, #24]
 8014f9a:	68fb      	ldr	r3, [r7, #12]
 8014f9c:	681b      	ldr	r3, [r3, #0]
 8014f9e:	697a      	ldr	r2, [r7, #20]
 8014fa0:	61da      	str	r2, [r3, #28]
 8014fa2:	68fb      	ldr	r3, [r7, #12]
 8014fa4:	681b      	ldr	r3, [r3, #0]
 8014fa6:	685b      	ldr	r3, [r3, #4]
 8014fa8:	2101      	movs	r1, #1
 8014faa:	68f8      	ldr	r0, [r7, #12]
 8014fac:	4798      	blx	r3
	       GETJOCTET(data[5]), (int) totallen);
      break;
 8014fae:	bf00      	nop
    switch (GETJOCTET(data[5])) {
 8014fb0:	e00e      	b.n	8014fd0 <examine_app0+0x2c0>
    }
  } else {
    /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
 8014fb2:	68fb      	ldr	r3, [r7, #12]
 8014fb4:	681b      	ldr	r3, [r3, #0]
 8014fb6:	224f      	movs	r2, #79	; 0x4f
 8014fb8:	615a      	str	r2, [r3, #20]
 8014fba:	68fb      	ldr	r3, [r7, #12]
 8014fbc:	681b      	ldr	r3, [r3, #0]
 8014fbe:	697a      	ldr	r2, [r7, #20]
 8014fc0:	619a      	str	r2, [r3, #24]
 8014fc2:	68fb      	ldr	r3, [r7, #12]
 8014fc4:	681b      	ldr	r3, [r3, #0]
 8014fc6:	685b      	ldr	r3, [r3, #4]
 8014fc8:	2101      	movs	r1, #1
 8014fca:	68f8      	ldr	r0, [r7, #12]
 8014fcc:	4798      	blx	r3
  }
}
 8014fce:	bf00      	nop
 8014fd0:	bf00      	nop
 8014fd2:	3718      	adds	r7, #24
 8014fd4:	46bd      	mov	sp, r7
 8014fd6:	bd80      	pop	{r7, pc}

08014fd8 <examine_app14>:
	       unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP14.
 * Take appropriate action if it is an Adobe marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
 8014fd8:	b580      	push	{r7, lr}
 8014fda:	b08a      	sub	sp, #40	; 0x28
 8014fdc:	af00      	add	r7, sp, #0
 8014fde:	60f8      	str	r0, [r7, #12]
 8014fe0:	60b9      	str	r1, [r7, #8]
 8014fe2:	607a      	str	r2, [r7, #4]
 8014fe4:	603b      	str	r3, [r7, #0]
  unsigned int version, flags0, flags1, transform;

  if (datalen >= APP14_DATA_LEN &&
 8014fe6:	687b      	ldr	r3, [r7, #4]
 8014fe8:	2b0b      	cmp	r3, #11
 8014fea:	d95d      	bls.n	80150a8 <examine_app14+0xd0>
      GETJOCTET(data[0]) == 0x41 &&
 8014fec:	68bb      	ldr	r3, [r7, #8]
 8014fee:	781b      	ldrb	r3, [r3, #0]
  if (datalen >= APP14_DATA_LEN &&
 8014ff0:	2b41      	cmp	r3, #65	; 0x41
 8014ff2:	d159      	bne.n	80150a8 <examine_app14+0xd0>
      GETJOCTET(data[1]) == 0x64 &&
 8014ff4:	68bb      	ldr	r3, [r7, #8]
 8014ff6:	3301      	adds	r3, #1
 8014ff8:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[0]) == 0x41 &&
 8014ffa:	2b64      	cmp	r3, #100	; 0x64
 8014ffc:	d154      	bne.n	80150a8 <examine_app14+0xd0>
      GETJOCTET(data[2]) == 0x6F &&
 8014ffe:	68bb      	ldr	r3, [r7, #8]
 8015000:	3302      	adds	r3, #2
 8015002:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[1]) == 0x64 &&
 8015004:	2b6f      	cmp	r3, #111	; 0x6f
 8015006:	d14f      	bne.n	80150a8 <examine_app14+0xd0>
      GETJOCTET(data[3]) == 0x62 &&
 8015008:	68bb      	ldr	r3, [r7, #8]
 801500a:	3303      	adds	r3, #3
 801500c:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[2]) == 0x6F &&
 801500e:	2b62      	cmp	r3, #98	; 0x62
 8015010:	d14a      	bne.n	80150a8 <examine_app14+0xd0>
      GETJOCTET(data[4]) == 0x65) {
 8015012:	68bb      	ldr	r3, [r7, #8]
 8015014:	3304      	adds	r3, #4
 8015016:	781b      	ldrb	r3, [r3, #0]
      GETJOCTET(data[3]) == 0x62 &&
 8015018:	2b65      	cmp	r3, #101	; 0x65
 801501a:	d145      	bne.n	80150a8 <examine_app14+0xd0>
    /* Found Adobe APP14 marker */
    version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
 801501c:	68bb      	ldr	r3, [r7, #8]
 801501e:	3305      	adds	r3, #5
 8015020:	781b      	ldrb	r3, [r3, #0]
 8015022:	021b      	lsls	r3, r3, #8
 8015024:	68ba      	ldr	r2, [r7, #8]
 8015026:	3206      	adds	r2, #6
 8015028:	7812      	ldrb	r2, [r2, #0]
 801502a:	4413      	add	r3, r2
 801502c:	627b      	str	r3, [r7, #36]	; 0x24
    flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
 801502e:	68bb      	ldr	r3, [r7, #8]
 8015030:	3307      	adds	r3, #7
 8015032:	781b      	ldrb	r3, [r3, #0]
 8015034:	021b      	lsls	r3, r3, #8
 8015036:	68ba      	ldr	r2, [r7, #8]
 8015038:	3208      	adds	r2, #8
 801503a:	7812      	ldrb	r2, [r2, #0]
 801503c:	4413      	add	r3, r2
 801503e:	623b      	str	r3, [r7, #32]
    flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
 8015040:	68bb      	ldr	r3, [r7, #8]
 8015042:	3309      	adds	r3, #9
 8015044:	781b      	ldrb	r3, [r3, #0]
 8015046:	021b      	lsls	r3, r3, #8
 8015048:	68ba      	ldr	r2, [r7, #8]
 801504a:	320a      	adds	r2, #10
 801504c:	7812      	ldrb	r2, [r2, #0]
 801504e:	4413      	add	r3, r2
 8015050:	61fb      	str	r3, [r7, #28]
    transform = GETJOCTET(data[11]);
 8015052:	68bb      	ldr	r3, [r7, #8]
 8015054:	330b      	adds	r3, #11
 8015056:	781b      	ldrb	r3, [r3, #0]
 8015058:	61bb      	str	r3, [r7, #24]
    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
 801505a:	68fb      	ldr	r3, [r7, #12]
 801505c:	681b      	ldr	r3, [r3, #0]
 801505e:	3318      	adds	r3, #24
 8015060:	617b      	str	r3, [r7, #20]
 8015062:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015064:	697b      	ldr	r3, [r7, #20]
 8015066:	601a      	str	r2, [r3, #0]
 8015068:	697b      	ldr	r3, [r7, #20]
 801506a:	3304      	adds	r3, #4
 801506c:	6a3a      	ldr	r2, [r7, #32]
 801506e:	601a      	str	r2, [r3, #0]
 8015070:	697b      	ldr	r3, [r7, #20]
 8015072:	3308      	adds	r3, #8
 8015074:	69fa      	ldr	r2, [r7, #28]
 8015076:	601a      	str	r2, [r3, #0]
 8015078:	697b      	ldr	r3, [r7, #20]
 801507a:	330c      	adds	r3, #12
 801507c:	69ba      	ldr	r2, [r7, #24]
 801507e:	601a      	str	r2, [r3, #0]
 8015080:	68fb      	ldr	r3, [r7, #12]
 8015082:	681b      	ldr	r3, [r3, #0]
 8015084:	224e      	movs	r2, #78	; 0x4e
 8015086:	615a      	str	r2, [r3, #20]
 8015088:	68fb      	ldr	r3, [r7, #12]
 801508a:	681b      	ldr	r3, [r3, #0]
 801508c:	685b      	ldr	r3, [r3, #4]
 801508e:	2101      	movs	r1, #1
 8015090:	68f8      	ldr	r0, [r7, #12]
 8015092:	4798      	blx	r3
    cinfo->saw_Adobe_marker = TRUE;
 8015094:	68fb      	ldr	r3, [r7, #12]
 8015096:	2201      	movs	r2, #1
 8015098:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    cinfo->Adobe_transform = (UINT8) transform;
 801509c:	69bb      	ldr	r3, [r7, #24]
 801509e:	b2da      	uxtb	r2, r3
 80150a0:	68fb      	ldr	r3, [r7, #12]
 80150a2:	f883 212c 	strb.w	r2, [r3, #300]	; 0x12c
 80150a6:	e010      	b.n	80150ca <examine_app14+0xf2>
  } else {
    /* Start of APP14 does not match "Adobe", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));
 80150a8:	68fb      	ldr	r3, [r7, #12]
 80150aa:	681b      	ldr	r3, [r3, #0]
 80150ac:	2250      	movs	r2, #80	; 0x50
 80150ae:	615a      	str	r2, [r3, #20]
 80150b0:	683a      	ldr	r2, [r7, #0]
 80150b2:	687b      	ldr	r3, [r7, #4]
 80150b4:	441a      	add	r2, r3
 80150b6:	68fb      	ldr	r3, [r7, #12]
 80150b8:	681b      	ldr	r3, [r3, #0]
 80150ba:	619a      	str	r2, [r3, #24]
 80150bc:	68fb      	ldr	r3, [r7, #12]
 80150be:	681b      	ldr	r3, [r3, #0]
 80150c0:	685b      	ldr	r3, [r3, #4]
 80150c2:	2101      	movs	r1, #1
 80150c4:	68f8      	ldr	r0, [r7, #12]
 80150c6:	4798      	blx	r3
  }
}
 80150c8:	bf00      	nop
 80150ca:	bf00      	nop
 80150cc:	3728      	adds	r7, #40	; 0x28
 80150ce:	46bd      	mov	sp, r7
 80150d0:	bd80      	pop	{r7, pc}

080150d2 <get_interesting_appn>:


METHODDEF(boolean)
get_interesting_appn (j_decompress_ptr cinfo)
/* Process an APP0 or APP14 marker without saving it */
{
 80150d2:	b580      	push	{r7, lr}
 80150d4:	b08c      	sub	sp, #48	; 0x30
 80150d6:	af00      	add	r7, sp, #0
 80150d8:	6078      	str	r0, [r7, #4]
  INT32 length;
  JOCTET b[APPN_DATA_LEN];
  unsigned int i, numtoread;
  INPUT_VARS(cinfo);
 80150da:	687b      	ldr	r3, [r7, #4]
 80150dc:	699b      	ldr	r3, [r3, #24]
 80150de:	61fb      	str	r3, [r7, #28]
 80150e0:	69fb      	ldr	r3, [r7, #28]
 80150e2:	681b      	ldr	r3, [r3, #0]
 80150e4:	627b      	str	r3, [r7, #36]	; 0x24
 80150e6:	69fb      	ldr	r3, [r7, #28]
 80150e8:	685b      	ldr	r3, [r3, #4]
 80150ea:	623b      	str	r3, [r7, #32]

  INPUT_2BYTES(cinfo, length, return FALSE);
 80150ec:	6a3b      	ldr	r3, [r7, #32]
 80150ee:	2b00      	cmp	r3, #0
 80150f0:	d10e      	bne.n	8015110 <get_interesting_appn+0x3e>
 80150f2:	69fb      	ldr	r3, [r7, #28]
 80150f4:	68db      	ldr	r3, [r3, #12]
 80150f6:	6878      	ldr	r0, [r7, #4]
 80150f8:	4798      	blx	r3
 80150fa:	4603      	mov	r3, r0
 80150fc:	2b00      	cmp	r3, #0
 80150fe:	d101      	bne.n	8015104 <get_interesting_appn+0x32>
 8015100:	2300      	movs	r3, #0
 8015102:	e0a1      	b.n	8015248 <get_interesting_appn+0x176>
 8015104:	69fb      	ldr	r3, [r7, #28]
 8015106:	681b      	ldr	r3, [r3, #0]
 8015108:	627b      	str	r3, [r7, #36]	; 0x24
 801510a:	69fb      	ldr	r3, [r7, #28]
 801510c:	685b      	ldr	r3, [r3, #4]
 801510e:	623b      	str	r3, [r7, #32]
 8015110:	6a3b      	ldr	r3, [r7, #32]
 8015112:	3b01      	subs	r3, #1
 8015114:	623b      	str	r3, [r7, #32]
 8015116:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015118:	1c5a      	adds	r2, r3, #1
 801511a:	627a      	str	r2, [r7, #36]	; 0x24
 801511c:	781b      	ldrb	r3, [r3, #0]
 801511e:	021b      	lsls	r3, r3, #8
 8015120:	61bb      	str	r3, [r7, #24]
 8015122:	6a3b      	ldr	r3, [r7, #32]
 8015124:	2b00      	cmp	r3, #0
 8015126:	d10e      	bne.n	8015146 <get_interesting_appn+0x74>
 8015128:	69fb      	ldr	r3, [r7, #28]
 801512a:	68db      	ldr	r3, [r3, #12]
 801512c:	6878      	ldr	r0, [r7, #4]
 801512e:	4798      	blx	r3
 8015130:	4603      	mov	r3, r0
 8015132:	2b00      	cmp	r3, #0
 8015134:	d101      	bne.n	801513a <get_interesting_appn+0x68>
 8015136:	2300      	movs	r3, #0
 8015138:	e086      	b.n	8015248 <get_interesting_appn+0x176>
 801513a:	69fb      	ldr	r3, [r7, #28]
 801513c:	681b      	ldr	r3, [r3, #0]
 801513e:	627b      	str	r3, [r7, #36]	; 0x24
 8015140:	69fb      	ldr	r3, [r7, #28]
 8015142:	685b      	ldr	r3, [r3, #4]
 8015144:	623b      	str	r3, [r7, #32]
 8015146:	6a3b      	ldr	r3, [r7, #32]
 8015148:	3b01      	subs	r3, #1
 801514a:	623b      	str	r3, [r7, #32]
 801514c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801514e:	1c5a      	adds	r2, r3, #1
 8015150:	627a      	str	r2, [r7, #36]	; 0x24
 8015152:	781b      	ldrb	r3, [r3, #0]
 8015154:	461a      	mov	r2, r3
 8015156:	69bb      	ldr	r3, [r7, #24]
 8015158:	4413      	add	r3, r2
 801515a:	61bb      	str	r3, [r7, #24]
  length -= 2;
 801515c:	69bb      	ldr	r3, [r7, #24]
 801515e:	3b02      	subs	r3, #2
 8015160:	61bb      	str	r3, [r7, #24]

  /* get the interesting part of the marker data */
  if (length >= APPN_DATA_LEN)
 8015162:	69bb      	ldr	r3, [r7, #24]
 8015164:	2b0d      	cmp	r3, #13
 8015166:	dd02      	ble.n	801516e <get_interesting_appn+0x9c>
    numtoread = APPN_DATA_LEN;
 8015168:	230e      	movs	r3, #14
 801516a:	62bb      	str	r3, [r7, #40]	; 0x28
 801516c:	e007      	b.n	801517e <get_interesting_appn+0xac>
  else if (length > 0)
 801516e:	69bb      	ldr	r3, [r7, #24]
 8015170:	2b00      	cmp	r3, #0
 8015172:	dd02      	ble.n	801517a <get_interesting_appn+0xa8>
    numtoread = (unsigned int) length;
 8015174:	69bb      	ldr	r3, [r7, #24]
 8015176:	62bb      	str	r3, [r7, #40]	; 0x28
 8015178:	e001      	b.n	801517e <get_interesting_appn+0xac>
  else
    numtoread = 0;
 801517a:	2300      	movs	r3, #0
 801517c:	62bb      	str	r3, [r7, #40]	; 0x28
  for (i = 0; i < numtoread; i++)
 801517e:	2300      	movs	r3, #0
 8015180:	62fb      	str	r3, [r7, #44]	; 0x2c
 8015182:	e021      	b.n	80151c8 <get_interesting_appn+0xf6>
    INPUT_BYTE(cinfo, b[i], return FALSE);
 8015184:	6a3b      	ldr	r3, [r7, #32]
 8015186:	2b00      	cmp	r3, #0
 8015188:	d10e      	bne.n	80151a8 <get_interesting_appn+0xd6>
 801518a:	69fb      	ldr	r3, [r7, #28]
 801518c:	68db      	ldr	r3, [r3, #12]
 801518e:	6878      	ldr	r0, [r7, #4]
 8015190:	4798      	blx	r3
 8015192:	4603      	mov	r3, r0
 8015194:	2b00      	cmp	r3, #0
 8015196:	d101      	bne.n	801519c <get_interesting_appn+0xca>
 8015198:	2300      	movs	r3, #0
 801519a:	e055      	b.n	8015248 <get_interesting_appn+0x176>
 801519c:	69fb      	ldr	r3, [r7, #28]
 801519e:	681b      	ldr	r3, [r3, #0]
 80151a0:	627b      	str	r3, [r7, #36]	; 0x24
 80151a2:	69fb      	ldr	r3, [r7, #28]
 80151a4:	685b      	ldr	r3, [r3, #4]
 80151a6:	623b      	str	r3, [r7, #32]
 80151a8:	6a3b      	ldr	r3, [r7, #32]
 80151aa:	3b01      	subs	r3, #1
 80151ac:	623b      	str	r3, [r7, #32]
 80151ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80151b0:	1c5a      	adds	r2, r3, #1
 80151b2:	627a      	str	r2, [r7, #36]	; 0x24
 80151b4:	7819      	ldrb	r1, [r3, #0]
 80151b6:	f107 0208 	add.w	r2, r7, #8
 80151ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151bc:	4413      	add	r3, r2
 80151be:	460a      	mov	r2, r1
 80151c0:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numtoread; i++)
 80151c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80151c4:	3301      	adds	r3, #1
 80151c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80151c8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80151ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80151cc:	429a      	cmp	r2, r3
 80151ce:	d3d9      	bcc.n	8015184 <get_interesting_appn+0xb2>
  length -= numtoread;
 80151d0:	69ba      	ldr	r2, [r7, #24]
 80151d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80151d4:	1ad3      	subs	r3, r2, r3
 80151d6:	61bb      	str	r3, [r7, #24]

  /* process it */
  switch (cinfo->unread_marker) {
 80151d8:	687b      	ldr	r3, [r7, #4]
 80151da:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80151de:	2be0      	cmp	r3, #224	; 0xe0
 80151e0:	d002      	beq.n	80151e8 <get_interesting_appn+0x116>
 80151e2:	2bee      	cmp	r3, #238	; 0xee
 80151e4:	d008      	beq.n	80151f8 <get_interesting_appn+0x126>
 80151e6:	e00f      	b.n	8015208 <get_interesting_appn+0x136>
  case M_APP0:
    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
 80151e8:	f107 0108 	add.w	r1, r7, #8
 80151ec:	69bb      	ldr	r3, [r7, #24]
 80151ee:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80151f0:	6878      	ldr	r0, [r7, #4]
 80151f2:	f7ff fd8d 	bl	8014d10 <examine_app0>
    break;
 80151f6:	e017      	b.n	8015228 <get_interesting_appn+0x156>
  case M_APP14:
    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
 80151f8:	f107 0108 	add.w	r1, r7, #8
 80151fc:	69bb      	ldr	r3, [r7, #24]
 80151fe:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015200:	6878      	ldr	r0, [r7, #4]
 8015202:	f7ff fee9 	bl	8014fd8 <examine_app14>
    break;
 8015206:	e00f      	b.n	8015228 <get_interesting_appn+0x156>
  default:
    /* can't get here unless jpeg_save_markers chooses wrong processor */
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 8015208:	687b      	ldr	r3, [r7, #4]
 801520a:	681b      	ldr	r3, [r3, #0]
 801520c:	2246      	movs	r2, #70	; 0x46
 801520e:	615a      	str	r2, [r3, #20]
 8015210:	687b      	ldr	r3, [r7, #4]
 8015212:	681b      	ldr	r3, [r3, #0]
 8015214:	687a      	ldr	r2, [r7, #4]
 8015216:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 801521a:	619a      	str	r2, [r3, #24]
 801521c:	687b      	ldr	r3, [r7, #4]
 801521e:	681b      	ldr	r3, [r3, #0]
 8015220:	681b      	ldr	r3, [r3, #0]
 8015222:	6878      	ldr	r0, [r7, #4]
 8015224:	4798      	blx	r3
    break;
 8015226:	bf00      	nop
  }

  /* skip any remaining data -- could be lots */
  INPUT_SYNC(cinfo);
 8015228:	69fb      	ldr	r3, [r7, #28]
 801522a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801522c:	601a      	str	r2, [r3, #0]
 801522e:	69fb      	ldr	r3, [r7, #28]
 8015230:	6a3a      	ldr	r2, [r7, #32]
 8015232:	605a      	str	r2, [r3, #4]
  if (length > 0)
 8015234:	69bb      	ldr	r3, [r7, #24]
 8015236:	2b00      	cmp	r3, #0
 8015238:	dd05      	ble.n	8015246 <get_interesting_appn+0x174>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 801523a:	687b      	ldr	r3, [r7, #4]
 801523c:	699b      	ldr	r3, [r3, #24]
 801523e:	691b      	ldr	r3, [r3, #16]
 8015240:	69b9      	ldr	r1, [r7, #24]
 8015242:	6878      	ldr	r0, [r7, #4]
 8015244:	4798      	blx	r3

  return TRUE;
 8015246:	2301      	movs	r3, #1
}
 8015248:	4618      	mov	r0, r3
 801524a:	3730      	adds	r7, #48	; 0x30
 801524c:	46bd      	mov	sp, r7
 801524e:	bd80      	pop	{r7, pc}

08015250 <skip_variable>:


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
 8015250:	b580      	push	{r7, lr}
 8015252:	b086      	sub	sp, #24
 8015254:	af00      	add	r7, sp, #0
 8015256:	6078      	str	r0, [r7, #4]
  INT32 length;
  INPUT_VARS(cinfo);
 8015258:	687b      	ldr	r3, [r7, #4]
 801525a:	699b      	ldr	r3, [r3, #24]
 801525c:	60fb      	str	r3, [r7, #12]
 801525e:	68fb      	ldr	r3, [r7, #12]
 8015260:	681b      	ldr	r3, [r3, #0]
 8015262:	617b      	str	r3, [r7, #20]
 8015264:	68fb      	ldr	r3, [r7, #12]
 8015266:	685b      	ldr	r3, [r3, #4]
 8015268:	613b      	str	r3, [r7, #16]

  INPUT_2BYTES(cinfo, length, return FALSE);
 801526a:	693b      	ldr	r3, [r7, #16]
 801526c:	2b00      	cmp	r3, #0
 801526e:	d10e      	bne.n	801528e <skip_variable+0x3e>
 8015270:	68fb      	ldr	r3, [r7, #12]
 8015272:	68db      	ldr	r3, [r3, #12]
 8015274:	6878      	ldr	r0, [r7, #4]
 8015276:	4798      	blx	r3
 8015278:	4603      	mov	r3, r0
 801527a:	2b00      	cmp	r3, #0
 801527c:	d101      	bne.n	8015282 <skip_variable+0x32>
 801527e:	2300      	movs	r3, #0
 8015280:	e052      	b.n	8015328 <skip_variable+0xd8>
 8015282:	68fb      	ldr	r3, [r7, #12]
 8015284:	681b      	ldr	r3, [r3, #0]
 8015286:	617b      	str	r3, [r7, #20]
 8015288:	68fb      	ldr	r3, [r7, #12]
 801528a:	685b      	ldr	r3, [r3, #4]
 801528c:	613b      	str	r3, [r7, #16]
 801528e:	693b      	ldr	r3, [r7, #16]
 8015290:	3b01      	subs	r3, #1
 8015292:	613b      	str	r3, [r7, #16]
 8015294:	697b      	ldr	r3, [r7, #20]
 8015296:	1c5a      	adds	r2, r3, #1
 8015298:	617a      	str	r2, [r7, #20]
 801529a:	781b      	ldrb	r3, [r3, #0]
 801529c:	021b      	lsls	r3, r3, #8
 801529e:	60bb      	str	r3, [r7, #8]
 80152a0:	693b      	ldr	r3, [r7, #16]
 80152a2:	2b00      	cmp	r3, #0
 80152a4:	d10e      	bne.n	80152c4 <skip_variable+0x74>
 80152a6:	68fb      	ldr	r3, [r7, #12]
 80152a8:	68db      	ldr	r3, [r3, #12]
 80152aa:	6878      	ldr	r0, [r7, #4]
 80152ac:	4798      	blx	r3
 80152ae:	4603      	mov	r3, r0
 80152b0:	2b00      	cmp	r3, #0
 80152b2:	d101      	bne.n	80152b8 <skip_variable+0x68>
 80152b4:	2300      	movs	r3, #0
 80152b6:	e037      	b.n	8015328 <skip_variable+0xd8>
 80152b8:	68fb      	ldr	r3, [r7, #12]
 80152ba:	681b      	ldr	r3, [r3, #0]
 80152bc:	617b      	str	r3, [r7, #20]
 80152be:	68fb      	ldr	r3, [r7, #12]
 80152c0:	685b      	ldr	r3, [r3, #4]
 80152c2:	613b      	str	r3, [r7, #16]
 80152c4:	693b      	ldr	r3, [r7, #16]
 80152c6:	3b01      	subs	r3, #1
 80152c8:	613b      	str	r3, [r7, #16]
 80152ca:	697b      	ldr	r3, [r7, #20]
 80152cc:	1c5a      	adds	r2, r3, #1
 80152ce:	617a      	str	r2, [r7, #20]
 80152d0:	781b      	ldrb	r3, [r3, #0]
 80152d2:	461a      	mov	r2, r3
 80152d4:	68bb      	ldr	r3, [r7, #8]
 80152d6:	4413      	add	r3, r2
 80152d8:	60bb      	str	r3, [r7, #8]
  length -= 2;
 80152da:	68bb      	ldr	r3, [r7, #8]
 80152dc:	3b02      	subs	r3, #2
 80152de:	60bb      	str	r3, [r7, #8]
  
  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
 80152e0:	687b      	ldr	r3, [r7, #4]
 80152e2:	681b      	ldr	r3, [r3, #0]
 80152e4:	225d      	movs	r2, #93	; 0x5d
 80152e6:	615a      	str	r2, [r3, #20]
 80152e8:	687b      	ldr	r3, [r7, #4]
 80152ea:	681b      	ldr	r3, [r3, #0]
 80152ec:	687a      	ldr	r2, [r7, #4]
 80152ee:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 80152f2:	619a      	str	r2, [r3, #24]
 80152f4:	687b      	ldr	r3, [r7, #4]
 80152f6:	681b      	ldr	r3, [r3, #0]
 80152f8:	68ba      	ldr	r2, [r7, #8]
 80152fa:	61da      	str	r2, [r3, #28]
 80152fc:	687b      	ldr	r3, [r7, #4]
 80152fe:	681b      	ldr	r3, [r3, #0]
 8015300:	685b      	ldr	r3, [r3, #4]
 8015302:	2101      	movs	r1, #1
 8015304:	6878      	ldr	r0, [r7, #4]
 8015306:	4798      	blx	r3

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
 8015308:	68fb      	ldr	r3, [r7, #12]
 801530a:	697a      	ldr	r2, [r7, #20]
 801530c:	601a      	str	r2, [r3, #0]
 801530e:	68fb      	ldr	r3, [r7, #12]
 8015310:	693a      	ldr	r2, [r7, #16]
 8015312:	605a      	str	r2, [r3, #4]
  if (length > 0)
 8015314:	68bb      	ldr	r3, [r7, #8]
 8015316:	2b00      	cmp	r3, #0
 8015318:	dd05      	ble.n	8015326 <skip_variable+0xd6>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
 801531a:	687b      	ldr	r3, [r7, #4]
 801531c:	699b      	ldr	r3, [r3, #24]
 801531e:	691b      	ldr	r3, [r3, #16]
 8015320:	68b9      	ldr	r1, [r7, #8]
 8015322:	6878      	ldr	r0, [r7, #4]
 8015324:	4798      	blx	r3

  return TRUE;
 8015326:	2301      	movs	r3, #1
}
 8015328:	4618      	mov	r0, r3
 801532a:	3718      	adds	r7, #24
 801532c:	46bd      	mov	sp, r7
 801532e:	bd80      	pop	{r7, pc}

08015330 <next_marker>:
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
 8015330:	b580      	push	{r7, lr}
 8015332:	b086      	sub	sp, #24
 8015334:	af00      	add	r7, sp, #0
 8015336:	6078      	str	r0, [r7, #4]
  int c;
  INPUT_VARS(cinfo);
 8015338:	687b      	ldr	r3, [r7, #4]
 801533a:	699b      	ldr	r3, [r3, #24]
 801533c:	60bb      	str	r3, [r7, #8]
 801533e:	68bb      	ldr	r3, [r7, #8]
 8015340:	681b      	ldr	r3, [r3, #0]
 8015342:	613b      	str	r3, [r7, #16]
 8015344:	68bb      	ldr	r3, [r7, #8]
 8015346:	685b      	ldr	r3, [r3, #4]
 8015348:	60fb      	str	r3, [r7, #12]

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
 801534a:	68fb      	ldr	r3, [r7, #12]
 801534c:	2b00      	cmp	r3, #0
 801534e:	d10e      	bne.n	801536e <next_marker+0x3e>
 8015350:	68bb      	ldr	r3, [r7, #8]
 8015352:	68db      	ldr	r3, [r3, #12]
 8015354:	6878      	ldr	r0, [r7, #4]
 8015356:	4798      	blx	r3
 8015358:	4603      	mov	r3, r0
 801535a:	2b00      	cmp	r3, #0
 801535c:	d101      	bne.n	8015362 <next_marker+0x32>
 801535e:	2300      	movs	r3, #0
 8015360:	e094      	b.n	801548c <next_marker+0x15c>
 8015362:	68bb      	ldr	r3, [r7, #8]
 8015364:	681b      	ldr	r3, [r3, #0]
 8015366:	613b      	str	r3, [r7, #16]
 8015368:	68bb      	ldr	r3, [r7, #8]
 801536a:	685b      	ldr	r3, [r3, #4]
 801536c:	60fb      	str	r3, [r7, #12]
 801536e:	68fb      	ldr	r3, [r7, #12]
 8015370:	3b01      	subs	r3, #1
 8015372:	60fb      	str	r3, [r7, #12]
 8015374:	693b      	ldr	r3, [r7, #16]
 8015376:	1c5a      	adds	r2, r3, #1
 8015378:	613a      	str	r2, [r7, #16]
 801537a:	781b      	ldrb	r3, [r3, #0]
 801537c:	617b      	str	r3, [r7, #20]
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
 801537e:	e025      	b.n	80153cc <next_marker+0x9c>
      cinfo->marker->discarded_bytes++;
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015386:	699a      	ldr	r2, [r3, #24]
 8015388:	3201      	adds	r2, #1
 801538a:	619a      	str	r2, [r3, #24]
      INPUT_SYNC(cinfo);
 801538c:	68bb      	ldr	r3, [r7, #8]
 801538e:	693a      	ldr	r2, [r7, #16]
 8015390:	601a      	str	r2, [r3, #0]
 8015392:	68bb      	ldr	r3, [r7, #8]
 8015394:	68fa      	ldr	r2, [r7, #12]
 8015396:	605a      	str	r2, [r3, #4]
      INPUT_BYTE(cinfo, c, return FALSE);
 8015398:	68fb      	ldr	r3, [r7, #12]
 801539a:	2b00      	cmp	r3, #0
 801539c:	d10e      	bne.n	80153bc <next_marker+0x8c>
 801539e:	68bb      	ldr	r3, [r7, #8]
 80153a0:	68db      	ldr	r3, [r3, #12]
 80153a2:	6878      	ldr	r0, [r7, #4]
 80153a4:	4798      	blx	r3
 80153a6:	4603      	mov	r3, r0
 80153a8:	2b00      	cmp	r3, #0
 80153aa:	d101      	bne.n	80153b0 <next_marker+0x80>
 80153ac:	2300      	movs	r3, #0
 80153ae:	e06d      	b.n	801548c <next_marker+0x15c>
 80153b0:	68bb      	ldr	r3, [r7, #8]
 80153b2:	681b      	ldr	r3, [r3, #0]
 80153b4:	613b      	str	r3, [r7, #16]
 80153b6:	68bb      	ldr	r3, [r7, #8]
 80153b8:	685b      	ldr	r3, [r3, #4]
 80153ba:	60fb      	str	r3, [r7, #12]
 80153bc:	68fb      	ldr	r3, [r7, #12]
 80153be:	3b01      	subs	r3, #1
 80153c0:	60fb      	str	r3, [r7, #12]
 80153c2:	693b      	ldr	r3, [r7, #16]
 80153c4:	1c5a      	adds	r2, r3, #1
 80153c6:	613a      	str	r2, [r7, #16]
 80153c8:	781b      	ldrb	r3, [r3, #0]
 80153ca:	617b      	str	r3, [r7, #20]
    while (c != 0xFF) {
 80153cc:	697b      	ldr	r3, [r7, #20]
 80153ce:	2bff      	cmp	r3, #255	; 0xff
 80153d0:	d1d6      	bne.n	8015380 <next_marker+0x50>
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
 80153d2:	68fb      	ldr	r3, [r7, #12]
 80153d4:	2b00      	cmp	r3, #0
 80153d6:	d10e      	bne.n	80153f6 <next_marker+0xc6>
 80153d8:	68bb      	ldr	r3, [r7, #8]
 80153da:	68db      	ldr	r3, [r3, #12]
 80153dc:	6878      	ldr	r0, [r7, #4]
 80153de:	4798      	blx	r3
 80153e0:	4603      	mov	r3, r0
 80153e2:	2b00      	cmp	r3, #0
 80153e4:	d101      	bne.n	80153ea <next_marker+0xba>
 80153e6:	2300      	movs	r3, #0
 80153e8:	e050      	b.n	801548c <next_marker+0x15c>
 80153ea:	68bb      	ldr	r3, [r7, #8]
 80153ec:	681b      	ldr	r3, [r3, #0]
 80153ee:	613b      	str	r3, [r7, #16]
 80153f0:	68bb      	ldr	r3, [r7, #8]
 80153f2:	685b      	ldr	r3, [r3, #4]
 80153f4:	60fb      	str	r3, [r7, #12]
 80153f6:	68fb      	ldr	r3, [r7, #12]
 80153f8:	3b01      	subs	r3, #1
 80153fa:	60fb      	str	r3, [r7, #12]
 80153fc:	693b      	ldr	r3, [r7, #16]
 80153fe:	1c5a      	adds	r2, r3, #1
 8015400:	613a      	str	r2, [r7, #16]
 8015402:	781b      	ldrb	r3, [r3, #0]
 8015404:	617b      	str	r3, [r7, #20]
    } while (c == 0xFF);
 8015406:	697b      	ldr	r3, [r7, #20]
 8015408:	2bff      	cmp	r3, #255	; 0xff
 801540a:	d0e2      	beq.n	80153d2 <next_marker+0xa2>
    if (c != 0)
 801540c:	697b      	ldr	r3, [r7, #20]
 801540e:	2b00      	cmp	r3, #0
 8015410:	d10f      	bne.n	8015432 <next_marker+0x102>
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
 8015412:	687b      	ldr	r3, [r7, #4]
 8015414:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015418:	699a      	ldr	r2, [r3, #24]
 801541a:	687b      	ldr	r3, [r7, #4]
 801541c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015420:	3202      	adds	r2, #2
 8015422:	619a      	str	r2, [r3, #24]
    INPUT_SYNC(cinfo);
 8015424:	68bb      	ldr	r3, [r7, #8]
 8015426:	693a      	ldr	r2, [r7, #16]
 8015428:	601a      	str	r2, [r3, #0]
 801542a:	68bb      	ldr	r3, [r7, #8]
 801542c:	68fa      	ldr	r2, [r7, #12]
 801542e:	605a      	str	r2, [r3, #4]
    INPUT_BYTE(cinfo, c, return FALSE);
 8015430:	e78b      	b.n	801534a <next_marker+0x1a>
      break;			/* found a valid marker, exit loop */
 8015432:	bf00      	nop
  }

  if (cinfo->marker->discarded_bytes != 0) {
 8015434:	687b      	ldr	r3, [r7, #4]
 8015436:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801543a:	699b      	ldr	r3, [r3, #24]
 801543c:	2b00      	cmp	r3, #0
 801543e:	d01a      	beq.n	8015476 <next_marker+0x146>
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
 8015440:	687b      	ldr	r3, [r7, #4]
 8015442:	681b      	ldr	r3, [r3, #0]
 8015444:	2277      	movs	r2, #119	; 0x77
 8015446:	615a      	str	r2, [r3, #20]
 8015448:	687b      	ldr	r3, [r7, #4]
 801544a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801544e:	699a      	ldr	r2, [r3, #24]
 8015450:	687b      	ldr	r3, [r7, #4]
 8015452:	681b      	ldr	r3, [r3, #0]
 8015454:	619a      	str	r2, [r3, #24]
 8015456:	687b      	ldr	r3, [r7, #4]
 8015458:	681b      	ldr	r3, [r3, #0]
 801545a:	697a      	ldr	r2, [r7, #20]
 801545c:	61da      	str	r2, [r3, #28]
 801545e:	687b      	ldr	r3, [r7, #4]
 8015460:	681b      	ldr	r3, [r3, #0]
 8015462:	685b      	ldr	r3, [r3, #4]
 8015464:	f04f 31ff 	mov.w	r1, #4294967295
 8015468:	6878      	ldr	r0, [r7, #4]
 801546a:	4798      	blx	r3
    cinfo->marker->discarded_bytes = 0;
 801546c:	687b      	ldr	r3, [r7, #4]
 801546e:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015472:	2200      	movs	r2, #0
 8015474:	619a      	str	r2, [r3, #24]
  }

  cinfo->unread_marker = c;
 8015476:	687b      	ldr	r3, [r7, #4]
 8015478:	697a      	ldr	r2, [r7, #20]
 801547a:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4

  INPUT_SYNC(cinfo);
 801547e:	68bb      	ldr	r3, [r7, #8]
 8015480:	693a      	ldr	r2, [r7, #16]
 8015482:	601a      	str	r2, [r3, #0]
 8015484:	68bb      	ldr	r3, [r7, #8]
 8015486:	68fa      	ldr	r2, [r7, #12]
 8015488:	605a      	str	r2, [r3, #4]
  return TRUE;
 801548a:	2301      	movs	r3, #1
}
 801548c:	4618      	mov	r0, r3
 801548e:	3718      	adds	r7, #24
 8015490:	46bd      	mov	sp, r7
 8015492:	bd80      	pop	{r7, pc}

08015494 <first_marker>:
/* For this marker, we do not allow preceding garbage or fill; otherwise,
 * we might well scan an entire input file before realizing it ain't JPEG.
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
 8015494:	b580      	push	{r7, lr}
 8015496:	b088      	sub	sp, #32
 8015498:	af00      	add	r7, sp, #0
 801549a:	6078      	str	r0, [r7, #4]
  int c, c2;
  INPUT_VARS(cinfo);
 801549c:	687b      	ldr	r3, [r7, #4]
 801549e:	699b      	ldr	r3, [r3, #24]
 80154a0:	617b      	str	r3, [r7, #20]
 80154a2:	697b      	ldr	r3, [r7, #20]
 80154a4:	681b      	ldr	r3, [r3, #0]
 80154a6:	61fb      	str	r3, [r7, #28]
 80154a8:	697b      	ldr	r3, [r7, #20]
 80154aa:	685b      	ldr	r3, [r3, #4]
 80154ac:	61bb      	str	r3, [r7, #24]

  INPUT_BYTE(cinfo, c, return FALSE);
 80154ae:	69bb      	ldr	r3, [r7, #24]
 80154b0:	2b00      	cmp	r3, #0
 80154b2:	d10e      	bne.n	80154d2 <first_marker+0x3e>
 80154b4:	697b      	ldr	r3, [r7, #20]
 80154b6:	68db      	ldr	r3, [r3, #12]
 80154b8:	6878      	ldr	r0, [r7, #4]
 80154ba:	4798      	blx	r3
 80154bc:	4603      	mov	r3, r0
 80154be:	2b00      	cmp	r3, #0
 80154c0:	d101      	bne.n	80154c6 <first_marker+0x32>
 80154c2:	2300      	movs	r3, #0
 80154c4:	e049      	b.n	801555a <first_marker+0xc6>
 80154c6:	697b      	ldr	r3, [r7, #20]
 80154c8:	681b      	ldr	r3, [r3, #0]
 80154ca:	61fb      	str	r3, [r7, #28]
 80154cc:	697b      	ldr	r3, [r7, #20]
 80154ce:	685b      	ldr	r3, [r3, #4]
 80154d0:	61bb      	str	r3, [r7, #24]
 80154d2:	69bb      	ldr	r3, [r7, #24]
 80154d4:	3b01      	subs	r3, #1
 80154d6:	61bb      	str	r3, [r7, #24]
 80154d8:	69fb      	ldr	r3, [r7, #28]
 80154da:	1c5a      	adds	r2, r3, #1
 80154dc:	61fa      	str	r2, [r7, #28]
 80154de:	781b      	ldrb	r3, [r3, #0]
 80154e0:	613b      	str	r3, [r7, #16]
  INPUT_BYTE(cinfo, c2, return FALSE);
 80154e2:	69bb      	ldr	r3, [r7, #24]
 80154e4:	2b00      	cmp	r3, #0
 80154e6:	d10e      	bne.n	8015506 <first_marker+0x72>
 80154e8:	697b      	ldr	r3, [r7, #20]
 80154ea:	68db      	ldr	r3, [r3, #12]
 80154ec:	6878      	ldr	r0, [r7, #4]
 80154ee:	4798      	blx	r3
 80154f0:	4603      	mov	r3, r0
 80154f2:	2b00      	cmp	r3, #0
 80154f4:	d101      	bne.n	80154fa <first_marker+0x66>
 80154f6:	2300      	movs	r3, #0
 80154f8:	e02f      	b.n	801555a <first_marker+0xc6>
 80154fa:	697b      	ldr	r3, [r7, #20]
 80154fc:	681b      	ldr	r3, [r3, #0]
 80154fe:	61fb      	str	r3, [r7, #28]
 8015500:	697b      	ldr	r3, [r7, #20]
 8015502:	685b      	ldr	r3, [r3, #4]
 8015504:	61bb      	str	r3, [r7, #24]
 8015506:	69bb      	ldr	r3, [r7, #24]
 8015508:	3b01      	subs	r3, #1
 801550a:	61bb      	str	r3, [r7, #24]
 801550c:	69fb      	ldr	r3, [r7, #28]
 801550e:	1c5a      	adds	r2, r3, #1
 8015510:	61fa      	str	r2, [r7, #28]
 8015512:	781b      	ldrb	r3, [r3, #0]
 8015514:	60fb      	str	r3, [r7, #12]
  if (c != 0xFF || c2 != (int) M_SOI)
 8015516:	693b      	ldr	r3, [r7, #16]
 8015518:	2bff      	cmp	r3, #255	; 0xff
 801551a:	d102      	bne.n	8015522 <first_marker+0x8e>
 801551c:	68fb      	ldr	r3, [r7, #12]
 801551e:	2bd8      	cmp	r3, #216	; 0xd8
 8015520:	d010      	beq.n	8015544 <first_marker+0xb0>
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);
 8015522:	687b      	ldr	r3, [r7, #4]
 8015524:	681b      	ldr	r3, [r3, #0]
 8015526:	2237      	movs	r2, #55	; 0x37
 8015528:	615a      	str	r2, [r3, #20]
 801552a:	687b      	ldr	r3, [r7, #4]
 801552c:	681b      	ldr	r3, [r3, #0]
 801552e:	693a      	ldr	r2, [r7, #16]
 8015530:	619a      	str	r2, [r3, #24]
 8015532:	687b      	ldr	r3, [r7, #4]
 8015534:	681b      	ldr	r3, [r3, #0]
 8015536:	68fa      	ldr	r2, [r7, #12]
 8015538:	61da      	str	r2, [r3, #28]
 801553a:	687b      	ldr	r3, [r7, #4]
 801553c:	681b      	ldr	r3, [r3, #0]
 801553e:	681b      	ldr	r3, [r3, #0]
 8015540:	6878      	ldr	r0, [r7, #4]
 8015542:	4798      	blx	r3

  cinfo->unread_marker = c2;
 8015544:	687b      	ldr	r3, [r7, #4]
 8015546:	68fa      	ldr	r2, [r7, #12]
 8015548:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4

  INPUT_SYNC(cinfo);
 801554c:	697b      	ldr	r3, [r7, #20]
 801554e:	69fa      	ldr	r2, [r7, #28]
 8015550:	601a      	str	r2, [r3, #0]
 8015552:	697b      	ldr	r3, [r7, #20]
 8015554:	69ba      	ldr	r2, [r7, #24]
 8015556:	605a      	str	r2, [r3, #4]
  return TRUE;
 8015558:	2301      	movs	r3, #1
}
 801555a:	4618      	mov	r0, r3
 801555c:	3720      	adds	r7, #32
 801555e:	46bd      	mov	sp, r7
 8015560:	bd80      	pop	{r7, pc}
	...

08015564 <read_markers>:
 * after processing for the caller.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
 8015564:	b580      	push	{r7, lr}
 8015566:	b082      	sub	sp, #8
 8015568:	af00      	add	r7, sp, #0
 801556a:	6078      	str	r0, [r7, #4]
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
 801556c:	687b      	ldr	r3, [r7, #4]
 801556e:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 8015572:	2b00      	cmp	r3, #0
 8015574:	d115      	bne.n	80155a2 <read_markers+0x3e>
      if (! cinfo->marker->saw_SOI) {
 8015576:	687b      	ldr	r3, [r7, #4]
 8015578:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801557c:	68db      	ldr	r3, [r3, #12]
 801557e:	2b00      	cmp	r3, #0
 8015580:	d107      	bne.n	8015592 <read_markers+0x2e>
	if (! first_marker(cinfo))
 8015582:	6878      	ldr	r0, [r7, #4]
 8015584:	f7ff ff86 	bl	8015494 <first_marker>
 8015588:	4603      	mov	r3, r0
 801558a:	2b00      	cmp	r3, #0
 801558c:	d109      	bne.n	80155a2 <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801558e:	2300      	movs	r3, #0
 8015590:	e192      	b.n	80158b8 <read_markers+0x354>
      } else {
	if (! next_marker(cinfo))
 8015592:	6878      	ldr	r0, [r7, #4]
 8015594:	f7ff fecc 	bl	8015330 <next_marker>
 8015598:	4603      	mov	r3, r0
 801559a:	2b00      	cmp	r3, #0
 801559c:	d101      	bne.n	80155a2 <read_markers+0x3e>
	  return JPEG_SUSPENDED;
 801559e:	2300      	movs	r3, #0
 80155a0:	e18a      	b.n	80158b8 <read_markers+0x354>
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
 80155a2:	687b      	ldr	r3, [r7, #4]
 80155a4:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80155a8:	2b01      	cmp	r3, #1
 80155aa:	f000 813e 	beq.w	801582a <read_markers+0x2c6>
 80155ae:	2b00      	cmp	r3, #0
 80155b0:	f340 8154 	ble.w	801585c <read_markers+0x2f8>
 80155b4:	2bfe      	cmp	r3, #254	; 0xfe
 80155b6:	f300 8151 	bgt.w	801585c <read_markers+0x2f8>
 80155ba:	2bc0      	cmp	r3, #192	; 0xc0
 80155bc:	f2c0 814e 	blt.w	801585c <read_markers+0x2f8>
 80155c0:	3bc0      	subs	r3, #192	; 0xc0
 80155c2:	2b3e      	cmp	r3, #62	; 0x3e
 80155c4:	f200 814a 	bhi.w	801585c <read_markers+0x2f8>
 80155c8:	a201      	add	r2, pc, #4	; (adr r2, 80155d0 <read_markers+0x6c>)
 80155ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80155ce:	bf00      	nop
 80155d0:	080156df 	.word	0x080156df
 80155d4:	080156f7 	.word	0x080156f7
 80155d8:	0801570f 	.word	0x0801570f
 80155dc:	08015757 	.word	0x08015757
 80155e0:	080157c3 	.word	0x080157c3
 80155e4:	08015757 	.word	0x08015757
 80155e8:	08015757 	.word	0x08015757
 80155ec:	08015757 	.word	0x08015757
 80155f0:	08015757 	.word	0x08015757
 80155f4:	08015727 	.word	0x08015727
 80155f8:	0801573f 	.word	0x0801573f
 80155fc:	08015757 	.word	0x08015757
 8015600:	080157b3 	.word	0x080157b3
 8015604:	08015757 	.word	0x08015757
 8015608:	08015757 	.word	0x08015757
 801560c:	08015757 	.word	0x08015757
 8015610:	0801582b 	.word	0x0801582b
 8015614:	0801582b 	.word	0x0801582b
 8015618:	0801582b 	.word	0x0801582b
 801561c:	0801582b 	.word	0x0801582b
 8015620:	0801582b 	.word	0x0801582b
 8015624:	0801582b 	.word	0x0801582b
 8015628:	0801582b 	.word	0x0801582b
 801562c:	0801582b 	.word	0x0801582b
 8015630:	080156cd 	.word	0x080156cd
 8015634:	08015793 	.word	0x08015793
 8015638:	08015777 	.word	0x08015777
 801563c:	080157d3 	.word	0x080157d3
 8015640:	0801584d 	.word	0x0801584d
 8015644:	080157e3 	.word	0x080157e3
 8015648:	0801585d 	.word	0x0801585d
 801564c:	0801585d 	.word	0x0801585d
 8015650:	080157f3 	.word	0x080157f3
 8015654:	080157f3 	.word	0x080157f3
 8015658:	080157f3 	.word	0x080157f3
 801565c:	080157f3 	.word	0x080157f3
 8015660:	080157f3 	.word	0x080157f3
 8015664:	080157f3 	.word	0x080157f3
 8015668:	080157f3 	.word	0x080157f3
 801566c:	080157f3 	.word	0x080157f3
 8015670:	080157f3 	.word	0x080157f3
 8015674:	080157f3 	.word	0x080157f3
 8015678:	080157f3 	.word	0x080157f3
 801567c:	080157f3 	.word	0x080157f3
 8015680:	080157f3 	.word	0x080157f3
 8015684:	080157f3 	.word	0x080157f3
 8015688:	080157f3 	.word	0x080157f3
 801568c:	080157f3 	.word	0x080157f3
 8015690:	0801585d 	.word	0x0801585d
 8015694:	0801585d 	.word	0x0801585d
 8015698:	0801585d 	.word	0x0801585d
 801569c:	0801585d 	.word	0x0801585d
 80156a0:	0801585d 	.word	0x0801585d
 80156a4:	0801585d 	.word	0x0801585d
 80156a8:	0801585d 	.word	0x0801585d
 80156ac:	0801585d 	.word	0x0801585d
 80156b0:	0801585d 	.word	0x0801585d
 80156b4:	0801585d 	.word	0x0801585d
 80156b8:	0801585d 	.word	0x0801585d
 80156bc:	0801585d 	.word	0x0801585d
 80156c0:	0801585d 	.word	0x0801585d
 80156c4:	0801585d 	.word	0x0801585d
 80156c8:	08015815 	.word	0x08015815
    case M_SOI:
      if (! get_soi(cinfo))
 80156cc:	6878      	ldr	r0, [r7, #4]
 80156ce:	f7fe f88b 	bl	80137e8 <get_soi>
 80156d2:	4603      	mov	r3, r0
 80156d4:	2b00      	cmp	r3, #0
 80156d6:	f040 80d1 	bne.w	801587c <read_markers+0x318>
	return JPEG_SUSPENDED;
 80156da:	2300      	movs	r3, #0
 80156dc:	e0ec      	b.n	80158b8 <read_markers+0x354>
      break;

    case M_SOF0:		/* Baseline */
      if (! get_sof(cinfo, TRUE, FALSE, FALSE))
 80156de:	2300      	movs	r3, #0
 80156e0:	2200      	movs	r2, #0
 80156e2:	2101      	movs	r1, #1
 80156e4:	6878      	ldr	r0, [r7, #4]
 80156e6:	f7fe f8ee 	bl	80138c6 <get_sof>
 80156ea:	4603      	mov	r3, r0
 80156ec:	2b00      	cmp	r3, #0
 80156ee:	f040 80c7 	bne.w	8015880 <read_markers+0x31c>
	return JPEG_SUSPENDED;
 80156f2:	2300      	movs	r3, #0
 80156f4:	e0e0      	b.n	80158b8 <read_markers+0x354>
      break;

    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE, FALSE))
 80156f6:	2300      	movs	r3, #0
 80156f8:	2200      	movs	r2, #0
 80156fa:	2100      	movs	r1, #0
 80156fc:	6878      	ldr	r0, [r7, #4]
 80156fe:	f7fe f8e2 	bl	80138c6 <get_sof>
 8015702:	4603      	mov	r3, r0
 8015704:	2b00      	cmp	r3, #0
 8015706:	f040 80bd 	bne.w	8015884 <read_markers+0x320>
	return JPEG_SUSPENDED;
 801570a:	2300      	movs	r3, #0
 801570c:	e0d4      	b.n	80158b8 <read_markers+0x354>
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, FALSE, TRUE, FALSE))
 801570e:	2300      	movs	r3, #0
 8015710:	2201      	movs	r2, #1
 8015712:	2100      	movs	r1, #0
 8015714:	6878      	ldr	r0, [r7, #4]
 8015716:	f7fe f8d6 	bl	80138c6 <get_sof>
 801571a:	4603      	mov	r3, r0
 801571c:	2b00      	cmp	r3, #0
 801571e:	f040 80b3 	bne.w	8015888 <read_markers+0x324>
	return JPEG_SUSPENDED;
 8015722:	2300      	movs	r3, #0
 8015724:	e0c8      	b.n	80158b8 <read_markers+0x354>
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, FALSE, TRUE))
 8015726:	2301      	movs	r3, #1
 8015728:	2200      	movs	r2, #0
 801572a:	2100      	movs	r1, #0
 801572c:	6878      	ldr	r0, [r7, #4]
 801572e:	f7fe f8ca 	bl	80138c6 <get_sof>
 8015732:	4603      	mov	r3, r0
 8015734:	2b00      	cmp	r3, #0
 8015736:	f040 80a9 	bne.w	801588c <read_markers+0x328>
	return JPEG_SUSPENDED;
 801573a:	2300      	movs	r3, #0
 801573c:	e0bc      	b.n	80158b8 <read_markers+0x354>
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE, TRUE))
 801573e:	2301      	movs	r3, #1
 8015740:	2201      	movs	r2, #1
 8015742:	2100      	movs	r1, #0
 8015744:	6878      	ldr	r0, [r7, #4]
 8015746:	f7fe f8be 	bl	80138c6 <get_sof>
 801574a:	4603      	mov	r3, r0
 801574c:	2b00      	cmp	r3, #0
 801574e:	f040 809f 	bne.w	8015890 <read_markers+0x32c>
	return JPEG_SUSPENDED;
 8015752:	2300      	movs	r3, #0
 8015754:	e0b0      	b.n	80158b8 <read_markers+0x354>
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
 8015756:	687b      	ldr	r3, [r7, #4]
 8015758:	681b      	ldr	r3, [r3, #0]
 801575a:	223e      	movs	r2, #62	; 0x3e
 801575c:	615a      	str	r2, [r3, #20]
 801575e:	687b      	ldr	r3, [r7, #4]
 8015760:	681b      	ldr	r3, [r3, #0]
 8015762:	687a      	ldr	r2, [r7, #4]
 8015764:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 8015768:	619a      	str	r2, [r3, #24]
 801576a:	687b      	ldr	r3, [r7, #4]
 801576c:	681b      	ldr	r3, [r3, #0]
 801576e:	681b      	ldr	r3, [r3, #0]
 8015770:	6878      	ldr	r0, [r7, #4]
 8015772:	4798      	blx	r3
      break;
 8015774:	e09b      	b.n	80158ae <read_markers+0x34a>

    case M_SOS:
      if (! get_sos(cinfo))
 8015776:	6878      	ldr	r0, [r7, #4]
 8015778:	f7fe fab9 	bl	8013cee <get_sos>
 801577c:	4603      	mov	r3, r0
 801577e:	2b00      	cmp	r3, #0
 8015780:	d101      	bne.n	8015786 <read_markers+0x222>
	return JPEG_SUSPENDED;
 8015782:	2300      	movs	r3, #0
 8015784:	e098      	b.n	80158b8 <read_markers+0x354>
      cinfo->unread_marker = 0;	/* processed the marker */
 8015786:	687b      	ldr	r3, [r7, #4]
 8015788:	2200      	movs	r2, #0
 801578a:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
      return JPEG_REACHED_SOS;
 801578e:	2301      	movs	r3, #1
 8015790:	e092      	b.n	80158b8 <read_markers+0x354>
    
    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
 8015792:	687b      	ldr	r3, [r7, #4]
 8015794:	681b      	ldr	r3, [r3, #0]
 8015796:	2257      	movs	r2, #87	; 0x57
 8015798:	615a      	str	r2, [r3, #20]
 801579a:	687b      	ldr	r3, [r7, #4]
 801579c:	681b      	ldr	r3, [r3, #0]
 801579e:	685b      	ldr	r3, [r3, #4]
 80157a0:	2101      	movs	r1, #1
 80157a2:	6878      	ldr	r0, [r7, #4]
 80157a4:	4798      	blx	r3
      cinfo->unread_marker = 0;	/* processed the marker */
 80157a6:	687b      	ldr	r3, [r7, #4]
 80157a8:	2200      	movs	r2, #0
 80157aa:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
      return JPEG_REACHED_EOI;
 80157ae:	2302      	movs	r3, #2
 80157b0:	e082      	b.n	80158b8 <read_markers+0x354>
      
    case M_DAC:
      if (! get_dac(cinfo))
 80157b2:	6878      	ldr	r0, [r7, #4]
 80157b4:	f7fe fc69 	bl	801408a <get_dac>
 80157b8:	4603      	mov	r3, r0
 80157ba:	2b00      	cmp	r3, #0
 80157bc:	d16a      	bne.n	8015894 <read_markers+0x330>
	return JPEG_SUSPENDED;
 80157be:	2300      	movs	r3, #0
 80157c0:	e07a      	b.n	80158b8 <read_markers+0x354>
      break;
      
    case M_DHT:
      if (! get_dht(cinfo))
 80157c2:	6878      	ldr	r0, [r7, #4]
 80157c4:	f7fe fd5b 	bl	801427e <get_dht>
 80157c8:	4603      	mov	r3, r0
 80157ca:	2b00      	cmp	r3, #0
 80157cc:	d164      	bne.n	8015898 <read_markers+0x334>
	return JPEG_SUSPENDED;
 80157ce:	2300      	movs	r3, #0
 80157d0:	e072      	b.n	80158b8 <read_markers+0x354>
      break;
      
    case M_DQT:
      if (! get_dqt(cinfo))
 80157d2:	6878      	ldr	r0, [r7, #4]
 80157d4:	f7fe ffac 	bl	8014730 <get_dqt>
 80157d8:	4603      	mov	r3, r0
 80157da:	2b00      	cmp	r3, #0
 80157dc:	d15e      	bne.n	801589c <read_markers+0x338>
	return JPEG_SUSPENDED;
 80157de:	2300      	movs	r3, #0
 80157e0:	e06a      	b.n	80158b8 <read_markers+0x354>
      break;
      
    case M_DRI:
      if (! get_dri(cinfo))
 80157e2:	6878      	ldr	r0, [r7, #4]
 80157e4:	f7ff f9ee 	bl	8014bc4 <get_dri>
 80157e8:	4603      	mov	r3, r0
 80157ea:	2b00      	cmp	r3, #0
 80157ec:	d158      	bne.n	80158a0 <read_markers+0x33c>
	return JPEG_SUSPENDED;
 80157ee:	2300      	movs	r3, #0
 80157f0:	e062      	b.n	80158b8 <read_markers+0x354>
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 80157f2:	687b      	ldr	r3, [r7, #4]
 80157f4:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
		cinfo->unread_marker - (int) M_APP0]) (cinfo))
 80157f8:	687a      	ldr	r2, [r7, #4]
 80157fa:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 80157fe:	3ae0      	subs	r2, #224	; 0xe0
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
 8015800:	3208      	adds	r2, #8
 8015802:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8015806:	6878      	ldr	r0, [r7, #4]
 8015808:	4798      	blx	r3
 801580a:	4603      	mov	r3, r0
 801580c:	2b00      	cmp	r3, #0
 801580e:	d149      	bne.n	80158a4 <read_markers+0x340>
	return JPEG_SUSPENDED;
 8015810:	2300      	movs	r3, #0
 8015812:	e051      	b.n	80158b8 <read_markers+0x354>
      break;
      
    case M_COM:
      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
 8015814:	687b      	ldr	r3, [r7, #4]
 8015816:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 801581a:	69db      	ldr	r3, [r3, #28]
 801581c:	6878      	ldr	r0, [r7, #4]
 801581e:	4798      	blx	r3
 8015820:	4603      	mov	r3, r0
 8015822:	2b00      	cmp	r3, #0
 8015824:	d140      	bne.n	80158a8 <read_markers+0x344>
	return JPEG_SUSPENDED;
 8015826:	2300      	movs	r3, #0
 8015828:	e046      	b.n	80158b8 <read_markers+0x354>
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
 801582a:	687b      	ldr	r3, [r7, #4]
 801582c:	681b      	ldr	r3, [r3, #0]
 801582e:	225e      	movs	r2, #94	; 0x5e
 8015830:	615a      	str	r2, [r3, #20]
 8015832:	687b      	ldr	r3, [r7, #4]
 8015834:	681b      	ldr	r3, [r3, #0]
 8015836:	687a      	ldr	r2, [r7, #4]
 8015838:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 801583c:	619a      	str	r2, [r3, #24]
 801583e:	687b      	ldr	r3, [r7, #4]
 8015840:	681b      	ldr	r3, [r3, #0]
 8015842:	685b      	ldr	r3, [r3, #4]
 8015844:	2101      	movs	r1, #1
 8015846:	6878      	ldr	r0, [r7, #4]
 8015848:	4798      	blx	r3
      break;
 801584a:	e030      	b.n	80158ae <read_markers+0x34a>

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
 801584c:	6878      	ldr	r0, [r7, #4]
 801584e:	f7ff fcff 	bl	8015250 <skip_variable>
 8015852:	4603      	mov	r3, r0
 8015854:	2b00      	cmp	r3, #0
 8015856:	d129      	bne.n	80158ac <read_markers+0x348>
	return JPEG_SUSPENDED;
 8015858:	2300      	movs	r3, #0
 801585a:	e02d      	b.n	80158b8 <read_markers+0x354>
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
 801585c:	687b      	ldr	r3, [r7, #4]
 801585e:	681b      	ldr	r3, [r3, #0]
 8015860:	2246      	movs	r2, #70	; 0x46
 8015862:	615a      	str	r2, [r3, #20]
 8015864:	687b      	ldr	r3, [r7, #4]
 8015866:	681b      	ldr	r3, [r3, #0]
 8015868:	687a      	ldr	r2, [r7, #4]
 801586a:	f8d2 21b4 	ldr.w	r2, [r2, #436]	; 0x1b4
 801586e:	619a      	str	r2, [r3, #24]
 8015870:	687b      	ldr	r3, [r7, #4]
 8015872:	681b      	ldr	r3, [r3, #0]
 8015874:	681b      	ldr	r3, [r3, #0]
 8015876:	6878      	ldr	r0, [r7, #4]
 8015878:	4798      	blx	r3
      break;
 801587a:	e018      	b.n	80158ae <read_markers+0x34a>
      break;
 801587c:	bf00      	nop
 801587e:	e016      	b.n	80158ae <read_markers+0x34a>
      break;
 8015880:	bf00      	nop
 8015882:	e014      	b.n	80158ae <read_markers+0x34a>
      break;
 8015884:	bf00      	nop
 8015886:	e012      	b.n	80158ae <read_markers+0x34a>
      break;
 8015888:	bf00      	nop
 801588a:	e010      	b.n	80158ae <read_markers+0x34a>
      break;
 801588c:	bf00      	nop
 801588e:	e00e      	b.n	80158ae <read_markers+0x34a>
      break;
 8015890:	bf00      	nop
 8015892:	e00c      	b.n	80158ae <read_markers+0x34a>
      break;
 8015894:	bf00      	nop
 8015896:	e00a      	b.n	80158ae <read_markers+0x34a>
      break;
 8015898:	bf00      	nop
 801589a:	e008      	b.n	80158ae <read_markers+0x34a>
      break;
 801589c:	bf00      	nop
 801589e:	e006      	b.n	80158ae <read_markers+0x34a>
      break;
 80158a0:	bf00      	nop
 80158a2:	e004      	b.n	80158ae <read_markers+0x34a>
      break;
 80158a4:	bf00      	nop
 80158a6:	e002      	b.n	80158ae <read_markers+0x34a>
      break;
 80158a8:	bf00      	nop
 80158aa:	e000      	b.n	80158ae <read_markers+0x34a>
      break;
 80158ac:	bf00      	nop
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
 80158ae:	687b      	ldr	r3, [r7, #4]
 80158b0:	2200      	movs	r2, #0
 80158b2:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
    if (cinfo->unread_marker == 0) {
 80158b6:	e659      	b.n	801556c <read_markers+0x8>
  } /* end loop */
}
 80158b8:	4618      	mov	r0, r3
 80158ba:	3708      	adds	r7, #8
 80158bc:	46bd      	mov	sp, r7
 80158be:	bd80      	pop	{r7, pc}

080158c0 <read_restart_marker>:
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
 80158c0:	b580      	push	{r7, lr}
 80158c2:	b082      	sub	sp, #8
 80158c4:	af00      	add	r7, sp, #0
 80158c6:	6078      	str	r0, [r7, #4]
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
 80158c8:	687b      	ldr	r3, [r7, #4]
 80158ca:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80158ce:	2b00      	cmp	r3, #0
 80158d0:	d107      	bne.n	80158e2 <read_restart_marker+0x22>
    if (! next_marker(cinfo))
 80158d2:	6878      	ldr	r0, [r7, #4]
 80158d4:	f7ff fd2c 	bl	8015330 <next_marker>
 80158d8:	4603      	mov	r3, r0
 80158da:	2b00      	cmp	r3, #0
 80158dc:	d101      	bne.n	80158e2 <read_restart_marker+0x22>
      return FALSE;
 80158de:	2300      	movs	r3, #0
 80158e0:	e03a      	b.n	8015958 <read_restart_marker+0x98>
  }

  if (cinfo->unread_marker ==
 80158e2:	687b      	ldr	r3, [r7, #4]
 80158e4:	f8d3 21b4 	ldr.w	r2, [r3, #436]	; 0x1b4
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
 80158e8:	687b      	ldr	r3, [r7, #4]
 80158ea:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 80158ee:	695b      	ldr	r3, [r3, #20]
 80158f0:	33d0      	adds	r3, #208	; 0xd0
  if (cinfo->unread_marker ==
 80158f2:	429a      	cmp	r2, r3
 80158f4:	d115      	bne.n	8015922 <read_restart_marker+0x62>
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
 80158f6:	687b      	ldr	r3, [r7, #4]
 80158f8:	681b      	ldr	r3, [r3, #0]
 80158fa:	2264      	movs	r2, #100	; 0x64
 80158fc:	615a      	str	r2, [r3, #20]
 80158fe:	687b      	ldr	r3, [r7, #4]
 8015900:	f8d3 21cc 	ldr.w	r2, [r3, #460]	; 0x1cc
 8015904:	687b      	ldr	r3, [r7, #4]
 8015906:	681b      	ldr	r3, [r3, #0]
 8015908:	6952      	ldr	r2, [r2, #20]
 801590a:	619a      	str	r2, [r3, #24]
 801590c:	687b      	ldr	r3, [r7, #4]
 801590e:	681b      	ldr	r3, [r3, #0]
 8015910:	685b      	ldr	r3, [r3, #4]
 8015912:	2103      	movs	r1, #3
 8015914:	6878      	ldr	r0, [r7, #4]
 8015916:	4798      	blx	r3
    cinfo->unread_marker = 0;
 8015918:	687b      	ldr	r3, [r7, #4]
 801591a:	2200      	movs	r2, #0
 801591c:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
 8015920:	e00e      	b.n	8015940 <read_restart_marker+0x80>
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 8015922:	687b      	ldr	r3, [r7, #4]
 8015924:	699b      	ldr	r3, [r3, #24]
 8015926:	695b      	ldr	r3, [r3, #20]
					    cinfo->marker->next_restart_num))
 8015928:	687a      	ldr	r2, [r7, #4]
 801592a:	f8d2 21cc 	ldr.w	r2, [r2, #460]	; 0x1cc
    if (! (*cinfo->src->resync_to_restart) (cinfo,
 801592e:	6952      	ldr	r2, [r2, #20]
 8015930:	4611      	mov	r1, r2
 8015932:	6878      	ldr	r0, [r7, #4]
 8015934:	4798      	blx	r3
 8015936:	4603      	mov	r3, r0
 8015938:	2b00      	cmp	r3, #0
 801593a:	d101      	bne.n	8015940 <read_restart_marker+0x80>
      return FALSE;
 801593c:	2300      	movs	r3, #0
 801593e:	e00b      	b.n	8015958 <read_restart_marker+0x98>
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015946:	695b      	ldr	r3, [r3, #20]
 8015948:	1c5a      	adds	r2, r3, #1
 801594a:	687b      	ldr	r3, [r7, #4]
 801594c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015950:	f002 0207 	and.w	r2, r2, #7
 8015954:	615a      	str	r2, [r3, #20]

  return TRUE;
 8015956:	2301      	movs	r3, #1
}
 8015958:	4618      	mov	r0, r3
 801595a:	3708      	adds	r7, #8
 801595c:	46bd      	mov	sp, r7
 801595e:	bd80      	pop	{r7, pc}

08015960 <jpeg_resync_to_restart>:
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
 8015960:	b580      	push	{r7, lr}
 8015962:	b084      	sub	sp, #16
 8015964:	af00      	add	r7, sp, #0
 8015966:	6078      	str	r0, [r7, #4]
 8015968:	6039      	str	r1, [r7, #0]
  int marker = cinfo->unread_marker;
 801596a:	687b      	ldr	r3, [r7, #4]
 801596c:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 8015970:	60fb      	str	r3, [r7, #12]
  int action = 1;
 8015972:	2301      	movs	r3, #1
 8015974:	60bb      	str	r3, [r7, #8]
  
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
 8015976:	687b      	ldr	r3, [r7, #4]
 8015978:	681b      	ldr	r3, [r3, #0]
 801597a:	227c      	movs	r2, #124	; 0x7c
 801597c:	615a      	str	r2, [r3, #20]
 801597e:	687b      	ldr	r3, [r7, #4]
 8015980:	681b      	ldr	r3, [r3, #0]
 8015982:	68fa      	ldr	r2, [r7, #12]
 8015984:	619a      	str	r2, [r3, #24]
 8015986:	687b      	ldr	r3, [r7, #4]
 8015988:	681b      	ldr	r3, [r3, #0]
 801598a:	683a      	ldr	r2, [r7, #0]
 801598c:	61da      	str	r2, [r3, #28]
 801598e:	687b      	ldr	r3, [r7, #4]
 8015990:	681b      	ldr	r3, [r3, #0]
 8015992:	685b      	ldr	r3, [r3, #4]
 8015994:	f04f 31ff 	mov.w	r1, #4294967295
 8015998:	6878      	ldr	r0, [r7, #4]
 801599a:	4798      	blx	r3
  
  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
 801599c:	68fb      	ldr	r3, [r7, #12]
 801599e:	2bbf      	cmp	r3, #191	; 0xbf
 80159a0:	dc02      	bgt.n	80159a8 <jpeg_resync_to_restart+0x48>
      action = 2;		/* invalid marker */
 80159a2:	2302      	movs	r3, #2
 80159a4:	60bb      	str	r3, [r7, #8]
 80159a6:	e030      	b.n	8015a0a <jpeg_resync_to_restart+0xaa>
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
 80159a8:	68fb      	ldr	r3, [r7, #12]
 80159aa:	2bcf      	cmp	r3, #207	; 0xcf
 80159ac:	dd02      	ble.n	80159b4 <jpeg_resync_to_restart+0x54>
 80159ae:	68fb      	ldr	r3, [r7, #12]
 80159b0:	2bd7      	cmp	r3, #215	; 0xd7
 80159b2:	dd02      	ble.n	80159ba <jpeg_resync_to_restart+0x5a>
      action = 3;		/* valid non-restart marker */
 80159b4:	2303      	movs	r3, #3
 80159b6:	60bb      	str	r3, [r7, #8]
 80159b8:	e027      	b.n	8015a0a <jpeg_resync_to_restart+0xaa>
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 80159ba:	683b      	ldr	r3, [r7, #0]
 80159bc:	3301      	adds	r3, #1
 80159be:	f003 0307 	and.w	r3, r3, #7
 80159c2:	33d0      	adds	r3, #208	; 0xd0
 80159c4:	68fa      	ldr	r2, [r7, #12]
 80159c6:	429a      	cmp	r2, r3
 80159c8:	d007      	beq.n	80159da <jpeg_resync_to_restart+0x7a>
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
 80159ca:	683b      	ldr	r3, [r7, #0]
 80159cc:	3302      	adds	r3, #2
 80159ce:	f003 0307 	and.w	r3, r3, #7
 80159d2:	33d0      	adds	r3, #208	; 0xd0
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
 80159d4:	68fa      	ldr	r2, [r7, #12]
 80159d6:	429a      	cmp	r2, r3
 80159d8:	d102      	bne.n	80159e0 <jpeg_resync_to_restart+0x80>
	action = 3;		/* one of the next two expected restarts */
 80159da:	2303      	movs	r3, #3
 80159dc:	60bb      	str	r3, [r7, #8]
 80159de:	e014      	b.n	8015a0a <jpeg_resync_to_restart+0xaa>
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 80159e0:	683b      	ldr	r3, [r7, #0]
 80159e2:	3b01      	subs	r3, #1
 80159e4:	f003 0307 	and.w	r3, r3, #7
 80159e8:	33d0      	adds	r3, #208	; 0xd0
 80159ea:	68fa      	ldr	r2, [r7, #12]
 80159ec:	429a      	cmp	r2, r3
 80159ee:	d007      	beq.n	8015a00 <jpeg_resync_to_restart+0xa0>
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
 80159f0:	683b      	ldr	r3, [r7, #0]
 80159f2:	3b02      	subs	r3, #2
 80159f4:	f003 0307 	and.w	r3, r3, #7
 80159f8:	33d0      	adds	r3, #208	; 0xd0
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
 80159fa:	68fa      	ldr	r2, [r7, #12]
 80159fc:	429a      	cmp	r2, r3
 80159fe:	d102      	bne.n	8015a06 <jpeg_resync_to_restart+0xa6>
	action = 2;		/* a prior restart, so advance */
 8015a00:	2302      	movs	r3, #2
 8015a02:	60bb      	str	r3, [r7, #8]
 8015a04:	e001      	b.n	8015a0a <jpeg_resync_to_restart+0xaa>
      else
	action = 1;		/* desired restart or too far away */
 8015a06:	2301      	movs	r3, #1
 8015a08:	60bb      	str	r3, [r7, #8]
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
 8015a0a:	687b      	ldr	r3, [r7, #4]
 8015a0c:	681b      	ldr	r3, [r3, #0]
 8015a0e:	2263      	movs	r2, #99	; 0x63
 8015a10:	615a      	str	r2, [r3, #20]
 8015a12:	687b      	ldr	r3, [r7, #4]
 8015a14:	681b      	ldr	r3, [r3, #0]
 8015a16:	68fa      	ldr	r2, [r7, #12]
 8015a18:	619a      	str	r2, [r3, #24]
 8015a1a:	687b      	ldr	r3, [r7, #4]
 8015a1c:	681b      	ldr	r3, [r3, #0]
 8015a1e:	68ba      	ldr	r2, [r7, #8]
 8015a20:	61da      	str	r2, [r3, #28]
 8015a22:	687b      	ldr	r3, [r7, #4]
 8015a24:	681b      	ldr	r3, [r3, #0]
 8015a26:	685b      	ldr	r3, [r3, #4]
 8015a28:	2104      	movs	r1, #4
 8015a2a:	6878      	ldr	r0, [r7, #4]
 8015a2c:	4798      	blx	r3
    switch (action) {
 8015a2e:	68bb      	ldr	r3, [r7, #8]
 8015a30:	2b03      	cmp	r3, #3
 8015a32:	d01c      	beq.n	8015a6e <jpeg_resync_to_restart+0x10e>
 8015a34:	68bb      	ldr	r3, [r7, #8]
 8015a36:	2b03      	cmp	r3, #3
 8015a38:	dcb0      	bgt.n	801599c <jpeg_resync_to_restart+0x3c>
 8015a3a:	68bb      	ldr	r3, [r7, #8]
 8015a3c:	2b01      	cmp	r3, #1
 8015a3e:	d003      	beq.n	8015a48 <jpeg_resync_to_restart+0xe8>
 8015a40:	68bb      	ldr	r3, [r7, #8]
 8015a42:	2b02      	cmp	r3, #2
 8015a44:	d006      	beq.n	8015a54 <jpeg_resync_to_restart+0xf4>
 8015a46:	e014      	b.n	8015a72 <jpeg_resync_to_restart+0x112>
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
 8015a48:	687b      	ldr	r3, [r7, #4]
 8015a4a:	2200      	movs	r2, #0
 8015a4c:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
      return TRUE;
 8015a50:	2301      	movs	r3, #1
 8015a52:	e00f      	b.n	8015a74 <jpeg_resync_to_restart+0x114>
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
 8015a54:	6878      	ldr	r0, [r7, #4]
 8015a56:	f7ff fc6b 	bl	8015330 <next_marker>
 8015a5a:	4603      	mov	r3, r0
 8015a5c:	2b00      	cmp	r3, #0
 8015a5e:	d101      	bne.n	8015a64 <jpeg_resync_to_restart+0x104>
	return FALSE;
 8015a60:	2300      	movs	r3, #0
 8015a62:	e007      	b.n	8015a74 <jpeg_resync_to_restart+0x114>
      marker = cinfo->unread_marker;
 8015a64:	687b      	ldr	r3, [r7, #4]
 8015a66:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 8015a6a:	60fb      	str	r3, [r7, #12]
      break;
 8015a6c:	e001      	b.n	8015a72 <jpeg_resync_to_restart+0x112>
    case 3:
      /* Return without advancing past this marker. */
      /* Entropy decoder will be forced to process an empty segment. */
      return TRUE;
 8015a6e:	2301      	movs	r3, #1
 8015a70:	e000      	b.n	8015a74 <jpeg_resync_to_restart+0x114>
    if (marker < (int) M_SOF0)
 8015a72:	e793      	b.n	801599c <jpeg_resync_to_restart+0x3c>
    }
  } /* end loop */
}
 8015a74:	4618      	mov	r0, r3
 8015a76:	3710      	adds	r7, #16
 8015a78:	46bd      	mov	sp, r7
 8015a7a:	bd80      	pop	{r7, pc}

08015a7c <reset_marker_reader>:
 * Reset marker processing state to begin a fresh datastream.
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
 8015a7c:	b480      	push	{r7}
 8015a7e:	b085      	sub	sp, #20
 8015a80:	af00      	add	r7, sp, #0
 8015a82:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
 8015a84:	687b      	ldr	r3, [r7, #4]
 8015a86:	f8d3 31cc 	ldr.w	r3, [r3, #460]	; 0x1cc
 8015a8a:	60fb      	str	r3, [r7, #12]

  cinfo->comp_info = NULL;		/* until allocated by get_sof */
 8015a8c:	687b      	ldr	r3, [r7, #4]
 8015a8e:	2200      	movs	r2, #0
 8015a90:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
 8015a94:	687b      	ldr	r3, [r7, #4]
 8015a96:	2200      	movs	r2, #0
 8015a98:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  cinfo->unread_marker = 0;		/* no pending marker */
 8015a9c:	687b      	ldr	r3, [r7, #4]
 8015a9e:	2200      	movs	r2, #0
 8015aa0:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  marker->pub.saw_SOI = FALSE;		/* set internal state too */
 8015aa4:	68fb      	ldr	r3, [r7, #12]
 8015aa6:	2200      	movs	r2, #0
 8015aa8:	60da      	str	r2, [r3, #12]
  marker->pub.saw_SOF = FALSE;
 8015aaa:	68fb      	ldr	r3, [r7, #12]
 8015aac:	2200      	movs	r2, #0
 8015aae:	611a      	str	r2, [r3, #16]
  marker->pub.discarded_bytes = 0;
 8015ab0:	68fb      	ldr	r3, [r7, #12]
 8015ab2:	2200      	movs	r2, #0
 8015ab4:	619a      	str	r2, [r3, #24]
  marker->cur_marker = NULL;
 8015ab6:	68fb      	ldr	r3, [r7, #12]
 8015ab8:	2200      	movs	r2, #0
 8015aba:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8015abe:	bf00      	nop
 8015ac0:	3714      	adds	r7, #20
 8015ac2:	46bd      	mov	sp, r7
 8015ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ac8:	4770      	bx	lr
	...

08015acc <jinit_marker_reader>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
 8015acc:	b580      	push	{r7, lr}
 8015ace:	b084      	sub	sp, #16
 8015ad0:	af00      	add	r7, sp, #0
 8015ad2:	6078      	str	r0, [r7, #4]
  my_marker_ptr marker;
  int i;

  /* Create subobject in permanent pool */
  marker = (my_marker_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 8015ad4:	687b      	ldr	r3, [r7, #4]
 8015ad6:	685b      	ldr	r3, [r3, #4]
 8015ad8:	681b      	ldr	r3, [r3, #0]
 8015ada:	22ac      	movs	r2, #172	; 0xac
 8015adc:	2100      	movs	r1, #0
 8015ade:	6878      	ldr	r0, [r7, #4]
 8015ae0:	4798      	blx	r3
 8015ae2:	60b8      	str	r0, [r7, #8]
				SIZEOF(my_marker_reader));
  cinfo->marker = (struct jpeg_marker_reader *) marker;
 8015ae4:	687b      	ldr	r3, [r7, #4]
 8015ae6:	68ba      	ldr	r2, [r7, #8]
 8015ae8:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
  /* Initialize public method pointers */
  marker->pub.reset_marker_reader = reset_marker_reader;
 8015aec:	68bb      	ldr	r3, [r7, #8]
 8015aee:	4a18      	ldr	r2, [pc, #96]	; (8015b50 <jinit_marker_reader+0x84>)
 8015af0:	601a      	str	r2, [r3, #0]
  marker->pub.read_markers = read_markers;
 8015af2:	68bb      	ldr	r3, [r7, #8]
 8015af4:	4a17      	ldr	r2, [pc, #92]	; (8015b54 <jinit_marker_reader+0x88>)
 8015af6:	605a      	str	r2, [r3, #4]
  marker->pub.read_restart_marker = read_restart_marker;
 8015af8:	68bb      	ldr	r3, [r7, #8]
 8015afa:	4a17      	ldr	r2, [pc, #92]	; (8015b58 <jinit_marker_reader+0x8c>)
 8015afc:	609a      	str	r2, [r3, #8]
  /* Initialize COM/APPn processing.
   * By default, we examine and then discard APP0 and APP14,
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
 8015afe:	68bb      	ldr	r3, [r7, #8]
 8015b00:	4a16      	ldr	r2, [pc, #88]	; (8015b5c <jinit_marker_reader+0x90>)
 8015b02:	61da      	str	r2, [r3, #28]
  marker->length_limit_COM = 0;
 8015b04:	68bb      	ldr	r3, [r7, #8]
 8015b06:	2200      	movs	r2, #0
 8015b08:	661a      	str	r2, [r3, #96]	; 0x60
  for (i = 0; i < 16; i++) {
 8015b0a:	2300      	movs	r3, #0
 8015b0c:	60fb      	str	r3, [r7, #12]
 8015b0e:	e00f      	b.n	8015b30 <jinit_marker_reader+0x64>
    marker->process_APPn[i] = skip_variable;
 8015b10:	68bb      	ldr	r3, [r7, #8]
 8015b12:	68fa      	ldr	r2, [r7, #12]
 8015b14:	3208      	adds	r2, #8
 8015b16:	4911      	ldr	r1, [pc, #68]	; (8015b5c <jinit_marker_reader+0x90>)
 8015b18:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    marker->length_limit_APPn[i] = 0;
 8015b1c:	68ba      	ldr	r2, [r7, #8]
 8015b1e:	68fb      	ldr	r3, [r7, #12]
 8015b20:	3318      	adds	r3, #24
 8015b22:	009b      	lsls	r3, r3, #2
 8015b24:	4413      	add	r3, r2
 8015b26:	2200      	movs	r2, #0
 8015b28:	605a      	str	r2, [r3, #4]
  for (i = 0; i < 16; i++) {
 8015b2a:	68fb      	ldr	r3, [r7, #12]
 8015b2c:	3301      	adds	r3, #1
 8015b2e:	60fb      	str	r3, [r7, #12]
 8015b30:	68fb      	ldr	r3, [r7, #12]
 8015b32:	2b0f      	cmp	r3, #15
 8015b34:	ddec      	ble.n	8015b10 <jinit_marker_reader+0x44>
  }
  marker->process_APPn[0] = get_interesting_appn;
 8015b36:	68bb      	ldr	r3, [r7, #8]
 8015b38:	4a09      	ldr	r2, [pc, #36]	; (8015b60 <jinit_marker_reader+0x94>)
 8015b3a:	621a      	str	r2, [r3, #32]
  marker->process_APPn[14] = get_interesting_appn;
 8015b3c:	68bb      	ldr	r3, [r7, #8]
 8015b3e:	4a08      	ldr	r2, [pc, #32]	; (8015b60 <jinit_marker_reader+0x94>)
 8015b40:	659a      	str	r2, [r3, #88]	; 0x58
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
 8015b42:	6878      	ldr	r0, [r7, #4]
 8015b44:	f7ff ff9a 	bl	8015a7c <reset_marker_reader>
}
 8015b48:	bf00      	nop
 8015b4a:	3710      	adds	r7, #16
 8015b4c:	46bd      	mov	sp, r7
 8015b4e:	bd80      	pop	{r7, pc}
 8015b50:	08015a7d 	.word	0x08015a7d
 8015b54:	08015565 	.word	0x08015565
 8015b58:	080158c1 	.word	0x080158c1
 8015b5c:	08015251 	.word	0x08015251
 8015b60:	080150d3 	.word	0x080150d3

08015b64 <use_merged_upsample>:
 * CRUCIAL: this must match the actual capabilities of jdmerge.c!
 */

LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
 8015b64:	b480      	push	{r7}
 8015b66:	b083      	sub	sp, #12
 8015b68:	af00      	add	r7, sp, #0
 8015b6a:	6078      	str	r0, [r7, #4]
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
 8015b6c:	687b      	ldr	r3, [r7, #4]
 8015b6e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015b70:	2b00      	cmp	r3, #0
 8015b72:	d104      	bne.n	8015b7e <use_merged_upsample+0x1a>
 8015b74:	687b      	ldr	r3, [r7, #4]
 8015b76:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 8015b7a:	2b00      	cmp	r3, #0
 8015b7c:	d001      	beq.n	8015b82 <use_merged_upsample+0x1e>
    return FALSE;
 8015b7e:	2300      	movs	r3, #0
 8015b80:	e07a      	b.n	8015c78 <use_merged_upsample+0x114>
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 8015b82:	687b      	ldr	r3, [r7, #4]
 8015b84:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8015b88:	2b03      	cmp	r3, #3
 8015b8a:	d10c      	bne.n	8015ba6 <use_merged_upsample+0x42>
 8015b8c:	687b      	ldr	r3, [r7, #4]
 8015b8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015b90:	2b03      	cmp	r3, #3
 8015b92:	d108      	bne.n	8015ba6 <use_merged_upsample+0x42>
      cinfo->out_color_space != JCS_RGB ||
 8015b94:	687b      	ldr	r3, [r7, #4]
 8015b96:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
 8015b9a:	2b02      	cmp	r3, #2
 8015b9c:	d103      	bne.n	8015ba6 <use_merged_upsample+0x42>
      cinfo->out_color_components != RGB_PIXELSIZE)
 8015b9e:	687b      	ldr	r3, [r7, #4]
 8015ba0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
      cinfo->out_color_space != JCS_RGB ||
 8015ba2:	2b03      	cmp	r3, #3
 8015ba4:	d001      	beq.n	8015baa <use_merged_upsample+0x46>
    return FALSE;
 8015ba6:	2300      	movs	r3, #0
 8015ba8:	e066      	b.n	8015c78 <use_merged_upsample+0x114>
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 8015baa:	687b      	ldr	r3, [r7, #4]
 8015bac:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015bb0:	689b      	ldr	r3, [r3, #8]
 8015bb2:	2b02      	cmp	r3, #2
 8015bb4:	d121      	bne.n	8015bfa <use_merged_upsample+0x96>
      cinfo->comp_info[1].h_samp_factor != 1 ||
 8015bb6:	687b      	ldr	r3, [r7, #4]
 8015bb8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015bbc:	3358      	adds	r3, #88	; 0x58
 8015bbe:	689b      	ldr	r3, [r3, #8]
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
 8015bc0:	2b01      	cmp	r3, #1
 8015bc2:	d11a      	bne.n	8015bfa <use_merged_upsample+0x96>
      cinfo->comp_info[2].h_samp_factor != 1 ||
 8015bc4:	687b      	ldr	r3, [r7, #4]
 8015bc6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015bca:	33b0      	adds	r3, #176	; 0xb0
 8015bcc:	689b      	ldr	r3, [r3, #8]
      cinfo->comp_info[1].h_samp_factor != 1 ||
 8015bce:	2b01      	cmp	r3, #1
 8015bd0:	d113      	bne.n	8015bfa <use_merged_upsample+0x96>
      cinfo->comp_info[0].v_samp_factor >  2 ||
 8015bd2:	687b      	ldr	r3, [r7, #4]
 8015bd4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015bd8:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[2].h_samp_factor != 1 ||
 8015bda:	2b02      	cmp	r3, #2
 8015bdc:	dc0d      	bgt.n	8015bfa <use_merged_upsample+0x96>
      cinfo->comp_info[1].v_samp_factor != 1 ||
 8015bde:	687b      	ldr	r3, [r7, #4]
 8015be0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015be4:	3358      	adds	r3, #88	; 0x58
 8015be6:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[0].v_samp_factor >  2 ||
 8015be8:	2b01      	cmp	r3, #1
 8015bea:	d106      	bne.n	8015bfa <use_merged_upsample+0x96>
      cinfo->comp_info[2].v_samp_factor != 1)
 8015bec:	687b      	ldr	r3, [r7, #4]
 8015bee:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015bf2:	33b0      	adds	r3, #176	; 0xb0
 8015bf4:	68db      	ldr	r3, [r3, #12]
      cinfo->comp_info[1].v_samp_factor != 1 ||
 8015bf6:	2b01      	cmp	r3, #1
 8015bf8:	d001      	beq.n	8015bfe <use_merged_upsample+0x9a>
    return FALSE;
 8015bfa:	2300      	movs	r3, #0
 8015bfc:	e03c      	b.n	8015c78 <use_merged_upsample+0x114>
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015bfe:	687b      	ldr	r3, [r7, #4]
 8015c00:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c04:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015c06:	687b      	ldr	r3, [r7, #4]
 8015c08:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8015c0c:	429a      	cmp	r2, r3
 8015c0e:	d130      	bne.n	8015c72 <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015c10:	687b      	ldr	r3, [r7, #4]
 8015c12:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c16:	3358      	adds	r3, #88	; 0x58
 8015c18:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015c1a:	687b      	ldr	r3, [r7, #4]
 8015c1c:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
  if (cinfo->comp_info[0].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015c20:	429a      	cmp	r2, r3
 8015c22:	d126      	bne.n	8015c72 <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015c24:	687b      	ldr	r3, [r7, #4]
 8015c26:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c2a:	33b0      	adds	r3, #176	; 0xb0
 8015c2c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015c2e:	687b      	ldr	r3, [r7, #4]
 8015c30:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
      cinfo->comp_info[1].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015c34:	429a      	cmp	r2, r3
 8015c36:	d11c      	bne.n	8015c72 <use_merged_upsample+0x10e>
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 8015c38:	687b      	ldr	r3, [r7, #4]
 8015c3a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8015c40:	687b      	ldr	r3, [r7, #4]
 8015c42:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
      cinfo->comp_info[2].DCT_h_scaled_size != cinfo->min_DCT_h_scaled_size ||
 8015c46:	429a      	cmp	r2, r3
 8015c48:	d113      	bne.n	8015c72 <use_merged_upsample+0x10e>
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 8015c4a:	687b      	ldr	r3, [r7, #4]
 8015c4c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c50:	3358      	adds	r3, #88	; 0x58
 8015c52:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8015c54:	687b      	ldr	r3, [r7, #4]
 8015c56:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
      cinfo->comp_info[0].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 8015c5a:	429a      	cmp	r2, r3
 8015c5c:	d109      	bne.n	8015c72 <use_merged_upsample+0x10e>
      cinfo->comp_info[2].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size)
 8015c5e:	687b      	ldr	r3, [r7, #4]
 8015c60:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015c64:	33b0      	adds	r3, #176	; 0xb0
 8015c66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8015c68:	687b      	ldr	r3, [r7, #4]
 8015c6a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
      cinfo->comp_info[1].DCT_v_scaled_size != cinfo->min_DCT_v_scaled_size ||
 8015c6e:	429a      	cmp	r2, r3
 8015c70:	d001      	beq.n	8015c76 <use_merged_upsample+0x112>
    return FALSE;
 8015c72:	2300      	movs	r3, #0
 8015c74:	e000      	b.n	8015c78 <use_merged_upsample+0x114>
  /* ??? also need to test for upsample-time rescaling, when & if supported */
  return TRUE;			/* by golly, it'll work... */
 8015c76:	2301      	movs	r3, #1
#else
  return FALSE;
#endif
}
 8015c78:	4618      	mov	r0, r3
 8015c7a:	370c      	adds	r7, #12
 8015c7c:	46bd      	mov	sp, r7
 8015c7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c82:	4770      	bx	lr

08015c84 <jpeg_calc_output_dimensions>:
GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase.
 * This function is used for full decompression.
 */
{
 8015c84:	b580      	push	{r7, lr}
 8015c86:	b086      	sub	sp, #24
 8015c88:	af00      	add	r7, sp, #0
 8015c8a:	6078      	str	r0, [r7, #4]
  int ci;
  jpeg_component_info *compptr;
#endif

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
 8015c8c:	687b      	ldr	r3, [r7, #4]
 8015c8e:	695b      	ldr	r3, [r3, #20]
 8015c90:	2bca      	cmp	r3, #202	; 0xca
 8015c92:	d00d      	beq.n	8015cb0 <jpeg_calc_output_dimensions+0x2c>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 8015c94:	687b      	ldr	r3, [r7, #4]
 8015c96:	681b      	ldr	r3, [r3, #0]
 8015c98:	2215      	movs	r2, #21
 8015c9a:	615a      	str	r2, [r3, #20]
 8015c9c:	687b      	ldr	r3, [r7, #4]
 8015c9e:	681b      	ldr	r3, [r3, #0]
 8015ca0:	687a      	ldr	r2, [r7, #4]
 8015ca2:	6952      	ldr	r2, [r2, #20]
 8015ca4:	619a      	str	r2, [r3, #24]
 8015ca6:	687b      	ldr	r3, [r7, #4]
 8015ca8:	681b      	ldr	r3, [r3, #0]
 8015caa:	681b      	ldr	r3, [r3, #0]
 8015cac:	6878      	ldr	r0, [r7, #4]
 8015cae:	4798      	blx	r3

  /* Compute core output image dimensions and DCT scaling choices. */
  jpeg_core_output_dimensions(cinfo);
 8015cb0:	6878      	ldr	r0, [r7, #4]
 8015cb2:	f7fc f871 	bl	8011d98 <jpeg_core_output_dimensions>
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code adapts subsampling ratios which are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015cb6:	2300      	movs	r3, #0
 8015cb8:	617b      	str	r3, [r7, #20]
 8015cba:	687b      	ldr	r3, [r7, #4]
 8015cbc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015cc0:	613b      	str	r3, [r7, #16]
 8015cc2:	e078      	b.n	8015db6 <jpeg_calc_output_dimensions+0x132>
       ci++, compptr++) {
    int ssize = 1;
 8015cc4:	2301      	movs	r3, #1
 8015cc6:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 8015cc8:	e002      	b.n	8015cd0 <jpeg_calc_output_dimensions+0x4c>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 8015cca:	68fb      	ldr	r3, [r7, #12]
 8015ccc:	005b      	lsls	r3, r3, #1
 8015cce:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 8015cd0:	687b      	ldr	r3, [r7, #4]
 8015cd2:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8015cd6:	68fa      	ldr	r2, [r7, #12]
 8015cd8:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 8015cdc:	687a      	ldr	r2, [r7, #4]
 8015cde:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8015ce0:	2a00      	cmp	r2, #0
 8015ce2:	d001      	beq.n	8015ce8 <jpeg_calc_output_dimensions+0x64>
 8015ce4:	2208      	movs	r2, #8
 8015ce6:	e000      	b.n	8015cea <jpeg_calc_output_dimensions+0x66>
 8015ce8:	2204      	movs	r2, #4
    while (cinfo->min_DCT_h_scaled_size * ssize <=
 8015cea:	429a      	cmp	r2, r3
 8015cec:	db0f      	blt.n	8015d0e <jpeg_calc_output_dimensions+0x8a>
	   (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
 8015cee:	687b      	ldr	r3, [r7, #4]
 8015cf0:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 8015cf4:	693a      	ldr	r2, [r7, #16]
 8015cf6:	6892      	ldr	r2, [r2, #8]
 8015cf8:	68f9      	ldr	r1, [r7, #12]
 8015cfa:	fb01 f202 	mul.w	r2, r1, r2
 8015cfe:	0052      	lsls	r2, r2, #1
 8015d00:	fb93 f1f2 	sdiv	r1, r3, r2
 8015d04:	fb02 f201 	mul.w	r2, r2, r1
 8015d08:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 8015d0a:	2b00      	cmp	r3, #0
 8015d0c:	d0dd      	beq.n	8015cca <jpeg_calc_output_dimensions+0x46>
    }
    compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
 8015d0e:	687b      	ldr	r3, [r7, #4]
 8015d10:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8015d14:	68fa      	ldr	r2, [r7, #12]
 8015d16:	fb02 f203 	mul.w	r2, r2, r3
 8015d1a:	693b      	ldr	r3, [r7, #16]
 8015d1c:	625a      	str	r2, [r3, #36]	; 0x24
    ssize = 1;
 8015d1e:	2301      	movs	r3, #1
 8015d20:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 8015d22:	e002      	b.n	8015d2a <jpeg_calc_output_dimensions+0xa6>
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
      ssize = ssize * 2;
 8015d24:	68fb      	ldr	r3, [r7, #12]
 8015d26:	005b      	lsls	r3, r3, #1
 8015d28:	60fb      	str	r3, [r7, #12]
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 8015d2a:	687b      	ldr	r3, [r7, #4]
 8015d2c:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8015d30:	68fa      	ldr	r2, [r7, #12]
 8015d32:	fb02 f303 	mul.w	r3, r2, r3
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 8015d36:	687a      	ldr	r2, [r7, #4]
 8015d38:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8015d3a:	2a00      	cmp	r2, #0
 8015d3c:	d001      	beq.n	8015d42 <jpeg_calc_output_dimensions+0xbe>
 8015d3e:	2208      	movs	r2, #8
 8015d40:	e000      	b.n	8015d44 <jpeg_calc_output_dimensions+0xc0>
 8015d42:	2204      	movs	r2, #4
    while (cinfo->min_DCT_v_scaled_size * ssize <=
 8015d44:	429a      	cmp	r2, r3
 8015d46:	db0f      	blt.n	8015d68 <jpeg_calc_output_dimensions+0xe4>
	   (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
 8015d48:	687b      	ldr	r3, [r7, #4]
 8015d4a:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8015d4e:	693a      	ldr	r2, [r7, #16]
 8015d50:	68d2      	ldr	r2, [r2, #12]
 8015d52:	68f9      	ldr	r1, [r7, #12]
 8015d54:	fb01 f202 	mul.w	r2, r1, r2
 8015d58:	0052      	lsls	r2, r2, #1
 8015d5a:	fb93 f1f2 	sdiv	r1, r3, r2
 8015d5e:	fb02 f201 	mul.w	r2, r2, r1
 8015d62:	1a9b      	subs	r3, r3, r2
	   (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
 8015d64:	2b00      	cmp	r3, #0
 8015d66:	d0dd      	beq.n	8015d24 <jpeg_calc_output_dimensions+0xa0>
    }
    compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 8015d68:	687b      	ldr	r3, [r7, #4]
 8015d6a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8015d6e:	68fa      	ldr	r2, [r7, #12]
 8015d70:	fb02 f203 	mul.w	r2, r2, r3
 8015d74:	693b      	ldr	r3, [r7, #16]
 8015d76:	629a      	str	r2, [r3, #40]	; 0x28

    /* We don't support IDCT ratios larger than 2. */
    if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
 8015d78:	693b      	ldr	r3, [r7, #16]
 8015d7a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015d7c:	693b      	ldr	r3, [r7, #16]
 8015d7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015d80:	005b      	lsls	r3, r3, #1
 8015d82:	429a      	cmp	r2, r3
 8015d84:	dd05      	ble.n	8015d92 <jpeg_calc_output_dimensions+0x10e>
	compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size * 2;
 8015d86:	693b      	ldr	r3, [r7, #16]
 8015d88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015d8a:	005a      	lsls	r2, r3, #1
 8015d8c:	693b      	ldr	r3, [r7, #16]
 8015d8e:	625a      	str	r2, [r3, #36]	; 0x24
 8015d90:	e00b      	b.n	8015daa <jpeg_calc_output_dimensions+0x126>
    else if (compptr->DCT_v_scaled_size > compptr->DCT_h_scaled_size * 2)
 8015d92:	693b      	ldr	r3, [r7, #16]
 8015d94:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8015d96:	693b      	ldr	r3, [r7, #16]
 8015d98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015d9a:	005b      	lsls	r3, r3, #1
 8015d9c:	429a      	cmp	r2, r3
 8015d9e:	dd04      	ble.n	8015daa <jpeg_calc_output_dimensions+0x126>
	compptr->DCT_v_scaled_size = compptr->DCT_h_scaled_size * 2;
 8015da0:	693b      	ldr	r3, [r7, #16]
 8015da2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015da4:	005a      	lsls	r2, r3, #1
 8015da6:	693b      	ldr	r3, [r7, #16]
 8015da8:	629a      	str	r2, [r3, #40]	; 0x28
       ci++, compptr++) {
 8015daa:	697b      	ldr	r3, [r7, #20]
 8015dac:	3301      	adds	r3, #1
 8015dae:	617b      	str	r3, [r7, #20]
 8015db0:	693b      	ldr	r3, [r7, #16]
 8015db2:	3358      	adds	r3, #88	; 0x58
 8015db4:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015db6:	687b      	ldr	r3, [r7, #4]
 8015db8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015dba:	697a      	ldr	r2, [r7, #20]
 8015dbc:	429a      	cmp	r2, r3
 8015dbe:	db81      	blt.n	8015cc4 <jpeg_calc_output_dimensions+0x40>
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015dc0:	2300      	movs	r3, #0
 8015dc2:	617b      	str	r3, [r7, #20]
 8015dc4:	687b      	ldr	r3, [r7, #4]
 8015dc6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8015dca:	613b      	str	r3, [r7, #16]
 8015dcc:	e039      	b.n	8015e42 <jpeg_calc_output_dimensions+0x1be>
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_width *
 8015dce:	687b      	ldr	r3, [r7, #4]
 8015dd0:	69db      	ldr	r3, [r3, #28]
 8015dd2:	4619      	mov	r1, r3
		    (long) (compptr->h_samp_factor * compptr->DCT_h_scaled_size),
 8015dd4:	693b      	ldr	r3, [r7, #16]
 8015dd6:	689b      	ldr	r3, [r3, #8]
 8015dd8:	693a      	ldr	r2, [r7, #16]
 8015dda:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8015ddc:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 8015de0:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_h_samp_factor * cinfo->block_size));
 8015de4:	687b      	ldr	r3, [r7, #4]
 8015de6:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 8015dea:	687a      	ldr	r2, [r7, #4]
 8015dec:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8015df0:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_width *
 8015df4:	4619      	mov	r1, r3
 8015df6:	f011 fe91 	bl	8027b1c <jdiv_round_up>
 8015dfa:	4603      	mov	r3, r0
    compptr->downsampled_width = (JDIMENSION)
 8015dfc:	461a      	mov	r2, r3
 8015dfe:	693b      	ldr	r3, [r7, #16]
 8015e00:	62da      	str	r2, [r3, #44]	; 0x2c
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height *
 8015e02:	687b      	ldr	r3, [r7, #4]
 8015e04:	6a1b      	ldr	r3, [r3, #32]
 8015e06:	4619      	mov	r1, r3
		    (long) (compptr->v_samp_factor * compptr->DCT_v_scaled_size),
 8015e08:	693b      	ldr	r3, [r7, #16]
 8015e0a:	68db      	ldr	r3, [r3, #12]
 8015e0c:	693a      	ldr	r2, [r7, #16]
 8015e0e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8015e10:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 8015e14:	fb03 f001 	mul.w	r0, r3, r1
		    (long) (cinfo->max_v_samp_factor * cinfo->block_size));
 8015e18:	687b      	ldr	r3, [r7, #4]
 8015e1a:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8015e1e:	687a      	ldr	r2, [r7, #4]
 8015e20:	f8d2 21a8 	ldr.w	r2, [r2, #424]	; 0x1a8
 8015e24:	fb02 f303 	mul.w	r3, r2, r3
      jdiv_round_up((long) cinfo->image_height *
 8015e28:	4619      	mov	r1, r3
 8015e2a:	f011 fe77 	bl	8027b1c <jdiv_round_up>
 8015e2e:	4603      	mov	r3, r0
    compptr->downsampled_height = (JDIMENSION)
 8015e30:	461a      	mov	r2, r3
 8015e32:	693b      	ldr	r3, [r7, #16]
 8015e34:	631a      	str	r2, [r3, #48]	; 0x30
       ci++, compptr++) {
 8015e36:	697b      	ldr	r3, [r7, #20]
 8015e38:	3301      	adds	r3, #1
 8015e3a:	617b      	str	r3, [r7, #20]
 8015e3c:	693b      	ldr	r3, [r7, #16]
 8015e3e:	3358      	adds	r3, #88	; 0x58
 8015e40:	613b      	str	r3, [r7, #16]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8015e42:	687b      	ldr	r3, [r7, #4]
 8015e44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015e46:	697a      	ldr	r2, [r7, #20]
 8015e48:	429a      	cmp	r2, r3
 8015e4a:	dbc0      	blt.n	8015dce <jpeg_calc_output_dimensions+0x14a>

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
 8015e4c:	687b      	ldr	r3, [r7, #4]
 8015e4e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8015e52:	3b01      	subs	r3, #1
 8015e54:	2b04      	cmp	r3, #4
 8015e56:	d81d      	bhi.n	8015e94 <jpeg_calc_output_dimensions+0x210>
 8015e58:	a201      	add	r2, pc, #4	; (adr r2, 8015e60 <jpeg_calc_output_dimensions+0x1dc>)
 8015e5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015e5e:	bf00      	nop
 8015e60:	08015e75 	.word	0x08015e75
 8015e64:	08015e7d 	.word	0x08015e7d
 8015e68:	08015e85 	.word	0x08015e85
 8015e6c:	08015e8d 	.word	0x08015e8d
 8015e70:	08015e8d 	.word	0x08015e8d
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
 8015e74:	687b      	ldr	r3, [r7, #4]
 8015e76:	2201      	movs	r2, #1
 8015e78:	679a      	str	r2, [r3, #120]	; 0x78
    break;
 8015e7a:	e010      	b.n	8015e9e <jpeg_calc_output_dimensions+0x21a>
  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
 8015e7c:	687b      	ldr	r3, [r7, #4]
 8015e7e:	2203      	movs	r2, #3
 8015e80:	679a      	str	r2, [r3, #120]	; 0x78
    break;
 8015e82:	e00c      	b.n	8015e9e <jpeg_calc_output_dimensions+0x21a>
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
 8015e84:	687b      	ldr	r3, [r7, #4]
 8015e86:	2203      	movs	r2, #3
 8015e88:	679a      	str	r2, [r3, #120]	; 0x78
    break;
 8015e8a:	e008      	b.n	8015e9e <jpeg_calc_output_dimensions+0x21a>
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
 8015e8c:	687b      	ldr	r3, [r7, #4]
 8015e8e:	2204      	movs	r2, #4
 8015e90:	679a      	str	r2, [r3, #120]	; 0x78
    break;
 8015e92:	e004      	b.n	8015e9e <jpeg_calc_output_dimensions+0x21a>
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
 8015e94:	687b      	ldr	r3, [r7, #4]
 8015e96:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015e98:	687b      	ldr	r3, [r7, #4]
 8015e9a:	679a      	str	r2, [r3, #120]	; 0x78
    break;
 8015e9c:	bf00      	nop
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
 8015e9e:	687b      	ldr	r3, [r7, #4]
 8015ea0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015ea2:	2b00      	cmp	r3, #0
 8015ea4:	d102      	bne.n	8015eac <jpeg_calc_output_dimensions+0x228>
 8015ea6:	687b      	ldr	r3, [r7, #4]
 8015ea8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015eaa:	e000      	b.n	8015eae <jpeg_calc_output_dimensions+0x22a>
 8015eac:	2301      	movs	r3, #1
 8015eae:	687a      	ldr	r2, [r7, #4]
 8015eb0:	67d3      	str	r3, [r2, #124]	; 0x7c
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
 8015eb2:	6878      	ldr	r0, [r7, #4]
 8015eb4:	f7ff fe56 	bl	8015b64 <use_merged_upsample>
 8015eb8:	4603      	mov	r3, r0
 8015eba:	2b00      	cmp	r3, #0
 8015ebc:	d006      	beq.n	8015ecc <jpeg_calc_output_dimensions+0x248>
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
 8015ebe:	687b      	ldr	r3, [r7, #4]
 8015ec0:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
 8015ec4:	687b      	ldr	r3, [r7, #4]
 8015ec6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  else
    cinfo->rec_outbuf_height = 1;
}
 8015eca:	e003      	b.n	8015ed4 <jpeg_calc_output_dimensions+0x250>
    cinfo->rec_outbuf_height = 1;
 8015ecc:	687b      	ldr	r3, [r7, #4]
 8015ece:	2201      	movs	r2, #1
 8015ed0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 8015ed4:	bf00      	nop
 8015ed6:	3718      	adds	r7, #24
 8015ed8:	46bd      	mov	sp, r7
 8015eda:	bd80      	pop	{r7, pc}

08015edc <prepare_range_limit_table>:
 */

LOCAL(void)
prepare_range_limit_table (j_decompress_ptr cinfo)
/* Allocate and fill in the sample_range_limit table */
{
 8015edc:	b580      	push	{r7, lr}
 8015ede:	b084      	sub	sp, #16
 8015ee0:	af00      	add	r7, sp, #0
 8015ee2:	6078      	str	r0, [r7, #4]
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8015ee4:	687b      	ldr	r3, [r7, #4]
 8015ee6:	685b      	ldr	r3, [r3, #4]
 8015ee8:	681b      	ldr	r3, [r3, #0]
 8015eea:	f44f 62b0 	mov.w	r2, #1408	; 0x580
 8015eee:	2101      	movs	r1, #1
 8015ef0:	6878      	ldr	r0, [r7, #4]
 8015ef2:	4798      	blx	r3
 8015ef4:	60b8      	str	r0, [r7, #8]
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
 8015ef6:	68bb      	ldr	r3, [r7, #8]
 8015ef8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8015efc:	60bb      	str	r3, [r7, #8]
  cinfo->sample_range_limit = table;
 8015efe:	687b      	ldr	r3, [r7, #4]
 8015f00:	68ba      	ldr	r2, [r7, #8]
 8015f02:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
 8015f06:	68bb      	ldr	r3, [r7, #8]
 8015f08:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8015f0c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8015f10:	2100      	movs	r1, #0
 8015f12:	4618      	mov	r0, r3
 8015f14:	f012 f9b4 	bl	8028280 <memset>
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
 8015f18:	2300      	movs	r3, #0
 8015f1a:	60fb      	str	r3, [r7, #12]
 8015f1c:	e008      	b.n	8015f30 <prepare_range_limit_table+0x54>
    table[i] = (JSAMPLE) i;
 8015f1e:	68fb      	ldr	r3, [r7, #12]
 8015f20:	68ba      	ldr	r2, [r7, #8]
 8015f22:	4413      	add	r3, r2
 8015f24:	68fa      	ldr	r2, [r7, #12]
 8015f26:	b2d2      	uxtb	r2, r2
 8015f28:	701a      	strb	r2, [r3, #0]
  for (i = 0; i <= MAXJSAMPLE; i++)
 8015f2a:	68fb      	ldr	r3, [r7, #12]
 8015f2c:	3301      	adds	r3, #1
 8015f2e:	60fb      	str	r3, [r7, #12]
 8015f30:	68fb      	ldr	r3, [r7, #12]
 8015f32:	2bff      	cmp	r3, #255	; 0xff
 8015f34:	ddf3      	ble.n	8015f1e <prepare_range_limit_table+0x42>
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
 8015f36:	68bb      	ldr	r3, [r7, #8]
 8015f38:	3380      	adds	r3, #128	; 0x80
 8015f3a:	60bb      	str	r3, [r7, #8]
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 8015f3c:	2380      	movs	r3, #128	; 0x80
 8015f3e:	60fb      	str	r3, [r7, #12]
 8015f40:	e007      	b.n	8015f52 <prepare_range_limit_table+0x76>
    table[i] = MAXJSAMPLE;
 8015f42:	68fb      	ldr	r3, [r7, #12]
 8015f44:	68ba      	ldr	r2, [r7, #8]
 8015f46:	4413      	add	r3, r2
 8015f48:	22ff      	movs	r2, #255	; 0xff
 8015f4a:	701a      	strb	r2, [r3, #0]
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
 8015f4c:	68fb      	ldr	r3, [r7, #12]
 8015f4e:	3301      	adds	r3, #1
 8015f50:	60fb      	str	r3, [r7, #12]
 8015f52:	68fb      	ldr	r3, [r7, #12]
 8015f54:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8015f58:	dbf3      	blt.n	8015f42 <prepare_range_limit_table+0x66>
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
 8015f5a:	68bb      	ldr	r3, [r7, #8]
 8015f5c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8015f60:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8015f64:	2100      	movs	r1, #0
 8015f66:	4618      	mov	r0, r3
 8015f68:	f012 f98a 	bl	8028280 <memset>
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
 8015f6c:	68bb      	ldr	r3, [r7, #8]
 8015f6e:	f503 7060 	add.w	r0, r3, #896	; 0x380
 8015f72:	687b      	ldr	r3, [r7, #4]
 8015f74:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8015f78:	2280      	movs	r2, #128	; 0x80
 8015f7a:	4619      	mov	r1, r3
 8015f7c:	f012 f972 	bl	8028264 <memcpy>
	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
}
 8015f80:	bf00      	nop
 8015f82:	3710      	adds	r7, #16
 8015f84:	46bd      	mov	sp, r7
 8015f86:	bd80      	pop	{r7, pc}

08015f88 <master_selection>:
 * settings.
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
 8015f88:	b580      	push	{r7, lr}
 8015f8a:	b088      	sub	sp, #32
 8015f8c:	af00      	add	r7, sp, #0
 8015f8e:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 8015f90:	687b      	ldr	r3, [r7, #4]
 8015f92:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 8015f96:	61bb      	str	r3, [r7, #24]
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
 8015f98:	6878      	ldr	r0, [r7, #4]
 8015f9a:	f7ff fe73 	bl	8015c84 <jpeg_calc_output_dimensions>
  prepare_range_limit_table(cinfo);
 8015f9e:	6878      	ldr	r0, [r7, #4]
 8015fa0:	f7ff ff9c 	bl	8015edc <prepare_range_limit_table>

  /* Width of an output scanline must be representable as JDIMENSION. */
  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
 8015fa4:	687b      	ldr	r3, [r7, #4]
 8015fa6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8015fa8:	461a      	mov	r2, r3
 8015faa:	687b      	ldr	r3, [r7, #4]
 8015fac:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015fae:	fb03 f302 	mul.w	r3, r3, r2
 8015fb2:	617b      	str	r3, [r7, #20]
  jd_samplesperrow = (JDIMENSION) samplesperrow;
 8015fb4:	697b      	ldr	r3, [r7, #20]
 8015fb6:	613b      	str	r3, [r7, #16]
  if ((long) jd_samplesperrow != samplesperrow)
 8015fb8:	693b      	ldr	r3, [r7, #16]
 8015fba:	697a      	ldr	r2, [r7, #20]
 8015fbc:	429a      	cmp	r2, r3
 8015fbe:	d008      	beq.n	8015fd2 <master_selection+0x4a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 8015fc0:	687b      	ldr	r3, [r7, #4]
 8015fc2:	681b      	ldr	r3, [r3, #0]
 8015fc4:	2248      	movs	r2, #72	; 0x48
 8015fc6:	615a      	str	r2, [r3, #20]
 8015fc8:	687b      	ldr	r3, [r7, #4]
 8015fca:	681b      	ldr	r3, [r3, #0]
 8015fcc:	681b      	ldr	r3, [r3, #0]
 8015fce:	6878      	ldr	r0, [r7, #4]
 8015fd0:	4798      	blx	r3

  /* Initialize my private state */
  master->pass_number = 0;
 8015fd2:	69bb      	ldr	r3, [r7, #24]
 8015fd4:	2200      	movs	r2, #0
 8015fd6:	60da      	str	r2, [r3, #12]
  master->using_merged_upsample = use_merged_upsample(cinfo);
 8015fd8:	6878      	ldr	r0, [r7, #4]
 8015fda:	f7ff fdc3 	bl	8015b64 <use_merged_upsample>
 8015fde:	4602      	mov	r2, r0
 8015fe0:	69bb      	ldr	r3, [r7, #24]
 8015fe2:	611a      	str	r2, [r3, #16]

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
 8015fe4:	69bb      	ldr	r3, [r7, #24]
 8015fe6:	2200      	movs	r2, #0
 8015fe8:	615a      	str	r2, [r3, #20]
  master->quantizer_2pass = NULL;
 8015fea:	69bb      	ldr	r3, [r7, #24]
 8015fec:	2200      	movs	r2, #0
 8015fee:	619a      	str	r2, [r3, #24]
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
 8015ff0:	687b      	ldr	r3, [r7, #4]
 8015ff2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015ff4:	2b00      	cmp	r3, #0
 8015ff6:	d003      	beq.n	8016000 <master_selection+0x78>
 8015ff8:	687b      	ldr	r3, [r7, #4]
 8015ffa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8015ffc:	2b00      	cmp	r3, #0
 8015ffe:	d108      	bne.n	8016012 <master_selection+0x8a>
    cinfo->enable_1pass_quant = FALSE;
 8016000:	687b      	ldr	r3, [r7, #4]
 8016002:	2200      	movs	r2, #0
 8016004:	665a      	str	r2, [r3, #100]	; 0x64
    cinfo->enable_external_quant = FALSE;
 8016006:	687b      	ldr	r3, [r7, #4]
 8016008:	2200      	movs	r2, #0
 801600a:	669a      	str	r2, [r3, #104]	; 0x68
    cinfo->enable_2pass_quant = FALSE;
 801600c:	687b      	ldr	r3, [r7, #4]
 801600e:	2200      	movs	r2, #0
 8016010:	66da      	str	r2, [r3, #108]	; 0x6c
  }
  if (cinfo->quantize_colors) {
 8016012:	687b      	ldr	r3, [r7, #4]
 8016014:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016016:	2b00      	cmp	r3, #0
 8016018:	d04e      	beq.n	80160b8 <master_selection+0x130>
    if (cinfo->raw_data_out)
 801601a:	687b      	ldr	r3, [r7, #4]
 801601c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801601e:	2b00      	cmp	r3, #0
 8016020:	d008      	beq.n	8016034 <master_selection+0xac>
      ERREXIT(cinfo, JERR_NOTIMPL);
 8016022:	687b      	ldr	r3, [r7, #4]
 8016024:	681b      	ldr	r3, [r3, #0]
 8016026:	2230      	movs	r2, #48	; 0x30
 8016028:	615a      	str	r2, [r3, #20]
 801602a:	687b      	ldr	r3, [r7, #4]
 801602c:	681b      	ldr	r3, [r3, #0]
 801602e:	681b      	ldr	r3, [r3, #0]
 8016030:	6878      	ldr	r0, [r7, #4]
 8016032:	4798      	blx	r3
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
 8016034:	687b      	ldr	r3, [r7, #4]
 8016036:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016038:	2b03      	cmp	r3, #3
 801603a:	d00d      	beq.n	8016058 <master_selection+0xd0>
      cinfo->enable_1pass_quant = TRUE;
 801603c:	687b      	ldr	r3, [r7, #4]
 801603e:	2201      	movs	r2, #1
 8016040:	665a      	str	r2, [r3, #100]	; 0x64
      cinfo->enable_external_quant = FALSE;
 8016042:	687b      	ldr	r3, [r7, #4]
 8016044:	2200      	movs	r2, #0
 8016046:	669a      	str	r2, [r3, #104]	; 0x68
      cinfo->enable_2pass_quant = FALSE;
 8016048:	687b      	ldr	r3, [r7, #4]
 801604a:	2200      	movs	r2, #0
 801604c:	66da      	str	r2, [r3, #108]	; 0x6c
      cinfo->colormap = NULL;
 801604e:	687b      	ldr	r3, [r7, #4]
 8016050:	2200      	movs	r2, #0
 8016052:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 8016056:	e013      	b.n	8016080 <master_selection+0xf8>
    } else if (cinfo->colormap != NULL) {
 8016058:	687b      	ldr	r3, [r7, #4]
 801605a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801605e:	2b00      	cmp	r3, #0
 8016060:	d003      	beq.n	801606a <master_selection+0xe2>
      cinfo->enable_external_quant = TRUE;
 8016062:	687b      	ldr	r3, [r7, #4]
 8016064:	2201      	movs	r2, #1
 8016066:	669a      	str	r2, [r3, #104]	; 0x68
 8016068:	e00a      	b.n	8016080 <master_selection+0xf8>
    } else if (cinfo->two_pass_quantize) {
 801606a:	687b      	ldr	r3, [r7, #4]
 801606c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 801606e:	2b00      	cmp	r3, #0
 8016070:	d003      	beq.n	801607a <master_selection+0xf2>
      cinfo->enable_2pass_quant = TRUE;
 8016072:	687b      	ldr	r3, [r7, #4]
 8016074:	2201      	movs	r2, #1
 8016076:	66da      	str	r2, [r3, #108]	; 0x6c
 8016078:	e002      	b.n	8016080 <master_selection+0xf8>
    } else {
      cinfo->enable_1pass_quant = TRUE;
 801607a:	687b      	ldr	r3, [r7, #4]
 801607c:	2201      	movs	r2, #1
 801607e:	665a      	str	r2, [r3, #100]	; 0x64
    }

    if (cinfo->enable_1pass_quant) {
 8016080:	687b      	ldr	r3, [r7, #4]
 8016082:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8016084:	2b00      	cmp	r3, #0
 8016086:	d007      	beq.n	8016098 <master_selection+0x110>
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
 8016088:	6878      	ldr	r0, [r7, #4]
 801608a:	f010 f933 	bl	80262f4 <jinit_1pass_quantizer>
      master->quantizer_1pass = cinfo->cquantize;
 801608e:	687b      	ldr	r3, [r7, #4]
 8016090:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 8016094:	69bb      	ldr	r3, [r7, #24]
 8016096:	615a      	str	r2, [r3, #20]
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
 8016098:	687b      	ldr	r3, [r7, #4]
 801609a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801609c:	2b00      	cmp	r3, #0
 801609e:	d103      	bne.n	80160a8 <master_selection+0x120>
 80160a0:	687b      	ldr	r3, [r7, #4]
 80160a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80160a4:	2b00      	cmp	r3, #0
 80160a6:	d007      	beq.n	80160b8 <master_selection+0x130>
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
 80160a8:	6878      	ldr	r0, [r7, #4]
 80160aa:	f011 fc83 	bl	80279b4 <jinit_2pass_quantizer>
      master->quantizer_2pass = cinfo->cquantize;
 80160ae:	687b      	ldr	r3, [r7, #4]
 80160b0:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 80160b4:	69bb      	ldr	r3, [r7, #24]
 80160b6:	619a      	str	r2, [r3, #24]
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
 80160b8:	687b      	ldr	r3, [r7, #4]
 80160ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80160bc:	2b00      	cmp	r3, #0
 80160be:	d113      	bne.n	80160e8 <master_selection+0x160>
    if (master->using_merged_upsample) {
 80160c0:	69bb      	ldr	r3, [r7, #24]
 80160c2:	691b      	ldr	r3, [r3, #16]
 80160c4:	2b00      	cmp	r3, #0
 80160c6:	d003      	beq.n	80160d0 <master_selection+0x148>
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
 80160c8:	6878      	ldr	r0, [r7, #4]
 80160ca:	f000 fca1 	bl	8016a10 <jinit_merged_upsampler>
 80160ce:	e005      	b.n	80160dc <master_selection+0x154>
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
 80160d0:	6878      	ldr	r0, [r7, #4]
 80160d2:	f7f9 f991 	bl	800f3f8 <jinit_color_deconverter>
      jinit_upsampler(cinfo);
 80160d6:	6878      	ldr	r0, [r7, #4]
 80160d8:	f001 f88e 	bl	80171f8 <jinit_upsampler>
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
 80160dc:	687b      	ldr	r3, [r7, #4]
 80160de:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80160e0:	4619      	mov	r1, r3
 80160e2:	6878      	ldr	r0, [r7, #4]
 80160e4:	f000 fe6e 	bl	8016dc4 <jinit_d_post_controller>
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
 80160e8:	6878      	ldr	r0, [r7, #4]
 80160ea:	f7f9 fde7 	bl	800fcbc <jinit_inverse_dct>
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code)
 80160ee:	687b      	ldr	r3, [r7, #4]
 80160f0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80160f4:	2b00      	cmp	r3, #0
 80160f6:	d003      	beq.n	8016100 <master_selection+0x178>
    jinit_arith_decoder(cinfo);
 80160f8:	6878      	ldr	r0, [r7, #4]
 80160fa:	f7f7 fc21 	bl	800d940 <jinit_arith_decoder>
 80160fe:	e002      	b.n	8016106 <master_selection+0x17e>
  else {
    jinit_huff_decoder(cinfo);
 8016100:	6878      	ldr	r0, [r7, #4]
 8016102:	f7fb fdd5 	bl	8011cb0 <jinit_huff_decoder>
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
 8016106:	687b      	ldr	r3, [r7, #4]
 8016108:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 801610c:	691b      	ldr	r3, [r3, #16]
 801610e:	2b00      	cmp	r3, #0
 8016110:	d103      	bne.n	801611a <master_selection+0x192>
 8016112:	687b      	ldr	r3, [r7, #4]
 8016114:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8016116:	2b00      	cmp	r3, #0
 8016118:	d001      	beq.n	801611e <master_selection+0x196>
 801611a:	2301      	movs	r3, #1
 801611c:	e000      	b.n	8016120 <master_selection+0x198>
 801611e:	2300      	movs	r3, #0
 8016120:	60fb      	str	r3, [r7, #12]
  jinit_d_coef_controller(cinfo, use_c_buffer);
 8016122:	68f9      	ldr	r1, [r7, #12]
 8016124:	6878      	ldr	r0, [r7, #4]
 8016126:	f7f8 fd9b 	bl	800ec60 <jinit_d_coef_controller>

  if (! cinfo->raw_data_out)
 801612a:	687b      	ldr	r3, [r7, #4]
 801612c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801612e:	2b00      	cmp	r3, #0
 8016130:	d103      	bne.n	801613a <master_selection+0x1b2>
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
 8016132:	2100      	movs	r1, #0
 8016134:	6878      	ldr	r0, [r7, #4]
 8016136:	f7fd fad9 	bl	80136ec <jinit_d_main_controller>

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
 801613a:	687b      	ldr	r3, [r7, #4]
 801613c:	685b      	ldr	r3, [r3, #4]
 801613e:	699b      	ldr	r3, [r3, #24]
 8016140:	6878      	ldr	r0, [r7, #4]
 8016142:	4798      	blx	r3

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);
 8016144:	687b      	ldr	r3, [r7, #4]
 8016146:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 801614a:	689b      	ldr	r3, [r3, #8]
 801614c:	6878      	ldr	r0, [r7, #4]
 801614e:	4798      	blx	r3
#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 8016150:	687b      	ldr	r3, [r7, #4]
 8016152:	689b      	ldr	r3, [r3, #8]
 8016154:	2b00      	cmp	r3, #0
 8016156:	d03a      	beq.n	80161ce <master_selection+0x246>
 8016158:	687b      	ldr	r3, [r7, #4]
 801615a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801615c:	2b00      	cmp	r3, #0
 801615e:	d136      	bne.n	80161ce <master_selection+0x246>
      cinfo->inputctl->has_multiple_scans) {
 8016160:	687b      	ldr	r3, [r7, #4]
 8016162:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8016166:	691b      	ldr	r3, [r3, #16]
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
 8016168:	2b00      	cmp	r3, #0
 801616a:	d030      	beq.n	80161ce <master_selection+0x246>
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
 801616c:	687b      	ldr	r3, [r7, #4]
 801616e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8016172:	2b00      	cmp	r3, #0
 8016174:	d007      	beq.n	8016186 <master_selection+0x1fe>
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
 8016176:	687b      	ldr	r3, [r7, #4]
 8016178:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801617a:	4613      	mov	r3, r2
 801617c:	005b      	lsls	r3, r3, #1
 801617e:	4413      	add	r3, r2
 8016180:	3302      	adds	r3, #2
 8016182:	61fb      	str	r3, [r7, #28]
 8016184:	e002      	b.n	801618c <master_selection+0x204>
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
 8016186:	687b      	ldr	r3, [r7, #4]
 8016188:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801618a:	61fb      	str	r3, [r7, #28]
    }
    cinfo->progress->pass_counter = 0L;
 801618c:	687b      	ldr	r3, [r7, #4]
 801618e:	689b      	ldr	r3, [r3, #8]
 8016190:	2200      	movs	r2, #0
 8016192:	605a      	str	r2, [r3, #4]
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
 8016194:	687b      	ldr	r3, [r7, #4]
 8016196:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 801619a:	4619      	mov	r1, r3
 801619c:	687b      	ldr	r3, [r7, #4]
 801619e:	689b      	ldr	r3, [r3, #8]
 80161a0:	69fa      	ldr	r2, [r7, #28]
 80161a2:	fb02 f201 	mul.w	r2, r2, r1
 80161a6:	609a      	str	r2, [r3, #8]
    cinfo->progress->completed_passes = 0;
 80161a8:	687b      	ldr	r3, [r7, #4]
 80161aa:	689b      	ldr	r3, [r3, #8]
 80161ac:	2200      	movs	r2, #0
 80161ae:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
 80161b0:	687b      	ldr	r3, [r7, #4]
 80161b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80161b4:	2b00      	cmp	r3, #0
 80161b6:	d001      	beq.n	80161bc <master_selection+0x234>
 80161b8:	2203      	movs	r2, #3
 80161ba:	e000      	b.n	80161be <master_selection+0x236>
 80161bc:	2202      	movs	r2, #2
 80161be:	687b      	ldr	r3, [r7, #4]
 80161c0:	689b      	ldr	r3, [r3, #8]
 80161c2:	611a      	str	r2, [r3, #16]
    /* Count the input pass as done */
    master->pass_number++;
 80161c4:	69bb      	ldr	r3, [r7, #24]
 80161c6:	68db      	ldr	r3, [r3, #12]
 80161c8:	1c5a      	adds	r2, r3, #1
 80161ca:	69bb      	ldr	r3, [r7, #24]
 80161cc:	60da      	str	r2, [r3, #12]
  }
#endif /* D_MULTISCAN_FILES_SUPPORTED */
}
 80161ce:	bf00      	nop
 80161d0:	3720      	adds	r7, #32
 80161d2:	46bd      	mov	sp, r7
 80161d4:	bd80      	pop	{r7, pc}

080161d6 <prepare_for_output_pass>:
 * (In the latter case, jdapistd.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
 80161d6:	b580      	push	{r7, lr}
 80161d8:	b084      	sub	sp, #16
 80161da:	af00      	add	r7, sp, #0
 80161dc:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 80161de:	687b      	ldr	r3, [r7, #4]
 80161e0:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 80161e4:	60fb      	str	r3, [r7, #12]

  if (master->pub.is_dummy_pass) {
 80161e6:	68fb      	ldr	r3, [r7, #12]
 80161e8:	689b      	ldr	r3, [r3, #8]
 80161ea:	2b00      	cmp	r3, #0
 80161ec:	d018      	beq.n	8016220 <prepare_for_output_pass+0x4a>
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
 80161ee:	68fb      	ldr	r3, [r7, #12]
 80161f0:	2200      	movs	r2, #0
 80161f2:	609a      	str	r2, [r3, #8]
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
 80161f4:	687b      	ldr	r3, [r7, #4]
 80161f6:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80161fa:	681b      	ldr	r3, [r3, #0]
 80161fc:	2100      	movs	r1, #0
 80161fe:	6878      	ldr	r0, [r7, #4]
 8016200:	4798      	blx	r3
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
 8016202:	687b      	ldr	r3, [r7, #4]
 8016204:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8016208:	681b      	ldr	r3, [r3, #0]
 801620a:	2102      	movs	r1, #2
 801620c:	6878      	ldr	r0, [r7, #4]
 801620e:	4798      	blx	r3
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
 8016210:	687b      	ldr	r3, [r7, #4]
 8016212:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 8016216:	681b      	ldr	r3, [r3, #0]
 8016218:	2102      	movs	r1, #2
 801621a:	6878      	ldr	r0, [r7, #4]
 801621c:	4798      	blx	r3
 801621e:	e06e      	b.n	80162fe <prepare_for_output_pass+0x128>
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
 8016220:	687b      	ldr	r3, [r7, #4]
 8016222:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016224:	2b00      	cmp	r3, #0
 8016226:	d028      	beq.n	801627a <prepare_for_output_pass+0xa4>
 8016228:	687b      	ldr	r3, [r7, #4]
 801622a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801622e:	2b00      	cmp	r3, #0
 8016230:	d123      	bne.n	801627a <prepare_for_output_pass+0xa4>
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
 8016232:	687b      	ldr	r3, [r7, #4]
 8016234:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8016236:	2b00      	cmp	r3, #0
 8016238:	d00c      	beq.n	8016254 <prepare_for_output_pass+0x7e>
 801623a:	687b      	ldr	r3, [r7, #4]
 801623c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801623e:	2b00      	cmp	r3, #0
 8016240:	d008      	beq.n	8016254 <prepare_for_output_pass+0x7e>
	cinfo->cquantize = master->quantizer_2pass;
 8016242:	68fb      	ldr	r3, [r7, #12]
 8016244:	699a      	ldr	r2, [r3, #24]
 8016246:	687b      	ldr	r3, [r7, #4]
 8016248:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
	master->pub.is_dummy_pass = TRUE;
 801624c:	68fb      	ldr	r3, [r7, #12]
 801624e:	2201      	movs	r2, #1
 8016250:	609a      	str	r2, [r3, #8]
 8016252:	e012      	b.n	801627a <prepare_for_output_pass+0xa4>
      } else if (cinfo->enable_1pass_quant) {
 8016254:	687b      	ldr	r3, [r7, #4]
 8016256:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8016258:	2b00      	cmp	r3, #0
 801625a:	d005      	beq.n	8016268 <prepare_for_output_pass+0x92>
	cinfo->cquantize = master->quantizer_1pass;
 801625c:	68fb      	ldr	r3, [r7, #12]
 801625e:	695a      	ldr	r2, [r3, #20]
 8016260:	687b      	ldr	r3, [r7, #4]
 8016262:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
 8016266:	e008      	b.n	801627a <prepare_for_output_pass+0xa4>
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
 8016268:	687b      	ldr	r3, [r7, #4]
 801626a:	681b      	ldr	r3, [r3, #0]
 801626c:	222f      	movs	r2, #47	; 0x2f
 801626e:	615a      	str	r2, [r3, #20]
 8016270:	687b      	ldr	r3, [r7, #4]
 8016272:	681b      	ldr	r3, [r3, #0]
 8016274:	681b      	ldr	r3, [r3, #0]
 8016276:	6878      	ldr	r0, [r7, #4]
 8016278:	4798      	blx	r3
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
 801627a:	687b      	ldr	r3, [r7, #4]
 801627c:	f8d3 31d4 	ldr.w	r3, [r3, #468]	; 0x1d4
 8016280:	681b      	ldr	r3, [r3, #0]
 8016282:	6878      	ldr	r0, [r7, #4]
 8016284:	4798      	blx	r3
    (*cinfo->coef->start_output_pass) (cinfo);
 8016286:	687b      	ldr	r3, [r7, #4]
 8016288:	f8d3 31c0 	ldr.w	r3, [r3, #448]	; 0x1c0
 801628c:	689b      	ldr	r3, [r3, #8]
 801628e:	6878      	ldr	r0, [r7, #4]
 8016290:	4798      	blx	r3
    if (! cinfo->raw_data_out) {
 8016292:	687b      	ldr	r3, [r7, #4]
 8016294:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016296:	2b00      	cmp	r3, #0
 8016298:	d131      	bne.n	80162fe <prepare_for_output_pass+0x128>
      if (! master->using_merged_upsample)
 801629a:	68fb      	ldr	r3, [r7, #12]
 801629c:	691b      	ldr	r3, [r3, #16]
 801629e:	2b00      	cmp	r3, #0
 80162a0:	d105      	bne.n	80162ae <prepare_for_output_pass+0xd8>
	(*cinfo->cconvert->start_pass) (cinfo);
 80162a2:	687b      	ldr	r3, [r7, #4]
 80162a4:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 80162a8:	681b      	ldr	r3, [r3, #0]
 80162aa:	6878      	ldr	r0, [r7, #4]
 80162ac:	4798      	blx	r3
      (*cinfo->upsample->start_pass) (cinfo);
 80162ae:	687b      	ldr	r3, [r7, #4]
 80162b0:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 80162b4:	681b      	ldr	r3, [r3, #0]
 80162b6:	6878      	ldr	r0, [r7, #4]
 80162b8:	4798      	blx	r3
      if (cinfo->quantize_colors)
 80162ba:	687b      	ldr	r3, [r7, #4]
 80162bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80162be:	2b00      	cmp	r3, #0
 80162c0:	d008      	beq.n	80162d4 <prepare_for_output_pass+0xfe>
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
 80162c2:	687b      	ldr	r3, [r7, #4]
 80162c4:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80162c8:	681b      	ldr	r3, [r3, #0]
 80162ca:	68fa      	ldr	r2, [r7, #12]
 80162cc:	6892      	ldr	r2, [r2, #8]
 80162ce:	4611      	mov	r1, r2
 80162d0:	6878      	ldr	r0, [r7, #4]
 80162d2:	4798      	blx	r3
      (*cinfo->post->start_pass) (cinfo,
 80162d4:	687b      	ldr	r3, [r7, #4]
 80162d6:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 80162da:	681b      	ldr	r3, [r3, #0]
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
 80162dc:	68fa      	ldr	r2, [r7, #12]
 80162de:	6892      	ldr	r2, [r2, #8]
      (*cinfo->post->start_pass) (cinfo,
 80162e0:	2a00      	cmp	r2, #0
 80162e2:	d001      	beq.n	80162e8 <prepare_for_output_pass+0x112>
 80162e4:	2203      	movs	r2, #3
 80162e6:	e000      	b.n	80162ea <prepare_for_output_pass+0x114>
 80162e8:	2200      	movs	r2, #0
 80162ea:	4611      	mov	r1, r2
 80162ec:	6878      	ldr	r0, [r7, #4]
 80162ee:	4798      	blx	r3
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
 80162f0:	687b      	ldr	r3, [r7, #4]
 80162f2:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 80162f6:	681b      	ldr	r3, [r3, #0]
 80162f8:	2100      	movs	r1, #0
 80162fa:	6878      	ldr	r0, [r7, #4]
 80162fc:	4798      	blx	r3
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
 80162fe:	687b      	ldr	r3, [r7, #4]
 8016300:	689b      	ldr	r3, [r3, #8]
 8016302:	2b00      	cmp	r3, #0
 8016304:	d029      	beq.n	801635a <prepare_for_output_pass+0x184>
    cinfo->progress->completed_passes = master->pass_number;
 8016306:	687b      	ldr	r3, [r7, #4]
 8016308:	689b      	ldr	r3, [r3, #8]
 801630a:	68fa      	ldr	r2, [r7, #12]
 801630c:	68d2      	ldr	r2, [r2, #12]
 801630e:	60da      	str	r2, [r3, #12]
    cinfo->progress->total_passes = master->pass_number +
 8016310:	68fb      	ldr	r3, [r7, #12]
 8016312:	68da      	ldr	r2, [r3, #12]
				    (master->pub.is_dummy_pass ? 2 : 1);
 8016314:	68fb      	ldr	r3, [r7, #12]
 8016316:	689b      	ldr	r3, [r3, #8]
 8016318:	2b00      	cmp	r3, #0
 801631a:	d001      	beq.n	8016320 <prepare_for_output_pass+0x14a>
 801631c:	2102      	movs	r1, #2
 801631e:	e000      	b.n	8016322 <prepare_for_output_pass+0x14c>
 8016320:	2101      	movs	r1, #1
    cinfo->progress->total_passes = master->pass_number +
 8016322:	687b      	ldr	r3, [r7, #4]
 8016324:	689b      	ldr	r3, [r3, #8]
 8016326:	440a      	add	r2, r1
 8016328:	611a      	str	r2, [r3, #16]
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
 801632a:	687b      	ldr	r3, [r7, #4]
 801632c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801632e:	2b00      	cmp	r3, #0
 8016330:	d013      	beq.n	801635a <prepare_for_output_pass+0x184>
 8016332:	687b      	ldr	r3, [r7, #4]
 8016334:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 8016338:	695b      	ldr	r3, [r3, #20]
 801633a:	2b00      	cmp	r3, #0
 801633c:	d10d      	bne.n	801635a <prepare_for_output_pass+0x184>
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
 801633e:	687b      	ldr	r3, [r7, #4]
 8016340:	689b      	ldr	r3, [r3, #8]
 8016342:	691a      	ldr	r2, [r3, #16]
 8016344:	687b      	ldr	r3, [r7, #4]
 8016346:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8016348:	2b00      	cmp	r3, #0
 801634a:	d001      	beq.n	8016350 <prepare_for_output_pass+0x17a>
 801634c:	2102      	movs	r1, #2
 801634e:	e000      	b.n	8016352 <prepare_for_output_pass+0x17c>
 8016350:	2101      	movs	r1, #1
 8016352:	687b      	ldr	r3, [r7, #4]
 8016354:	689b      	ldr	r3, [r3, #8]
 8016356:	440a      	add	r2, r1
 8016358:	611a      	str	r2, [r3, #16]
    }
  }
}
 801635a:	bf00      	nop
 801635c:	3710      	adds	r7, #16
 801635e:	46bd      	mov	sp, r7
 8016360:	bd80      	pop	{r7, pc}

08016362 <finish_output_pass>:
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
 8016362:	b580      	push	{r7, lr}
 8016364:	b084      	sub	sp, #16
 8016366:	af00      	add	r7, sp, #0
 8016368:	6078      	str	r0, [r7, #4]
  my_master_ptr master = (my_master_ptr) cinfo->master;
 801636a:	687b      	ldr	r3, [r7, #4]
 801636c:	f8d3 31b8 	ldr.w	r3, [r3, #440]	; 0x1b8
 8016370:	60fb      	str	r3, [r7, #12]

  if (cinfo->quantize_colors)
 8016372:	687b      	ldr	r3, [r7, #4]
 8016374:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016376:	2b00      	cmp	r3, #0
 8016378:	d005      	beq.n	8016386 <finish_output_pass+0x24>
    (*cinfo->cquantize->finish_pass) (cinfo);
 801637a:	687b      	ldr	r3, [r7, #4]
 801637c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8016380:	689b      	ldr	r3, [r3, #8]
 8016382:	6878      	ldr	r0, [r7, #4]
 8016384:	4798      	blx	r3
  master->pass_number++;
 8016386:	68fb      	ldr	r3, [r7, #12]
 8016388:	68db      	ldr	r3, [r3, #12]
 801638a:	1c5a      	adds	r2, r3, #1
 801638c:	68fb      	ldr	r3, [r7, #12]
 801638e:	60da      	str	r2, [r3, #12]
}
 8016390:	bf00      	nop
 8016392:	3710      	adds	r7, #16
 8016394:	46bd      	mov	sp, r7
 8016396:	bd80      	pop	{r7, pc}

08016398 <jinit_master_decompress>:
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
 8016398:	b580      	push	{r7, lr}
 801639a:	b084      	sub	sp, #16
 801639c:	af00      	add	r7, sp, #0
 801639e:	6078      	str	r0, [r7, #4]
  my_master_ptr master;

  master = (my_master_ptr)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80163a0:	687b      	ldr	r3, [r7, #4]
 80163a2:	685b      	ldr	r3, [r3, #4]
 80163a4:	681b      	ldr	r3, [r3, #0]
 80163a6:	221c      	movs	r2, #28
 80163a8:	2101      	movs	r1, #1
 80163aa:	6878      	ldr	r0, [r7, #4]
 80163ac:	4798      	blx	r3
 80163ae:	60f8      	str	r0, [r7, #12]
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
 80163b0:	687b      	ldr	r3, [r7, #4]
 80163b2:	68fa      	ldr	r2, [r7, #12]
 80163b4:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
 80163b8:	68fb      	ldr	r3, [r7, #12]
 80163ba:	4a07      	ldr	r2, [pc, #28]	; (80163d8 <jinit_master_decompress+0x40>)
 80163bc:	601a      	str	r2, [r3, #0]
  master->pub.finish_output_pass = finish_output_pass;
 80163be:	68fb      	ldr	r3, [r7, #12]
 80163c0:	4a06      	ldr	r2, [pc, #24]	; (80163dc <jinit_master_decompress+0x44>)
 80163c2:	605a      	str	r2, [r3, #4]

  master->pub.is_dummy_pass = FALSE;
 80163c4:	68fb      	ldr	r3, [r7, #12]
 80163c6:	2200      	movs	r2, #0
 80163c8:	609a      	str	r2, [r3, #8]

  master_selection(cinfo);
 80163ca:	6878      	ldr	r0, [r7, #4]
 80163cc:	f7ff fddc 	bl	8015f88 <master_selection>
}
 80163d0:	bf00      	nop
 80163d2:	3710      	adds	r7, #16
 80163d4:	46bd      	mov	sp, r7
 80163d6:	bd80      	pop	{r7, pc}
 80163d8:	080161d7 	.word	0x080161d7
 80163dc:	08016363 	.word	0x08016363

080163e0 <build_ycc_rgb_table>:
 * This is taken directly from jdcolor.c; see that file for more info.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
 80163e0:	b580      	push	{r7, lr}
 80163e2:	b086      	sub	sp, #24
 80163e4:	af00      	add	r7, sp, #0
 80163e6:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 80163e8:	687b      	ldr	r3, [r7, #4]
 80163ea:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 80163ee:	60fb      	str	r3, [r7, #12]
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80163f0:	687b      	ldr	r3, [r7, #4]
 80163f2:	685b      	ldr	r3, [r3, #4]
 80163f4:	681b      	ldr	r3, [r3, #0]
 80163f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80163fa:	2101      	movs	r1, #1
 80163fc:	6878      	ldr	r0, [r7, #4]
 80163fe:	4798      	blx	r3
 8016400:	4602      	mov	r2, r0
  upsample->Cr_r_tab = (int *)
 8016402:	68fb      	ldr	r3, [r7, #12]
 8016404:	611a      	str	r2, [r3, #16]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016406:	687b      	ldr	r3, [r7, #4]
 8016408:	685b      	ldr	r3, [r3, #4]
 801640a:	681b      	ldr	r3, [r3, #0]
 801640c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016410:	2101      	movs	r1, #1
 8016412:	6878      	ldr	r0, [r7, #4]
 8016414:	4798      	blx	r3
 8016416:	4602      	mov	r2, r0
  upsample->Cb_b_tab = (int *)
 8016418:	68fb      	ldr	r3, [r7, #12]
 801641a:	615a      	str	r2, [r3, #20]
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 801641c:	687b      	ldr	r3, [r7, #4]
 801641e:	685b      	ldr	r3, [r3, #4]
 8016420:	681b      	ldr	r3, [r3, #0]
 8016422:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016426:	2101      	movs	r1, #1
 8016428:	6878      	ldr	r0, [r7, #4]
 801642a:	4798      	blx	r3
 801642c:	4602      	mov	r2, r0
  upsample->Cr_g_tab = (INT32 *)
 801642e:	68fb      	ldr	r3, [r7, #12]
 8016430:	619a      	str	r2, [r3, #24]
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016432:	687b      	ldr	r3, [r7, #4]
 8016434:	685b      	ldr	r3, [r3, #4]
 8016436:	681b      	ldr	r3, [r3, #0]
 8016438:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801643c:	2101      	movs	r1, #1
 801643e:	6878      	ldr	r0, [r7, #4]
 8016440:	4798      	blx	r3
 8016442:	4602      	mov	r2, r0
  upsample->Cb_g_tab = (INT32 *)
 8016444:	68fb      	ldr	r3, [r7, #12]
 8016446:	61da      	str	r2, [r3, #28]
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 8016448:	2300      	movs	r3, #0
 801644a:	617b      	str	r3, [r7, #20]
 801644c:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 8016450:	613b      	str	r3, [r7, #16]
 8016452:	e035      	b.n	80164c0 <build_ycc_rgb_table+0xe0>
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 8016454:	693b      	ldr	r3, [r7, #16]
 8016456:	4a1e      	ldr	r2, [pc, #120]	; (80164d0 <build_ycc_rgb_table+0xf0>)
 8016458:	fb02 f303 	mul.w	r3, r2, r3
 801645c:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
    upsample->Cr_r_tab[i] = (int)
 8016460:	68fb      	ldr	r3, [r7, #12]
 8016462:	6919      	ldr	r1, [r3, #16]
 8016464:	697b      	ldr	r3, [r7, #20]
 8016466:	009b      	lsls	r3, r3, #2
 8016468:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
 801646a:	1412      	asrs	r2, r2, #16
    upsample->Cr_r_tab[i] = (int)
 801646c:	601a      	str	r2, [r3, #0]
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 801646e:	693b      	ldr	r3, [r7, #16]
 8016470:	4a18      	ldr	r2, [pc, #96]	; (80164d4 <build_ycc_rgb_table+0xf4>)
 8016472:	fb02 f303 	mul.w	r3, r2, r3
 8016476:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
    upsample->Cb_b_tab[i] = (int)
 801647a:	68fb      	ldr	r3, [r7, #12]
 801647c:	6959      	ldr	r1, [r3, #20]
 801647e:	697b      	ldr	r3, [r7, #20]
 8016480:	009b      	lsls	r3, r3, #2
 8016482:	440b      	add	r3, r1
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
 8016484:	1412      	asrs	r2, r2, #16
    upsample->Cb_b_tab[i] = (int)
 8016486:	601a      	str	r2, [r3, #0]
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
 8016488:	68fb      	ldr	r3, [r7, #12]
 801648a:	699a      	ldr	r2, [r3, #24]
 801648c:	697b      	ldr	r3, [r7, #20]
 801648e:	009b      	lsls	r3, r3, #2
 8016490:	4413      	add	r3, r2
 8016492:	693a      	ldr	r2, [r7, #16]
 8016494:	4910      	ldr	r1, [pc, #64]	; (80164d8 <build_ycc_rgb_table+0xf8>)
 8016496:	fb01 f202 	mul.w	r2, r1, r2
 801649a:	601a      	str	r2, [r3, #0]
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
 801649c:	693b      	ldr	r3, [r7, #16]
 801649e:	4a0f      	ldr	r2, [pc, #60]	; (80164dc <build_ycc_rgb_table+0xfc>)
 80164a0:	fb02 f203 	mul.w	r2, r2, r3
 80164a4:	68fb      	ldr	r3, [r7, #12]
 80164a6:	69d9      	ldr	r1, [r3, #28]
 80164a8:	697b      	ldr	r3, [r7, #20]
 80164aa:	009b      	lsls	r3, r3, #2
 80164ac:	440b      	add	r3, r1
 80164ae:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 80164b2:	601a      	str	r2, [r3, #0]
  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
 80164b4:	697b      	ldr	r3, [r7, #20]
 80164b6:	3301      	adds	r3, #1
 80164b8:	617b      	str	r3, [r7, #20]
 80164ba:	693b      	ldr	r3, [r7, #16]
 80164bc:	3301      	adds	r3, #1
 80164be:	613b      	str	r3, [r7, #16]
 80164c0:	697b      	ldr	r3, [r7, #20]
 80164c2:	2bff      	cmp	r3, #255	; 0xff
 80164c4:	ddc6      	ble.n	8016454 <build_ycc_rgb_table+0x74>
  }
}
 80164c6:	bf00      	nop
 80164c8:	bf00      	nop
 80164ca:	3718      	adds	r7, #24
 80164cc:	46bd      	mov	sp, r7
 80164ce:	bd80      	pop	{r7, pc}
 80164d0:	000166e9 	.word	0x000166e9
 80164d4:	0001c5a2 	.word	0x0001c5a2
 80164d8:	ffff492e 	.word	0xffff492e
 80164dc:	ffffa7e6 	.word	0xffffa7e6

080164e0 <start_pass_merged_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
 80164e0:	b480      	push	{r7}
 80164e2:	b085      	sub	sp, #20
 80164e4:	af00      	add	r7, sp, #0
 80164e6:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 80164e8:	687b      	ldr	r3, [r7, #4]
 80164ea:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 80164ee:	60fb      	str	r3, [r7, #12]

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
 80164f0:	68fb      	ldr	r3, [r7, #12]
 80164f2:	2200      	movs	r2, #0
 80164f4:	625a      	str	r2, [r3, #36]	; 0x24
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 80164f6:	687b      	ldr	r3, [r7, #4]
 80164f8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80164fa:	68fb      	ldr	r3, [r7, #12]
 80164fc:	62da      	str	r2, [r3, #44]	; 0x2c
}
 80164fe:	bf00      	nop
 8016500:	3714      	adds	r7, #20
 8016502:	46bd      	mov	sp, r7
 8016504:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016508:	4770      	bx	lr

0801650a <merged_2v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
 801650a:	b590      	push	{r4, r7, lr}
 801650c:	b08b      	sub	sp, #44	; 0x2c
 801650e:	af02      	add	r7, sp, #8
 8016510:	60f8      	str	r0, [r7, #12]
 8016512:	60b9      	str	r1, [r7, #8]
 8016514:	607a      	str	r2, [r7, #4]
 8016516:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8016518:	68fb      	ldr	r3, [r7, #12]
 801651a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 801651e:	61bb      	str	r3, [r7, #24]
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
 8016520:	69bb      	ldr	r3, [r7, #24]
 8016522:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016524:	2b00      	cmp	r3, #0
 8016526:	d016      	beq.n	8016556 <merged_2v_upsample+0x4c>
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
 8016528:	69bb      	ldr	r3, [r7, #24]
 801652a:	f103 0020 	add.w	r0, r3, #32
 801652e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016530:	681b      	ldr	r3, [r3, #0]
 8016532:	009b      	lsls	r3, r3, #2
 8016534:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016536:	441a      	add	r2, r3
 8016538:	69bb      	ldr	r3, [r7, #24]
 801653a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801653c:	9301      	str	r3, [sp, #4]
 801653e:	2301      	movs	r3, #1
 8016540:	9300      	str	r3, [sp, #0]
 8016542:	2300      	movs	r3, #0
 8016544:	2100      	movs	r1, #0
 8016546:	f011 fb15 	bl	8027b74 <jcopy_sample_rows>
		      1, upsample->out_row_width);
    num_rows = 1;
 801654a:	2301      	movs	r3, #1
 801654c:	61fb      	str	r3, [r7, #28]
    upsample->spare_full = FALSE;
 801654e:	69bb      	ldr	r3, [r7, #24]
 8016550:	2200      	movs	r2, #0
 8016552:	625a      	str	r2, [r3, #36]	; 0x24
 8016554:	e036      	b.n	80165c4 <merged_2v_upsample+0xba>
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
 8016556:	2302      	movs	r3, #2
 8016558:	61fb      	str	r3, [r7, #28]
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
 801655a:	69bb      	ldr	r3, [r7, #24]
 801655c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801655e:	69fa      	ldr	r2, [r7, #28]
 8016560:	429a      	cmp	r2, r3
 8016562:	d902      	bls.n	801656a <merged_2v_upsample+0x60>
      num_rows = upsample->rows_to_go;
 8016564:	69bb      	ldr	r3, [r7, #24]
 8016566:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016568:	61fb      	str	r3, [r7, #28]
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
 801656a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801656c:	681b      	ldr	r3, [r3, #0]
 801656e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016570:	1ad3      	subs	r3, r2, r3
 8016572:	63bb      	str	r3, [r7, #56]	; 0x38
    if (num_rows > out_rows_avail)
 8016574:	69fa      	ldr	r2, [r7, #28]
 8016576:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016578:	429a      	cmp	r2, r3
 801657a:	d901      	bls.n	8016580 <merged_2v_upsample+0x76>
      num_rows = out_rows_avail;
 801657c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801657e:	61fb      	str	r3, [r7, #28]
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
 8016580:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016582:	681b      	ldr	r3, [r3, #0]
 8016584:	009b      	lsls	r3, r3, #2
 8016586:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016588:	4413      	add	r3, r2
 801658a:	681b      	ldr	r3, [r3, #0]
 801658c:	613b      	str	r3, [r7, #16]
    if (num_rows > 1) {
 801658e:	69fb      	ldr	r3, [r7, #28]
 8016590:	2b01      	cmp	r3, #1
 8016592:	d908      	bls.n	80165a6 <merged_2v_upsample+0x9c>
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
 8016594:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016596:	681b      	ldr	r3, [r3, #0]
 8016598:	3301      	adds	r3, #1
 801659a:	009b      	lsls	r3, r3, #2
 801659c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801659e:	4413      	add	r3, r2
 80165a0:	681b      	ldr	r3, [r3, #0]
 80165a2:	617b      	str	r3, [r7, #20]
 80165a4:	e005      	b.n	80165b2 <merged_2v_upsample+0xa8>
    } else {
      work_ptrs[1] = upsample->spare_row;
 80165a6:	69bb      	ldr	r3, [r7, #24]
 80165a8:	6a1b      	ldr	r3, [r3, #32]
 80165aa:	617b      	str	r3, [r7, #20]
      upsample->spare_full = TRUE;
 80165ac:	69bb      	ldr	r3, [r7, #24]
 80165ae:	2201      	movs	r2, #1
 80165b0:	625a      	str	r2, [r3, #36]	; 0x24
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
 80165b2:	69bb      	ldr	r3, [r7, #24]
 80165b4:	68dc      	ldr	r4, [r3, #12]
 80165b6:	687b      	ldr	r3, [r7, #4]
 80165b8:	681a      	ldr	r2, [r3, #0]
 80165ba:	f107 0310 	add.w	r3, r7, #16
 80165be:	68b9      	ldr	r1, [r7, #8]
 80165c0:	68f8      	ldr	r0, [r7, #12]
 80165c2:	47a0      	blx	r4
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
 80165c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165c6:	681a      	ldr	r2, [r3, #0]
 80165c8:	69fb      	ldr	r3, [r7, #28]
 80165ca:	441a      	add	r2, r3
 80165cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165ce:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 80165d0:	69bb      	ldr	r3, [r7, #24]
 80165d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80165d4:	69fb      	ldr	r3, [r7, #28]
 80165d6:	1ad2      	subs	r2, r2, r3
 80165d8:	69bb      	ldr	r3, [r7, #24]
 80165da:	62da      	str	r2, [r3, #44]	; 0x2c
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
 80165dc:	69bb      	ldr	r3, [r7, #24]
 80165de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80165e0:	2b00      	cmp	r3, #0
 80165e2:	d104      	bne.n	80165ee <merged_2v_upsample+0xe4>
    (*in_row_group_ctr)++;
 80165e4:	687b      	ldr	r3, [r7, #4]
 80165e6:	681b      	ldr	r3, [r3, #0]
 80165e8:	1c5a      	adds	r2, r3, #1
 80165ea:	687b      	ldr	r3, [r7, #4]
 80165ec:	601a      	str	r2, [r3, #0]
}
 80165ee:	bf00      	nop
 80165f0:	3724      	adds	r7, #36	; 0x24
 80165f2:	46bd      	mov	sp, r7
 80165f4:	bd90      	pop	{r4, r7, pc}

080165f6 <merged_1v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
 80165f6:	b590      	push	{r4, r7, lr}
 80165f8:	b087      	sub	sp, #28
 80165fa:	af00      	add	r7, sp, #0
 80165fc:	60f8      	str	r0, [r7, #12]
 80165fe:	60b9      	str	r1, [r7, #8]
 8016600:	607a      	str	r2, [r7, #4]
 8016602:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8016604:	68fb      	ldr	r3, [r7, #12]
 8016606:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 801660a:	617b      	str	r3, [r7, #20]

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801660c:	697b      	ldr	r3, [r7, #20]
 801660e:	68dc      	ldr	r4, [r3, #12]
 8016610:	687b      	ldr	r3, [r7, #4]
 8016612:	6819      	ldr	r1, [r3, #0]
			 output_buf + *out_row_ctr);
 8016614:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016616:	681b      	ldr	r3, [r3, #0]
 8016618:	009b      	lsls	r3, r3, #2
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 801661a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801661c:	4413      	add	r3, r2
 801661e:	460a      	mov	r2, r1
 8016620:	68b9      	ldr	r1, [r7, #8]
 8016622:	68f8      	ldr	r0, [r7, #12]
 8016624:	47a0      	blx	r4
  /* Adjust counts */
  (*out_row_ctr)++;
 8016626:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016628:	681b      	ldr	r3, [r3, #0]
 801662a:	1c5a      	adds	r2, r3, #1
 801662c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801662e:	601a      	str	r2, [r3, #0]
  (*in_row_group_ctr)++;
 8016630:	687b      	ldr	r3, [r7, #4]
 8016632:	681b      	ldr	r3, [r3, #0]
 8016634:	1c5a      	adds	r2, r3, #1
 8016636:	687b      	ldr	r3, [r7, #4]
 8016638:	601a      	str	r2, [r3, #0]
}
 801663a:	bf00      	nop
 801663c:	371c      	adds	r7, #28
 801663e:	46bd      	mov	sp, r7
 8016640:	bd90      	pop	{r4, r7, pc}

08016642 <h2v1_merged_upsample>:

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 8016642:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 8016646:	b093      	sub	sp, #76	; 0x4c
 8016648:	af00      	add	r7, sp, #0
 801664a:	6178      	str	r0, [r7, #20]
 801664c:	6139      	str	r1, [r7, #16]
 801664e:	60fa      	str	r2, [r7, #12]
 8016650:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8016652:	697b      	ldr	r3, [r7, #20]
 8016654:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016658:	637b      	str	r3, [r7, #52]	; 0x34
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 801665a:	697b      	ldr	r3, [r7, #20]
 801665c:	f8d3 514c 	ldr.w	r5, [r3, #332]	; 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 8016660:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016662:	691b      	ldr	r3, [r3, #16]
 8016664:	633b      	str	r3, [r7, #48]	; 0x30
  int * Cbbtab = upsample->Cb_b_tab;
 8016666:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016668:	695b      	ldr	r3, [r3, #20]
 801666a:	62fb      	str	r3, [r7, #44]	; 0x2c
  INT32 * Crgtab = upsample->Cr_g_tab;
 801666c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801666e:	699b      	ldr	r3, [r3, #24]
 8016670:	62bb      	str	r3, [r7, #40]	; 0x28
  INT32 * Cbgtab = upsample->Cb_g_tab;
 8016672:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016674:	69db      	ldr	r3, [r3, #28]
 8016676:	627b      	str	r3, [r7, #36]	; 0x24
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
 8016678:	693b      	ldr	r3, [r7, #16]
 801667a:	681a      	ldr	r2, [r3, #0]
 801667c:	68fb      	ldr	r3, [r7, #12]
 801667e:	009b      	lsls	r3, r3, #2
 8016680:	4413      	add	r3, r2
 8016682:	681b      	ldr	r3, [r3, #0]
 8016684:	647b      	str	r3, [r7, #68]	; 0x44
  inptr1 = input_buf[1][in_row_group_ctr];
 8016686:	693b      	ldr	r3, [r7, #16]
 8016688:	3304      	adds	r3, #4
 801668a:	681a      	ldr	r2, [r3, #0]
 801668c:	68fb      	ldr	r3, [r7, #12]
 801668e:	009b      	lsls	r3, r3, #2
 8016690:	4413      	add	r3, r2
 8016692:	681b      	ldr	r3, [r3, #0]
 8016694:	643b      	str	r3, [r7, #64]	; 0x40
  inptr2 = input_buf[2][in_row_group_ctr];
 8016696:	693b      	ldr	r3, [r7, #16]
 8016698:	3308      	adds	r3, #8
 801669a:	681a      	ldr	r2, [r3, #0]
 801669c:	68fb      	ldr	r3, [r7, #12]
 801669e:	009b      	lsls	r3, r3, #2
 80166a0:	4413      	add	r3, r2
 80166a2:	681b      	ldr	r3, [r3, #0]
 80166a4:	63fb      	str	r3, [r7, #60]	; 0x3c
  outptr = output_buf[0];
 80166a6:	68bb      	ldr	r3, [r7, #8]
 80166a8:	681c      	ldr	r4, [r3, #0]
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 80166aa:	697b      	ldr	r3, [r7, #20]
 80166ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80166ae:	085b      	lsrs	r3, r3, #1
 80166b0:	63bb      	str	r3, [r7, #56]	; 0x38
 80166b2:	e050      	b.n	8016756 <h2v1_merged_upsample+0x114>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 80166b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166b6:	1c5a      	adds	r2, r3, #1
 80166b8:	643a      	str	r2, [r7, #64]	; 0x40
 80166ba:	781b      	ldrb	r3, [r3, #0]
 80166bc:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2++);
 80166be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80166c0:	1c5a      	adds	r2, r3, #1
 80166c2:	63fa      	str	r2, [r7, #60]	; 0x3c
 80166c4:	781b      	ldrb	r3, [r3, #0]
 80166c6:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 80166c8:	69fb      	ldr	r3, [r7, #28]
 80166ca:	009b      	lsls	r3, r3, #2
 80166cc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80166ce:	4413      	add	r3, r2
 80166d0:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 80166d2:	6a3b      	ldr	r3, [r7, #32]
 80166d4:	009b      	lsls	r3, r3, #2
 80166d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80166d8:	4413      	add	r3, r2
 80166da:	681a      	ldr	r2, [r3, #0]
 80166dc:	69fb      	ldr	r3, [r7, #28]
 80166de:	009b      	lsls	r3, r3, #2
 80166e0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80166e2:	440b      	add	r3, r1
 80166e4:	681b      	ldr	r3, [r3, #0]
 80166e6:	4413      	add	r3, r2
 80166e8:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 80166ec:	6a3b      	ldr	r3, [r7, #32]
 80166ee:	009b      	lsls	r3, r3, #2
 80166f0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80166f2:	4413      	add	r3, r2
 80166f4:	681b      	ldr	r3, [r3, #0]
 80166f6:	607b      	str	r3, [r7, #4]
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
 80166f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80166fa:	1c5a      	adds	r2, r3, #1
 80166fc:	647a      	str	r2, [r7, #68]	; 0x44
 80166fe:	781b      	ldrb	r3, [r3, #0]
 8016700:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 8016702:	4601      	mov	r1, r0
 8016704:	1873      	adds	r3, r6, r1
 8016706:	442b      	add	r3, r5
 8016708:	781b      	ldrb	r3, [r3, #0]
 801670a:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 801670c:	eb06 0308 	add.w	r3, r6, r8
 8016710:	18ea      	adds	r2, r5, r3
 8016712:	1c63      	adds	r3, r4, #1
 8016714:	7812      	ldrb	r2, [r2, #0]
 8016716:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 8016718:	6878      	ldr	r0, [r7, #4]
 801671a:	1833      	adds	r3, r6, r0
 801671c:	18ea      	adds	r2, r5, r3
 801671e:	1ca3      	adds	r3, r4, #2
 8016720:	7812      	ldrb	r2, [r2, #0]
 8016722:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 8016724:	3403      	adds	r4, #3
    y  = GETJSAMPLE(*inptr0++);
 8016726:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016728:	1c5a      	adds	r2, r3, #1
 801672a:	647a      	str	r2, [r7, #68]	; 0x44
 801672c:	781b      	ldrb	r3, [r3, #0]
 801672e:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 8016730:	1873      	adds	r3, r6, r1
 8016732:	442b      	add	r3, r5
 8016734:	781b      	ldrb	r3, [r3, #0]
 8016736:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 8016738:	eb06 0308 	add.w	r3, r6, r8
 801673c:	18ea      	adds	r2, r5, r3
 801673e:	1c63      	adds	r3, r4, #1
 8016740:	7812      	ldrb	r2, [r2, #0]
 8016742:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 8016744:	1833      	adds	r3, r6, r0
 8016746:	18ea      	adds	r2, r5, r3
 8016748:	1ca3      	adds	r3, r4, #2
 801674a:	7812      	ldrb	r2, [r2, #0]
 801674c:	701a      	strb	r2, [r3, #0]
    outptr += RGB_PIXELSIZE;
 801674e:	3403      	adds	r4, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 8016750:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016752:	3b01      	subs	r3, #1
 8016754:	63bb      	str	r3, [r7, #56]	; 0x38
 8016756:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016758:	2b00      	cmp	r3, #0
 801675a:	d1ab      	bne.n	80166b4 <h2v1_merged_upsample+0x72>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801675c:	697b      	ldr	r3, [r7, #20]
 801675e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8016760:	f003 0301 	and.w	r3, r3, #1
 8016764:	2b00      	cmp	r3, #0
 8016766:	d02e      	beq.n	80167c6 <h2v1_merged_upsample+0x184>
    cb = GETJSAMPLE(*inptr1);
 8016768:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801676a:	781b      	ldrb	r3, [r3, #0]
 801676c:	623b      	str	r3, [r7, #32]
    cr = GETJSAMPLE(*inptr2);
 801676e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016770:	781b      	ldrb	r3, [r3, #0]
 8016772:	61fb      	str	r3, [r7, #28]
    cred = Crrtab[cr];
 8016774:	69fb      	ldr	r3, [r7, #28]
 8016776:	009b      	lsls	r3, r3, #2
 8016778:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801677a:	4413      	add	r3, r2
 801677c:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801677e:	6a3b      	ldr	r3, [r7, #32]
 8016780:	009b      	lsls	r3, r3, #2
 8016782:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016784:	4413      	add	r3, r2
 8016786:	681a      	ldr	r2, [r3, #0]
 8016788:	69fb      	ldr	r3, [r7, #28]
 801678a:	009b      	lsls	r3, r3, #2
 801678c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801678e:	440b      	add	r3, r1
 8016790:	681b      	ldr	r3, [r3, #0]
 8016792:	4413      	add	r3, r2
 8016794:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 8016798:	6a3b      	ldr	r3, [r7, #32]
 801679a:	009b      	lsls	r3, r3, #2
 801679c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801679e:	4413      	add	r3, r2
 80167a0:	6819      	ldr	r1, [r3, #0]
    y  = GETJSAMPLE(*inptr0);
 80167a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80167a4:	781b      	ldrb	r3, [r3, #0]
 80167a6:	461e      	mov	r6, r3
    outptr[RGB_RED] =   range_limit[y + cred];
 80167a8:	1833      	adds	r3, r6, r0
 80167aa:	442b      	add	r3, r5
 80167ac:	781b      	ldrb	r3, [r3, #0]
 80167ae:	7023      	strb	r3, [r4, #0]
    outptr[RGB_GREEN] = range_limit[y + cgreen];
 80167b0:	eb06 0308 	add.w	r3, r6, r8
 80167b4:	18ea      	adds	r2, r5, r3
 80167b6:	1c63      	adds	r3, r4, #1
 80167b8:	7812      	ldrb	r2, [r2, #0]
 80167ba:	701a      	strb	r2, [r3, #0]
    outptr[RGB_BLUE] =  range_limit[y + cblue];
 80167bc:	1873      	adds	r3, r6, r1
 80167be:	18ea      	adds	r2, r5, r3
 80167c0:	1ca3      	adds	r3, r4, #2
 80167c2:	7812      	ldrb	r2, [r2, #0]
 80167c4:	701a      	strb	r2, [r3, #0]
  }
}
 80167c6:	bf00      	nop
 80167c8:	374c      	adds	r7, #76	; 0x4c
 80167ca:	46bd      	mov	sp, r7
 80167cc:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 80167d0:	4770      	bx	lr

080167d2 <h2v2_merged_upsample>:

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
 80167d2:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
 80167d6:	b093      	sub	sp, #76	; 0x4c
 80167d8:	af00      	add	r7, sp, #0
 80167da:	6178      	str	r0, [r7, #20]
 80167dc:	6139      	str	r1, [r7, #16]
 80167de:	60fa      	str	r2, [r7, #12]
 80167e0:	60bb      	str	r3, [r7, #8]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 80167e2:	697b      	ldr	r3, [r7, #20]
 80167e4:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 80167e8:	633b      	str	r3, [r7, #48]	; 0x30
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
 80167ea:	697b      	ldr	r3, [r7, #20]
 80167ec:	f8d3 414c 	ldr.w	r4, [r3, #332]	; 0x14c
  int * Crrtab = upsample->Cr_r_tab;
 80167f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167f2:	691b      	ldr	r3, [r3, #16]
 80167f4:	62fb      	str	r3, [r7, #44]	; 0x2c
  int * Cbbtab = upsample->Cb_b_tab;
 80167f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167f8:	695b      	ldr	r3, [r3, #20]
 80167fa:	62bb      	str	r3, [r7, #40]	; 0x28
  INT32 * Crgtab = upsample->Cr_g_tab;
 80167fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167fe:	699b      	ldr	r3, [r3, #24]
 8016800:	627b      	str	r3, [r7, #36]	; 0x24
  INT32 * Cbgtab = upsample->Cb_g_tab;
 8016802:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016804:	69db      	ldr	r3, [r3, #28]
 8016806:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
 8016808:	693b      	ldr	r3, [r7, #16]
 801680a:	681a      	ldr	r2, [r3, #0]
 801680c:	68fb      	ldr	r3, [r7, #12]
 801680e:	00db      	lsls	r3, r3, #3
 8016810:	4413      	add	r3, r2
 8016812:	681b      	ldr	r3, [r3, #0]
 8016814:	647b      	str	r3, [r7, #68]	; 0x44
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
 8016816:	693b      	ldr	r3, [r7, #16]
 8016818:	681a      	ldr	r2, [r3, #0]
 801681a:	68fb      	ldr	r3, [r7, #12]
 801681c:	00db      	lsls	r3, r3, #3
 801681e:	3304      	adds	r3, #4
 8016820:	4413      	add	r3, r2
 8016822:	681b      	ldr	r3, [r3, #0]
 8016824:	643b      	str	r3, [r7, #64]	; 0x40
  inptr1 = input_buf[1][in_row_group_ctr];
 8016826:	693b      	ldr	r3, [r7, #16]
 8016828:	3304      	adds	r3, #4
 801682a:	681a      	ldr	r2, [r3, #0]
 801682c:	68fb      	ldr	r3, [r7, #12]
 801682e:	009b      	lsls	r3, r3, #2
 8016830:	4413      	add	r3, r2
 8016832:	681b      	ldr	r3, [r3, #0]
 8016834:	63fb      	str	r3, [r7, #60]	; 0x3c
  inptr2 = input_buf[2][in_row_group_ctr];
 8016836:	693b      	ldr	r3, [r7, #16]
 8016838:	3308      	adds	r3, #8
 801683a:	681a      	ldr	r2, [r3, #0]
 801683c:	68fb      	ldr	r3, [r7, #12]
 801683e:	009b      	lsls	r3, r3, #2
 8016840:	4413      	add	r3, r2
 8016842:	681b      	ldr	r3, [r3, #0]
 8016844:	63bb      	str	r3, [r7, #56]	; 0x38
  outptr0 = output_buf[0];
 8016846:	68bb      	ldr	r3, [r7, #8]
 8016848:	681b      	ldr	r3, [r3, #0]
 801684a:	607b      	str	r3, [r7, #4]
  outptr1 = output_buf[1];
 801684c:	68bb      	ldr	r3, [r7, #8]
 801684e:	685e      	ldr	r6, [r3, #4]
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 8016850:	697b      	ldr	r3, [r7, #20]
 8016852:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8016854:	085b      	lsrs	r3, r3, #1
 8016856:	637b      	str	r3, [r7, #52]	; 0x34
 8016858:	e083      	b.n	8016962 <h2v2_merged_upsample+0x190>
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
 801685a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801685c:	1c5a      	adds	r2, r3, #1
 801685e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8016860:	781b      	ldrb	r3, [r3, #0]
 8016862:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2++);
 8016864:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016866:	1c5a      	adds	r2, r3, #1
 8016868:	63ba      	str	r2, [r7, #56]	; 0x38
 801686a:	781b      	ldrb	r3, [r3, #0]
 801686c:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 801686e:	69bb      	ldr	r3, [r7, #24]
 8016870:	009b      	lsls	r3, r3, #2
 8016872:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016874:	4413      	add	r3, r2
 8016876:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 8016878:	69fb      	ldr	r3, [r7, #28]
 801687a:	009b      	lsls	r3, r3, #2
 801687c:	6a3a      	ldr	r2, [r7, #32]
 801687e:	4413      	add	r3, r2
 8016880:	681a      	ldr	r2, [r3, #0]
 8016882:	69bb      	ldr	r3, [r7, #24]
 8016884:	009b      	lsls	r3, r3, #2
 8016886:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016888:	440b      	add	r3, r1
 801688a:	681b      	ldr	r3, [r3, #0]
 801688c:	4413      	add	r3, r2
 801688e:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 8016892:	69fb      	ldr	r3, [r7, #28]
 8016894:	009b      	lsls	r3, r3, #2
 8016896:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016898:	4413      	add	r3, r2
 801689a:	681b      	ldr	r3, [r3, #0]
 801689c:	603b      	str	r3, [r7, #0]
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
 801689e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168a0:	1c5a      	adds	r2, r3, #1
 80168a2:	647a      	str	r2, [r7, #68]	; 0x44
 80168a4:	781b      	ldrb	r3, [r3, #0]
 80168a6:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 80168a8:	4601      	mov	r1, r0
 80168aa:	186b      	adds	r3, r5, r1
 80168ac:	4423      	add	r3, r4
 80168ae:	781b      	ldrb	r3, [r3, #0]
 80168b0:	6878      	ldr	r0, [r7, #4]
 80168b2:	4602      	mov	r2, r0
 80168b4:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 80168b6:	eb05 0308 	add.w	r3, r5, r8
 80168ba:	18e2      	adds	r2, r4, r3
 80168bc:	6078      	str	r0, [r7, #4]
 80168be:	1c43      	adds	r3, r0, #1
 80168c0:	7812      	ldrb	r2, [r2, #0]
 80168c2:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 80168c4:	6838      	ldr	r0, [r7, #0]
 80168c6:	182b      	adds	r3, r5, r0
 80168c8:	18e2      	adds	r2, r4, r3
 80168ca:	687d      	ldr	r5, [r7, #4]
 80168cc:	1cab      	adds	r3, r5, #2
 80168ce:	7812      	ldrb	r2, [r2, #0]
 80168d0:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 80168d2:	3503      	adds	r5, #3
 80168d4:	607d      	str	r5, [r7, #4]
    y  = GETJSAMPLE(*inptr00++);
 80168d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168d8:	1c5a      	adds	r2, r3, #1
 80168da:	647a      	str	r2, [r7, #68]	; 0x44
 80168dc:	781b      	ldrb	r3, [r3, #0]
 80168de:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 80168e0:	186b      	adds	r3, r5, r1
 80168e2:	4423      	add	r3, r4
 80168e4:	781b      	ldrb	r3, [r3, #0]
 80168e6:	687a      	ldr	r2, [r7, #4]
 80168e8:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 80168ea:	eb05 0308 	add.w	r3, r5, r8
 80168ee:	18e2      	adds	r2, r4, r3
 80168f0:	687b      	ldr	r3, [r7, #4]
 80168f2:	3301      	adds	r3, #1
 80168f4:	7812      	ldrb	r2, [r2, #0]
 80168f6:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 80168f8:	182b      	adds	r3, r5, r0
 80168fa:	18e2      	adds	r2, r4, r3
 80168fc:	687d      	ldr	r5, [r7, #4]
 80168fe:	1cab      	adds	r3, r5, #2
 8016900:	7812      	ldrb	r2, [r2, #0]
 8016902:	701a      	strb	r2, [r3, #0]
    outptr0 += RGB_PIXELSIZE;
 8016904:	1ceb      	adds	r3, r5, #3
 8016906:	607b      	str	r3, [r7, #4]
    y  = GETJSAMPLE(*inptr01++);
 8016908:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801690a:	1c5a      	adds	r2, r3, #1
 801690c:	643a      	str	r2, [r7, #64]	; 0x40
 801690e:	781b      	ldrb	r3, [r3, #0]
 8016910:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 8016912:	186b      	adds	r3, r5, r1
 8016914:	4423      	add	r3, r4
 8016916:	781b      	ldrb	r3, [r3, #0]
 8016918:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 801691a:	eb05 0308 	add.w	r3, r5, r8
 801691e:	18e2      	adds	r2, r4, r3
 8016920:	1c73      	adds	r3, r6, #1
 8016922:	7812      	ldrb	r2, [r2, #0]
 8016924:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 8016926:	182b      	adds	r3, r5, r0
 8016928:	18e2      	adds	r2, r4, r3
 801692a:	1cb3      	adds	r3, r6, #2
 801692c:	7812      	ldrb	r2, [r2, #0]
 801692e:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 8016930:	3603      	adds	r6, #3
    y  = GETJSAMPLE(*inptr01++);
 8016932:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016934:	1c5a      	adds	r2, r3, #1
 8016936:	643a      	str	r2, [r7, #64]	; 0x40
 8016938:	781b      	ldrb	r3, [r3, #0]
 801693a:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 801693c:	186b      	adds	r3, r5, r1
 801693e:	4423      	add	r3, r4
 8016940:	781b      	ldrb	r3, [r3, #0]
 8016942:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 8016944:	eb05 0308 	add.w	r3, r5, r8
 8016948:	18e2      	adds	r2, r4, r3
 801694a:	1c73      	adds	r3, r6, #1
 801694c:	7812      	ldrb	r2, [r2, #0]
 801694e:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 8016950:	182b      	adds	r3, r5, r0
 8016952:	18e2      	adds	r2, r4, r3
 8016954:	1cb3      	adds	r3, r6, #2
 8016956:	7812      	ldrb	r2, [r2, #0]
 8016958:	701a      	strb	r2, [r3, #0]
    outptr1 += RGB_PIXELSIZE;
 801695a:	3603      	adds	r6, #3
  for (col = cinfo->output_width >> 1; col > 0; col--) {
 801695c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801695e:	3b01      	subs	r3, #1
 8016960:	637b      	str	r3, [r7, #52]	; 0x34
 8016962:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016964:	2b00      	cmp	r3, #0
 8016966:	f47f af78 	bne.w	801685a <h2v2_merged_upsample+0x88>
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
 801696a:	697b      	ldr	r3, [r7, #20]
 801696c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801696e:	f003 0301 	and.w	r3, r3, #1
 8016972:	2b00      	cmp	r3, #0
 8016974:	d045      	beq.n	8016a02 <h2v2_merged_upsample+0x230>
    cb = GETJSAMPLE(*inptr1);
 8016976:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016978:	781b      	ldrb	r3, [r3, #0]
 801697a:	61fb      	str	r3, [r7, #28]
    cr = GETJSAMPLE(*inptr2);
 801697c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801697e:	781b      	ldrb	r3, [r3, #0]
 8016980:	61bb      	str	r3, [r7, #24]
    cred = Crrtab[cr];
 8016982:	69bb      	ldr	r3, [r7, #24]
 8016984:	009b      	lsls	r3, r3, #2
 8016986:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016988:	4413      	add	r3, r2
 801698a:	6818      	ldr	r0, [r3, #0]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
 801698c:	69fb      	ldr	r3, [r7, #28]
 801698e:	009b      	lsls	r3, r3, #2
 8016990:	6a3a      	ldr	r2, [r7, #32]
 8016992:	4413      	add	r3, r2
 8016994:	681a      	ldr	r2, [r3, #0]
 8016996:	69bb      	ldr	r3, [r7, #24]
 8016998:	009b      	lsls	r3, r3, #2
 801699a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801699c:	440b      	add	r3, r1
 801699e:	681b      	ldr	r3, [r3, #0]
 80169a0:	4413      	add	r3, r2
 80169a2:	ea4f 4823 	mov.w	r8, r3, asr #16
    cblue = Cbbtab[cb];
 80169a6:	69fb      	ldr	r3, [r7, #28]
 80169a8:	009b      	lsls	r3, r3, #2
 80169aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80169ac:	4413      	add	r3, r2
 80169ae:	681b      	ldr	r3, [r3, #0]
 80169b0:	603b      	str	r3, [r7, #0]
    y  = GETJSAMPLE(*inptr00);
 80169b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80169b4:	781b      	ldrb	r3, [r3, #0]
 80169b6:	461d      	mov	r5, r3
    outptr0[RGB_RED] =   range_limit[y + cred];
 80169b8:	182b      	adds	r3, r5, r0
 80169ba:	4423      	add	r3, r4
 80169bc:	781b      	ldrb	r3, [r3, #0]
 80169be:	6879      	ldr	r1, [r7, #4]
 80169c0:	460a      	mov	r2, r1
 80169c2:	7013      	strb	r3, [r2, #0]
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
 80169c4:	eb05 0308 	add.w	r3, r5, r8
 80169c8:	18e2      	adds	r2, r4, r3
 80169ca:	1c4b      	adds	r3, r1, #1
 80169cc:	7812      	ldrb	r2, [r2, #0]
 80169ce:	701a      	strb	r2, [r3, #0]
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
 80169d0:	683b      	ldr	r3, [r7, #0]
 80169d2:	18eb      	adds	r3, r5, r3
 80169d4:	18e2      	adds	r2, r4, r3
 80169d6:	1c8b      	adds	r3, r1, #2
 80169d8:	7812      	ldrb	r2, [r2, #0]
 80169da:	701a      	strb	r2, [r3, #0]
    y  = GETJSAMPLE(*inptr01);
 80169dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80169de:	781b      	ldrb	r3, [r3, #0]
 80169e0:	461d      	mov	r5, r3
    outptr1[RGB_RED] =   range_limit[y + cred];
 80169e2:	182b      	adds	r3, r5, r0
 80169e4:	4423      	add	r3, r4
 80169e6:	781b      	ldrb	r3, [r3, #0]
 80169e8:	7033      	strb	r3, [r6, #0]
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
 80169ea:	eb05 0308 	add.w	r3, r5, r8
 80169ee:	18e2      	adds	r2, r4, r3
 80169f0:	1c73      	adds	r3, r6, #1
 80169f2:	7812      	ldrb	r2, [r2, #0]
 80169f4:	701a      	strb	r2, [r3, #0]
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
 80169f6:	683b      	ldr	r3, [r7, #0]
 80169f8:	18eb      	adds	r3, r5, r3
 80169fa:	18e2      	adds	r2, r4, r3
 80169fc:	1cb3      	adds	r3, r6, #2
 80169fe:	7812      	ldrb	r2, [r2, #0]
 8016a00:	701a      	strb	r2, [r3, #0]
  }
}
 8016a02:	bf00      	nop
 8016a04:	374c      	adds	r7, #76	; 0x4c
 8016a06:	46bd      	mov	sp, r7
 8016a08:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
 8016a0c:	4770      	bx	lr
	...

08016a10 <jinit_merged_upsampler>:
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
 8016a10:	b580      	push	{r7, lr}
 8016a12:	b084      	sub	sp, #16
 8016a14:	af00      	add	r7, sp, #0
 8016a16:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016a18:	687b      	ldr	r3, [r7, #4]
 8016a1a:	685b      	ldr	r3, [r3, #4]
 8016a1c:	681b      	ldr	r3, [r3, #0]
 8016a1e:	2230      	movs	r2, #48	; 0x30
 8016a20:	2101      	movs	r1, #1
 8016a22:	6878      	ldr	r0, [r7, #4]
 8016a24:	4798      	blx	r3
 8016a26:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 8016a28:	687b      	ldr	r3, [r7, #4]
 8016a2a:	68fa      	ldr	r2, [r7, #12]
 8016a2c:	f8c3 21d8 	str.w	r2, [r3, #472]	; 0x1d8
  upsample->pub.start_pass = start_pass_merged_upsample;
 8016a30:	68fb      	ldr	r3, [r7, #12]
 8016a32:	4a1a      	ldr	r2, [pc, #104]	; (8016a9c <jinit_merged_upsampler+0x8c>)
 8016a34:	601a      	str	r2, [r3, #0]
  upsample->pub.need_context_rows = FALSE;
 8016a36:	68fb      	ldr	r3, [r7, #12]
 8016a38:	2200      	movs	r2, #0
 8016a3a:	609a      	str	r2, [r3, #8]

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
 8016a3c:	687b      	ldr	r3, [r7, #4]
 8016a3e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8016a40:	687a      	ldr	r2, [r7, #4]
 8016a42:	6f92      	ldr	r2, [r2, #120]	; 0x78
 8016a44:	fb02 f203 	mul.w	r2, r2, r3
 8016a48:	68fb      	ldr	r3, [r7, #12]
 8016a4a:	629a      	str	r2, [r3, #40]	; 0x28

  if (cinfo->max_v_samp_factor == 2) {
 8016a4c:	687b      	ldr	r3, [r7, #4]
 8016a4e:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8016a52:	2b02      	cmp	r3, #2
 8016a54:	d111      	bne.n	8016a7a <jinit_merged_upsampler+0x6a>
    upsample->pub.upsample = merged_2v_upsample;
 8016a56:	68fb      	ldr	r3, [r7, #12]
 8016a58:	4a11      	ldr	r2, [pc, #68]	; (8016aa0 <jinit_merged_upsampler+0x90>)
 8016a5a:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v2_merged_upsample;
 8016a5c:	68fb      	ldr	r3, [r7, #12]
 8016a5e:	4a11      	ldr	r2, [pc, #68]	; (8016aa4 <jinit_merged_upsampler+0x94>)
 8016a60:	60da      	str	r2, [r3, #12]
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016a62:	687b      	ldr	r3, [r7, #4]
 8016a64:	685b      	ldr	r3, [r3, #4]
 8016a66:	685b      	ldr	r3, [r3, #4]
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
 8016a68:	68fa      	ldr	r2, [r7, #12]
 8016a6a:	6a92      	ldr	r2, [r2, #40]	; 0x28
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016a6c:	2101      	movs	r1, #1
 8016a6e:	6878      	ldr	r0, [r7, #4]
 8016a70:	4798      	blx	r3
 8016a72:	4602      	mov	r2, r0
    upsample->spare_row = (JSAMPROW)
 8016a74:	68fb      	ldr	r3, [r7, #12]
 8016a76:	621a      	str	r2, [r3, #32]
 8016a78:	e008      	b.n	8016a8c <jinit_merged_upsampler+0x7c>
  } else {
    upsample->pub.upsample = merged_1v_upsample;
 8016a7a:	68fb      	ldr	r3, [r7, #12]
 8016a7c:	4a0a      	ldr	r2, [pc, #40]	; (8016aa8 <jinit_merged_upsampler+0x98>)
 8016a7e:	605a      	str	r2, [r3, #4]
    upsample->upmethod = h2v1_merged_upsample;
 8016a80:	68fb      	ldr	r3, [r7, #12]
 8016a82:	4a0a      	ldr	r2, [pc, #40]	; (8016aac <jinit_merged_upsampler+0x9c>)
 8016a84:	60da      	str	r2, [r3, #12]
    /* No spare row needed */
    upsample->spare_row = NULL;
 8016a86:	68fb      	ldr	r3, [r7, #12]
 8016a88:	2200      	movs	r2, #0
 8016a8a:	621a      	str	r2, [r3, #32]
  }

  build_ycc_rgb_table(cinfo);
 8016a8c:	6878      	ldr	r0, [r7, #4]
 8016a8e:	f7ff fca7 	bl	80163e0 <build_ycc_rgb_table>
}
 8016a92:	bf00      	nop
 8016a94:	3710      	adds	r7, #16
 8016a96:	46bd      	mov	sp, r7
 8016a98:	bd80      	pop	{r7, pc}
 8016a9a:	bf00      	nop
 8016a9c:	080164e1 	.word	0x080164e1
 8016aa0:	0801650b 	.word	0x0801650b
 8016aa4:	080167d3 	.word	0x080167d3
 8016aa8:	080165f7 	.word	0x080165f7
 8016aac:	08016643 	.word	0x08016643

08016ab0 <start_pass_dpost>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
 8016ab0:	b590      	push	{r4, r7, lr}
 8016ab2:	b087      	sub	sp, #28
 8016ab4:	af02      	add	r7, sp, #8
 8016ab6:	6078      	str	r0, [r7, #4]
 8016ab8:	460b      	mov	r3, r1
 8016aba:	70fb      	strb	r3, [r7, #3]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 8016abc:	687b      	ldr	r3, [r7, #4]
 8016abe:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8016ac2:	60fb      	str	r3, [r7, #12]

  switch (pass_mode) {
 8016ac4:	78fb      	ldrb	r3, [r7, #3]
 8016ac6:	2b03      	cmp	r3, #3
 8016ac8:	d028      	beq.n	8016b1c <start_pass_dpost+0x6c>
 8016aca:	2b03      	cmp	r3, #3
 8016acc:	dc48      	bgt.n	8016b60 <start_pass_dpost+0xb0>
 8016ace:	2b00      	cmp	r3, #0
 8016ad0:	d002      	beq.n	8016ad8 <start_pass_dpost+0x28>
 8016ad2:	2b02      	cmp	r3, #2
 8016ad4:	d033      	beq.n	8016b3e <start_pass_dpost+0x8e>
 8016ad6:	e043      	b.n	8016b60 <start_pass_dpost+0xb0>
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
 8016ad8:	687b      	ldr	r3, [r7, #4]
 8016ada:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016adc:	2b00      	cmp	r3, #0
 8016ade:	d016      	beq.n	8016b0e <start_pass_dpost+0x5e>
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
 8016ae0:	68fb      	ldr	r3, [r7, #12]
 8016ae2:	4a2a      	ldr	r2, [pc, #168]	; (8016b8c <start_pass_dpost+0xdc>)
 8016ae4:	605a      	str	r2, [r3, #4]
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
 8016ae6:	68fb      	ldr	r3, [r7, #12]
 8016ae8:	68db      	ldr	r3, [r3, #12]
 8016aea:	2b00      	cmp	r3, #0
 8016aec:	d142      	bne.n	8016b74 <start_pass_dpost+0xc4>
	post->buffer = (*cinfo->mem->access_virt_sarray)
 8016aee:	687b      	ldr	r3, [r7, #4]
 8016af0:	685b      	ldr	r3, [r3, #4]
 8016af2:	69dc      	ldr	r4, [r3, #28]
 8016af4:	68fb      	ldr	r3, [r7, #12]
 8016af6:	6899      	ldr	r1, [r3, #8]
 8016af8:	68fb      	ldr	r3, [r7, #12]
 8016afa:	691b      	ldr	r3, [r3, #16]
 8016afc:	2201      	movs	r2, #1
 8016afe:	9200      	str	r2, [sp, #0]
 8016b00:	2200      	movs	r2, #0
 8016b02:	6878      	ldr	r0, [r7, #4]
 8016b04:	47a0      	blx	r4
 8016b06:	4602      	mov	r2, r0
 8016b08:	68fb      	ldr	r3, [r7, #12]
 8016b0a:	60da      	str	r2, [r3, #12]
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
    }
    break;
 8016b0c:	e032      	b.n	8016b74 <start_pass_dpost+0xc4>
      post->pub.post_process_data = cinfo->upsample->upsample;
 8016b0e:	687b      	ldr	r3, [r7, #4]
 8016b10:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016b14:	685a      	ldr	r2, [r3, #4]
 8016b16:	68fb      	ldr	r3, [r7, #12]
 8016b18:	605a      	str	r2, [r3, #4]
    break;
 8016b1a:	e02b      	b.n	8016b74 <start_pass_dpost+0xc4>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
 8016b1c:	68fb      	ldr	r3, [r7, #12]
 8016b1e:	689b      	ldr	r3, [r3, #8]
 8016b20:	2b00      	cmp	r3, #0
 8016b22:	d108      	bne.n	8016b36 <start_pass_dpost+0x86>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 8016b24:	687b      	ldr	r3, [r7, #4]
 8016b26:	681b      	ldr	r3, [r3, #0]
 8016b28:	2203      	movs	r2, #3
 8016b2a:	615a      	str	r2, [r3, #20]
 8016b2c:	687b      	ldr	r3, [r7, #4]
 8016b2e:	681b      	ldr	r3, [r3, #0]
 8016b30:	681b      	ldr	r3, [r3, #0]
 8016b32:	6878      	ldr	r0, [r7, #4]
 8016b34:	4798      	blx	r3
    post->pub.post_process_data = post_process_prepass;
 8016b36:	68fb      	ldr	r3, [r7, #12]
 8016b38:	4a15      	ldr	r2, [pc, #84]	; (8016b90 <start_pass_dpost+0xe0>)
 8016b3a:	605a      	str	r2, [r3, #4]
    break;
 8016b3c:	e01b      	b.n	8016b76 <start_pass_dpost+0xc6>
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
 8016b3e:	68fb      	ldr	r3, [r7, #12]
 8016b40:	689b      	ldr	r3, [r3, #8]
 8016b42:	2b00      	cmp	r3, #0
 8016b44:	d108      	bne.n	8016b58 <start_pass_dpost+0xa8>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 8016b46:	687b      	ldr	r3, [r7, #4]
 8016b48:	681b      	ldr	r3, [r3, #0]
 8016b4a:	2203      	movs	r2, #3
 8016b4c:	615a      	str	r2, [r3, #20]
 8016b4e:	687b      	ldr	r3, [r7, #4]
 8016b50:	681b      	ldr	r3, [r3, #0]
 8016b52:	681b      	ldr	r3, [r3, #0]
 8016b54:	6878      	ldr	r0, [r7, #4]
 8016b56:	4798      	blx	r3
    post->pub.post_process_data = post_process_2pass;
 8016b58:	68fb      	ldr	r3, [r7, #12]
 8016b5a:	4a0e      	ldr	r2, [pc, #56]	; (8016b94 <start_pass_dpost+0xe4>)
 8016b5c:	605a      	str	r2, [r3, #4]
    break;
 8016b5e:	e00a      	b.n	8016b76 <start_pass_dpost+0xc6>
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 8016b60:	687b      	ldr	r3, [r7, #4]
 8016b62:	681b      	ldr	r3, [r3, #0]
 8016b64:	2203      	movs	r2, #3
 8016b66:	615a      	str	r2, [r3, #20]
 8016b68:	687b      	ldr	r3, [r7, #4]
 8016b6a:	681b      	ldr	r3, [r3, #0]
 8016b6c:	681b      	ldr	r3, [r3, #0]
 8016b6e:	6878      	ldr	r0, [r7, #4]
 8016b70:	4798      	blx	r3
    break;
 8016b72:	e000      	b.n	8016b76 <start_pass_dpost+0xc6>
    break;
 8016b74:	bf00      	nop
  }
  post->starting_row = post->next_row = 0;
 8016b76:	68fb      	ldr	r3, [r7, #12]
 8016b78:	2200      	movs	r2, #0
 8016b7a:	619a      	str	r2, [r3, #24]
 8016b7c:	68fb      	ldr	r3, [r7, #12]
 8016b7e:	699a      	ldr	r2, [r3, #24]
 8016b80:	68fb      	ldr	r3, [r7, #12]
 8016b82:	615a      	str	r2, [r3, #20]
}
 8016b84:	bf00      	nop
 8016b86:	3714      	adds	r7, #20
 8016b88:	46bd      	mov	sp, r7
 8016b8a:	bd90      	pop	{r4, r7, pc}
 8016b8c:	08016b99 	.word	0x08016b99
 8016b90:	08016c1f 	.word	0x08016c1f
 8016b94:	08016ce9 	.word	0x08016ce9

08016b98 <post_process_1pass>:
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 8016b98:	b590      	push	{r4, r7, lr}
 8016b9a:	b08d      	sub	sp, #52	; 0x34
 8016b9c:	af04      	add	r7, sp, #16
 8016b9e:	60f8      	str	r0, [r7, #12]
 8016ba0:	60b9      	str	r1, [r7, #8]
 8016ba2:	607a      	str	r2, [r7, #4]
 8016ba4:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 8016ba6:	68fb      	ldr	r3, [r7, #12]
 8016ba8:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8016bac:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
 8016bae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016bb0:	681b      	ldr	r3, [r3, #0]
 8016bb2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016bb4:	1ad3      	subs	r3, r2, r3
 8016bb6:	61fb      	str	r3, [r7, #28]
  if (max_rows > post->strip_height)
 8016bb8:	69bb      	ldr	r3, [r7, #24]
 8016bba:	691b      	ldr	r3, [r3, #16]
 8016bbc:	69fa      	ldr	r2, [r7, #28]
 8016bbe:	429a      	cmp	r2, r3
 8016bc0:	d902      	bls.n	8016bc8 <post_process_1pass+0x30>
    max_rows = post->strip_height;
 8016bc2:	69bb      	ldr	r3, [r7, #24]
 8016bc4:	691b      	ldr	r3, [r3, #16]
 8016bc6:	61fb      	str	r3, [r7, #28]
  num_rows = 0;
 8016bc8:	2300      	movs	r3, #0
 8016bca:	617b      	str	r3, [r7, #20]
  (*cinfo->upsample->upsample) (cinfo,
 8016bcc:	68fb      	ldr	r3, [r7, #12]
 8016bce:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016bd2:	685c      	ldr	r4, [r3, #4]
 8016bd4:	69bb      	ldr	r3, [r7, #24]
 8016bd6:	68db      	ldr	r3, [r3, #12]
 8016bd8:	69fa      	ldr	r2, [r7, #28]
 8016bda:	9202      	str	r2, [sp, #8]
 8016bdc:	f107 0214 	add.w	r2, r7, #20
 8016be0:	9201      	str	r2, [sp, #4]
 8016be2:	9300      	str	r3, [sp, #0]
 8016be4:	683b      	ldr	r3, [r7, #0]
 8016be6:	687a      	ldr	r2, [r7, #4]
 8016be8:	68b9      	ldr	r1, [r7, #8]
 8016bea:	68f8      	ldr	r0, [r7, #12]
 8016bec:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 8016bee:	68fb      	ldr	r3, [r7, #12]
 8016bf0:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8016bf4:	685c      	ldr	r4, [r3, #4]
 8016bf6:	69bb      	ldr	r3, [r7, #24]
 8016bf8:	68d9      	ldr	r1, [r3, #12]
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
 8016bfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016bfc:	681b      	ldr	r3, [r3, #0]
 8016bfe:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 8016c00:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016c02:	441a      	add	r2, r3
 8016c04:	697b      	ldr	r3, [r7, #20]
 8016c06:	68f8      	ldr	r0, [r7, #12]
 8016c08:	47a0      	blx	r4
  *out_row_ctr += num_rows;
 8016c0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016c0c:	681a      	ldr	r2, [r3, #0]
 8016c0e:	697b      	ldr	r3, [r7, #20]
 8016c10:	441a      	add	r2, r3
 8016c12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016c14:	601a      	str	r2, [r3, #0]
}
 8016c16:	bf00      	nop
 8016c18:	3724      	adds	r7, #36	; 0x24
 8016c1a:	46bd      	mov	sp, r7
 8016c1c:	bd90      	pop	{r4, r7, pc}

08016c1e <post_process_prepass>:
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
 8016c1e:	b590      	push	{r4, r7, lr}
 8016c20:	b08d      	sub	sp, #52	; 0x34
 8016c22:	af04      	add	r7, sp, #16
 8016c24:	60f8      	str	r0, [r7, #12]
 8016c26:	60b9      	str	r1, [r7, #8]
 8016c28:	607a      	str	r2, [r7, #4]
 8016c2a:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 8016c2c:	68fb      	ldr	r3, [r7, #12]
 8016c2e:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8016c32:	61fb      	str	r3, [r7, #28]
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 8016c34:	69fb      	ldr	r3, [r7, #28]
 8016c36:	699b      	ldr	r3, [r3, #24]
 8016c38:	2b00      	cmp	r3, #0
 8016c3a:	d10f      	bne.n	8016c5c <post_process_prepass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 8016c3c:	68fb      	ldr	r3, [r7, #12]
 8016c3e:	685b      	ldr	r3, [r3, #4]
 8016c40:	69dc      	ldr	r4, [r3, #28]
 8016c42:	69fb      	ldr	r3, [r7, #28]
 8016c44:	6899      	ldr	r1, [r3, #8]
 8016c46:	69fb      	ldr	r3, [r7, #28]
 8016c48:	695a      	ldr	r2, [r3, #20]
 8016c4a:	69fb      	ldr	r3, [r7, #28]
 8016c4c:	691b      	ldr	r3, [r3, #16]
 8016c4e:	2001      	movs	r0, #1
 8016c50:	9000      	str	r0, [sp, #0]
 8016c52:	68f8      	ldr	r0, [r7, #12]
 8016c54:	47a0      	blx	r4
 8016c56:	4602      	mov	r2, r0
 8016c58:	69fb      	ldr	r3, [r7, #28]
 8016c5a:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
 8016c5c:	69fb      	ldr	r3, [r7, #28]
 8016c5e:	699b      	ldr	r3, [r3, #24]
 8016c60:	61bb      	str	r3, [r7, #24]
  (*cinfo->upsample->upsample) (cinfo,
 8016c62:	68fb      	ldr	r3, [r7, #12]
 8016c64:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016c68:	685c      	ldr	r4, [r3, #4]
 8016c6a:	69fb      	ldr	r3, [r7, #28]
 8016c6c:	68db      	ldr	r3, [r3, #12]
 8016c6e:	69fa      	ldr	r2, [r7, #28]
 8016c70:	3218      	adds	r2, #24
 8016c72:	69f9      	ldr	r1, [r7, #28]
 8016c74:	6909      	ldr	r1, [r1, #16]
 8016c76:	9102      	str	r1, [sp, #8]
 8016c78:	9201      	str	r2, [sp, #4]
 8016c7a:	9300      	str	r3, [sp, #0]
 8016c7c:	683b      	ldr	r3, [r7, #0]
 8016c7e:	687a      	ldr	r2, [r7, #4]
 8016c80:	68b9      	ldr	r1, [r7, #8]
 8016c82:	68f8      	ldr	r0, [r7, #12]
 8016c84:	47a0      	blx	r4
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
 8016c86:	69fb      	ldr	r3, [r7, #28]
 8016c88:	699b      	ldr	r3, [r3, #24]
 8016c8a:	69ba      	ldr	r2, [r7, #24]
 8016c8c:	429a      	cmp	r2, r3
 8016c8e:	d217      	bcs.n	8016cc0 <post_process_prepass+0xa2>
    num_rows = post->next_row - old_next_row;
 8016c90:	69fb      	ldr	r3, [r7, #28]
 8016c92:	699a      	ldr	r2, [r3, #24]
 8016c94:	69bb      	ldr	r3, [r7, #24]
 8016c96:	1ad3      	subs	r3, r2, r3
 8016c98:	617b      	str	r3, [r7, #20]
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
 8016c9a:	68fb      	ldr	r3, [r7, #12]
 8016c9c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8016ca0:	685c      	ldr	r4, [r3, #4]
 8016ca2:	69fb      	ldr	r3, [r7, #28]
 8016ca4:	68da      	ldr	r2, [r3, #12]
 8016ca6:	69bb      	ldr	r3, [r7, #24]
 8016ca8:	009b      	lsls	r3, r3, #2
 8016caa:	18d1      	adds	r1, r2, r3
 8016cac:	697b      	ldr	r3, [r7, #20]
 8016cae:	2200      	movs	r2, #0
 8016cb0:	68f8      	ldr	r0, [r7, #12]
 8016cb2:	47a0      	blx	r4
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
 8016cb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cb6:	681a      	ldr	r2, [r3, #0]
 8016cb8:	697b      	ldr	r3, [r7, #20]
 8016cba:	441a      	add	r2, r3
 8016cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cbe:	601a      	str	r2, [r3, #0]
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
 8016cc0:	69fb      	ldr	r3, [r7, #28]
 8016cc2:	699a      	ldr	r2, [r3, #24]
 8016cc4:	69fb      	ldr	r3, [r7, #28]
 8016cc6:	691b      	ldr	r3, [r3, #16]
 8016cc8:	429a      	cmp	r2, r3
 8016cca:	d309      	bcc.n	8016ce0 <post_process_prepass+0xc2>
    post->starting_row += post->strip_height;
 8016ccc:	69fb      	ldr	r3, [r7, #28]
 8016cce:	695a      	ldr	r2, [r3, #20]
 8016cd0:	69fb      	ldr	r3, [r7, #28]
 8016cd2:	691b      	ldr	r3, [r3, #16]
 8016cd4:	441a      	add	r2, r3
 8016cd6:	69fb      	ldr	r3, [r7, #28]
 8016cd8:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 8016cda:	69fb      	ldr	r3, [r7, #28]
 8016cdc:	2200      	movs	r2, #0
 8016cde:	619a      	str	r2, [r3, #24]
  }
}
 8016ce0:	bf00      	nop
 8016ce2:	3724      	adds	r7, #36	; 0x24
 8016ce4:	46bd      	mov	sp, r7
 8016ce6:	bd90      	pop	{r4, r7, pc}

08016ce8 <post_process_2pass>:
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
 8016ce8:	b590      	push	{r4, r7, lr}
 8016cea:	b08b      	sub	sp, #44	; 0x2c
 8016cec:	af02      	add	r7, sp, #8
 8016cee:	60f8      	str	r0, [r7, #12]
 8016cf0:	60b9      	str	r1, [r7, #8]
 8016cf2:	607a      	str	r2, [r7, #4]
 8016cf4:	603b      	str	r3, [r7, #0]
  my_post_ptr post = (my_post_ptr) cinfo->post;
 8016cf6:	68fb      	ldr	r3, [r7, #12]
 8016cf8:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8016cfc:	61bb      	str	r3, [r7, #24]
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
 8016cfe:	69bb      	ldr	r3, [r7, #24]
 8016d00:	699b      	ldr	r3, [r3, #24]
 8016d02:	2b00      	cmp	r3, #0
 8016d04:	d10f      	bne.n	8016d26 <post_process_2pass+0x3e>
    post->buffer = (*cinfo->mem->access_virt_sarray)
 8016d06:	68fb      	ldr	r3, [r7, #12]
 8016d08:	685b      	ldr	r3, [r3, #4]
 8016d0a:	69dc      	ldr	r4, [r3, #28]
 8016d0c:	69bb      	ldr	r3, [r7, #24]
 8016d0e:	6899      	ldr	r1, [r3, #8]
 8016d10:	69bb      	ldr	r3, [r7, #24]
 8016d12:	695a      	ldr	r2, [r3, #20]
 8016d14:	69bb      	ldr	r3, [r7, #24]
 8016d16:	691b      	ldr	r3, [r3, #16]
 8016d18:	2000      	movs	r0, #0
 8016d1a:	9000      	str	r0, [sp, #0]
 8016d1c:	68f8      	ldr	r0, [r7, #12]
 8016d1e:	47a0      	blx	r4
 8016d20:	4602      	mov	r2, r0
 8016d22:	69bb      	ldr	r3, [r7, #24]
 8016d24:	60da      	str	r2, [r3, #12]
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
 8016d26:	69bb      	ldr	r3, [r7, #24]
 8016d28:	691a      	ldr	r2, [r3, #16]
 8016d2a:	69bb      	ldr	r3, [r7, #24]
 8016d2c:	699b      	ldr	r3, [r3, #24]
 8016d2e:	1ad3      	subs	r3, r2, r3
 8016d30:	61fb      	str	r3, [r7, #28]
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
 8016d32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d34:	681b      	ldr	r3, [r3, #0]
 8016d36:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016d38:	1ad3      	subs	r3, r2, r3
 8016d3a:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 8016d3c:	69fa      	ldr	r2, [r7, #28]
 8016d3e:	697b      	ldr	r3, [r7, #20]
 8016d40:	429a      	cmp	r2, r3
 8016d42:	d901      	bls.n	8016d48 <post_process_2pass+0x60>
    num_rows = max_rows;
 8016d44:	697b      	ldr	r3, [r7, #20]
 8016d46:	61fb      	str	r3, [r7, #28]
  /* We have to check bottom of image here, can't depend on upsampler. */
  max_rows = cinfo->output_height - post->starting_row;
 8016d48:	68fb      	ldr	r3, [r7, #12]
 8016d4a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8016d4c:	69bb      	ldr	r3, [r7, #24]
 8016d4e:	695b      	ldr	r3, [r3, #20]
 8016d50:	1ad3      	subs	r3, r2, r3
 8016d52:	617b      	str	r3, [r7, #20]
  if (num_rows > max_rows)
 8016d54:	69fa      	ldr	r2, [r7, #28]
 8016d56:	697b      	ldr	r3, [r7, #20]
 8016d58:	429a      	cmp	r2, r3
 8016d5a:	d901      	bls.n	8016d60 <post_process_2pass+0x78>
    num_rows = max_rows;
 8016d5c:	697b      	ldr	r3, [r7, #20]
 8016d5e:	61fb      	str	r3, [r7, #28]

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
 8016d60:	68fb      	ldr	r3, [r7, #12]
 8016d62:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8016d66:	685c      	ldr	r4, [r3, #4]
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 8016d68:	69bb      	ldr	r3, [r7, #24]
 8016d6a:	68da      	ldr	r2, [r3, #12]
 8016d6c:	69bb      	ldr	r3, [r7, #24]
 8016d6e:	699b      	ldr	r3, [r3, #24]
 8016d70:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 8016d72:	18d1      	adds	r1, r2, r3
		post->buffer + post->next_row, output_buf + *out_row_ctr,
 8016d74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d76:	681b      	ldr	r3, [r3, #0]
 8016d78:	009b      	lsls	r3, r3, #2
  (*cinfo->cquantize->color_quantize) (cinfo,
 8016d7a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016d7c:	441a      	add	r2, r3
 8016d7e:	69fb      	ldr	r3, [r7, #28]
 8016d80:	68f8      	ldr	r0, [r7, #12]
 8016d82:	47a0      	blx	r4
		(int) num_rows);
  *out_row_ctr += num_rows;
 8016d84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d86:	681a      	ldr	r2, [r3, #0]
 8016d88:	69fb      	ldr	r3, [r7, #28]
 8016d8a:	441a      	add	r2, r3
 8016d8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d8e:	601a      	str	r2, [r3, #0]

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
 8016d90:	69bb      	ldr	r3, [r7, #24]
 8016d92:	699a      	ldr	r2, [r3, #24]
 8016d94:	69fb      	ldr	r3, [r7, #28]
 8016d96:	441a      	add	r2, r3
 8016d98:	69bb      	ldr	r3, [r7, #24]
 8016d9a:	619a      	str	r2, [r3, #24]
  if (post->next_row >= post->strip_height) {
 8016d9c:	69bb      	ldr	r3, [r7, #24]
 8016d9e:	699a      	ldr	r2, [r3, #24]
 8016da0:	69bb      	ldr	r3, [r7, #24]
 8016da2:	691b      	ldr	r3, [r3, #16]
 8016da4:	429a      	cmp	r2, r3
 8016da6:	d309      	bcc.n	8016dbc <post_process_2pass+0xd4>
    post->starting_row += post->strip_height;
 8016da8:	69bb      	ldr	r3, [r7, #24]
 8016daa:	695a      	ldr	r2, [r3, #20]
 8016dac:	69bb      	ldr	r3, [r7, #24]
 8016dae:	691b      	ldr	r3, [r3, #16]
 8016db0:	441a      	add	r2, r3
 8016db2:	69bb      	ldr	r3, [r7, #24]
 8016db4:	615a      	str	r2, [r3, #20]
    post->next_row = 0;
 8016db6:	69bb      	ldr	r3, [r7, #24]
 8016db8:	2200      	movs	r2, #0
 8016dba:	619a      	str	r2, [r3, #24]
  }
}
 8016dbc:	bf00      	nop
 8016dbe:	3724      	adds	r7, #36	; 0x24
 8016dc0:	46bd      	mov	sp, r7
 8016dc2:	bd90      	pop	{r4, r7, pc}

08016dc4 <jinit_d_post_controller>:
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
 8016dc4:	b5b0      	push	{r4, r5, r7, lr}
 8016dc6:	b086      	sub	sp, #24
 8016dc8:	af02      	add	r7, sp, #8
 8016dca:	6078      	str	r0, [r7, #4]
 8016dcc:	6039      	str	r1, [r7, #0]
  my_post_ptr post;

  post = (my_post_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8016dce:	687b      	ldr	r3, [r7, #4]
 8016dd0:	685b      	ldr	r3, [r3, #4]
 8016dd2:	681b      	ldr	r3, [r3, #0]
 8016dd4:	221c      	movs	r2, #28
 8016dd6:	2101      	movs	r1, #1
 8016dd8:	6878      	ldr	r0, [r7, #4]
 8016dda:	4798      	blx	r3
 8016ddc:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
 8016dde:	687b      	ldr	r3, [r7, #4]
 8016de0:	68fa      	ldr	r2, [r7, #12]
 8016de2:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
  post->pub.start_pass = start_pass_dpost;
 8016de6:	68fb      	ldr	r3, [r7, #12]
 8016de8:	4a25      	ldr	r2, [pc, #148]	; (8016e80 <jinit_d_post_controller+0xbc>)
 8016dea:	601a      	str	r2, [r3, #0]
  post->whole_image = NULL;	/* flag for no virtual arrays */
 8016dec:	68fb      	ldr	r3, [r7, #12]
 8016dee:	2200      	movs	r2, #0
 8016df0:	609a      	str	r2, [r3, #8]
  post->buffer = NULL;		/* flag for no strip buffer */
 8016df2:	68fb      	ldr	r3, [r7, #12]
 8016df4:	2200      	movs	r2, #0
 8016df6:	60da      	str	r2, [r3, #12]

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
 8016df8:	687b      	ldr	r3, [r7, #4]
 8016dfa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016dfc:	2b00      	cmp	r3, #0
 8016dfe:	d03a      	beq.n	8016e76 <jinit_d_post_controller+0xb2>
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
 8016e00:	687b      	ldr	r3, [r7, #4]
 8016e02:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8016e06:	461a      	mov	r2, r3
 8016e08:	68fb      	ldr	r3, [r7, #12]
 8016e0a:	611a      	str	r2, [r3, #16]
    if (need_full_buffer) {
 8016e0c:	683b      	ldr	r3, [r7, #0]
 8016e0e:	2b00      	cmp	r3, #0
 8016e10:	d020      	beq.n	8016e54 <jinit_d_post_controller+0x90>
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 8016e12:	687b      	ldr	r3, [r7, #4]
 8016e14:	685b      	ldr	r3, [r3, #4]
 8016e16:	691c      	ldr	r4, [r3, #16]
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 cinfo->output_width * cinfo->out_color_components,
 8016e18:	687b      	ldr	r3, [r7, #4]
 8016e1a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8016e1c:	687a      	ldr	r2, [r7, #4]
 8016e1e:	6f92      	ldr	r2, [r2, #120]	; 0x78
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 8016e20:	fb02 f503 	mul.w	r5, r2, r3
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 8016e24:	687b      	ldr	r3, [r7, #4]
 8016e26:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016e28:	461a      	mov	r2, r3
				(long) post->strip_height),
 8016e2a:	68fb      	ldr	r3, [r7, #12]
 8016e2c:	691b      	ldr	r3, [r3, #16]
	 (JDIMENSION) jround_up((long) cinfo->output_height,
 8016e2e:	4619      	mov	r1, r3
 8016e30:	4610      	mov	r0, r2
 8016e32:	f010 fe85 	bl	8027b40 <jround_up>
 8016e36:	4603      	mov	r3, r0
      post->whole_image = (*cinfo->mem->request_virt_sarray)
 8016e38:	461a      	mov	r2, r3
 8016e3a:	68fb      	ldr	r3, [r7, #12]
 8016e3c:	691b      	ldr	r3, [r3, #16]
 8016e3e:	9301      	str	r3, [sp, #4]
 8016e40:	9200      	str	r2, [sp, #0]
 8016e42:	462b      	mov	r3, r5
 8016e44:	2200      	movs	r2, #0
 8016e46:	2101      	movs	r1, #1
 8016e48:	6878      	ldr	r0, [r7, #4]
 8016e4a:	47a0      	blx	r4
 8016e4c:	4602      	mov	r2, r0
 8016e4e:	68fb      	ldr	r3, [r7, #12]
 8016e50:	609a      	str	r2, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 cinfo->output_width * cinfo->out_color_components,
	 post->strip_height);
    }
  }
}
 8016e52:	e010      	b.n	8016e76 <jinit_d_post_controller+0xb2>
      post->buffer = (*cinfo->mem->alloc_sarray)
 8016e54:	687b      	ldr	r3, [r7, #4]
 8016e56:	685b      	ldr	r3, [r3, #4]
 8016e58:	689c      	ldr	r4, [r3, #8]
	 cinfo->output_width * cinfo->out_color_components,
 8016e5a:	687b      	ldr	r3, [r7, #4]
 8016e5c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8016e5e:	687a      	ldr	r2, [r7, #4]
 8016e60:	6f92      	ldr	r2, [r2, #120]	; 0x78
      post->buffer = (*cinfo->mem->alloc_sarray)
 8016e62:	fb02 f203 	mul.w	r2, r2, r3
 8016e66:	68fb      	ldr	r3, [r7, #12]
 8016e68:	691b      	ldr	r3, [r3, #16]
 8016e6a:	2101      	movs	r1, #1
 8016e6c:	6878      	ldr	r0, [r7, #4]
 8016e6e:	47a0      	blx	r4
 8016e70:	4602      	mov	r2, r0
 8016e72:	68fb      	ldr	r3, [r7, #12]
 8016e74:	60da      	str	r2, [r3, #12]
}
 8016e76:	bf00      	nop
 8016e78:	3710      	adds	r7, #16
 8016e7a:	46bd      	mov	sp, r7
 8016e7c:	bdb0      	pop	{r4, r5, r7, pc}
 8016e7e:	bf00      	nop
 8016e80:	08016ab1 	.word	0x08016ab1

08016e84 <start_pass_upsample>:
 * Initialize for an upsampling pass.
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
 8016e84:	b480      	push	{r7}
 8016e86:	b085      	sub	sp, #20
 8016e88:	af00      	add	r7, sp, #0
 8016e8a:	6078      	str	r0, [r7, #4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8016e8c:	687b      	ldr	r3, [r7, #4]
 8016e8e:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016e92:	60fb      	str	r3, [r7, #12]

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
 8016e94:	687b      	ldr	r3, [r7, #4]
 8016e96:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
 8016e9a:	68fb      	ldr	r3, [r7, #12]
 8016e9c:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
 8016e9e:	687b      	ldr	r3, [r7, #4]
 8016ea0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8016ea2:	68fb      	ldr	r3, [r7, #12]
 8016ea4:	661a      	str	r2, [r3, #96]	; 0x60
}
 8016ea6:	bf00      	nop
 8016ea8:	3714      	adds	r7, #20
 8016eaa:	46bd      	mov	sp, r7
 8016eac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016eb0:	4770      	bx	lr

08016eb2 <sep_upsample>:
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
 8016eb2:	b590      	push	{r4, r7, lr}
 8016eb4:	b08b      	sub	sp, #44	; 0x2c
 8016eb6:	af02      	add	r7, sp, #8
 8016eb8:	60f8      	str	r0, [r7, #12]
 8016eba:	60b9      	str	r1, [r7, #8]
 8016ebc:	607a      	str	r2, [r7, #4]
 8016ebe:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8016ec0:	68fb      	ldr	r3, [r7, #12]
 8016ec2:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 8016ec6:	613b      	str	r3, [r7, #16]
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
 8016ec8:	693b      	ldr	r3, [r7, #16]
 8016eca:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8016ecc:	68fb      	ldr	r3, [r7, #12]
 8016ece:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8016ed2:	429a      	cmp	r2, r3
 8016ed4:	db35      	blt.n	8016f42 <sep_upsample+0x90>
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8016ed6:	2300      	movs	r3, #0
 8016ed8:	61fb      	str	r3, [r7, #28]
 8016eda:	68fb      	ldr	r3, [r7, #12]
 8016edc:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8016ee0:	61bb      	str	r3, [r7, #24]
 8016ee2:	e026      	b.n	8016f32 <sep_upsample+0x80>
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
 8016ee4:	693a      	ldr	r2, [r7, #16]
 8016ee6:	69fb      	ldr	r3, [r7, #28]
 8016ee8:	330c      	adds	r3, #12
 8016eea:	009b      	lsls	r3, r3, #2
 8016eec:	4413      	add	r3, r2
 8016eee:	685c      	ldr	r4, [r3, #4]
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
 8016ef0:	69fb      	ldr	r3, [r7, #28]
 8016ef2:	009b      	lsls	r3, r3, #2
 8016ef4:	68ba      	ldr	r2, [r7, #8]
 8016ef6:	4413      	add	r3, r2
 8016ef8:	681a      	ldr	r2, [r3, #0]
 8016efa:	687b      	ldr	r3, [r7, #4]
 8016efc:	6819      	ldr	r1, [r3, #0]
 8016efe:	6938      	ldr	r0, [r7, #16]
 8016f00:	69fb      	ldr	r3, [r7, #28]
 8016f02:	3318      	adds	r3, #24
 8016f04:	009b      	lsls	r3, r3, #2
 8016f06:	4403      	add	r3, r0
 8016f08:	685b      	ldr	r3, [r3, #4]
 8016f0a:	fb03 f301 	mul.w	r3, r3, r1
 8016f0e:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 8016f10:	18d1      	adds	r1, r2, r3
	upsample->color_buf + ci);
 8016f12:	693b      	ldr	r3, [r7, #16]
 8016f14:	f103 020c 	add.w	r2, r3, #12
 8016f18:	69fb      	ldr	r3, [r7, #28]
 8016f1a:	009b      	lsls	r3, r3, #2
      (*upsample->methods[ci]) (cinfo, compptr,
 8016f1c:	4413      	add	r3, r2
 8016f1e:	460a      	mov	r2, r1
 8016f20:	69b9      	ldr	r1, [r7, #24]
 8016f22:	68f8      	ldr	r0, [r7, #12]
 8016f24:	47a0      	blx	r4
	 ci++, compptr++) {
 8016f26:	69fb      	ldr	r3, [r7, #28]
 8016f28:	3301      	adds	r3, #1
 8016f2a:	61fb      	str	r3, [r7, #28]
 8016f2c:	69bb      	ldr	r3, [r7, #24]
 8016f2e:	3358      	adds	r3, #88	; 0x58
 8016f30:	61bb      	str	r3, [r7, #24]
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8016f32:	68fb      	ldr	r3, [r7, #12]
 8016f34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016f36:	69fa      	ldr	r2, [r7, #28]
 8016f38:	429a      	cmp	r2, r3
 8016f3a:	dbd3      	blt.n	8016ee4 <sep_upsample+0x32>
    }
    upsample->next_row_out = 0;
 8016f3c:	693b      	ldr	r3, [r7, #16]
 8016f3e:	2200      	movs	r2, #0
 8016f40:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
 8016f42:	68fb      	ldr	r3, [r7, #12]
 8016f44:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
 8016f48:	693b      	ldr	r3, [r7, #16]
 8016f4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8016f4c:	1ad3      	subs	r3, r2, r3
 8016f4e:	617b      	str	r3, [r7, #20]
  /* Not more than the distance to the end of the image.  Need this test
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go) 
 8016f50:	693b      	ldr	r3, [r7, #16]
 8016f52:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8016f54:	697a      	ldr	r2, [r7, #20]
 8016f56:	429a      	cmp	r2, r3
 8016f58:	d902      	bls.n	8016f60 <sep_upsample+0xae>
    num_rows = upsample->rows_to_go;
 8016f5a:	693b      	ldr	r3, [r7, #16]
 8016f5c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8016f5e:	617b      	str	r3, [r7, #20]
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
 8016f60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016f62:	681b      	ldr	r3, [r3, #0]
 8016f64:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016f66:	1ad3      	subs	r3, r2, r3
 8016f68:	63bb      	str	r3, [r7, #56]	; 0x38
  if (num_rows > out_rows_avail)
 8016f6a:	697a      	ldr	r2, [r7, #20]
 8016f6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016f6e:	429a      	cmp	r2, r3
 8016f70:	d901      	bls.n	8016f76 <sep_upsample+0xc4>
    num_rows = out_rows_avail;
 8016f72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016f74:	617b      	str	r3, [r7, #20]

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 8016f76:	68fb      	ldr	r3, [r7, #12]
 8016f78:	f8d3 31dc 	ldr.w	r3, [r3, #476]	; 0x1dc
 8016f7c:	685c      	ldr	r4, [r3, #4]
 8016f7e:	693b      	ldr	r3, [r7, #16]
 8016f80:	f103 010c 	add.w	r1, r3, #12
				     (JDIMENSION) upsample->next_row_out,
 8016f84:	693b      	ldr	r3, [r7, #16]
 8016f86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 8016f88:	4618      	mov	r0, r3
				     output_buf + *out_row_ctr,
 8016f8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016f8c:	681b      	ldr	r3, [r3, #0]
 8016f8e:	009b      	lsls	r3, r3, #2
  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 8016f90:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016f92:	441a      	add	r2, r3
 8016f94:	697b      	ldr	r3, [r7, #20]
 8016f96:	9300      	str	r3, [sp, #0]
 8016f98:	4613      	mov	r3, r2
 8016f9a:	4602      	mov	r2, r0
 8016f9c:	68f8      	ldr	r0, [r7, #12]
 8016f9e:	47a0      	blx	r4
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
 8016fa0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016fa2:	681a      	ldr	r2, [r3, #0]
 8016fa4:	697b      	ldr	r3, [r7, #20]
 8016fa6:	441a      	add	r2, r3
 8016fa8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016faa:	601a      	str	r2, [r3, #0]
  upsample->rows_to_go -= num_rows;
 8016fac:	693b      	ldr	r3, [r7, #16]
 8016fae:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8016fb0:	697b      	ldr	r3, [r7, #20]
 8016fb2:	1ad2      	subs	r2, r2, r3
 8016fb4:	693b      	ldr	r3, [r7, #16]
 8016fb6:	661a      	str	r2, [r3, #96]	; 0x60
  upsample->next_row_out += num_rows;
 8016fb8:	693b      	ldr	r3, [r7, #16]
 8016fba:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8016fbc:	461a      	mov	r2, r3
 8016fbe:	697b      	ldr	r3, [r7, #20]
 8016fc0:	4413      	add	r3, r2
 8016fc2:	461a      	mov	r2, r3
 8016fc4:	693b      	ldr	r3, [r7, #16]
 8016fc6:	65da      	str	r2, [r3, #92]	; 0x5c
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
 8016fc8:	693b      	ldr	r3, [r7, #16]
 8016fca:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8016fcc:	68fb      	ldr	r3, [r7, #12]
 8016fce:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8016fd2:	429a      	cmp	r2, r3
 8016fd4:	db04      	blt.n	8016fe0 <sep_upsample+0x12e>
    (*in_row_group_ctr)++;
 8016fd6:	687b      	ldr	r3, [r7, #4]
 8016fd8:	681b      	ldr	r3, [r3, #0]
 8016fda:	1c5a      	adds	r2, r3, #1
 8016fdc:	687b      	ldr	r3, [r7, #4]
 8016fde:	601a      	str	r2, [r3, #0]
}
 8016fe0:	bf00      	nop
 8016fe2:	3724      	adds	r7, #36	; 0x24
 8016fe4:	46bd      	mov	sp, r7
 8016fe6:	bd90      	pop	{r4, r7, pc}

08016fe8 <fullsize_upsample>:
 */

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 8016fe8:	b480      	push	{r7}
 8016fea:	b085      	sub	sp, #20
 8016fec:	af00      	add	r7, sp, #0
 8016fee:	60f8      	str	r0, [r7, #12]
 8016ff0:	60b9      	str	r1, [r7, #8]
 8016ff2:	607a      	str	r2, [r7, #4]
 8016ff4:	603b      	str	r3, [r7, #0]
  *output_data_ptr = input_data;
 8016ff6:	683b      	ldr	r3, [r7, #0]
 8016ff8:	687a      	ldr	r2, [r7, #4]
 8016ffa:	601a      	str	r2, [r3, #0]
}
 8016ffc:	bf00      	nop
 8016ffe:	3714      	adds	r7, #20
 8017000:	46bd      	mov	sp, r7
 8017002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017006:	4770      	bx	lr

08017008 <noop_upsample>:
 */

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 8017008:	b480      	push	{r7}
 801700a:	b085      	sub	sp, #20
 801700c:	af00      	add	r7, sp, #0
 801700e:	60f8      	str	r0, [r7, #12]
 8017010:	60b9      	str	r1, [r7, #8]
 8017012:	607a      	str	r2, [r7, #4]
 8017014:	603b      	str	r3, [r7, #0]
  *output_data_ptr = NULL;	/* safety check */
 8017016:	683b      	ldr	r3, [r7, #0]
 8017018:	2200      	movs	r2, #0
 801701a:	601a      	str	r2, [r3, #0]
}
 801701c:	bf00      	nop
 801701e:	3714      	adds	r7, #20
 8017020:	46bd      	mov	sp, r7
 8017022:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017026:	4770      	bx	lr

08017028 <int_upsample>:
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 8017028:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801702c:	b08e      	sub	sp, #56	; 0x38
 801702e:	af02      	add	r7, sp, #8
 8017030:	60f8      	str	r0, [r7, #12]
 8017032:	60b9      	str	r1, [r7, #8]
 8017034:	607a      	str	r2, [r7, #4]
 8017036:	603b      	str	r3, [r7, #0]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
 8017038:	68fb      	ldr	r3, [r7, #12]
 801703a:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
 801703e:	627b      	str	r3, [r7, #36]	; 0x24
  JSAMPARRAY output_data = *output_data_ptr;
 8017040:	683b      	ldr	r3, [r7, #0]
 8017042:	681b      	ldr	r3, [r3, #0]
 8017044:	623b      	str	r3, [r7, #32]
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
 8017046:	68bb      	ldr	r3, [r7, #8]
 8017048:	685b      	ldr	r3, [r3, #4]
 801704a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801704c:	4413      	add	r3, r2
 801704e:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
 8017052:	61fb      	str	r3, [r7, #28]
  v_expand = upsample->v_expand[compptr->component_index];
 8017054:	68bb      	ldr	r3, [r7, #8]
 8017056:	685b      	ldr	r3, [r3, #4]
 8017058:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801705a:	4413      	add	r3, r2
 801705c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8017060:	61bb      	str	r3, [r7, #24]

  inrow = outrow = 0;
 8017062:	2300      	movs	r3, #0
 8017064:	62bb      	str	r3, [r7, #40]	; 0x28
 8017066:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017068:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (outrow < cinfo->max_v_samp_factor) {
 801706a:	e036      	b.n	80170da <int_upsample+0xb2>
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
 801706c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801706e:	009b      	lsls	r3, r3, #2
 8017070:	687a      	ldr	r2, [r7, #4]
 8017072:	4413      	add	r3, r2
 8017074:	681e      	ldr	r6, [r3, #0]
    outptr = output_data[outrow];
 8017076:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017078:	009b      	lsls	r3, r3, #2
 801707a:	6a3a      	ldr	r2, [r7, #32]
 801707c:	4413      	add	r3, r2
 801707e:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 8017080:	68fb      	ldr	r3, [r7, #12]
 8017082:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017084:	4423      	add	r3, r4
 8017086:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 8017088:	e00c      	b.n	80170a4 <int_upsample+0x7c>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801708a:	4633      	mov	r3, r6
 801708c:	1c5e      	adds	r6, r3, #1
 801708e:	f893 8000 	ldrb.w	r8, [r3]
      for (h = h_expand; h > 0; h--) {
 8017092:	69fd      	ldr	r5, [r7, #28]
 8017094:	e004      	b.n	80170a0 <int_upsample+0x78>
	*outptr++ = invalue;
 8017096:	4623      	mov	r3, r4
 8017098:	1c5c      	adds	r4, r3, #1
 801709a:	4642      	mov	r2, r8
 801709c:	701a      	strb	r2, [r3, #0]
      for (h = h_expand; h > 0; h--) {
 801709e:	3d01      	subs	r5, #1
 80170a0:	2d00      	cmp	r5, #0
 80170a2:	dcf8      	bgt.n	8017096 <int_upsample+0x6e>
    while (outptr < outend) {
 80170a4:	697b      	ldr	r3, [r7, #20]
 80170a6:	429c      	cmp	r4, r3
 80170a8:	d3ef      	bcc.n	801708a <int_upsample+0x62>
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
 80170aa:	69bb      	ldr	r3, [r7, #24]
 80170ac:	2b01      	cmp	r3, #1
 80170ae:	dd0d      	ble.n	80170cc <int_upsample+0xa4>
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 80170b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80170b2:	1c59      	adds	r1, r3, #1
 80170b4:	69bb      	ldr	r3, [r7, #24]
 80170b6:	3b01      	subs	r3, #1
 80170b8:	68fa      	ldr	r2, [r7, #12]
 80170ba:	6f12      	ldr	r2, [r2, #112]	; 0x70
 80170bc:	9201      	str	r2, [sp, #4]
 80170be:	9300      	str	r3, [sp, #0]
 80170c0:	460b      	mov	r3, r1
 80170c2:	6a3a      	ldr	r2, [r7, #32]
 80170c4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80170c6:	6a38      	ldr	r0, [r7, #32]
 80170c8:	f010 fd54 	bl	8027b74 <jcopy_sample_rows>
			v_expand-1, cinfo->output_width);
    }
    inrow++;
 80170cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80170ce:	3301      	adds	r3, #1
 80170d0:	62fb      	str	r3, [r7, #44]	; 0x2c
    outrow += v_expand;
 80170d2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80170d4:	69bb      	ldr	r3, [r7, #24]
 80170d6:	4413      	add	r3, r2
 80170d8:	62bb      	str	r3, [r7, #40]	; 0x28
  while (outrow < cinfo->max_v_samp_factor) {
 80170da:	68fb      	ldr	r3, [r7, #12]
 80170dc:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 80170e0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80170e2:	429a      	cmp	r2, r3
 80170e4:	dbc2      	blt.n	801706c <int_upsample+0x44>
  }
}
 80170e6:	bf00      	nop
 80170e8:	bf00      	nop
 80170ea:	3730      	adds	r7, #48	; 0x30
 80170ec:	46bd      	mov	sp, r7
 80170ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080170f2 <h2v1_upsample>:
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 80170f2:	b4f0      	push	{r4, r5, r6, r7}
 80170f4:	b088      	sub	sp, #32
 80170f6:	af00      	add	r7, sp, #0
 80170f8:	60f8      	str	r0, [r7, #12]
 80170fa:	60b9      	str	r1, [r7, #8]
 80170fc:	607a      	str	r2, [r7, #4]
 80170fe:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 8017100:	683b      	ldr	r3, [r7, #0]
 8017102:	681b      	ldr	r3, [r3, #0]
 8017104:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int outrow;

  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 8017106:	2300      	movs	r3, #0
 8017108:	61fb      	str	r3, [r7, #28]
 801710a:	e01f      	b.n	801714c <h2v1_upsample+0x5a>
    inptr = input_data[outrow];
 801710c:	69fb      	ldr	r3, [r7, #28]
 801710e:	009b      	lsls	r3, r3, #2
 8017110:	687a      	ldr	r2, [r7, #4]
 8017112:	4413      	add	r3, r2
 8017114:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 8017116:	69fb      	ldr	r3, [r7, #28]
 8017118:	009b      	lsls	r3, r3, #2
 801711a:	69ba      	ldr	r2, [r7, #24]
 801711c:	4413      	add	r3, r2
 801711e:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 8017120:	68fb      	ldr	r3, [r7, #12]
 8017122:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017124:	4423      	add	r3, r4
 8017126:	617b      	str	r3, [r7, #20]
    while (outptr < outend) {
 8017128:	e00a      	b.n	8017140 <h2v1_upsample+0x4e>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 801712a:	462b      	mov	r3, r5
 801712c:	1c5d      	adds	r5, r3, #1
 801712e:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 8017130:	4623      	mov	r3, r4
 8017132:	1c5c      	adds	r4, r3, #1
 8017134:	4632      	mov	r2, r6
 8017136:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 8017138:	4623      	mov	r3, r4
 801713a:	1c5c      	adds	r4, r3, #1
 801713c:	4632      	mov	r2, r6
 801713e:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 8017140:	697b      	ldr	r3, [r7, #20]
 8017142:	429c      	cmp	r4, r3
 8017144:	d3f1      	bcc.n	801712a <h2v1_upsample+0x38>
  for (outrow = 0; outrow < cinfo->max_v_samp_factor; outrow++) {
 8017146:	69fb      	ldr	r3, [r7, #28]
 8017148:	3301      	adds	r3, #1
 801714a:	61fb      	str	r3, [r7, #28]
 801714c:	68fb      	ldr	r3, [r7, #12]
 801714e:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8017152:	69fa      	ldr	r2, [r7, #28]
 8017154:	429a      	cmp	r2, r3
 8017156:	dbd9      	blt.n	801710c <h2v1_upsample+0x1a>
    }
  }
}
 8017158:	bf00      	nop
 801715a:	bf00      	nop
 801715c:	3720      	adds	r7, #32
 801715e:	46bd      	mov	sp, r7
 8017160:	bcf0      	pop	{r4, r5, r6, r7}
 8017162:	4770      	bx	lr

08017164 <h2v2_upsample>:
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
 8017164:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017166:	b08b      	sub	sp, #44	; 0x2c
 8017168:	af02      	add	r7, sp, #8
 801716a:	60f8      	str	r0, [r7, #12]
 801716c:	60b9      	str	r1, [r7, #8]
 801716e:	607a      	str	r2, [r7, #4]
 8017170:	603b      	str	r3, [r7, #0]
  JSAMPARRAY output_data = *output_data_ptr;
 8017172:	683b      	ldr	r3, [r7, #0]
 8017174:	681b      	ldr	r3, [r3, #0]
 8017176:	617b      	str	r3, [r7, #20]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
 8017178:	2300      	movs	r3, #0
 801717a:	61bb      	str	r3, [r7, #24]
 801717c:	69bb      	ldr	r3, [r7, #24]
 801717e:	61fb      	str	r3, [r7, #28]
  while (outrow < cinfo->max_v_samp_factor) {
 8017180:	e02f      	b.n	80171e2 <h2v2_upsample+0x7e>
    inptr = input_data[inrow];
 8017182:	69fb      	ldr	r3, [r7, #28]
 8017184:	009b      	lsls	r3, r3, #2
 8017186:	687a      	ldr	r2, [r7, #4]
 8017188:	4413      	add	r3, r2
 801718a:	681d      	ldr	r5, [r3, #0]
    outptr = output_data[outrow];
 801718c:	69bb      	ldr	r3, [r7, #24]
 801718e:	009b      	lsls	r3, r3, #2
 8017190:	697a      	ldr	r2, [r7, #20]
 8017192:	4413      	add	r3, r2
 8017194:	681c      	ldr	r4, [r3, #0]
    outend = outptr + cinfo->output_width;
 8017196:	68fb      	ldr	r3, [r7, #12]
 8017198:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801719a:	4423      	add	r3, r4
 801719c:	613b      	str	r3, [r7, #16]
    while (outptr < outend) {
 801719e:	e00a      	b.n	80171b6 <h2v2_upsample+0x52>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
 80171a0:	462b      	mov	r3, r5
 80171a2:	1c5d      	adds	r5, r3, #1
 80171a4:	781e      	ldrb	r6, [r3, #0]
      *outptr++ = invalue;
 80171a6:	4623      	mov	r3, r4
 80171a8:	1c5c      	adds	r4, r3, #1
 80171aa:	4632      	mov	r2, r6
 80171ac:	701a      	strb	r2, [r3, #0]
      *outptr++ = invalue;
 80171ae:	4623      	mov	r3, r4
 80171b0:	1c5c      	adds	r4, r3, #1
 80171b2:	4632      	mov	r2, r6
 80171b4:	701a      	strb	r2, [r3, #0]
    while (outptr < outend) {
 80171b6:	693b      	ldr	r3, [r7, #16]
 80171b8:	429c      	cmp	r4, r3
 80171ba:	d3f1      	bcc.n	80171a0 <h2v2_upsample+0x3c>
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
 80171bc:	69bb      	ldr	r3, [r7, #24]
 80171be:	1c5a      	adds	r2, r3, #1
 80171c0:	68fb      	ldr	r3, [r7, #12]
 80171c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80171c4:	9301      	str	r3, [sp, #4]
 80171c6:	2301      	movs	r3, #1
 80171c8:	9300      	str	r3, [sp, #0]
 80171ca:	4613      	mov	r3, r2
 80171cc:	697a      	ldr	r2, [r7, #20]
 80171ce:	69b9      	ldr	r1, [r7, #24]
 80171d0:	6978      	ldr	r0, [r7, #20]
 80171d2:	f010 fccf 	bl	8027b74 <jcopy_sample_rows>
		      1, cinfo->output_width);
    inrow++;
 80171d6:	69fb      	ldr	r3, [r7, #28]
 80171d8:	3301      	adds	r3, #1
 80171da:	61fb      	str	r3, [r7, #28]
    outrow += 2;
 80171dc:	69bb      	ldr	r3, [r7, #24]
 80171de:	3302      	adds	r3, #2
 80171e0:	61bb      	str	r3, [r7, #24]
  while (outrow < cinfo->max_v_samp_factor) {
 80171e2:	68fb      	ldr	r3, [r7, #12]
 80171e4:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 80171e8:	69ba      	ldr	r2, [r7, #24]
 80171ea:	429a      	cmp	r2, r3
 80171ec:	dbc9      	blt.n	8017182 <h2v2_upsample+0x1e>
  }
}
 80171ee:	bf00      	nop
 80171f0:	bf00      	nop
 80171f2:	3724      	adds	r7, #36	; 0x24
 80171f4:	46bd      	mov	sp, r7
 80171f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080171f8 <jinit_upsampler>:
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
 80171f8:	b590      	push	{r4, r7, lr}
 80171fa:	b08b      	sub	sp, #44	; 0x2c
 80171fc:	af00      	add	r7, sp, #0
 80171fe:	6078      	str	r0, [r7, #4]
  jpeg_component_info * compptr;
  boolean need_buffer;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8017200:	687b      	ldr	r3, [r7, #4]
 8017202:	685b      	ldr	r3, [r3, #4]
 8017204:	681b      	ldr	r3, [r3, #0]
 8017206:	22a0      	movs	r2, #160	; 0xa0
 8017208:	2101      	movs	r1, #1
 801720a:	6878      	ldr	r0, [r7, #4]
 801720c:	4798      	blx	r3
 801720e:	61b8      	str	r0, [r7, #24]
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
 8017210:	687b      	ldr	r3, [r7, #4]
 8017212:	69ba      	ldr	r2, [r7, #24]
 8017214:	f8c3 21d8 	str.w	r2, [r3, #472]	; 0x1d8
  upsample->pub.start_pass = start_pass_upsample;
 8017218:	69bb      	ldr	r3, [r7, #24]
 801721a:	4a7a      	ldr	r2, [pc, #488]	; (8017404 <jinit_upsampler+0x20c>)
 801721c:	601a      	str	r2, [r3, #0]
  upsample->pub.upsample = sep_upsample;
 801721e:	69bb      	ldr	r3, [r7, #24]
 8017220:	4a79      	ldr	r2, [pc, #484]	; (8017408 <jinit_upsampler+0x210>)
 8017222:	605a      	str	r2, [r3, #4]
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
 8017224:	69bb      	ldr	r3, [r7, #24]
 8017226:	2200      	movs	r2, #0
 8017228:	609a      	str	r2, [r3, #8]

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
 801722a:	687b      	ldr	r3, [r7, #4]
 801722c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 8017230:	2b00      	cmp	r3, #0
 8017232:	d008      	beq.n	8017246 <jinit_upsampler+0x4e>
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
 8017234:	687b      	ldr	r3, [r7, #4]
 8017236:	681b      	ldr	r3, [r3, #0]
 8017238:	221a      	movs	r2, #26
 801723a:	615a      	str	r2, [r3, #20]
 801723c:	687b      	ldr	r3, [r7, #4]
 801723e:	681b      	ldr	r3, [r3, #0]
 8017240:	681b      	ldr	r3, [r3, #0]
 8017242:	6878      	ldr	r0, [r7, #4]
 8017244:	4798      	blx	r3

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 8017246:	2300      	movs	r3, #0
 8017248:	627b      	str	r3, [r7, #36]	; 0x24
 801724a:	687b      	ldr	r3, [r7, #4]
 801724c:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8017250:	623b      	str	r3, [r7, #32]
 8017252:	e0cb      	b.n	80173ec <jinit_upsampler+0x1f4>
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 8017254:	6a3b      	ldr	r3, [r7, #32]
 8017256:	689b      	ldr	r3, [r3, #8]
 8017258:	6a3a      	ldr	r2, [r7, #32]
 801725a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801725c:	fb02 f203 	mul.w	r2, r2, r3
		 cinfo->min_DCT_h_scaled_size;
 8017260:	687b      	ldr	r3, [r7, #4]
 8017262:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
    h_in_group = (compptr->h_samp_factor * compptr->DCT_h_scaled_size) /
 8017266:	fb92 f3f3 	sdiv	r3, r2, r3
 801726a:	617b      	str	r3, [r7, #20]
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801726c:	6a3b      	ldr	r3, [r7, #32]
 801726e:	68db      	ldr	r3, [r3, #12]
 8017270:	6a3a      	ldr	r2, [r7, #32]
 8017272:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8017274:	fb02 f203 	mul.w	r2, r2, r3
		 cinfo->min_DCT_v_scaled_size;
 8017278:	687b      	ldr	r3, [r7, #4]
 801727a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
    v_in_group = (compptr->v_samp_factor * compptr->DCT_v_scaled_size) /
 801727e:	fb92 f3f3 	sdiv	r3, r2, r3
 8017282:	613b      	str	r3, [r7, #16]
    h_out_group = cinfo->max_h_samp_factor;
 8017284:	687b      	ldr	r3, [r7, #4]
 8017286:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 801728a:	60fb      	str	r3, [r7, #12]
    v_out_group = cinfo->max_v_samp_factor;
 801728c:	687b      	ldr	r3, [r7, #4]
 801728e:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8017292:	60bb      	str	r3, [r7, #8]
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
 8017294:	69ba      	ldr	r2, [r7, #24]
 8017296:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017298:	3318      	adds	r3, #24
 801729a:	009b      	lsls	r3, r3, #2
 801729c:	4413      	add	r3, r2
 801729e:	693a      	ldr	r2, [r7, #16]
 80172a0:	605a      	str	r2, [r3, #4]
    need_buffer = TRUE;
 80172a2:	2301      	movs	r3, #1
 80172a4:	61fb      	str	r3, [r7, #28]
    if (! compptr->component_needed) {
 80172a6:	6a3b      	ldr	r3, [r7, #32]
 80172a8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80172aa:	2b00      	cmp	r3, #0
 80172ac:	d109      	bne.n	80172c2 <jinit_upsampler+0xca>
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
 80172ae:	69ba      	ldr	r2, [r7, #24]
 80172b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80172b2:	330c      	adds	r3, #12
 80172b4:	009b      	lsls	r3, r3, #2
 80172b6:	4413      	add	r3, r2
 80172b8:	4a54      	ldr	r2, [pc, #336]	; (801740c <jinit_upsampler+0x214>)
 80172ba:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 80172bc:	2300      	movs	r3, #0
 80172be:	61fb      	str	r3, [r7, #28]
 80172c0:	e06f      	b.n	80173a2 <jinit_upsampler+0x1aa>
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
 80172c2:	697a      	ldr	r2, [r7, #20]
 80172c4:	68fb      	ldr	r3, [r7, #12]
 80172c6:	429a      	cmp	r2, r3
 80172c8:	d10d      	bne.n	80172e6 <jinit_upsampler+0xee>
 80172ca:	693a      	ldr	r2, [r7, #16]
 80172cc:	68bb      	ldr	r3, [r7, #8]
 80172ce:	429a      	cmp	r2, r3
 80172d0:	d109      	bne.n	80172e6 <jinit_upsampler+0xee>
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
 80172d2:	69ba      	ldr	r2, [r7, #24]
 80172d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80172d6:	330c      	adds	r3, #12
 80172d8:	009b      	lsls	r3, r3, #2
 80172da:	4413      	add	r3, r2
 80172dc:	4a4c      	ldr	r2, [pc, #304]	; (8017410 <jinit_upsampler+0x218>)
 80172de:	605a      	str	r2, [r3, #4]
      need_buffer = FALSE;
 80172e0:	2300      	movs	r3, #0
 80172e2:	61fb      	str	r3, [r7, #28]
 80172e4:	e05d      	b.n	80173a2 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 80172e6:	697b      	ldr	r3, [r7, #20]
 80172e8:	005b      	lsls	r3, r3, #1
 80172ea:	68fa      	ldr	r2, [r7, #12]
 80172ec:	429a      	cmp	r2, r3
 80172ee:	d10b      	bne.n	8017308 <jinit_upsampler+0x110>
 80172f0:	693a      	ldr	r2, [r7, #16]
 80172f2:	68bb      	ldr	r3, [r7, #8]
 80172f4:	429a      	cmp	r2, r3
 80172f6:	d107      	bne.n	8017308 <jinit_upsampler+0x110>
	       v_in_group == v_out_group) {
      /* Special case for 2h1v upsampling */
      upsample->methods[ci] = h2v1_upsample;
 80172f8:	69ba      	ldr	r2, [r7, #24]
 80172fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80172fc:	330c      	adds	r3, #12
 80172fe:	009b      	lsls	r3, r3, #2
 8017300:	4413      	add	r3, r2
 8017302:	4a44      	ldr	r2, [pc, #272]	; (8017414 <jinit_upsampler+0x21c>)
 8017304:	605a      	str	r2, [r3, #4]
 8017306:	e04c      	b.n	80173a2 <jinit_upsampler+0x1aa>
    } else if (h_in_group * 2 == h_out_group &&
 8017308:	697b      	ldr	r3, [r7, #20]
 801730a:	005b      	lsls	r3, r3, #1
 801730c:	68fa      	ldr	r2, [r7, #12]
 801730e:	429a      	cmp	r2, r3
 8017310:	d10c      	bne.n	801732c <jinit_upsampler+0x134>
	       v_in_group * 2 == v_out_group) {
 8017312:	693b      	ldr	r3, [r7, #16]
 8017314:	005b      	lsls	r3, r3, #1
    } else if (h_in_group * 2 == h_out_group &&
 8017316:	68ba      	ldr	r2, [r7, #8]
 8017318:	429a      	cmp	r2, r3
 801731a:	d107      	bne.n	801732c <jinit_upsampler+0x134>
      /* Special case for 2h2v upsampling */
      upsample->methods[ci] = h2v2_upsample;
 801731c:	69ba      	ldr	r2, [r7, #24]
 801731e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017320:	330c      	adds	r3, #12
 8017322:	009b      	lsls	r3, r3, #2
 8017324:	4413      	add	r3, r2
 8017326:	4a3c      	ldr	r2, [pc, #240]	; (8017418 <jinit_upsampler+0x220>)
 8017328:	605a      	str	r2, [r3, #4]
 801732a:	e03a      	b.n	80173a2 <jinit_upsampler+0x1aa>
    } else if ((h_out_group % h_in_group) == 0 &&
 801732c:	68fb      	ldr	r3, [r7, #12]
 801732e:	697a      	ldr	r2, [r7, #20]
 8017330:	fb93 f2f2 	sdiv	r2, r3, r2
 8017334:	6979      	ldr	r1, [r7, #20]
 8017336:	fb01 f202 	mul.w	r2, r1, r2
 801733a:	1a9b      	subs	r3, r3, r2
 801733c:	2b00      	cmp	r3, #0
 801733e:	d127      	bne.n	8017390 <jinit_upsampler+0x198>
	       (v_out_group % v_in_group) == 0) {
 8017340:	68bb      	ldr	r3, [r7, #8]
 8017342:	693a      	ldr	r2, [r7, #16]
 8017344:	fb93 f2f2 	sdiv	r2, r3, r2
 8017348:	6939      	ldr	r1, [r7, #16]
 801734a:	fb01 f202 	mul.w	r2, r1, r2
 801734e:	1a9b      	subs	r3, r3, r2
    } else if ((h_out_group % h_in_group) == 0 &&
 8017350:	2b00      	cmp	r3, #0
 8017352:	d11d      	bne.n	8017390 <jinit_upsampler+0x198>
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
 8017354:	69ba      	ldr	r2, [r7, #24]
 8017356:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017358:	330c      	adds	r3, #12
 801735a:	009b      	lsls	r3, r3, #2
 801735c:	4413      	add	r3, r2
 801735e:	4a2f      	ldr	r2, [pc, #188]	; (801741c <jinit_upsampler+0x224>)
 8017360:	605a      	str	r2, [r3, #4]
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
 8017362:	68fa      	ldr	r2, [r7, #12]
 8017364:	697b      	ldr	r3, [r7, #20]
 8017366:	fb92 f3f3 	sdiv	r3, r2, r3
 801736a:	b2d9      	uxtb	r1, r3
 801736c:	69ba      	ldr	r2, [r7, #24]
 801736e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017370:	4413      	add	r3, r2
 8017372:	338c      	adds	r3, #140	; 0x8c
 8017374:	460a      	mov	r2, r1
 8017376:	701a      	strb	r2, [r3, #0]
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
 8017378:	68ba      	ldr	r2, [r7, #8]
 801737a:	693b      	ldr	r3, [r7, #16]
 801737c:	fb92 f3f3 	sdiv	r3, r2, r3
 8017380:	b2d9      	uxtb	r1, r3
 8017382:	69ba      	ldr	r2, [r7, #24]
 8017384:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017386:	4413      	add	r3, r2
 8017388:	3396      	adds	r3, #150	; 0x96
 801738a:	460a      	mov	r2, r1
 801738c:	701a      	strb	r2, [r3, #0]
 801738e:	e008      	b.n	80173a2 <jinit_upsampler+0x1aa>
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
 8017390:	687b      	ldr	r3, [r7, #4]
 8017392:	681b      	ldr	r3, [r3, #0]
 8017394:	2227      	movs	r2, #39	; 0x27
 8017396:	615a      	str	r2, [r3, #20]
 8017398:	687b      	ldr	r3, [r7, #4]
 801739a:	681b      	ldr	r3, [r3, #0]
 801739c:	681b      	ldr	r3, [r3, #0]
 801739e:	6878      	ldr	r0, [r7, #4]
 80173a0:	4798      	blx	r3
    if (need_buffer) {
 80173a2:	69fb      	ldr	r3, [r7, #28]
 80173a4:	2b00      	cmp	r3, #0
 80173a6:	d01b      	beq.n	80173e0 <jinit_upsampler+0x1e8>
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 80173a8:	687b      	ldr	r3, [r7, #4]
 80173aa:	685b      	ldr	r3, [r3, #4]
 80173ac:	689c      	ldr	r4, [r3, #8]
	((j_common_ptr) cinfo, JPOOL_IMAGE,
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 80173ae:	687b      	ldr	r3, [r7, #4]
 80173b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80173b2:	461a      	mov	r2, r3
				(long) cinfo->max_h_samp_factor),
 80173b4:	687b      	ldr	r3, [r7, #4]
 80173b6:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
	 (JDIMENSION) jround_up((long) cinfo->output_width,
 80173ba:	4619      	mov	r1, r3
 80173bc:	4610      	mov	r0, r2
 80173be:	f010 fbbf 	bl	8027b40 <jround_up>
 80173c2:	4603      	mov	r3, r0
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 80173c4:	461a      	mov	r2, r3
	 (JDIMENSION) cinfo->max_v_samp_factor);
 80173c6:	687b      	ldr	r3, [r7, #4]
 80173c8:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
 80173cc:	2101      	movs	r1, #1
 80173ce:	6878      	ldr	r0, [r7, #4]
 80173d0:	47a0      	blx	r4
 80173d2:	4601      	mov	r1, r0
 80173d4:	69ba      	ldr	r2, [r7, #24]
 80173d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80173d8:	3302      	adds	r3, #2
 80173da:	009b      	lsls	r3, r3, #2
 80173dc:	4413      	add	r3, r2
 80173de:	6059      	str	r1, [r3, #4]
       ci++, compptr++) {
 80173e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80173e2:	3301      	adds	r3, #1
 80173e4:	627b      	str	r3, [r7, #36]	; 0x24
 80173e6:	6a3b      	ldr	r3, [r7, #32]
 80173e8:	3358      	adds	r3, #88	; 0x58
 80173ea:	623b      	str	r3, [r7, #32]
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 80173ec:	687b      	ldr	r3, [r7, #4]
 80173ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80173f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80173f2:	429a      	cmp	r2, r3
 80173f4:	f6ff af2e 	blt.w	8017254 <jinit_upsampler+0x5c>
    }
  }
}
 80173f8:	bf00      	nop
 80173fa:	bf00      	nop
 80173fc:	372c      	adds	r7, #44	; 0x2c
 80173fe:	46bd      	mov	sp, r7
 8017400:	bd90      	pop	{r4, r7, pc}
 8017402:	bf00      	nop
 8017404:	08016e85 	.word	0x08016e85
 8017408:	08016eb3 	.word	0x08016eb3
 801740c:	08017009 	.word	0x08017009
 8017410:	08016fe9 	.word	0x08016fe9
 8017414:	080170f3 	.word	0x080170f3
 8017418:	08017165 	.word	0x08017165
 801741c:	08017029 	.word	0x08017029

08017420 <error_exit>:
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
 8017420:	b580      	push	{r7, lr}
 8017422:	b082      	sub	sp, #8
 8017424:	af00      	add	r7, sp, #0
 8017426:	6078      	str	r0, [r7, #4]
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);
 8017428:	687b      	ldr	r3, [r7, #4]
 801742a:	681b      	ldr	r3, [r3, #0]
 801742c:	689b      	ldr	r3, [r3, #8]
 801742e:	6878      	ldr	r0, [r7, #4]
 8017430:	4798      	blx	r3

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);
 8017432:	6878      	ldr	r0, [r7, #4]
 8017434:	f7f4 fdcb 	bl	800bfce <jpeg_destroy>

  //exit(EXIT_FAILURE);
}
 8017438:	bf00      	nop
 801743a:	3708      	adds	r7, #8
 801743c:	46bd      	mov	sp, r7
 801743e:	bd80      	pop	{r7, pc}

08017440 <output_message>:
 * not just not use this routine.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
 8017440:	b580      	push	{r7, lr}
 8017442:	b0b4      	sub	sp, #208	; 0xd0
 8017444:	af00      	add	r7, sp, #0
 8017446:	6078      	str	r0, [r7, #4]
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);
 8017448:	687b      	ldr	r3, [r7, #4]
 801744a:	681b      	ldr	r3, [r3, #0]
 801744c:	68db      	ldr	r3, [r3, #12]
 801744e:	f107 0208 	add.w	r2, r7, #8
 8017452:	4611      	mov	r1, r2
 8017454:	6878      	ldr	r0, [r7, #4]
 8017456:	4798      	blx	r3
#else
  /* Send it to stderr, adding a newline */
//  fprintf(stderr, "%s\n", buffer);
//  printf( "%s\n", buffer);
#endif
}
 8017458:	bf00      	nop
 801745a:	37d0      	adds	r7, #208	; 0xd0
 801745c:	46bd      	mov	sp, r7
 801745e:	bd80      	pop	{r7, pc}

08017460 <emit_message>:
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
 8017460:	b580      	push	{r7, lr}
 8017462:	b084      	sub	sp, #16
 8017464:	af00      	add	r7, sp, #0
 8017466:	6078      	str	r0, [r7, #4]
 8017468:	6039      	str	r1, [r7, #0]
  struct jpeg_error_mgr * err = cinfo->err;
 801746a:	687b      	ldr	r3, [r7, #4]
 801746c:	681b      	ldr	r3, [r3, #0]
 801746e:	60fb      	str	r3, [r7, #12]

  if (msg_level < 0) {
 8017470:	683b      	ldr	r3, [r7, #0]
 8017472:	2b00      	cmp	r3, #0
 8017474:	da11      	bge.n	801749a <emit_message+0x3a>
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
 8017476:	68fb      	ldr	r3, [r7, #12]
 8017478:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801747a:	2b00      	cmp	r3, #0
 801747c:	d003      	beq.n	8017486 <emit_message+0x26>
 801747e:	68fb      	ldr	r3, [r7, #12]
 8017480:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017482:	2b02      	cmp	r3, #2
 8017484:	dd03      	ble.n	801748e <emit_message+0x2e>
      (*err->output_message) (cinfo);
 8017486:	68fb      	ldr	r3, [r7, #12]
 8017488:	689b      	ldr	r3, [r3, #8]
 801748a:	6878      	ldr	r0, [r7, #4]
 801748c:	4798      	blx	r3
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
 801748e:	68fb      	ldr	r3, [r7, #12]
 8017490:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8017492:	1c5a      	adds	r2, r3, #1
 8017494:	68fb      	ldr	r3, [r7, #12]
 8017496:	66da      	str	r2, [r3, #108]	; 0x6c
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}
 8017498:	e008      	b.n	80174ac <emit_message+0x4c>
    if (err->trace_level >= msg_level)
 801749a:	68fb      	ldr	r3, [r7, #12]
 801749c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801749e:	683a      	ldr	r2, [r7, #0]
 80174a0:	429a      	cmp	r2, r3
 80174a2:	dc03      	bgt.n	80174ac <emit_message+0x4c>
      (*err->output_message) (cinfo);
 80174a4:	68fb      	ldr	r3, [r7, #12]
 80174a6:	689b      	ldr	r3, [r3, #8]
 80174a8:	6878      	ldr	r0, [r7, #4]
 80174aa:	4798      	blx	r3
}
 80174ac:	bf00      	nop
 80174ae:	3710      	adds	r7, #16
 80174b0:	46bd      	mov	sp, r7
 80174b2:	bd80      	pop	{r7, pc}

080174b4 <format_message>:
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
 80174b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80174b6:	b091      	sub	sp, #68	; 0x44
 80174b8:	af06      	add	r7, sp, #24
 80174ba:	60f8      	str	r0, [r7, #12]
 80174bc:	60b9      	str	r1, [r7, #8]
  struct jpeg_error_mgr * err = cinfo->err;
 80174be:	68fb      	ldr	r3, [r7, #12]
 80174c0:	681b      	ldr	r3, [r3, #0]
 80174c2:	61bb      	str	r3, [r7, #24]
  int msg_code = err->msg_code;
 80174c4:	69bb      	ldr	r3, [r7, #24]
 80174c6:	695b      	ldr	r3, [r3, #20]
 80174c8:	617b      	str	r3, [r7, #20]
  const char * msgtext = NULL;
 80174ca:	2300      	movs	r3, #0
 80174cc:	627b      	str	r3, [r7, #36]	; 0x24
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
 80174ce:	697b      	ldr	r3, [r7, #20]
 80174d0:	2b00      	cmp	r3, #0
 80174d2:	dd0c      	ble.n	80174ee <format_message+0x3a>
 80174d4:	69bb      	ldr	r3, [r7, #24]
 80174d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80174d8:	697a      	ldr	r2, [r7, #20]
 80174da:	429a      	cmp	r2, r3
 80174dc:	dc07      	bgt.n	80174ee <format_message+0x3a>
    msgtext = err->jpeg_message_table[msg_code];
 80174de:	69bb      	ldr	r3, [r7, #24]
 80174e0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80174e2:	697b      	ldr	r3, [r7, #20]
 80174e4:	009b      	lsls	r3, r3, #2
 80174e6:	4413      	add	r3, r2
 80174e8:	681b      	ldr	r3, [r3, #0]
 80174ea:	627b      	str	r3, [r7, #36]	; 0x24
 80174ec:	e018      	b.n	8017520 <format_message+0x6c>
  } else if (err->addon_message_table != NULL &&
 80174ee:	69bb      	ldr	r3, [r7, #24]
 80174f0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80174f2:	2b00      	cmp	r3, #0
 80174f4:	d014      	beq.n	8017520 <format_message+0x6c>
	     msg_code >= err->first_addon_message &&
 80174f6:	69bb      	ldr	r3, [r7, #24]
 80174f8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  } else if (err->addon_message_table != NULL &&
 80174fa:	697a      	ldr	r2, [r7, #20]
 80174fc:	429a      	cmp	r2, r3
 80174fe:	db0f      	blt.n	8017520 <format_message+0x6c>
	     msg_code <= err->last_addon_message) {
 8017500:	69bb      	ldr	r3, [r7, #24]
 8017502:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
	     msg_code >= err->first_addon_message &&
 8017506:	697a      	ldr	r2, [r7, #20]
 8017508:	429a      	cmp	r2, r3
 801750a:	dc09      	bgt.n	8017520 <format_message+0x6c>
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
 801750c:	69bb      	ldr	r3, [r7, #24]
 801750e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8017510:	69bb      	ldr	r3, [r7, #24]
 8017512:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8017514:	6979      	ldr	r1, [r7, #20]
 8017516:	1acb      	subs	r3, r1, r3
 8017518:	009b      	lsls	r3, r3, #2
 801751a:	4413      	add	r3, r2
 801751c:	681b      	ldr	r3, [r3, #0]
 801751e:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
 8017520:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017522:	2b00      	cmp	r3, #0
 8017524:	d106      	bne.n	8017534 <format_message+0x80>
    err->msg_parm.i[0] = msg_code;
 8017526:	69bb      	ldr	r3, [r7, #24]
 8017528:	697a      	ldr	r2, [r7, #20]
 801752a:	619a      	str	r2, [r3, #24]
    msgtext = err->jpeg_message_table[0];
 801752c:	69bb      	ldr	r3, [r7, #24]
 801752e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8017530:	681b      	ldr	r3, [r3, #0]
 8017532:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
 8017534:	2300      	movs	r3, #0
 8017536:	61fb      	str	r3, [r7, #28]
  msgptr = msgtext;
 8017538:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801753a:	623b      	str	r3, [r7, #32]
  while ((ch = *msgptr++) != '\0') {
 801753c:	e009      	b.n	8017552 <format_message+0x9e>
    if (ch == '%') {
 801753e:	7cfb      	ldrb	r3, [r7, #19]
 8017540:	2b25      	cmp	r3, #37	; 0x25
 8017542:	d106      	bne.n	8017552 <format_message+0x9e>
      if (*msgptr == 's') isstring = TRUE;
 8017544:	6a3b      	ldr	r3, [r7, #32]
 8017546:	781b      	ldrb	r3, [r3, #0]
 8017548:	2b73      	cmp	r3, #115	; 0x73
 801754a:	d10b      	bne.n	8017564 <format_message+0xb0>
 801754c:	2301      	movs	r3, #1
 801754e:	61fb      	str	r3, [r7, #28]
      break;
 8017550:	e008      	b.n	8017564 <format_message+0xb0>
  while ((ch = *msgptr++) != '\0') {
 8017552:	6a3b      	ldr	r3, [r7, #32]
 8017554:	1c5a      	adds	r2, r3, #1
 8017556:	623a      	str	r2, [r7, #32]
 8017558:	781b      	ldrb	r3, [r3, #0]
 801755a:	74fb      	strb	r3, [r7, #19]
 801755c:	7cfb      	ldrb	r3, [r7, #19]
 801755e:	2b00      	cmp	r3, #0
 8017560:	d1ed      	bne.n	801753e <format_message+0x8a>
 8017562:	e000      	b.n	8017566 <format_message+0xb2>
      break;
 8017564:	bf00      	nop
    }
  }

  /* Format the message into the passed buffer */
  if (isstring)
 8017566:	69fb      	ldr	r3, [r7, #28]
 8017568:	2b00      	cmp	r3, #0
 801756a:	d007      	beq.n	801757c <format_message+0xc8>
    sprintf(buffer, msgtext, err->msg_parm.s);
 801756c:	69bb      	ldr	r3, [r7, #24]
 801756e:	3318      	adds	r3, #24
 8017570:	461a      	mov	r2, r3
 8017572:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017574:	68b8      	ldr	r0, [r7, #8]
 8017576:	f010 ff45 	bl	8028404 <siprintf>
    sprintf(buffer, msgtext,
	    err->msg_parm.i[0], err->msg_parm.i[1],
	    err->msg_parm.i[2], err->msg_parm.i[3],
	    err->msg_parm.i[4], err->msg_parm.i[5],
	    err->msg_parm.i[6], err->msg_parm.i[7]);
}
 801757a:	e01c      	b.n	80175b6 <format_message+0x102>
    sprintf(buffer, msgtext,
 801757c:	69bb      	ldr	r3, [r7, #24]
 801757e:	699e      	ldr	r6, [r3, #24]
 8017580:	69bb      	ldr	r3, [r7, #24]
 8017582:	69db      	ldr	r3, [r3, #28]
 8017584:	607b      	str	r3, [r7, #4]
 8017586:	69bb      	ldr	r3, [r7, #24]
 8017588:	6a1b      	ldr	r3, [r3, #32]
 801758a:	69ba      	ldr	r2, [r7, #24]
 801758c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801758e:	69b9      	ldr	r1, [r7, #24]
 8017590:	6a89      	ldr	r1, [r1, #40]	; 0x28
 8017592:	69b8      	ldr	r0, [r7, #24]
 8017594:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8017596:	69bc      	ldr	r4, [r7, #24]
 8017598:	6b24      	ldr	r4, [r4, #48]	; 0x30
 801759a:	69bd      	ldr	r5, [r7, #24]
 801759c:	6b6d      	ldr	r5, [r5, #52]	; 0x34
 801759e:	9505      	str	r5, [sp, #20]
 80175a0:	9404      	str	r4, [sp, #16]
 80175a2:	9003      	str	r0, [sp, #12]
 80175a4:	9102      	str	r1, [sp, #8]
 80175a6:	9201      	str	r2, [sp, #4]
 80175a8:	9300      	str	r3, [sp, #0]
 80175aa:	687b      	ldr	r3, [r7, #4]
 80175ac:	4632      	mov	r2, r6
 80175ae:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80175b0:	68b8      	ldr	r0, [r7, #8]
 80175b2:	f010 ff27 	bl	8028404 <siprintf>
}
 80175b6:	bf00      	nop
 80175b8:	372c      	adds	r7, #44	; 0x2c
 80175ba:	46bd      	mov	sp, r7
 80175bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080175be <reset_error_mgr>:
 * this method if it has additional error processing state.
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
 80175be:	b480      	push	{r7}
 80175c0:	b083      	sub	sp, #12
 80175c2:	af00      	add	r7, sp, #0
 80175c4:	6078      	str	r0, [r7, #4]
  cinfo->err->num_warnings = 0;
 80175c6:	687b      	ldr	r3, [r7, #4]
 80175c8:	681b      	ldr	r3, [r3, #0]
 80175ca:	2200      	movs	r2, #0
 80175cc:	66da      	str	r2, [r3, #108]	; 0x6c
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
 80175ce:	687b      	ldr	r3, [r7, #4]
 80175d0:	681b      	ldr	r3, [r3, #0]
 80175d2:	2200      	movs	r2, #0
 80175d4:	615a      	str	r2, [r3, #20]
}
 80175d6:	bf00      	nop
 80175d8:	370c      	adds	r7, #12
 80175da:	46bd      	mov	sp, r7
 80175dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80175e0:	4770      	bx	lr
	...

080175e4 <jpeg_std_error>:
 * after which the application may override some of the methods.
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{
 80175e4:	b480      	push	{r7}
 80175e6:	b083      	sub	sp, #12
 80175e8:	af00      	add	r7, sp, #0
 80175ea:	6078      	str	r0, [r7, #4]
  err->error_exit = error_exit;
 80175ec:	687b      	ldr	r3, [r7, #4]
 80175ee:	4a17      	ldr	r2, [pc, #92]	; (801764c <jpeg_std_error+0x68>)
 80175f0:	601a      	str	r2, [r3, #0]
  err->emit_message = emit_message;
 80175f2:	687b      	ldr	r3, [r7, #4]
 80175f4:	4a16      	ldr	r2, [pc, #88]	; (8017650 <jpeg_std_error+0x6c>)
 80175f6:	605a      	str	r2, [r3, #4]
  err->output_message = output_message;
 80175f8:	687b      	ldr	r3, [r7, #4]
 80175fa:	4a16      	ldr	r2, [pc, #88]	; (8017654 <jpeg_std_error+0x70>)
 80175fc:	609a      	str	r2, [r3, #8]
  err->format_message = format_message;
 80175fe:	687b      	ldr	r3, [r7, #4]
 8017600:	4a15      	ldr	r2, [pc, #84]	; (8017658 <jpeg_std_error+0x74>)
 8017602:	60da      	str	r2, [r3, #12]
  err->reset_error_mgr = reset_error_mgr;
 8017604:	687b      	ldr	r3, [r7, #4]
 8017606:	4a15      	ldr	r2, [pc, #84]	; (801765c <jpeg_std_error+0x78>)
 8017608:	611a      	str	r2, [r3, #16]

  err->trace_level = 0;		/* default = no tracing */
 801760a:	687b      	ldr	r3, [r7, #4]
 801760c:	2200      	movs	r2, #0
 801760e:	669a      	str	r2, [r3, #104]	; 0x68
  err->num_warnings = 0;	/* no warnings emitted yet */
 8017610:	687b      	ldr	r3, [r7, #4]
 8017612:	2200      	movs	r2, #0
 8017614:	66da      	str	r2, [r3, #108]	; 0x6c
  err->msg_code = 0;		/* may be useful as a flag for "no error" */
 8017616:	687b      	ldr	r3, [r7, #4]
 8017618:	2200      	movs	r2, #0
 801761a:	615a      	str	r2, [r3, #20]

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
 801761c:	687b      	ldr	r3, [r7, #4]
 801761e:	4a10      	ldr	r2, [pc, #64]	; (8017660 <jpeg_std_error+0x7c>)
 8017620:	671a      	str	r2, [r3, #112]	; 0x70
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
 8017622:	687b      	ldr	r3, [r7, #4]
 8017624:	227e      	movs	r2, #126	; 0x7e
 8017626:	675a      	str	r2, [r3, #116]	; 0x74

  err->addon_message_table = NULL;
 8017628:	687b      	ldr	r3, [r7, #4]
 801762a:	2200      	movs	r2, #0
 801762c:	679a      	str	r2, [r3, #120]	; 0x78
  err->first_addon_message = 0;	/* for safety */
 801762e:	687b      	ldr	r3, [r7, #4]
 8017630:	2200      	movs	r2, #0
 8017632:	67da      	str	r2, [r3, #124]	; 0x7c
  err->last_addon_message = 0;
 8017634:	687b      	ldr	r3, [r7, #4]
 8017636:	2200      	movs	r2, #0
 8017638:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  return err;
 801763c:	687b      	ldr	r3, [r7, #4]
}
 801763e:	4618      	mov	r0, r3
 8017640:	370c      	adds	r7, #12
 8017642:	46bd      	mov	sp, r7
 8017644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017648:	4770      	bx	lr
 801764a:	bf00      	nop
 801764c:	08017421 	.word	0x08017421
 8017650:	08017461 	.word	0x08017461
 8017654:	08017441 	.word	0x08017441
 8017658:	080174b5 	.word	0x080174b5
 801765c:	080175bf 	.word	0x080175bf
 8017660:	0802a94c 	.word	0x0802a94c

08017664 <jpeg_idct_float>:

GLOBAL(void)
jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8017664:	b490      	push	{r4, r7}
 8017666:	b0dc      	sub	sp, #368	; 0x170
 8017668:	af00      	add	r7, sp, #0
 801766a:	f107 040c 	add.w	r4, r7, #12
 801766e:	6020      	str	r0, [r4, #0]
 8017670:	f107 0008 	add.w	r0, r7, #8
 8017674:	6001      	str	r1, [r0, #0]
 8017676:	1d39      	adds	r1, r7, #4
 8017678:	600a      	str	r2, [r1, #0]
 801767a:	463a      	mov	r2, r7
 801767c:	6013      	str	r3, [r2, #0]
  FAST_FLOAT z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  FLOAT_MULT_TYPE * quantptr;
  FAST_FLOAT * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 801767e:	f107 030c 	add.w	r3, r7, #12
 8017682:	681b      	ldr	r3, [r3, #0]
 8017684:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8017688:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
  int ctr;
  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801768c:	1d3b      	adds	r3, r7, #4
 801768e:	681b      	ldr	r3, [r3, #0]
 8017690:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
 8017694:	f107 0308 	add.w	r3, r7, #8
 8017698:	681b      	ldr	r3, [r3, #0]
 801769a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801769c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
  wsptr = workspace;
 80176a0:	f107 0310 	add.w	r3, r7, #16
 80176a4:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 80176a8:	2308      	movs	r3, #8
 80176aa:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 80176ae:	e230      	b.n	8017b12 <jpeg_idct_float+0x4ae>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 80176b0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176b4:	3310      	adds	r3, #16
 80176b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80176ba:	2b00      	cmp	r3, #0
 80176bc:	d178      	bne.n	80177b0 <jpeg_idct_float+0x14c>
 80176be:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176c2:	3320      	adds	r3, #32
 80176c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80176c8:	2b00      	cmp	r3, #0
 80176ca:	d171      	bne.n	80177b0 <jpeg_idct_float+0x14c>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 80176cc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176d0:	3330      	adds	r3, #48	; 0x30
 80176d2:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 80176d6:	2b00      	cmp	r3, #0
 80176d8:	d16a      	bne.n	80177b0 <jpeg_idct_float+0x14c>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 80176da:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176de:	3340      	adds	r3, #64	; 0x40
 80176e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80176e4:	2b00      	cmp	r3, #0
 80176e6:	d163      	bne.n	80177b0 <jpeg_idct_float+0x14c>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 80176e8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176ec:	3350      	adds	r3, #80	; 0x50
 80176ee:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 80176f2:	2b00      	cmp	r3, #0
 80176f4:	d15c      	bne.n	80177b0 <jpeg_idct_float+0x14c>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 80176f6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80176fa:	3360      	adds	r3, #96	; 0x60
 80176fc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017700:	2b00      	cmp	r3, #0
 8017702:	d155      	bne.n	80177b0 <jpeg_idct_float+0x14c>
	inptr[DCTSIZE*7] == 0) {
 8017704:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017708:	3370      	adds	r3, #112	; 0x70
 801770a:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801770e:	2b00      	cmp	r3, #0
 8017710:	d14e      	bne.n	80177b0 <jpeg_idct_float+0x14c>
      /* AC terms all zero */
      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8017712:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017716:	f9b3 3000 	ldrsh.w	r3, [r3]
 801771a:	ee07 3a90 	vmov	s15, r3
 801771e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8017722:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8017726:	edd3 7a00 	vldr	s15, [r3]
 801772a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801772e:	edc7 7a44 	vstr	s15, [r7, #272]	; 0x110
      
      wsptr[DCTSIZE*0] = dcval;
 8017732:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017736:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 801773a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801773c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017740:	3320      	adds	r3, #32
 8017742:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8017746:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 8017748:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801774c:	3340      	adds	r3, #64	; 0x40
 801774e:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8017752:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 8017754:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017758:	3360      	adds	r3, #96	; 0x60
 801775a:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 801775e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 8017760:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017764:	3380      	adds	r3, #128	; 0x80
 8017766:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 801776a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801776c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017770:	33a0      	adds	r3, #160	; 0xa0
 8017772:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8017776:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 8017778:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801777c:	33c0      	adds	r3, #192	; 0xc0
 801777e:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8017782:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 8017784:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017788:	33e0      	adds	r3, #224	; 0xe0
 801778a:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 801778e:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 8017790:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017794:	3302      	adds	r3, #2
 8017796:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
      quantptr++;
 801779a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801779e:	3304      	adds	r3, #4
 80177a0:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
      wsptr++;
 80177a4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80177a8:	3304      	adds	r3, #4
 80177aa:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
      continue;
 80177ae:	e1ab      	b.n	8017b08 <jpeg_idct_float+0x4a4>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80177b0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80177b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80177b8:	ee07 3a90 	vmov	s15, r3
 80177bc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80177c0:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80177c4:	edd3 7a00 	vldr	s15, [r3]
 80177c8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80177cc:	edc7 7a50 	vstr	s15, [r7, #320]	; 0x140
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80177d0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80177d4:	3320      	adds	r3, #32
 80177d6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80177da:	ee07 3a90 	vmov	s15, r3
 80177de:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80177e2:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80177e6:	3340      	adds	r3, #64	; 0x40
 80177e8:	edd3 7a00 	vldr	s15, [r3]
 80177ec:	ee67 7a27 	vmul.f32	s15, s14, s15
 80177f0:	edc7 7a4e 	vstr	s15, [r7, #312]	; 0x138
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80177f4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80177f8:	3340      	adds	r3, #64	; 0x40
 80177fa:	f9b3 3000 	ldrsh.w	r3, [r3]
 80177fe:	ee07 3a90 	vmov	s15, r3
 8017802:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8017806:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801780a:	3380      	adds	r3, #128	; 0x80
 801780c:	edd3 7a00 	vldr	s15, [r3]
 8017810:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017814:	edc7 7a4d 	vstr	s15, [r7, #308]	; 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8017818:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801781c:	3360      	adds	r3, #96	; 0x60
 801781e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017822:	ee07 3a90 	vmov	s15, r3
 8017826:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801782a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801782e:	33c0      	adds	r3, #192	; 0xc0
 8017830:	edd3 7a00 	vldr	s15, [r3]
 8017834:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017838:	edc7 7a4f 	vstr	s15, [r7, #316]	; 0x13c

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801783c:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017840:	edd7 7a4d 	vldr	s15, [r7, #308]	; 0x134
 8017844:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017848:	edc7 7a54 	vstr	s15, [r7, #336]	; 0x150
    tmp11 = tmp0 - tmp2;
 801784c:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017850:	edd7 7a4d 	vldr	s15, [r7, #308]	; 0x134
 8017854:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017858:	edc7 7a53 	vstr	s15, [r7, #332]	; 0x14c

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801785c:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017860:	edd7 7a4f 	vldr	s15, [r7, #316]	; 0x13c
 8017864:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017868:	edc7 7a52 	vstr	s15, [r7, #328]	; 0x148
    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */
 801786c:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017870:	edd7 7a4f 	vldr	s15, [r7, #316]	; 0x13c
 8017874:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017878:	ed9f 7aad 	vldr	s14, [pc, #692]	; 8017b30 <jpeg_idct_float+0x4cc>
 801787c:	ee27 7a87 	vmul.f32	s14, s15, s14
 8017880:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 8017884:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017888:	edc7 7a51 	vstr	s15, [r7, #324]	; 0x144

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 801788c:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8017890:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 8017894:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017898:	edc7 7a50 	vstr	s15, [r7, #320]	; 0x140
    tmp3 = tmp10 - tmp13;
 801789c:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 80178a0:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 80178a4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80178a8:	edc7 7a4f 	vstr	s15, [r7, #316]	; 0x13c
    tmp1 = tmp11 + tmp12;
 80178ac:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 80178b0:	edd7 7a51 	vldr	s15, [r7, #324]	; 0x144
 80178b4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80178b8:	edc7 7a4e 	vstr	s15, [r7, #312]	; 0x138
    tmp2 = tmp11 - tmp12;
 80178bc:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 80178c0:	edd7 7a51 	vldr	s15, [r7, #324]	; 0x144
 80178c4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80178c8:	edc7 7a4d 	vstr	s15, [r7, #308]	; 0x134
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80178cc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80178d0:	3310      	adds	r3, #16
 80178d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80178d6:	ee07 3a90 	vmov	s15, r3
 80178da:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80178de:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80178e2:	3320      	adds	r3, #32
 80178e4:	edd3 7a00 	vldr	s15, [r3]
 80178e8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80178ec:	edc7 7a45 	vstr	s15, [r7, #276]	; 0x114
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80178f0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80178f4:	3330      	adds	r3, #48	; 0x30
 80178f6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80178fa:	ee07 3a90 	vmov	s15, r3
 80178fe:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8017902:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8017906:	3360      	adds	r3, #96	; 0x60
 8017908:	edd3 7a00 	vldr	s15, [r3]
 801790c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017910:	edc7 7a46 	vstr	s15, [r7, #280]	; 0x118
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8017914:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017918:	3350      	adds	r3, #80	; 0x50
 801791a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801791e:	ee07 3a90 	vmov	s15, r3
 8017922:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8017926:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801792a:	33a0      	adds	r3, #160	; 0xa0
 801792c:	edd3 7a00 	vldr	s15, [r3]
 8017930:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017934:	edc7 7a47 	vstr	s15, [r7, #284]	; 0x11c
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8017938:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801793c:	3370      	adds	r3, #112	; 0x70
 801793e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017942:	ee07 3a90 	vmov	s15, r3
 8017946:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801794a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801794e:	33e0      	adds	r3, #224	; 0xe0
 8017950:	edd3 7a00 	vldr	s15, [r3]
 8017954:	ee67 7a27 	vmul.f32	s15, s14, s15
 8017958:	edc7 7a48 	vstr	s15, [r7, #288]	; 0x120

    z13 = tmp6 + tmp5;		/* phase 6 */
 801795c:	ed97 7a47 	vldr	s14, [r7, #284]	; 0x11c
 8017960:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017964:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017968:	edc7 7a4c 	vstr	s15, [r7, #304]	; 0x130
    z10 = tmp6 - tmp5;
 801796c:	ed97 7a47 	vldr	s14, [r7, #284]	; 0x11c
 8017970:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017974:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017978:	edc7 7a4b 	vstr	s15, [r7, #300]	; 0x12c
    z11 = tmp4 + tmp7;
 801797c:	ed97 7a45 	vldr	s14, [r7, #276]	; 0x114
 8017980:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017984:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017988:	edc7 7a4a 	vstr	s15, [r7, #296]	; 0x128
    z12 = tmp4 - tmp7;
 801798c:	ed97 7a45 	vldr	s14, [r7, #276]	; 0x114
 8017990:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017994:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017998:	edc7 7a49 	vstr	s15, [r7, #292]	; 0x124

    tmp7 = z11 + z13;		/* phase 5 */
 801799c:	ed97 7a4a 	vldr	s14, [r7, #296]	; 0x128
 80179a0:	edd7 7a4c 	vldr	s15, [r7, #304]	; 0x130
 80179a4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80179a8:	edc7 7a48 	vstr	s15, [r7, #288]	; 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */
 80179ac:	ed97 7a4a 	vldr	s14, [r7, #296]	; 0x128
 80179b0:	edd7 7a4c 	vldr	s15, [r7, #304]	; 0x130
 80179b4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80179b8:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 8017b30 <jpeg_idct_float+0x4cc>
 80179bc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80179c0:	edc7 7a53 	vstr	s15, [r7, #332]	; 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 80179c4:	ed97 7a4b 	vldr	s14, [r7, #300]	; 0x12c
 80179c8:	edd7 7a49 	vldr	s15, [r7, #292]	; 0x124
 80179cc:	ee77 7a27 	vadd.f32	s15, s14, s15
 80179d0:	ed9f 7a58 	vldr	s14, [pc, #352]	; 8017b34 <jpeg_idct_float+0x4d0>
 80179d4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80179d8:	edc7 7a55 	vstr	s15, [r7, #340]	; 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 80179dc:	edd7 7a49 	vldr	s15, [r7, #292]	; 0x124
 80179e0:	ed9f 7a55 	vldr	s14, [pc, #340]	; 8017b38 <jpeg_idct_float+0x4d4>
 80179e4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80179e8:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 80179ec:	ee77 7a67 	vsub.f32	s15, s14, s15
 80179f0:	edc7 7a54 	vstr	s15, [r7, #336]	; 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 80179f4:	edd7 7a4b 	vldr	s15, [r7, #300]	; 0x12c
 80179f8:	ed9f 7a50 	vldr	s14, [pc, #320]	; 8017b3c <jpeg_idct_float+0x4d8>
 80179fc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017a00:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 8017a04:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a08:	edc7 7a51 	vstr	s15, [r7, #324]	; 0x144

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 8017a0c:	ed97 7a51 	vldr	s14, [r7, #324]	; 0x144
 8017a10:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017a14:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a18:	edc7 7a47 	vstr	s15, [r7, #284]	; 0x11c
    tmp5 = tmp11 - tmp6;
 8017a1c:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 8017a20:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017a24:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a28:	edc7 7a46 	vstr	s15, [r7, #280]	; 0x118
    tmp4 = tmp10 - tmp5;
 8017a2c:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8017a30:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017a34:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a38:	edc7 7a45 	vstr	s15, [r7, #276]	; 0x114

    wsptr[DCTSIZE*0] = tmp0 + tmp7;
 8017a3c:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017a40:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017a44:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017a48:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017a4c:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*7] = tmp0 - tmp7;
 8017a50:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017a54:	33e0      	adds	r3, #224	; 0xe0
 8017a56:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017a5a:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017a5e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a62:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*1] = tmp1 + tmp6;
 8017a66:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017a6a:	3320      	adds	r3, #32
 8017a6c:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017a70:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017a74:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017a78:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*6] = tmp1 - tmp6;
 8017a7c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017a80:	33c0      	adds	r3, #192	; 0xc0
 8017a82:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017a86:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017a8a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017a8e:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*2] = tmp2 + tmp5;
 8017a92:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017a96:	3340      	adds	r3, #64	; 0x40
 8017a98:	ed97 7a4d 	vldr	s14, [r7, #308]	; 0x134
 8017a9c:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017aa0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017aa4:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*5] = tmp2 - tmp5;
 8017aa8:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017aac:	33a0      	adds	r3, #160	; 0xa0
 8017aae:	ed97 7a4d 	vldr	s14, [r7, #308]	; 0x134
 8017ab2:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017ab6:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017aba:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*3] = tmp3 + tmp4;
 8017abe:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017ac2:	3360      	adds	r3, #96	; 0x60
 8017ac4:	ed97 7a4f 	vldr	s14, [r7, #316]	; 0x13c
 8017ac8:	edd7 7a45 	vldr	s15, [r7, #276]	; 0x114
 8017acc:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017ad0:	edc3 7a00 	vstr	s15, [r3]
    wsptr[DCTSIZE*4] = tmp3 - tmp4;
 8017ad4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017ad8:	3380      	adds	r3, #128	; 0x80
 8017ada:	ed97 7a4f 	vldr	s14, [r7, #316]	; 0x13c
 8017ade:	edd7 7a45 	vldr	s15, [r7, #276]	; 0x114
 8017ae2:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017ae6:	edc3 7a00 	vstr	s15, [r3]

    inptr++;			/* advance pointers to next column */
 8017aea:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017aee:	3302      	adds	r3, #2
 8017af0:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    quantptr++;
 8017af4:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8017af8:	3304      	adds	r3, #4
 8017afa:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    wsptr++;
 8017afe:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017b02:	3304      	adds	r3, #4
 8017b04:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 8017b08:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8017b0c:	3b01      	subs	r3, #1
 8017b0e:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 8017b12:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8017b16:	2b00      	cmp	r3, #0
 8017b18:	f73f adca 	bgt.w	80176b0 <jpeg_idct_float+0x4c>
  }
  
  /* Pass 2: process rows from work array, store into output array. */

  wsptr = workspace;
 8017b1c:	f107 0310 	add.w	r3, r7, #16
 8017b20:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 8017b24:	2300      	movs	r3, #0
 8017b26:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 8017b2a:	e1aa      	b.n	8017e82 <jpeg_idct_float+0x81e>
 8017b2c:	43008000 	.word	0x43008000
 8017b30:	3fb504f3 	.word	0x3fb504f3
 8017b34:	3fec835e 	.word	0x3fec835e
 8017b38:	3f8a8bd4 	.word	0x3f8a8bd4
 8017b3c:	40273d75 	.word	0x40273d75
    outptr = output_buf[ctr] + output_col;
 8017b40:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8017b44:	009b      	lsls	r3, r3, #2
 8017b46:	463a      	mov	r2, r7
 8017b48:	6812      	ldr	r2, [r2, #0]
 8017b4a:	4413      	add	r3, r2
 8017b4c:	681a      	ldr	r2, [r3, #0]
 8017b4e:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8017b52:	4413      	add	r3, r2
 8017b54:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
     */
    
    /* Even part */

    /* Apply signed->unsigned and prepare float->int conversion */
    z5 = wsptr[0] + ((FAST_FLOAT) CENTERJSAMPLE + (FAST_FLOAT) 0.5);
 8017b58:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017b5c:	edd3 7a00 	vldr	s15, [r3]
 8017b60:	ed1f 7a0e 	vldr	s14, [pc, #-56]	; 8017b2c <jpeg_idct_float+0x4c8>
 8017b64:	ee77 7a87 	vadd.f32	s15, s15, s14
 8017b68:	edc7 7a55 	vstr	s15, [r7, #340]	; 0x154
    tmp10 = z5 + wsptr[4];
 8017b6c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017b70:	3310      	adds	r3, #16
 8017b72:	edd3 7a00 	vldr	s15, [r3]
 8017b76:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 8017b7a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017b7e:	edc7 7a54 	vstr	s15, [r7, #336]	; 0x150
    tmp11 = z5 - wsptr[4];
 8017b82:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017b86:	3310      	adds	r3, #16
 8017b88:	edd3 7a00 	vldr	s15, [r3]
 8017b8c:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 8017b90:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017b94:	edc7 7a53 	vstr	s15, [r7, #332]	; 0x14c

    tmp13 = wsptr[2] + wsptr[6];
 8017b98:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017b9c:	3308      	adds	r3, #8
 8017b9e:	ed93 7a00 	vldr	s14, [r3]
 8017ba2:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017ba6:	3318      	adds	r3, #24
 8017ba8:	edd3 7a00 	vldr	s15, [r3]
 8017bac:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017bb0:	edc7 7a52 	vstr	s15, [r7, #328]	; 0x148
    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;
 8017bb4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017bb8:	3308      	adds	r3, #8
 8017bba:	ed93 7a00 	vldr	s14, [r3]
 8017bbe:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017bc2:	3318      	adds	r3, #24
 8017bc4:	edd3 7a00 	vldr	s15, [r3]
 8017bc8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017bcc:	ed1f 7a28 	vldr	s14, [pc, #-160]	; 8017b30 <jpeg_idct_float+0x4cc>
 8017bd0:	ee27 7a87 	vmul.f32	s14, s15, s14
 8017bd4:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 8017bd8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017bdc:	edc7 7a51 	vstr	s15, [r7, #324]	; 0x144

    tmp0 = tmp10 + tmp13;
 8017be0:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8017be4:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 8017be8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017bec:	edc7 7a50 	vstr	s15, [r7, #320]	; 0x140
    tmp3 = tmp10 - tmp13;
 8017bf0:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8017bf4:	edd7 7a52 	vldr	s15, [r7, #328]	; 0x148
 8017bf8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017bfc:	edc7 7a4f 	vstr	s15, [r7, #316]	; 0x13c
    tmp1 = tmp11 + tmp12;
 8017c00:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 8017c04:	edd7 7a51 	vldr	s15, [r7, #324]	; 0x144
 8017c08:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017c0c:	edc7 7a4e 	vstr	s15, [r7, #312]	; 0x138
    tmp2 = tmp11 - tmp12;
 8017c10:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 8017c14:	edd7 7a51 	vldr	s15, [r7, #324]	; 0x144
 8017c18:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017c1c:	edc7 7a4d 	vstr	s15, [r7, #308]	; 0x134

    /* Odd part */

    z13 = wsptr[5] + wsptr[3];
 8017c20:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c24:	3314      	adds	r3, #20
 8017c26:	ed93 7a00 	vldr	s14, [r3]
 8017c2a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c2e:	330c      	adds	r3, #12
 8017c30:	edd3 7a00 	vldr	s15, [r3]
 8017c34:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017c38:	edc7 7a4c 	vstr	s15, [r7, #304]	; 0x130
    z10 = wsptr[5] - wsptr[3];
 8017c3c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c40:	3314      	adds	r3, #20
 8017c42:	ed93 7a00 	vldr	s14, [r3]
 8017c46:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c4a:	330c      	adds	r3, #12
 8017c4c:	edd3 7a00 	vldr	s15, [r3]
 8017c50:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017c54:	edc7 7a4b 	vstr	s15, [r7, #300]	; 0x12c
    z11 = wsptr[1] + wsptr[7];
 8017c58:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c5c:	3304      	adds	r3, #4
 8017c5e:	ed93 7a00 	vldr	s14, [r3]
 8017c62:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c66:	331c      	adds	r3, #28
 8017c68:	edd3 7a00 	vldr	s15, [r3]
 8017c6c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017c70:	edc7 7a4a 	vstr	s15, [r7, #296]	; 0x128
    z12 = wsptr[1] - wsptr[7];
 8017c74:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c78:	3304      	adds	r3, #4
 8017c7a:	ed93 7a00 	vldr	s14, [r3]
 8017c7e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017c82:	331c      	adds	r3, #28
 8017c84:	edd3 7a00 	vldr	s15, [r3]
 8017c88:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017c8c:	edc7 7a49 	vstr	s15, [r7, #292]	; 0x124

    tmp7 = z11 + z13;
 8017c90:	ed97 7a4a 	vldr	s14, [r7, #296]	; 0x128
 8017c94:	edd7 7a4c 	vldr	s15, [r7, #304]	; 0x130
 8017c98:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017c9c:	edc7 7a48 	vstr	s15, [r7, #288]	; 0x120
    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);
 8017ca0:	ed97 7a4a 	vldr	s14, [r7, #296]	; 0x128
 8017ca4:	edd7 7a4c 	vldr	s15, [r7, #304]	; 0x130
 8017ca8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017cac:	ed1f 7a60 	vldr	s14, [pc, #-384]	; 8017b30 <jpeg_idct_float+0x4cc>
 8017cb0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017cb4:	edc7 7a53 	vstr	s15, [r7, #332]	; 0x14c

    z5 = (z10 + z12) * ((FAST_FLOAT) 1.847759065); /* 2*c2 */
 8017cb8:	ed97 7a4b 	vldr	s14, [r7, #300]	; 0x12c
 8017cbc:	edd7 7a49 	vldr	s15, [r7, #292]	; 0x124
 8017cc0:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017cc4:	ed1f 7a65 	vldr	s14, [pc, #-404]	; 8017b34 <jpeg_idct_float+0x4d0>
 8017cc8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017ccc:	edc7 7a55 	vstr	s15, [r7, #340]	; 0x154
    tmp10 = z5 - z12 * ((FAST_FLOAT) 1.082392200); /* 2*(c2-c6) */
 8017cd0:	edd7 7a49 	vldr	s15, [r7, #292]	; 0x124
 8017cd4:	ed1f 7a68 	vldr	s14, [pc, #-416]	; 8017b38 <jpeg_idct_float+0x4d4>
 8017cd8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017cdc:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 8017ce0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017ce4:	edc7 7a54 	vstr	s15, [r7, #336]	; 0x150
    tmp12 = z5 - z10 * ((FAST_FLOAT) 2.613125930); /* 2*(c2+c6) */
 8017ce8:	edd7 7a4b 	vldr	s15, [r7, #300]	; 0x12c
 8017cec:	ed1f 7a6d 	vldr	s14, [pc, #-436]	; 8017b3c <jpeg_idct_float+0x4d8>
 8017cf0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8017cf4:	ed97 7a55 	vldr	s14, [r7, #340]	; 0x154
 8017cf8:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017cfc:	edc7 7a51 	vstr	s15, [r7, #324]	; 0x144

    tmp6 = tmp12 - tmp7;
 8017d00:	ed97 7a51 	vldr	s14, [r7, #324]	; 0x144
 8017d04:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017d08:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017d0c:	edc7 7a47 	vstr	s15, [r7, #284]	; 0x11c
    tmp5 = tmp11 - tmp6;
 8017d10:	ed97 7a53 	vldr	s14, [r7, #332]	; 0x14c
 8017d14:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017d18:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017d1c:	edc7 7a46 	vstr	s15, [r7, #280]	; 0x118
    tmp4 = tmp10 - tmp5;
 8017d20:	ed97 7a54 	vldr	s14, [r7, #336]	; 0x150
 8017d24:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017d28:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017d2c:	edc7 7a45 	vstr	s15, [r7, #276]	; 0x114

    /* Final output stage: float->int conversion and range-limit */

    outptr[0] = range_limit[((int) (tmp0 + tmp7)) & RANGE_MASK];
 8017d30:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017d34:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017d38:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017d3c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017d40:	ee17 3a90 	vmov	r3, s15
 8017d44:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017d48:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017d4c:	4413      	add	r3, r2
 8017d4e:	781a      	ldrb	r2, [r3, #0]
 8017d50:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017d54:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[((int) (tmp0 - tmp7)) & RANGE_MASK];
 8017d56:	ed97 7a50 	vldr	s14, [r7, #320]	; 0x140
 8017d5a:	edd7 7a48 	vldr	s15, [r7, #288]	; 0x120
 8017d5e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017d62:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017d66:	ee17 3a90 	vmov	r3, s15
 8017d6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017d6e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017d72:	441a      	add	r2, r3
 8017d74:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017d78:	3307      	adds	r3, #7
 8017d7a:	7812      	ldrb	r2, [r2, #0]
 8017d7c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[((int) (tmp1 + tmp6)) & RANGE_MASK];
 8017d7e:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017d82:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017d86:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017d8a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017d8e:	ee17 3a90 	vmov	r3, s15
 8017d92:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017d96:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017d9a:	441a      	add	r2, r3
 8017d9c:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017da0:	3301      	adds	r3, #1
 8017da2:	7812      	ldrb	r2, [r2, #0]
 8017da4:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[((int) (tmp1 - tmp6)) & RANGE_MASK];
 8017da6:	ed97 7a4e 	vldr	s14, [r7, #312]	; 0x138
 8017daa:	edd7 7a47 	vldr	s15, [r7, #284]	; 0x11c
 8017dae:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017db2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017db6:	ee17 3a90 	vmov	r3, s15
 8017dba:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017dbe:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017dc2:	441a      	add	r2, r3
 8017dc4:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017dc8:	3306      	adds	r3, #6
 8017dca:	7812      	ldrb	r2, [r2, #0]
 8017dcc:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[((int) (tmp2 + tmp5)) & RANGE_MASK];
 8017dce:	ed97 7a4d 	vldr	s14, [r7, #308]	; 0x134
 8017dd2:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017dd6:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017dda:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017dde:	ee17 3a90 	vmov	r3, s15
 8017de2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017de6:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017dea:	441a      	add	r2, r3
 8017dec:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017df0:	3302      	adds	r3, #2
 8017df2:	7812      	ldrb	r2, [r2, #0]
 8017df4:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[((int) (tmp2 - tmp5)) & RANGE_MASK];
 8017df6:	ed97 7a4d 	vldr	s14, [r7, #308]	; 0x134
 8017dfa:	edd7 7a46 	vldr	s15, [r7, #280]	; 0x118
 8017dfe:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017e02:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017e06:	ee17 3a90 	vmov	r3, s15
 8017e0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017e0e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017e12:	441a      	add	r2, r3
 8017e14:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017e18:	3305      	adds	r3, #5
 8017e1a:	7812      	ldrb	r2, [r2, #0]
 8017e1c:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[((int) (tmp3 + tmp4)) & RANGE_MASK];
 8017e1e:	ed97 7a4f 	vldr	s14, [r7, #316]	; 0x13c
 8017e22:	edd7 7a45 	vldr	s15, [r7, #276]	; 0x114
 8017e26:	ee77 7a27 	vadd.f32	s15, s14, s15
 8017e2a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017e2e:	ee17 3a90 	vmov	r3, s15
 8017e32:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017e36:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017e3a:	441a      	add	r2, r3
 8017e3c:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017e40:	3303      	adds	r3, #3
 8017e42:	7812      	ldrb	r2, [r2, #0]
 8017e44:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[((int) (tmp3 - tmp4)) & RANGE_MASK];
 8017e46:	ed97 7a4f 	vldr	s14, [r7, #316]	; 0x13c
 8017e4a:	edd7 7a45 	vldr	s15, [r7, #276]	; 0x114
 8017e4e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017e52:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017e56:	ee17 3a90 	vmov	r3, s15
 8017e5a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8017e5e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8017e62:	441a      	add	r2, r3
 8017e64:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8017e68:	3304      	adds	r3, #4
 8017e6a:	7812      	ldrb	r2, [r2, #0]
 8017e6c:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 8017e6e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8017e72:	3320      	adds	r3, #32
 8017e74:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 8017e78:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8017e7c:	3301      	adds	r3, #1
 8017e7e:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 8017e82:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8017e86:	2b07      	cmp	r3, #7
 8017e88:	f77f ae5a 	ble.w	8017b40 <jpeg_idct_float+0x4dc>
  }
}
 8017e8c:	bf00      	nop
 8017e8e:	bf00      	nop
 8017e90:	f507 77b8 	add.w	r7, r7, #368	; 0x170
 8017e94:	46bd      	mov	sp, r7
 8017e96:	bc90      	pop	{r4, r7}
 8017e98:	4770      	bx	lr
 8017e9a:	bf00      	nop

08017e9c <jpeg_idct_ifast>:

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8017e9c:	b490      	push	{r4, r7}
 8017e9e:	b0de      	sub	sp, #376	; 0x178
 8017ea0:	af00      	add	r7, sp, #0
 8017ea2:	f107 040c 	add.w	r4, r7, #12
 8017ea6:	6020      	str	r0, [r4, #0]
 8017ea8:	f107 0008 	add.w	r0, r7, #8
 8017eac:	6001      	str	r1, [r0, #0]
 8017eae:	1d39      	adds	r1, r7, #4
 8017eb0:	600a      	str	r2, [r1, #0]
 8017eb2:	463a      	mov	r2, r7
 8017eb4:	6013      	str	r3, [r2, #0]
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  IFAST_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8017eb6:	f107 030c 	add.w	r3, r7, #12
 8017eba:	681b      	ldr	r3, [r3, #0]
 8017ebc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8017ec0:	3380      	adds	r3, #128	; 0x80
 8017ec2:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
  SHIFT_TEMPS			/* for DESCALE */
  ISHIFT_TEMPS			/* for IDESCALE */

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8017ec6:	1d3b      	adds	r3, r7, #4
 8017ec8:	681b      	ldr	r3, [r3, #0]
 8017eca:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
 8017ece:	f107 0308 	add.w	r3, r7, #8
 8017ed2:	681b      	ldr	r3, [r3, #0]
 8017ed4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8017ed6:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
  wsptr = workspace;
 8017eda:	f107 0314 	add.w	r3, r7, #20
 8017ede:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 8017ee2:	2308      	movs	r3, #8
 8017ee4:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 8017ee8:	e1ec      	b.n	80182c4 <jpeg_idct_ifast+0x428>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8017eea:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017eee:	3310      	adds	r3, #16
 8017ef0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017ef4:	2b00      	cmp	r3, #0
 8017ef6:	d174      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
 8017ef8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017efc:	3320      	adds	r3, #32
 8017efe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017f02:	2b00      	cmp	r3, #0
 8017f04:	d16d      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8017f06:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f0a:	3330      	adds	r3, #48	; 0x30
 8017f0c:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8017f10:	2b00      	cmp	r3, #0
 8017f12:	d166      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8017f14:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f18:	3340      	adds	r3, #64	; 0x40
 8017f1a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017f1e:	2b00      	cmp	r3, #0
 8017f20:	d15f      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8017f22:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f26:	3350      	adds	r3, #80	; 0x50
 8017f28:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8017f2c:	2b00      	cmp	r3, #0
 8017f2e:	d158      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8017f30:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f34:	3360      	adds	r3, #96	; 0x60
 8017f36:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017f3a:	2b00      	cmp	r3, #0
 8017f3c:	d151      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
	inptr[DCTSIZE*7] == 0) {
 8017f3e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f42:	3370      	adds	r3, #112	; 0x70
 8017f44:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8017f48:	2b00      	cmp	r3, #0
 8017f4a:	d14a      	bne.n	8017fe2 <jpeg_idct_ifast+0x146>
      /* AC terms all zero */
      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8017f4c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017f50:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017f54:	461a      	mov	r2, r3
 8017f56:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8017f5a:	681b      	ldr	r3, [r3, #0]
 8017f5c:	fb03 f302 	mul.w	r3, r3, r2
 8017f60:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

      wsptr[DCTSIZE*0] = dcval;
 8017f64:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017f68:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017f6c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 8017f6e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017f72:	3320      	adds	r3, #32
 8017f74:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017f78:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 8017f7a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017f7e:	3340      	adds	r3, #64	; 0x40
 8017f80:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017f84:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 8017f86:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017f8a:	3360      	adds	r3, #96	; 0x60
 8017f8c:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017f90:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 8017f92:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017f96:	3380      	adds	r3, #128	; 0x80
 8017f98:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017f9c:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 8017f9e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017fa2:	33a0      	adds	r3, #160	; 0xa0
 8017fa4:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017fa8:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 8017faa:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017fae:	33c0      	adds	r3, #192	; 0xc0
 8017fb0:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017fb4:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 8017fb6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017fba:	33e0      	adds	r3, #224	; 0xe0
 8017fbc:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8017fc0:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 8017fc2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017fc6:	3302      	adds	r3, #2
 8017fc8:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
      quantptr++;
 8017fcc:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8017fd0:	3304      	adds	r3, #4
 8017fd2:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
      wsptr++;
 8017fd6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8017fda:	3304      	adds	r3, #4
 8017fdc:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
      continue;
 8017fe0:	e16b      	b.n	80182ba <jpeg_idct_ifast+0x41e>
    }
    
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8017fe2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017fe6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017fea:	461a      	mov	r2, r3
 8017fec:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8017ff0:	681b      	ldr	r3, [r3, #0]
 8017ff2:	fb03 f302 	mul.w	r3, r3, r2
 8017ff6:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8017ffa:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8017ffe:	3320      	adds	r3, #32
 8018000:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018004:	461a      	mov	r2, r3
 8018006:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801800a:	3340      	adds	r3, #64	; 0x40
 801800c:	681b      	ldr	r3, [r3, #0]
 801800e:	fb03 f302 	mul.w	r3, r3, r2
 8018012:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8018016:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801801a:	3340      	adds	r3, #64	; 0x40
 801801c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018020:	461a      	mov	r2, r3
 8018022:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8018026:	3380      	adds	r3, #128	; 0x80
 8018028:	681b      	ldr	r3, [r3, #0]
 801802a:	fb03 f302 	mul.w	r3, r3, r2
 801802e:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8018032:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8018036:	3360      	adds	r3, #96	; 0x60
 8018038:	f9b3 3000 	ldrsh.w	r3, [r3]
 801803c:	461a      	mov	r2, r3
 801803e:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8018042:	33c0      	adds	r3, #192	; 0xc0
 8018044:	681b      	ldr	r3, [r3, #0]
 8018046:	fb03 f302 	mul.w	r3, r3, r2
 801804a:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    tmp10 = tmp0 + tmp2;	/* phase 3 */
 801804e:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 8018052:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018056:	4413      	add	r3, r2
 8018058:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp11 = tmp0 - tmp2;
 801805c:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 8018060:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018064:	1ad3      	subs	r3, r2, r3
 8018066:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
 801806a:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801806e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8018072:	4413      	add	r3, r2
 8018074:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
 8018078:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801807c:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8018080:	1ad3      	subs	r3, r2, r3
 8018082:	f44f 72b5 	mov.w	r2, #362	; 0x16a
 8018086:	fb02 f303 	mul.w	r3, r2, r3
 801808a:	121a      	asrs	r2, r3, #8
 801808c:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018090:	1ad3      	subs	r3, r2, r3
 8018092:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    tmp0 = tmp10 + tmp13;	/* phase 2 */
 8018096:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801809a:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801809e:	4413      	add	r3, r2
 80180a0:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp3 = tmp10 - tmp13;
 80180a4:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 80180a8:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 80180ac:	1ad3      	subs	r3, r2, r3
 80180ae:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    tmp1 = tmp11 + tmp12;
 80180b2:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80180b6:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 80180ba:	4413      	add	r3, r2
 80180bc:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    tmp2 = tmp11 - tmp12;
 80180c0:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80180c4:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 80180c8:	1ad3      	subs	r3, r2, r3
 80180ca:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    
    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80180ce:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 80180d2:	3310      	adds	r3, #16
 80180d4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80180d8:	461a      	mov	r2, r3
 80180da:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80180de:	3320      	adds	r3, #32
 80180e0:	681b      	ldr	r3, [r3, #0]
 80180e2:	fb03 f302 	mul.w	r3, r3, r2
 80180e6:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80180ea:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 80180ee:	3330      	adds	r3, #48	; 0x30
 80180f0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80180f4:	461a      	mov	r2, r3
 80180f6:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80180fa:	3360      	adds	r3, #96	; 0x60
 80180fc:	681b      	ldr	r3, [r3, #0]
 80180fe:	fb03 f302 	mul.w	r3, r3, r2
 8018102:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8018106:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801810a:	3350      	adds	r3, #80	; 0x50
 801810c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018110:	461a      	mov	r2, r3
 8018112:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8018116:	33a0      	adds	r3, #160	; 0xa0
 8018118:	681b      	ldr	r3, [r3, #0]
 801811a:	fb03 f302 	mul.w	r3, r3, r2
 801811e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8018122:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8018126:	3370      	adds	r3, #112	; 0x70
 8018128:	f9b3 3000 	ldrsh.w	r3, [r3]
 801812c:	461a      	mov	r2, r3
 801812e:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8018132:	33e0      	adds	r3, #224	; 0xe0
 8018134:	681b      	ldr	r3, [r3, #0]
 8018136:	fb03 f302 	mul.w	r3, r3, r2
 801813a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128

    z13 = tmp6 + tmp5;		/* phase 6 */
 801813e:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018142:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8018146:	4413      	add	r3, r2
 8018148:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z10 = tmp6 - tmp5;
 801814c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018150:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8018154:	1ad3      	subs	r3, r2, r3
 8018156:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z11 = tmp4 + tmp7;
 801815a:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801815e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018162:	4413      	add	r3, r2
 8018164:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    z12 = tmp4 - tmp7;
 8018168:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801816c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018170:	1ad3      	subs	r3, r2, r3
 8018172:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 8018176:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 801817a:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801817e:	4413      	add	r3, r2
 8018180:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 8018184:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8018188:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801818c:	1ad3      	subs	r3, r2, r3
 801818e:	f44f 72b5 	mov.w	r2, #362	; 0x16a
 8018192:	fb02 f303 	mul.w	r3, r2, r3
 8018196:	121b      	asrs	r3, r3, #8
 8018198:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 801819c:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80181a0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80181a4:	4413      	add	r3, r2
 80181a6:	f240 12d9 	movw	r2, #473	; 0x1d9
 80181aa:	fb02 f303 	mul.w	r3, r2, r3
 80181ae:	121b      	asrs	r3, r3, #8
 80181b0:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 80181b4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80181b8:	f240 1215 	movw	r2, #277	; 0x115
 80181bc:	fb02 f303 	mul.w	r3, r2, r3
 80181c0:	121a      	asrs	r2, r3, #8
 80181c2:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80181c6:	1ad3      	subs	r3, r2, r3
 80181c8:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 80181cc:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80181d0:	f46f 7227 	mvn.w	r2, #668	; 0x29c
 80181d4:	fb02 f303 	mul.w	r3, r2, r3
 80181d8:	121b      	asrs	r3, r3, #8
 80181da:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 80181de:	4413      	add	r3, r2
 80181e0:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 80181e4:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 80181e8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80181ec:	1ad3      	subs	r3, r2, r3
 80181ee:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp5 = tmp11 - tmp6;
 80181f2:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80181f6:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80181fa:	1ad3      	subs	r3, r2, r3
 80181fc:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp4 = tmp10 + tmp5;
 8018200:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 8018204:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8018208:	4413      	add	r3, r2
 801820a:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
 801820e:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 8018212:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018216:	441a      	add	r2, r3
 8018218:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801821c:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
 801821e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018222:	33e0      	adds	r3, #224	; 0xe0
 8018224:	f8d7 1148 	ldr.w	r1, [r7, #328]	; 0x148
 8018228:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801822c:	1a8a      	subs	r2, r1, r2
 801822e:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
 8018230:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018234:	3320      	adds	r3, #32
 8018236:	f8d7 1140 	ldr.w	r1, [r7, #320]	; 0x140
 801823a:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 801823e:	440a      	add	r2, r1
 8018240:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
 8018242:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018246:	33c0      	adds	r3, #192	; 0xc0
 8018248:	f8d7 1140 	ldr.w	r1, [r7, #320]	; 0x140
 801824c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018250:	1a8a      	subs	r2, r1, r2
 8018252:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
 8018254:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018258:	3340      	adds	r3, #64	; 0x40
 801825a:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
 801825e:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018262:	440a      	add	r2, r1
 8018264:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
 8018266:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801826a:	33a0      	adds	r3, #160	; 0xa0
 801826c:	f8d7 113c 	ldr.w	r1, [r7, #316]	; 0x13c
 8018270:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018274:	1a8a      	subs	r2, r1, r2
 8018276:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
 8018278:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801827c:	3380      	adds	r3, #128	; 0x80
 801827e:	f8d7 1144 	ldr.w	r1, [r7, #324]	; 0x144
 8018282:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018286:	440a      	add	r2, r1
 8018288:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
 801828a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801828e:	3360      	adds	r3, #96	; 0x60
 8018290:	f8d7 1144 	ldr.w	r1, [r7, #324]	; 0x144
 8018294:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018298:	1a8a      	subs	r2, r1, r2
 801829a:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 801829c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 80182a0:	3302      	adds	r3, #2
 80182a2:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
    quantptr++;
 80182a6:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80182aa:	3304      	adds	r3, #4
 80182ac:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
    wsptr++;
 80182b0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80182b4:	3304      	adds	r3, #4
 80182b6:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 80182ba:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80182be:	3b01      	subs	r3, #1
 80182c0:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 80182c4:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80182c8:	2b00      	cmp	r3, #0
 80182ca:	f73f ae0e 	bgt.w	8017eea <jpeg_idct_ifast+0x4e>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 80182ce:	f107 0314 	add.w	r3, r7, #20
 80182d2:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 80182d6:	2300      	movs	r3, #0
 80182d8:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 80182dc:	e1c5      	b.n	801866a <jpeg_idct_ifast+0x7ce>
    outptr = output_buf[ctr] + output_col;
 80182de:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80182e2:	009b      	lsls	r3, r3, #2
 80182e4:	463a      	mov	r2, r7
 80182e6:	6812      	ldr	r2, [r2, #0]
 80182e8:	4413      	add	r3, r2
 80182ea:	681a      	ldr	r2, [r3, #0]
 80182ec:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 80182f0:	4413      	add	r3, r2
 80182f2:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */
    
#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 80182f6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80182fa:	3304      	adds	r3, #4
 80182fc:	681b      	ldr	r3, [r3, #0]
 80182fe:	2b00      	cmp	r3, #0
 8018300:	d164      	bne.n	80183cc <jpeg_idct_ifast+0x530>
 8018302:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018306:	3308      	adds	r3, #8
 8018308:	681b      	ldr	r3, [r3, #0]
 801830a:	2b00      	cmp	r3, #0
 801830c:	d15e      	bne.n	80183cc <jpeg_idct_ifast+0x530>
 801830e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018312:	330c      	adds	r3, #12
 8018314:	681b      	ldr	r3, [r3, #0]
 8018316:	2b00      	cmp	r3, #0
 8018318:	d158      	bne.n	80183cc <jpeg_idct_ifast+0x530>
 801831a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801831e:	3310      	adds	r3, #16
 8018320:	681b      	ldr	r3, [r3, #0]
 8018322:	2b00      	cmp	r3, #0
 8018324:	d152      	bne.n	80183cc <jpeg_idct_ifast+0x530>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 8018326:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801832a:	3314      	adds	r3, #20
 801832c:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 801832e:	2b00      	cmp	r3, #0
 8018330:	d14c      	bne.n	80183cc <jpeg_idct_ifast+0x530>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 8018332:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018336:	3318      	adds	r3, #24
 8018338:	681b      	ldr	r3, [r3, #0]
 801833a:	2b00      	cmp	r3, #0
 801833c:	d146      	bne.n	80183cc <jpeg_idct_ifast+0x530>
 801833e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018342:	331c      	adds	r3, #28
 8018344:	681b      	ldr	r3, [r3, #0]
 8018346:	2b00      	cmp	r3, #0
 8018348:	d140      	bne.n	80183cc <jpeg_idct_ifast+0x530>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 801834a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801834e:	681b      	ldr	r3, [r3, #0]
 8018350:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 8018352:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 8018356:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801835a:	4413      	add	r3, r2
 801835c:	781b      	ldrb	r3, [r3, #0]
 801835e:	f887 315f 	strb.w	r3, [r7, #351]	; 0x15f
      
      outptr[0] = dcval;
 8018362:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018366:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 801836a:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 801836c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018370:	3301      	adds	r3, #1
 8018372:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 8018376:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 8018378:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801837c:	3302      	adds	r3, #2
 801837e:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 8018382:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 8018384:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018388:	3303      	adds	r3, #3
 801838a:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 801838e:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 8018390:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018394:	3304      	adds	r3, #4
 8018396:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 801839a:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 801839c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80183a0:	3305      	adds	r3, #5
 80183a2:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 80183a6:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 80183a8:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80183ac:	3306      	adds	r3, #6
 80183ae:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 80183b2:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 80183b4:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80183b8:	3307      	adds	r3, #7
 80183ba:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 80183be:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 80183c0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183c4:	3320      	adds	r3, #32
 80183c6:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
      continue;
 80183ca:	e149      	b.n	8018660 <jpeg_idct_ifast+0x7c4>
    }
#endif
    
    /* Even part */

    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
 80183cc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183d0:	681a      	ldr	r2, [r3, #0]
 80183d2:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183d6:	3310      	adds	r3, #16
 80183d8:	681b      	ldr	r3, [r3, #0]
 80183da:	4413      	add	r3, r2
 80183dc:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
 80183e0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183e4:	681a      	ldr	r2, [r3, #0]
 80183e6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183ea:	3310      	adds	r3, #16
 80183ec:	681b      	ldr	r3, [r3, #0]
 80183ee:	1ad3      	subs	r3, r2, r3
 80183f0:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
 80183f4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80183f8:	3308      	adds	r3, #8
 80183fa:	681a      	ldr	r2, [r3, #0]
 80183fc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018400:	3318      	adds	r3, #24
 8018402:	681b      	ldr	r3, [r3, #0]
 8018404:	4413      	add	r3, r2
 8018406:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
 801840a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801840e:	3308      	adds	r3, #8
 8018410:	681a      	ldr	r2, [r3, #0]
 8018412:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018416:	3318      	adds	r3, #24
 8018418:	681b      	ldr	r3, [r3, #0]
 801841a:	1ad3      	subs	r3, r2, r3
 801841c:	f44f 72b5 	mov.w	r2, #362	; 0x16a
 8018420:	fb02 f303 	mul.w	r3, r2, r3
 8018424:	121a      	asrs	r2, r3, #8
 8018426:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801842a:	1ad3      	subs	r3, r2, r3
 801842c:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
	    - tmp13;

    tmp0 = tmp10 + tmp13;
 8018430:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 8018434:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018438:	4413      	add	r3, r2
 801843a:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp3 = tmp10 - tmp13;
 801843e:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 8018442:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018446:	1ad3      	subs	r3, r2, r3
 8018448:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    tmp1 = tmp11 + tmp12;
 801844c:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 8018450:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8018454:	4413      	add	r3, r2
 8018456:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    tmp2 = tmp11 - tmp12;
 801845a:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801845e:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8018462:	1ad3      	subs	r3, r2, r3
 8018464:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    /* Odd part */

    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
 8018468:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801846c:	3314      	adds	r3, #20
 801846e:	681a      	ldr	r2, [r3, #0]
 8018470:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018474:	330c      	adds	r3, #12
 8018476:	681b      	ldr	r3, [r3, #0]
 8018478:	4413      	add	r3, r2
 801847a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
 801847e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018482:	3314      	adds	r3, #20
 8018484:	681a      	ldr	r2, [r3, #0]
 8018486:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801848a:	330c      	adds	r3, #12
 801848c:	681b      	ldr	r3, [r3, #0]
 801848e:	1ad3      	subs	r3, r2, r3
 8018490:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
 8018494:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8018498:	3304      	adds	r3, #4
 801849a:	681a      	ldr	r2, [r3, #0]
 801849c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80184a0:	331c      	adds	r3, #28
 80184a2:	681b      	ldr	r3, [r3, #0]
 80184a4:	4413      	add	r3, r2
 80184a6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
 80184aa:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80184ae:	3304      	adds	r3, #4
 80184b0:	681a      	ldr	r2, [r3, #0]
 80184b2:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80184b6:	331c      	adds	r3, #28
 80184b8:	681b      	ldr	r3, [r3, #0]
 80184ba:	1ad3      	subs	r3, r2, r3
 80184bc:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c

    tmp7 = z11 + z13;		/* phase 5 */
 80184c0:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 80184c4:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80184c8:	4413      	add	r3, r2
 80184ca:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
 80184ce:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 80184d2:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80184d6:	1ad3      	subs	r3, r2, r3
 80184d8:	f44f 72b5 	mov.w	r2, #362	; 0x16a
 80184dc:	fb02 f303 	mul.w	r3, r2, r3
 80184e0:	121b      	asrs	r3, r3, #8
 80184e2:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
 80184e6:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80184ea:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80184ee:	4413      	add	r3, r2
 80184f0:	f240 12d9 	movw	r2, #473	; 0x1d9
 80184f4:	fb02 f303 	mul.w	r3, r2, r3
 80184f8:	121b      	asrs	r3, r3, #8
 80184fa:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
 80184fe:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018502:	f240 1215 	movw	r2, #277	; 0x115
 8018506:	fb02 f303 	mul.w	r3, r2, r3
 801850a:	121a      	asrs	r2, r3, #8
 801850c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8018510:	1ad3      	subs	r3, r2, r3
 8018512:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
 8018516:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801851a:	f46f 7227 	mvn.w	r2, #668	; 0x29c
 801851e:	fb02 f303 	mul.w	r3, r2, r3
 8018522:	121b      	asrs	r3, r3, #8
 8018524:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8018528:	4413      	add	r3, r2
 801852a:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    tmp6 = tmp12 - tmp7;	/* phase 2 */
 801852e:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018532:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018536:	1ad3      	subs	r3, r2, r3
 8018538:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp5 = tmp11 - tmp6;
 801853c:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 8018540:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8018544:	1ad3      	subs	r3, r2, r3
 8018546:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp4 = tmp10 + tmp5;
 801854a:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801854e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8018552:	4413      	add	r3, r2
 8018554:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 8018558:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801855c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018560:	4413      	add	r3, r2
 8018562:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 8018564:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
 8018568:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801856c:	4413      	add	r3, r2
 801856e:	781a      	ldrb	r2, [r3, #0]
 8018570:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018574:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 8018576:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801857a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801857e:	1ad3      	subs	r3, r2, r3
 8018580:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 8018582:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
 8018586:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801858a:	441a      	add	r2, r3
 801858c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018590:	3307      	adds	r3, #7
 8018592:	7812      	ldrb	r2, [r2, #0]
 8018594:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 8018596:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801859a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 801859e:	4413      	add	r3, r2
 80185a0:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 80185a2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
 80185a6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80185aa:	441a      	add	r2, r3
 80185ac:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80185b0:	3301      	adds	r3, #1
 80185b2:	7812      	ldrb	r2, [r2, #0]
 80185b4:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 80185b6:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 80185ba:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80185be:	1ad3      	subs	r3, r2, r3
 80185c0:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 80185c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
 80185c6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80185ca:	441a      	add	r2, r3
 80185cc:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80185d0:	3306      	adds	r3, #6
 80185d2:	7812      	ldrb	r2, [r2, #0]
 80185d4:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 80185d6:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80185da:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80185de:	4413      	add	r3, r2
 80185e0:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 80185e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
 80185e6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80185ea:	441a      	add	r2, r3
 80185ec:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80185f0:	3302      	adds	r3, #2
 80185f2:	7812      	ldrb	r2, [r2, #0]
 80185f4:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 80185f6:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80185fa:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80185fe:	1ad3      	subs	r3, r2, r3
 8018600:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 8018602:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
 8018606:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801860a:	441a      	add	r2, r3
 801860c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018610:	3305      	adds	r3, #5
 8018612:	7812      	ldrb	r2, [r2, #0]
 8018614:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 8018616:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801861a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 801861e:	4413      	add	r3, r2
 8018620:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 8018622:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
 8018626:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801862a:	441a      	add	r2, r3
 801862c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018630:	3304      	adds	r3, #4
 8018632:	7812      	ldrb	r2, [r2, #0]
 8018634:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 8018636:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801863a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 801863e:	1ad3      	subs	r3, r2, r3
 8018640:	115b      	asrs	r3, r3, #5
			    & RANGE_MASK];
 8018642:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
 8018646:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801864a:	441a      	add	r2, r3
 801864c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8018650:	3303      	adds	r3, #3
 8018652:	7812      	ldrb	r2, [r2, #0]
 8018654:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 8018656:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801865a:	3320      	adds	r3, #32
 801865c:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 8018660:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8018664:	3301      	adds	r3, #1
 8018666:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 801866a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801866e:	2b07      	cmp	r3, #7
 8018670:	f77f ae35 	ble.w	80182de <jpeg_idct_ifast+0x442>
  }
}
 8018674:	bf00      	nop
 8018676:	bf00      	nop
 8018678:	f507 77bc 	add.w	r7, r7, #376	; 0x178
 801867c:	46bd      	mov	sp, r7
 801867e:	bc90      	pop	{r4, r7}
 8018680:	4770      	bx	lr
	...

08018684 <jpeg_idct_islow>:

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8018684:	b490      	push	{r4, r7}
 8018686:	b0d8      	sub	sp, #352	; 0x160
 8018688:	af00      	add	r7, sp, #0
 801868a:	f107 040c 	add.w	r4, r7, #12
 801868e:	6020      	str	r0, [r4, #0]
 8018690:	f107 0008 	add.w	r0, r7, #8
 8018694:	6001      	str	r1, [r0, #0]
 8018696:	1d39      	adds	r1, r7, #4
 8018698:	600a      	str	r2, [r1, #0]
 801869a:	463a      	mov	r2, r7
 801869c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801869e:	f107 030c 	add.w	r3, r7, #12
 80186a2:	681b      	ldr	r3, [r3, #0]
 80186a4:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 80186a8:	3380      	adds	r3, #128	; 0x80
 80186aa:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 80186ae:	1d3b      	adds	r3, r7, #4
 80186b0:	681b      	ldr	r3, [r3, #0]
 80186b2:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80186b6:	f107 0308 	add.w	r3, r7, #8
 80186ba:	681b      	ldr	r3, [r3, #0]
 80186bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80186be:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
  wsptr = workspace;
 80186c2:	f107 0314 	add.w	r3, r7, #20
 80186c6:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 80186ca:	2308      	movs	r3, #8
 80186cc:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
 80186d0:	e238      	b.n	8018b44 <jpeg_idct_islow+0x4c0>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 80186d2:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80186d6:	3310      	adds	r3, #16
 80186d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80186dc:	2b00      	cmp	r3, #0
 80186de:	d175      	bne.n	80187cc <jpeg_idct_islow+0x148>
 80186e0:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80186e4:	3320      	adds	r3, #32
 80186e6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80186ea:	2b00      	cmp	r3, #0
 80186ec:	d16e      	bne.n	80187cc <jpeg_idct_islow+0x148>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 80186ee:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80186f2:	3330      	adds	r3, #48	; 0x30
 80186f4:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 80186f8:	2b00      	cmp	r3, #0
 80186fa:	d167      	bne.n	80187cc <jpeg_idct_islow+0x148>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 80186fc:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018700:	3340      	adds	r3, #64	; 0x40
 8018702:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018706:	2b00      	cmp	r3, #0
 8018708:	d160      	bne.n	80187cc <jpeg_idct_islow+0x148>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801870a:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801870e:	3350      	adds	r3, #80	; 0x50
 8018710:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8018714:	2b00      	cmp	r3, #0
 8018716:	d159      	bne.n	80187cc <jpeg_idct_islow+0x148>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8018718:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801871c:	3360      	adds	r3, #96	; 0x60
 801871e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018722:	2b00      	cmp	r3, #0
 8018724:	d152      	bne.n	80187cc <jpeg_idct_islow+0x148>
	inptr[DCTSIZE*7] == 0) {
 8018726:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801872a:	3370      	adds	r3, #112	; 0x70
 801872c:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8018730:	2b00      	cmp	r3, #0
 8018732:	d14b      	bne.n	80187cc <jpeg_idct_islow+0x148>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 8018734:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018738:	f9b3 3000 	ldrsh.w	r3, [r3]
 801873c:	461a      	mov	r2, r3
 801873e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018742:	681b      	ldr	r3, [r3, #0]
 8018744:	fb03 f302 	mul.w	r3, r3, r2
 8018748:	009b      	lsls	r3, r3, #2
 801874a:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

      wsptr[DCTSIZE*0] = dcval;
 801874e:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018752:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8018756:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 8018758:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801875c:	3320      	adds	r3, #32
 801875e:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8018762:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 8018764:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018768:	3340      	adds	r3, #64	; 0x40
 801876a:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801876e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 8018770:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018774:	3360      	adds	r3, #96	; 0x60
 8018776:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801877a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801877c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018780:	3380      	adds	r3, #128	; 0x80
 8018782:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8018786:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 8018788:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801878c:	33a0      	adds	r3, #160	; 0xa0
 801878e:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8018792:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 8018794:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018798:	33c0      	adds	r3, #192	; 0xc0
 801879a:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801879e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 80187a0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80187a4:	33e0      	adds	r3, #224	; 0xe0
 80187a6:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 80187aa:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 80187ac:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80187b0:	3302      	adds	r3, #2
 80187b2:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
      quantptr++;
 80187b6:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 80187ba:	3304      	adds	r3, #4
 80187bc:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
      wsptr++;
 80187c0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80187c4:	3304      	adds	r3, #4
 80187c6:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
      continue;
 80187ca:	e1b6      	b.n	8018b3a <jpeg_idct_islow+0x4b6>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80187cc:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80187d0:	3320      	adds	r3, #32
 80187d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80187d6:	461a      	mov	r2, r3
 80187d8:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 80187dc:	3340      	adds	r3, #64	; 0x40
 80187de:	681b      	ldr	r3, [r3, #0]
 80187e0:	fb03 f302 	mul.w	r3, r3, r2
 80187e4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 80187e8:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80187ec:	3360      	adds	r3, #96	; 0x60
 80187ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80187f2:	461a      	mov	r2, r3
 80187f4:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 80187f8:	33c0      	adds	r3, #192	; 0xc0
 80187fa:	681b      	ldr	r3, [r3, #0]
 80187fc:	fb03 f302 	mul.w	r3, r3, r2
 8018800:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8018804:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018808:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801880c:	4413      	add	r3, r2
 801880e:	f241 1251 	movw	r2, #4433	; 0x1151
 8018812:	fb02 f303 	mul.w	r3, r2, r3
 8018816:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801881a:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801881e:	f641 027e 	movw	r2, #6270	; 0x187e
 8018822:	fb02 f303 	mul.w	r3, r2, r3
 8018826:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801882a:	4413      	add	r3, r2
 801882c:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 8018830:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018834:	4aca      	ldr	r2, [pc, #808]	; (8018b60 <jpeg_idct_islow+0x4dc>)
 8018836:	fb02 f303 	mul.w	r3, r2, r3
 801883a:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801883e:	4413      	add	r3, r2
 8018840:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8018844:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018848:	f9b3 3000 	ldrsh.w	r3, [r3]
 801884c:	461a      	mov	r2, r3
 801884e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018852:	681b      	ldr	r3, [r3, #0]
 8018854:	fb03 f302 	mul.w	r3, r3, r2
 8018858:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801885c:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018860:	3340      	adds	r3, #64	; 0x40
 8018862:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018866:	461a      	mov	r2, r3
 8018868:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801886c:	3380      	adds	r3, #128	; 0x80
 801886e:	681b      	ldr	r3, [r3, #0]
 8018870:	fb03 f302 	mul.w	r3, r3, r2
 8018874:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    z2 <<= CONST_BITS;
 8018878:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801887c:	035b      	lsls	r3, r3, #13
 801887e:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 <<= CONST_BITS;
 8018882:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018886:	035b      	lsls	r3, r3, #13
 8018888:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 801888c:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018890:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8018894:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

    tmp0 = z2 + z3;
 8018898:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801889c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 80188a0:	4413      	add	r3, r2
 80188a2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp1 = z2 - z3;
 80188a6:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 80188aa:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 80188ae:	1ad3      	subs	r3, r2, r3
 80188b0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128

    tmp10 = tmp0 + tmp2;
 80188b4:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 80188b8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80188bc:	4413      	add	r3, r2
 80188be:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp13 = tmp0 - tmp2;
 80188c2:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 80188c6:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80188ca:	1ad3      	subs	r3, r2, r3
 80188cc:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp11 = tmp1 + tmp3;
 80188d0:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 80188d4:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80188d8:	4413      	add	r3, r2
 80188da:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp12 = tmp1 - tmp3;
 80188de:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 80188e2:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80188e6:	1ad3      	subs	r3, r2, r3
 80188e8:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 80188ec:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 80188f0:	3370      	adds	r3, #112	; 0x70
 80188f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80188f6:	461a      	mov	r2, r3
 80188f8:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 80188fc:	33e0      	adds	r3, #224	; 0xe0
 80188fe:	681b      	ldr	r3, [r3, #0]
 8018900:	fb03 f302 	mul.w	r3, r3, r2
 8018904:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8018908:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801890c:	3350      	adds	r3, #80	; 0x50
 801890e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018912:	461a      	mov	r2, r3
 8018914:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018918:	33a0      	adds	r3, #160	; 0xa0
 801891a:	681b      	ldr	r3, [r3, #0]
 801891c:	fb03 f302 	mul.w	r3, r3, r2
 8018920:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8018924:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018928:	3330      	adds	r3, #48	; 0x30
 801892a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801892e:	461a      	mov	r2, r3
 8018930:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018934:	3360      	adds	r3, #96	; 0x60
 8018936:	681b      	ldr	r3, [r3, #0]
 8018938:	fb03 f302 	mul.w	r3, r3, r2
 801893c:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8018940:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018944:	3310      	adds	r3, #16
 8018946:	f9b3 3000 	ldrsh.w	r3, [r3]
 801894a:	461a      	mov	r2, r3
 801894c:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018950:	3320      	adds	r3, #32
 8018952:	681b      	ldr	r3, [r3, #0]
 8018954:	fb03 f302 	mul.w	r3, r3, r2
 8018958:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    
    z2 = tmp0 + tmp2;
 801895c:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018960:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018964:	4413      	add	r3, r2
 8018966:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = tmp1 + tmp3;
 801896a:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801896e:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018972:	4413      	add	r3, r2
 8018974:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8018978:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801897c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018980:	4413      	add	r3, r2
 8018982:	f242 52a1 	movw	r2, #9633	; 0x25a1
 8018986:	fb02 f303 	mul.w	r3, r2, r3
 801898a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801898e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018992:	4a74      	ldr	r2, [pc, #464]	; (8018b64 <jpeg_idct_islow+0x4e0>)
 8018994:	fb02 f303 	mul.w	r3, r2, r3
 8018998:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801899c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 80189a0:	4a71      	ldr	r2, [pc, #452]	; (8018b68 <jpeg_idct_islow+0x4e4>)
 80189a2:	fb02 f303 	mul.w	r3, r2, r3
 80189a6:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    z2 += z1;
 80189aa:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 80189ae:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80189b2:	4413      	add	r3, r2
 80189b4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 += z1;
 80189b8:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80189bc:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80189c0:	4413      	add	r3, r2
 80189c2:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80189c6:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 80189ca:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80189ce:	4413      	add	r3, r2
 80189d0:	4a66      	ldr	r2, [pc, #408]	; (8018b6c <jpeg_idct_islow+0x4e8>)
 80189d2:	fb02 f303 	mul.w	r3, r2, r3
 80189d6:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 80189da:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80189de:	f640 128e 	movw	r2, #2446	; 0x98e
 80189e2:	fb02 f303 	mul.w	r3, r2, r3
 80189e6:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 80189ea:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80189ee:	f243 020b 	movw	r2, #12299	; 0x300b
 80189f2:	fb02 f303 	mul.w	r3, r2, r3
 80189f6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tmp0 += z1 + z2;
 80189fa:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 80189fe:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018a02:	4413      	add	r3, r2
 8018a04:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018a08:	4413      	add	r3, r2
 8018a0a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp3 += z1 + z3;
 8018a0e:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018a12:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018a16:	4413      	add	r3, r2
 8018a18:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8018a1c:	4413      	add	r3, r2
 8018a1e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8018a22:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018a26:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018a2a:	4413      	add	r3, r2
 8018a2c:	4a50      	ldr	r2, [pc, #320]	; (8018b70 <jpeg_idct_islow+0x4ec>)
 8018a2e:	fb02 f303 	mul.w	r3, r2, r3
 8018a32:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8018a36:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018a3a:	f244 12b3 	movw	r2, #16819	; 0x41b3
 8018a3e:	fb02 f303 	mul.w	r3, r2, r3
 8018a42:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8018a46:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018a4a:	f246 2254 	movw	r2, #25172	; 0x6254
 8018a4e:	fb02 f303 	mul.w	r3, r2, r3
 8018a52:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp1 += z1 + z3;
 8018a56:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018a5a:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018a5e:	4413      	add	r3, r2
 8018a60:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018a64:	4413      	add	r3, r2
 8018a66:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 += z1 + z2;
 8018a6a:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018a6e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018a72:	4413      	add	r3, r2
 8018a74:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8018a78:	4413      	add	r3, r2
 8018a7a:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 8018a7e:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8018a82:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018a86:	4413      	add	r3, r2
 8018a88:	12da      	asrs	r2, r3, #11
 8018a8a:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018a8e:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 8018a90:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8018a94:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018a98:	1ad2      	subs	r2, r2, r3
 8018a9a:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018a9e:	33e0      	adds	r3, #224	; 0xe0
 8018aa0:	12d2      	asrs	r2, r2, #11
 8018aa2:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 8018aa4:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018aa8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018aac:	441a      	add	r2, r3
 8018aae:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018ab2:	3320      	adds	r3, #32
 8018ab4:	12d2      	asrs	r2, r2, #11
 8018ab6:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 8018ab8:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018abc:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018ac0:	1ad2      	subs	r2, r2, r3
 8018ac2:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018ac6:	33c0      	adds	r3, #192	; 0xc0
 8018ac8:	12d2      	asrs	r2, r2, #11
 8018aca:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 8018acc:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018ad0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018ad4:	441a      	add	r2, r3
 8018ad6:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018ada:	3340      	adds	r3, #64	; 0x40
 8018adc:	12d2      	asrs	r2, r2, #11
 8018ade:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 8018ae0:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018ae4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018ae8:	1ad2      	subs	r2, r2, r3
 8018aea:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018aee:	33a0      	adds	r3, #160	; 0xa0
 8018af0:	12d2      	asrs	r2, r2, #11
 8018af2:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 8018af4:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018af8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018afc:	441a      	add	r2, r3
 8018afe:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018b02:	3360      	adds	r3, #96	; 0x60
 8018b04:	12d2      	asrs	r2, r2, #11
 8018b06:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 8018b08:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018b0c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018b10:	1ad2      	subs	r2, r2, r3
 8018b12:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018b16:	3380      	adds	r3, #128	; 0x80
 8018b18:	12d2      	asrs	r2, r2, #11
 8018b1a:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 8018b1c:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8018b20:	3302      	adds	r3, #2
 8018b22:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    quantptr++;
 8018b26:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8018b2a:	3304      	adds	r3, #4
 8018b2c:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    wsptr++;
 8018b30:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018b34:	3304      	adds	r3, #4
 8018b36:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 8018b3a:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018b3e:	3b01      	subs	r3, #1
 8018b40:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
 8018b44:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018b48:	2b00      	cmp	r3, #0
 8018b4a:	f73f adc2 	bgt.w	80186d2 <jpeg_idct_islow+0x4e>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 8018b4e:	f107 0314 	add.w	r3, r7, #20
 8018b52:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 8018b56:	2300      	movs	r3, #0
 8018b58:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
 8018b5c:	e218      	b.n	8018f90 <jpeg_idct_islow+0x90c>
 8018b5e:	bf00      	nop
 8018b60:	ffffc4df 	.word	0xffffc4df
 8018b64:	ffffc13b 	.word	0xffffc13b
 8018b68:	fffff384 	.word	0xfffff384
 8018b6c:	ffffe333 	.word	0xffffe333
 8018b70:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 8018b74:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018b78:	009b      	lsls	r3, r3, #2
 8018b7a:	463a      	mov	r2, r7
 8018b7c:	6812      	ldr	r2, [r2, #0]
 8018b7e:	4413      	add	r3, r2
 8018b80:	681a      	ldr	r2, [r3, #0]
 8018b82:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8018b86:	4413      	add	r3, r2
 8018b88:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 8018b8c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018b90:	3304      	adds	r3, #4
 8018b92:	681b      	ldr	r3, [r3, #0]
 8018b94:	2b00      	cmp	r3, #0
 8018b96:	d165      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
 8018b98:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018b9c:	3308      	adds	r3, #8
 8018b9e:	681b      	ldr	r3, [r3, #0]
 8018ba0:	2b00      	cmp	r3, #0
 8018ba2:	d15f      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
 8018ba4:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018ba8:	330c      	adds	r3, #12
 8018baa:	681b      	ldr	r3, [r3, #0]
 8018bac:	2b00      	cmp	r3, #0
 8018bae:	d159      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
 8018bb0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018bb4:	3310      	adds	r3, #16
 8018bb6:	681b      	ldr	r3, [r3, #0]
 8018bb8:	2b00      	cmp	r3, #0
 8018bba:	d153      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 8018bbc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018bc0:	3314      	adds	r3, #20
 8018bc2:	681b      	ldr	r3, [r3, #0]
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 8018bc4:	2b00      	cmp	r3, #0
 8018bc6:	d14d      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
 8018bc8:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018bcc:	3318      	adds	r3, #24
 8018bce:	681b      	ldr	r3, [r3, #0]
 8018bd0:	2b00      	cmp	r3, #0
 8018bd2:	d147      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
 8018bd4:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018bd8:	331c      	adds	r3, #28
 8018bda:	681b      	ldr	r3, [r3, #0]
 8018bdc:	2b00      	cmp	r3, #0
 8018bde:	d141      	bne.n	8018c64 <jpeg_idct_islow+0x5e0>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 8018be0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018be4:	681b      	ldr	r3, [r3, #0]
 8018be6:	3310      	adds	r3, #16
 8018be8:	115b      	asrs	r3, r3, #5
				  & RANGE_MASK];
 8018bea:	f3c3 0309 	ubfx	r3, r3, #0, #10
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 8018bee:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018bf2:	4413      	add	r3, r2
 8018bf4:	781b      	ldrb	r3, [r3, #0]
 8018bf6:	f887 3147 	strb.w	r3, [r7, #327]	; 0x147

      outptr[0] = dcval;
 8018bfa:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018bfe:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c02:	701a      	strb	r2, [r3, #0]
      outptr[1] = dcval;
 8018c04:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c08:	3301      	adds	r3, #1
 8018c0a:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c0e:	701a      	strb	r2, [r3, #0]
      outptr[2] = dcval;
 8018c10:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c14:	3302      	adds	r3, #2
 8018c16:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c1a:	701a      	strb	r2, [r3, #0]
      outptr[3] = dcval;
 8018c1c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c20:	3303      	adds	r3, #3
 8018c22:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c26:	701a      	strb	r2, [r3, #0]
      outptr[4] = dcval;
 8018c28:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c2c:	3304      	adds	r3, #4
 8018c2e:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c32:	701a      	strb	r2, [r3, #0]
      outptr[5] = dcval;
 8018c34:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c38:	3305      	adds	r3, #5
 8018c3a:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c3e:	701a      	strb	r2, [r3, #0]
      outptr[6] = dcval;
 8018c40:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c44:	3306      	adds	r3, #6
 8018c46:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c4a:	701a      	strb	r2, [r3, #0]
      outptr[7] = dcval;
 8018c4c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018c50:	3307      	adds	r3, #7
 8018c52:	f897 2147 	ldrb.w	r2, [r7, #327]	; 0x147
 8018c56:	701a      	strb	r2, [r3, #0]

      wsptr += DCTSIZE;		/* advance pointer to next row */
 8018c58:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018c5c:	3320      	adds	r3, #32
 8018c5e:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
      continue;
 8018c62:	e190      	b.n	8018f86 <jpeg_idct_islow+0x902>
#endif

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 8018c64:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018c68:	3308      	adds	r3, #8
 8018c6a:	681b      	ldr	r3, [r3, #0]
 8018c6c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = (INT32) wsptr[6];
 8018c70:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018c74:	3318      	adds	r3, #24
 8018c76:	681b      	ldr	r3, [r3, #0]
 8018c78:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8018c7c:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018c80:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018c84:	4413      	add	r3, r2
 8018c86:	f241 1251 	movw	r2, #4433	; 0x1151
 8018c8a:	fb02 f303 	mul.w	r3, r2, r3
 8018c8e:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 8018c92:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018c96:	f641 027e 	movw	r2, #6270	; 0x187e
 8018c9a:	fb02 f303 	mul.w	r3, r2, r3
 8018c9e:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018ca2:	4413      	add	r3, r2
 8018ca4:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 8018ca8:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018cac:	4abe      	ldr	r2, [pc, #760]	; (8018fa8 <jpeg_idct_islow+0x924>)
 8018cae:	fb02 f303 	mul.w	r3, r2, r3
 8018cb2:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018cb6:	4413      	add	r3, r2
 8018cb8:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8018cbc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018cc0:	681b      	ldr	r3, [r3, #0]
 8018cc2:	3310      	adds	r3, #16
 8018cc4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = (INT32) wsptr[4];
 8018cc8:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018ccc:	3310      	adds	r3, #16
 8018cce:	681b      	ldr	r3, [r3, #0]
 8018cd0:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    tmp0 = (z2 + z3) << CONST_BITS;
 8018cd4:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018cd8:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018cdc:	4413      	add	r3, r2
 8018cde:	035b      	lsls	r3, r3, #13
 8018ce0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp1 = (z2 - z3) << CONST_BITS;
 8018ce4:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018ce8:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018cec:	1ad3      	subs	r3, r2, r3
 8018cee:	035b      	lsls	r3, r3, #13
 8018cf0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    
    tmp10 = tmp0 + tmp2;
 8018cf4:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018cf8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018cfc:	4413      	add	r3, r2
 8018cfe:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp13 = tmp0 - tmp2;
 8018d02:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018d06:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018d0a:	1ad3      	subs	r3, r2, r3
 8018d0c:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp11 = tmp1 + tmp3;
 8018d10:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018d14:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018d18:	4413      	add	r3, r2
 8018d1a:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp12 = tmp1 - tmp3;
 8018d1e:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018d22:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018d26:	1ad3      	subs	r3, r2, r3
 8018d28:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 8018d2c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018d30:	331c      	adds	r3, #28
 8018d32:	681b      	ldr	r3, [r3, #0]
 8018d34:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp1 = (INT32) wsptr[5];
 8018d38:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018d3c:	3314      	adds	r3, #20
 8018d3e:	681b      	ldr	r3, [r3, #0]
 8018d40:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 = (INT32) wsptr[3];
 8018d44:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018d48:	330c      	adds	r3, #12
 8018d4a:	681b      	ldr	r3, [r3, #0]
 8018d4c:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp3 = (INT32) wsptr[1];
 8018d50:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018d54:	3304      	adds	r3, #4
 8018d56:	681b      	ldr	r3, [r3, #0]
 8018d58:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    z2 = tmp0 + tmp2;
 8018d5c:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018d60:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018d64:	4413      	add	r3, r2
 8018d66:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = tmp1 + tmp3;
 8018d6a:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018d6e:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018d72:	4413      	add	r3, r2
 8018d74:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8018d78:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018d7c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018d80:	4413      	add	r3, r2
 8018d82:	f242 52a1 	movw	r2, #9633	; 0x25a1
 8018d86:	fb02 f303 	mul.w	r3, r2, r3
 8018d8a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 8018d8e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018d92:	4a86      	ldr	r2, [pc, #536]	; (8018fac <jpeg_idct_islow+0x928>)
 8018d94:	fb02 f303 	mul.w	r3, r2, r3
 8018d98:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 8018d9c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018da0:	4a83      	ldr	r2, [pc, #524]	; (8018fb0 <jpeg_idct_islow+0x92c>)
 8018da2:	fb02 f303 	mul.w	r3, r2, r3
 8018da6:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    z2 += z1;
 8018daa:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8018dae:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8018db2:	4413      	add	r3, r2
 8018db4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z3 += z1;
 8018db8:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8018dbc:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8018dc0:	4413      	add	r3, r2
 8018dc2:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 8018dc6:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018dca:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018dce:	4413      	add	r3, r2
 8018dd0:	4a78      	ldr	r2, [pc, #480]	; (8018fb4 <jpeg_idct_islow+0x930>)
 8018dd2:	fb02 f303 	mul.w	r3, r2, r3
 8018dd6:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8018dda:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018dde:	f640 128e 	movw	r2, #2446	; 0x98e
 8018de2:	fb02 f303 	mul.w	r3, r2, r3
 8018de6:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8018dea:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018dee:	f243 020b 	movw	r2, #12299	; 0x300b
 8018df2:	fb02 f303 	mul.w	r3, r2, r3
 8018df6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tmp0 += z1 + z2;
 8018dfa:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018dfe:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018e02:	4413      	add	r3, r2
 8018e04:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8018e08:	4413      	add	r3, r2
 8018e0a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp3 += z1 + z3;
 8018e0e:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018e12:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018e16:	4413      	add	r3, r2
 8018e18:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8018e1c:	4413      	add	r3, r2
 8018e1e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8018e22:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018e26:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018e2a:	4413      	add	r3, r2
 8018e2c:	4a62      	ldr	r2, [pc, #392]	; (8018fb8 <jpeg_idct_islow+0x934>)
 8018e2e:	fb02 f303 	mul.w	r3, r2, r3
 8018e32:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8018e36:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018e3a:	f244 12b3 	movw	r2, #16819	; 0x41b3
 8018e3e:	fb02 f303 	mul.w	r3, r2, r3
 8018e42:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8018e46:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018e4a:	f246 2254 	movw	r2, #25172	; 0x6254
 8018e4e:	fb02 f303 	mul.w	r3, r2, r3
 8018e52:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp1 += z1 + z3;
 8018e56:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018e5a:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8018e5e:	4413      	add	r3, r2
 8018e60:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8018e64:	4413      	add	r3, r2
 8018e66:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp2 += z1 + z2;
 8018e6a:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 8018e6e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8018e72:	4413      	add	r3, r2
 8018e74:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8018e78:	4413      	add	r3, r2
 8018e7a:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8018e7e:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8018e82:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018e86:	4413      	add	r3, r2
 8018e88:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018e8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 8018e8e:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018e92:	4413      	add	r3, r2
 8018e94:	781a      	ldrb	r2, [r3, #0]
 8018e96:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018e9a:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8018e9c:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8018ea0:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8018ea4:	1ad3      	subs	r3, r2, r3
 8018ea6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018ea8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8018eac:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018eb0:	441a      	add	r2, r3
 8018eb2:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018eb6:	3307      	adds	r3, #7
 8018eb8:	7812      	ldrb	r2, [r2, #0]
 8018eba:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8018ebc:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018ec0:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018ec4:	4413      	add	r3, r2
 8018ec6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018ec8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8018ecc:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018ed0:	441a      	add	r2, r3
 8018ed2:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018ed6:	3301      	adds	r3, #1
 8018ed8:	7812      	ldrb	r2, [r2, #0]
 8018eda:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8018edc:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8018ee0:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8018ee4:	1ad3      	subs	r3, r2, r3
 8018ee6:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018ee8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8018eec:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018ef0:	441a      	add	r2, r3
 8018ef2:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018ef6:	3306      	adds	r3, #6
 8018ef8:	7812      	ldrb	r2, [r2, #0]
 8018efa:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8018efc:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018f00:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018f04:	4413      	add	r3, r2
 8018f06:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018f08:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8018f0c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018f10:	441a      	add	r2, r3
 8018f12:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018f16:	3302      	adds	r3, #2
 8018f18:	7812      	ldrb	r2, [r2, #0]
 8018f1a:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8018f1c:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8018f20:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8018f24:	1ad3      	subs	r3, r2, r3
 8018f26:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018f28:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8018f2c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018f30:	441a      	add	r2, r3
 8018f32:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018f36:	3305      	adds	r3, #5
 8018f38:	7812      	ldrb	r2, [r2, #0]
 8018f3a:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8018f3c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018f40:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018f44:	4413      	add	r3, r2
 8018f46:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018f48:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8018f4c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018f50:	441a      	add	r2, r3
 8018f52:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018f56:	3303      	adds	r3, #3
 8018f58:	7812      	ldrb	r2, [r2, #0]
 8018f5a:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8018f5c:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8018f60:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8018f64:	1ad3      	subs	r3, r2, r3
 8018f66:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8018f68:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8018f6c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8018f70:	441a      	add	r2, r3
 8018f72:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8018f76:	3304      	adds	r3, #4
 8018f78:	7812      	ldrb	r2, [r2, #0]
 8018f7a:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 8018f7c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8018f80:	3320      	adds	r3, #32
 8018f82:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
 8018f86:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018f8a:	3301      	adds	r3, #1
 8018f8c:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
 8018f90:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8018f94:	2b07      	cmp	r3, #7
 8018f96:	f77f aded 	ble.w	8018b74 <jpeg_idct_islow+0x4f0>
  }
}
 8018f9a:	bf00      	nop
 8018f9c:	bf00      	nop
 8018f9e:	f507 77b0 	add.w	r7, r7, #352	; 0x160
 8018fa2:	46bd      	mov	sp, r7
 8018fa4:	bc90      	pop	{r4, r7}
 8018fa6:	4770      	bx	lr
 8018fa8:	ffffc4df 	.word	0xffffc4df
 8018fac:	ffffc13b 	.word	0xffffc13b
 8018fb0:	fffff384 	.word	0xfffff384
 8018fb4:	ffffe333 	.word	0xffffe333
 8018fb8:	ffffadfd 	.word	0xffffadfd

08018fbc <jpeg_idct_7x7>:

GLOBAL(void)
jpeg_idct_7x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8018fbc:	b490      	push	{r4, r7}
 8018fbe:	b0c6      	sub	sp, #280	; 0x118
 8018fc0:	af00      	add	r7, sp, #0
 8018fc2:	f107 040c 	add.w	r4, r7, #12
 8018fc6:	6020      	str	r0, [r4, #0]
 8018fc8:	f107 0008 	add.w	r0, r7, #8
 8018fcc:	6001      	str	r1, [r0, #0]
 8018fce:	1d39      	adds	r1, r7, #4
 8018fd0:	600a      	str	r2, [r1, #0]
 8018fd2:	463a      	mov	r2, r7
 8018fd4:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8018fd6:	f107 030c 	add.w	r3, r7, #12
 8018fda:	681b      	ldr	r3, [r3, #0]
 8018fdc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8018fe0:	3380      	adds	r3, #128	; 0x80
 8018fe2:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
  int workspace[7*7];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8018fe6:	1d3b      	adds	r3, r7, #4
 8018fe8:	681b      	ldr	r3, [r3, #0]
 8018fea:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8018fee:	f107 0308 	add.w	r3, r7, #8
 8018ff2:	681b      	ldr	r3, [r3, #0]
 8018ff4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8018ff6:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
  wsptr = workspace;
 8018ffa:	f107 0314 	add.w	r3, r7, #20
 8018ffe:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8019002:	2300      	movs	r3, #0
 8019004:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 8019008:	e17a      	b.n	8019300 <jpeg_idct_7x7+0x344>
    /* Even part */

    tmp13 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801900a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801900e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019012:	461a      	mov	r2, r3
 8019014:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019018:	681b      	ldr	r3, [r3, #0]
 801901a:	fb03 f302 	mul.w	r3, r3, r2
 801901e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp13 <<= CONST_BITS;
 8019022:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8019026:	035b      	lsls	r3, r3, #13
 8019028:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    /* Add fudge factor here for final descale. */
    tmp13 += ONE << (CONST_BITS-PASS1_BITS-1);
 801902c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8019030:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8019034:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8019038:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801903c:	3320      	adds	r3, #32
 801903e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019042:	461a      	mov	r2, r3
 8019044:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019048:	3340      	adds	r3, #64	; 0x40
 801904a:	681b      	ldr	r3, [r3, #0]
 801904c:	fb03 f302 	mul.w	r3, r3, r2
 8019050:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8019054:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8019058:	3340      	adds	r3, #64	; 0x40
 801905a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801905e:	461a      	mov	r2, r3
 8019060:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019064:	3380      	adds	r3, #128	; 0x80
 8019066:	681b      	ldr	r3, [r3, #0]
 8019068:	fb03 f302 	mul.w	r3, r3, r2
 801906c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8019070:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8019074:	3360      	adds	r3, #96	; 0x60
 8019076:	f9b3 3000 	ldrsh.w	r3, [r3]
 801907a:	461a      	mov	r2, r3
 801907c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019080:	33c0      	adds	r3, #192	; 0xc0
 8019082:	681b      	ldr	r3, [r3, #0]
 8019084:	fb03 f302 	mul.w	r3, r3, r2
 8019088:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 801908c:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8019090:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8019094:	1ad3      	subs	r3, r2, r3
 8019096:	f641 4237 	movw	r2, #7223	; 0x1c37
 801909a:	fb02 f303 	mul.w	r3, r2, r3
 801909e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 80190a2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80190a6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80190aa:	1ad3      	subs	r3, r2, r3
 80190ac:	f640 2212 	movw	r2, #2578	; 0xa12
 80190b0:	fb02 f303 	mul.w	r3, r2, r3
 80190b4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 80190b8:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80190bc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80190c0:	441a      	add	r2, r3
 80190c2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80190c6:	441a      	add	r2, r3
 80190c8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80190cc:	4993      	ldr	r1, [pc, #588]	; (801931c <jpeg_idct_7x7+0x360>)
 80190ce:	fb01 f303 	mul.w	r3, r1, r3
 80190d2:	4413      	add	r3, r2
 80190d4:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    tmp0 = z1 + z3;
 80190d8:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80190dc:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80190e0:	4413      	add	r3, r2
 80190e2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    z2 -= tmp0;
 80190e6:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 80190ea:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80190ee:	1ad3      	subs	r3, r2, r3
 80190f0:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 80190f4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80190f8:	f642 02c6 	movw	r2, #10438	; 0x28c6
 80190fc:	fb02 f303 	mul.w	r3, r2, r3
 8019100:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8019104:	4413      	add	r3, r2
 8019106:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 801910a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801910e:	f46f 721f 	mvn.w	r2, #636	; 0x27c
 8019112:	fb02 f203 	mul.w	r2, r2, r3
 8019116:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 801911a:	4413      	add	r3, r2
 801911c:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8019120:	4413      	add	r3, r2
 8019122:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 8019126:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 801912a:	4a7d      	ldr	r2, [pc, #500]	; (8019320 <jpeg_idct_7x7+0x364>)
 801912c:	fb02 f203 	mul.w	r2, r2, r3
 8019130:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8019134:	4413      	add	r3, r2
 8019136:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 801913a:	4413      	add	r3, r2
 801913c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 8019140:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019144:	f642 5241 	movw	r2, #11585	; 0x2d41
 8019148:	fb02 f303 	mul.w	r3, r2, r3
 801914c:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8019150:	4413      	add	r3, r2
 8019152:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8019156:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801915a:	3310      	adds	r3, #16
 801915c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019160:	461a      	mov	r2, r3
 8019162:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019166:	3320      	adds	r3, #32
 8019168:	681b      	ldr	r3, [r3, #0]
 801916a:	fb03 f302 	mul.w	r3, r3, r2
 801916e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8019172:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8019176:	3330      	adds	r3, #48	; 0x30
 8019178:	f9b3 3000 	ldrsh.w	r3, [r3]
 801917c:	461a      	mov	r2, r3
 801917e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019182:	3360      	adds	r3, #96	; 0x60
 8019184:	681b      	ldr	r3, [r3, #0]
 8019186:	fb03 f302 	mul.w	r3, r3, r2
 801918a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801918e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8019192:	3350      	adds	r3, #80	; 0x50
 8019194:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019198:	461a      	mov	r2, r3
 801919a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801919e:	33a0      	adds	r3, #160	; 0xa0
 80191a0:	681b      	ldr	r3, [r3, #0]
 80191a2:	fb03 f302 	mul.w	r3, r3, r2
 80191a6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 80191aa:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80191ae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80191b2:	4413      	add	r3, r2
 80191b4:	f641 52ef 	movw	r2, #7663	; 0x1def
 80191b8:	fb02 f303 	mul.w	r3, r2, r3
 80191bc:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 80191c0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80191c4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80191c8:	1ad3      	subs	r3, r2, r3
 80191ca:	f240 5273 	movw	r2, #1395	; 0x573
 80191ce:	fb02 f303 	mul.w	r3, r2, r3
 80191d2:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    tmp0 = tmp1 - tmp2;
 80191d6:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80191da:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80191de:	1ad3      	subs	r3, r2, r3
 80191e0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp1 += tmp2;
 80191e4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80191e8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80191ec:	4413      	add	r3, r2
 80191ee:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 80191f2:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 80191f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80191fa:	4413      	add	r3, r2
 80191fc:	4a49      	ldr	r2, [pc, #292]	; (8019324 <jpeg_idct_7x7+0x368>)
 80191fe:	fb02 f303 	mul.w	r3, r2, r3
 8019202:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    tmp1 += tmp2;
 8019206:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 801920a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801920e:	4413      	add	r3, r2
 8019210:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 8019214:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8019218:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801921c:	4413      	add	r3, r2
 801921e:	f241 32a3 	movw	r2, #5027	; 0x13a3
 8019222:	fb02 f303 	mul.w	r3, r2, r3
 8019226:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp0 += z2;
 801922a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 801922e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019232:	4413      	add	r3, r2
 8019234:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 8019238:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801923c:	f643 32de 	movw	r2, #15326	; 0x3bde
 8019240:	fb02 f203 	mul.w	r2, r2, r3
 8019244:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019248:	4413      	add	r3, r2
 801924a:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 801924e:	4413      	add	r3, r2
 8019250:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8

    /* Final output stage */

    wsptr[7*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8019254:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8019258:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 801925c:	4413      	add	r3, r2
 801925e:	12da      	asrs	r2, r3, #11
 8019260:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019264:	601a      	str	r2, [r3, #0]
    wsptr[7*6] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8019266:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 801926a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 801926e:	1ad2      	subs	r2, r2, r3
 8019270:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019274:	33a8      	adds	r3, #168	; 0xa8
 8019276:	12d2      	asrs	r2, r2, #11
 8019278:	601a      	str	r2, [r3, #0]
    wsptr[7*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 801927a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 801927e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019282:	441a      	add	r2, r3
 8019284:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019288:	331c      	adds	r3, #28
 801928a:	12d2      	asrs	r2, r2, #11
 801928c:	601a      	str	r2, [r3, #0]
    wsptr[7*5] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 801928e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8019292:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019296:	1ad2      	subs	r2, r2, r3
 8019298:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801929c:	338c      	adds	r3, #140	; 0x8c
 801929e:	12d2      	asrs	r2, r2, #11
 80192a0:	601a      	str	r2, [r3, #0]
    wsptr[7*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 80192a2:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 80192a6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80192aa:	441a      	add	r2, r3
 80192ac:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80192b0:	3338      	adds	r3, #56	; 0x38
 80192b2:	12d2      	asrs	r2, r2, #11
 80192b4:	601a      	str	r2, [r3, #0]
    wsptr[7*4] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 80192b6:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 80192ba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80192be:	1ad2      	subs	r2, r2, r3
 80192c0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80192c4:	3370      	adds	r3, #112	; 0x70
 80192c6:	12d2      	asrs	r2, r2, #11
 80192c8:	601a      	str	r2, [r3, #0]
    wsptr[7*3] = (int) RIGHT_SHIFT(tmp13, CONST_BITS-PASS1_BITS);
 80192ca:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80192ce:	3354      	adds	r3, #84	; 0x54
 80192d0:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 80192d4:	12d2      	asrs	r2, r2, #11
 80192d6:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 80192d8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80192dc:	3301      	adds	r3, #1
 80192de:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 80192e2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80192e6:	3302      	adds	r3, #2
 80192e8:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 80192ec:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80192f0:	3304      	adds	r3, #4
 80192f2:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
 80192f6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80192fa:	3304      	adds	r3, #4
 80192fc:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 8019300:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8019304:	2b06      	cmp	r3, #6
 8019306:	f77f ae80 	ble.w	801900a <jpeg_idct_7x7+0x4e>
  }

  /* Pass 2: process 7 rows from work array, store into output array. */

  wsptr = workspace;
 801930a:	f107 0314 	add.w	r3, r7, #20
 801930e:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 8019312:	2300      	movs	r3, #0
 8019314:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 8019318:	e171      	b.n	80195fe <jpeg_idct_7x7+0x642>
 801931a:	bf00      	nop
 801931c:	ffffc515 	.word	0xffffc515
 8019320:	ffffb0f1 	.word	0xffffb0f1
 8019324:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 8019328:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 801932c:	009b      	lsls	r3, r3, #2
 801932e:	463a      	mov	r2, r7
 8019330:	6812      	ldr	r2, [r2, #0]
 8019332:	4413      	add	r3, r2
 8019334:	681a      	ldr	r2, [r3, #0]
 8019336:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 801933a:	4413      	add	r3, r2
 801933c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp13 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8019340:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019344:	681b      	ldr	r3, [r3, #0]
 8019346:	3310      	adds	r3, #16
 8019348:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp13 <<= CONST_BITS;
 801934c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8019350:	035b      	lsls	r3, r3, #13
 8019352:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc

    z1 = (INT32) wsptr[2];
 8019356:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801935a:	3308      	adds	r3, #8
 801935c:	681b      	ldr	r3, [r3, #0]
 801935e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z2 = (INT32) wsptr[4];
 8019362:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019366:	3310      	adds	r3, #16
 8019368:	681b      	ldr	r3, [r3, #0]
 801936a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    z3 = (INT32) wsptr[6];
 801936e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019372:	3318      	adds	r3, #24
 8019374:	681b      	ldr	r3, [r3, #0]
 8019376:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0

    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */
 801937a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 801937e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8019382:	1ad3      	subs	r3, r2, r3
 8019384:	f641 4237 	movw	r2, #7223	; 0x1c37
 8019388:	fb02 f303 	mul.w	r3, r2, r3
 801938c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */
 8019390:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8019394:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019398:	1ad3      	subs	r3, r2, r3
 801939a:	f640 2212 	movw	r2, #2578	; 0xa12
 801939e:	fb02 f303 	mul.w	r3, r2, r3
 80193a2:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 80193a6:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80193aa:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80193ae:	441a      	add	r2, r3
 80193b0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80193b4:	441a      	add	r2, r3
 80193b6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80193ba:	4997      	ldr	r1, [pc, #604]	; (8019618 <jpeg_idct_7x7+0x65c>)
 80193bc:	fb01 f303 	mul.w	r3, r1, r3
 80193c0:	4413      	add	r3, r2
 80193c2:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    tmp0 = z1 + z3;
 80193c6:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80193ca:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80193ce:	4413      	add	r3, r2
 80193d0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    z2 -= tmp0;
 80193d4:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 80193d8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80193dc:	1ad3      	subs	r3, r2, r3
 80193de:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */
 80193e2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80193e6:	f642 02c6 	movw	r2, #10438	; 0x28c6
 80193ea:	fb02 f303 	mul.w	r3, r2, r3
 80193ee:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 80193f2:	4413      	add	r3, r2
 80193f4:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */
 80193f8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80193fc:	f46f 721f 	mvn.w	r2, #636	; 0x27c
 8019400:	fb02 f203 	mul.w	r2, r2, r3
 8019404:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8019408:	4413      	add	r3, r2
 801940a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 801940e:	4413      	add	r3, r2
 8019410:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */
 8019414:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8019418:	4a80      	ldr	r2, [pc, #512]	; (801961c <jpeg_idct_7x7+0x660>)
 801941a:	fb02 f203 	mul.w	r2, r2, r3
 801941e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8019422:	4413      	add	r3, r2
 8019424:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8019428:	4413      	add	r3, r2
 801942a:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */
 801942e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019432:	f642 5241 	movw	r2, #11585	; 0x2d41
 8019436:	fb02 f303 	mul.w	r3, r2, r3
 801943a:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 801943e:	4413      	add	r3, r2
 8019440:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8019444:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019448:	3304      	adds	r3, #4
 801944a:	681b      	ldr	r3, [r3, #0]
 801944c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z2 = (INT32) wsptr[3];
 8019450:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019454:	330c      	adds	r3, #12
 8019456:	681b      	ldr	r3, [r3, #0]
 8019458:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    z3 = (INT32) wsptr[5];
 801945c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8019460:	3314      	adds	r3, #20
 8019462:	681b      	ldr	r3, [r3, #0]
 8019464:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0

    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */
 8019468:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 801946c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019470:	4413      	add	r3, r2
 8019472:	f641 52ef 	movw	r2, #7663	; 0x1def
 8019476:	fb02 f303 	mul.w	r3, r2, r3
 801947a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */
 801947e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8019482:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019486:	1ad3      	subs	r3, r2, r3
 8019488:	f240 5273 	movw	r2, #1395	; 0x573
 801948c:	fb02 f303 	mul.w	r3, r2, r3
 8019490:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    tmp0 = tmp1 - tmp2;
 8019494:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019498:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801949c:	1ad3      	subs	r3, r2, r3
 801949e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp1 += tmp2;
 80194a2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80194a6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80194aa:	4413      	add	r3, r2
 80194ac:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp2 = MULTIPLY(z2 + z3, - FIX(1.378756276));    /* -c1 */
 80194b0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 80194b4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80194b8:	4413      	add	r3, r2
 80194ba:	4a59      	ldr	r2, [pc, #356]	; (8019620 <jpeg_idct_7x7+0x664>)
 80194bc:	fb02 f303 	mul.w	r3, r2, r3
 80194c0:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    tmp1 += tmp2;
 80194c4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80194c8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80194cc:	4413      	add	r3, r2
 80194ce:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */
 80194d2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80194d6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80194da:	4413      	add	r3, r2
 80194dc:	f241 32a3 	movw	r2, #5027	; 0x13a3
 80194e0:	fb02 f303 	mul.w	r3, r2, r3
 80194e4:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp0 += z2;
 80194e8:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 80194ec:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80194f0:	4413      	add	r3, r2
 80194f2:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */
 80194f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80194fa:	f643 32de 	movw	r2, #15326	; 0x3bde
 80194fe:	fb02 f203 	mul.w	r2, r2, r3
 8019502:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8019506:	4413      	add	r3, r2
 8019508:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 801950c:	4413      	add	r3, r2
 801950e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8019512:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8019516:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 801951a:	4413      	add	r3, r2
 801951c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801951e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8019522:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019526:	4413      	add	r3, r2
 8019528:	781a      	ldrb	r2, [r3, #0]
 801952a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801952e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8019530:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8019534:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8019538:	1ad3      	subs	r3, r2, r3
 801953a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801953c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8019540:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019544:	441a      	add	r2, r3
 8019546:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801954a:	3306      	adds	r3, #6
 801954c:	7812      	ldrb	r2, [r2, #0]
 801954e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8019550:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8019554:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019558:	4413      	add	r3, r2
 801955a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801955c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8019560:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019564:	441a      	add	r2, r3
 8019566:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801956a:	3301      	adds	r3, #1
 801956c:	7812      	ldrb	r2, [r2, #0]
 801956e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8019570:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8019574:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019578:	1ad3      	subs	r3, r2, r3
 801957a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801957c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8019580:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019584:	441a      	add	r2, r3
 8019586:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801958a:	3305      	adds	r3, #5
 801958c:	7812      	ldrb	r2, [r2, #0]
 801958e:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8019590:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8019594:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8019598:	4413      	add	r3, r2
 801959a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801959c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 80195a0:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80195a4:	441a      	add	r2, r3
 80195a6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80195aa:	3302      	adds	r3, #2
 80195ac:	7812      	ldrb	r2, [r2, #0]
 80195ae:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 80195b0:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 80195b4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80195b8:	1ad3      	subs	r3, r2, r3
 80195ba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80195bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 80195c0:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80195c4:	441a      	add	r2, r3
 80195c6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80195ca:	3304      	adds	r3, #4
 80195cc:	7812      	ldrb	r2, [r2, #0]
 80195ce:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 80195d0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80195d4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80195d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13,
 80195da:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80195de:	441a      	add	r2, r3
 80195e0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80195e4:	3303      	adds	r3, #3
 80195e6:	7812      	ldrb	r2, [r2, #0]
 80195e8:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 80195ea:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80195ee:	331c      	adds	r3, #28
 80195f0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  for (ctr = 0; ctr < 7; ctr++) {
 80195f4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80195f8:	3301      	adds	r3, #1
 80195fa:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 80195fe:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8019602:	2b06      	cmp	r3, #6
 8019604:	f77f ae90 	ble.w	8019328 <jpeg_idct_7x7+0x36c>
  }
}
 8019608:	bf00      	nop
 801960a:	bf00      	nop
 801960c:	f507 778c 	add.w	r7, r7, #280	; 0x118
 8019610:	46bd      	mov	sp, r7
 8019612:	bc90      	pop	{r4, r7}
 8019614:	4770      	bx	lr
 8019616:	bf00      	nop
 8019618:	ffffc515 	.word	0xffffc515
 801961c:	ffffb0f1 	.word	0xffffb0f1
 8019620:	ffffd3e1 	.word	0xffffd3e1

08019624 <jpeg_idct_6x6>:

GLOBAL(void)
jpeg_idct_6x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8019624:	b480      	push	{r7}
 8019626:	b0b9      	sub	sp, #228	; 0xe4
 8019628:	af00      	add	r7, sp, #0
 801962a:	60f8      	str	r0, [r7, #12]
 801962c:	60b9      	str	r1, [r7, #8]
 801962e:	607a      	str	r2, [r7, #4]
 8019630:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8019632:	68fb      	ldr	r3, [r7, #12]
 8019634:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8019638:	3380      	adds	r3, #128	; 0x80
 801963a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  int workspace[6*6];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801963e:	687b      	ldr	r3, [r7, #4]
 8019640:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8019644:	68bb      	ldr	r3, [r7, #8]
 8019646:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8019648:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  wsptr = workspace;
 801964c:	f107 0314 	add.w	r3, r7, #20
 8019650:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8019654:	2300      	movs	r3, #0
 8019656:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 801965a:	e105      	b.n	8019868 <jpeg_idct_6x6+0x244>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801965c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019660:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019664:	461a      	mov	r2, r3
 8019666:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801966a:	681b      	ldr	r3, [r3, #0]
 801966c:	fb03 f302 	mul.w	r3, r3, r2
 8019670:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp0 <<= CONST_BITS;
 8019674:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8019678:	035b      	lsls	r3, r3, #13
 801967a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801967e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8019682:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8019686:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801968a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801968e:	3340      	adds	r3, #64	; 0x40
 8019690:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019694:	461a      	mov	r2, r3
 8019696:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801969a:	3380      	adds	r3, #128	; 0x80
 801969c:	681b      	ldr	r3, [r3, #0]
 801969e:	fb03 f302 	mul.w	r3, r3, r2
 80196a2:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 80196a6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80196aa:	f241 62a1 	movw	r2, #5793	; 0x16a1
 80196ae:	fb02 f303 	mul.w	r3, r2, r3
 80196b2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp1 = tmp0 + tmp10;
 80196b6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80196ba:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80196be:	4413      	add	r3, r2
 80196c0:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 80196c4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80196c8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80196cc:	1ad2      	subs	r2, r2, r3
 80196ce:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80196d2:	1ad3      	subs	r3, r2, r3
 80196d4:	12db      	asrs	r3, r3, #11
 80196d6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80196da:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80196de:	3320      	adds	r3, #32
 80196e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80196e4:	461a      	mov	r2, r3
 80196e6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80196ea:	3340      	adds	r3, #64	; 0x40
 80196ec:	681b      	ldr	r3, [r3, #0]
 80196ee:	fb03 f302 	mul.w	r3, r3, r2
 80196f2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 80196f6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80196fa:	f242 7231 	movw	r2, #10033	; 0x2731
 80196fe:	fb02 f303 	mul.w	r3, r2, r3
 8019702:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp10 = tmp1 + tmp0;
 8019706:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801970a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 801970e:	4413      	add	r3, r2
 8019710:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp12 = tmp1 - tmp0;
 8019714:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8019718:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 801971c:	1ad3      	subs	r3, r2, r3
 801971e:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8019722:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019726:	3310      	adds	r3, #16
 8019728:	f9b3 3000 	ldrsh.w	r3, [r3]
 801972c:	461a      	mov	r2, r3
 801972e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8019732:	3320      	adds	r3, #32
 8019734:	681b      	ldr	r3, [r3, #0]
 8019736:	fb03 f302 	mul.w	r3, r3, r2
 801973a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801973e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019742:	3330      	adds	r3, #48	; 0x30
 8019744:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019748:	461a      	mov	r2, r3
 801974a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801974e:	3360      	adds	r3, #96	; 0x60
 8019750:	681b      	ldr	r3, [r3, #0]
 8019752:	fb03 f302 	mul.w	r3, r3, r2
 8019756:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801975a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801975e:	3350      	adds	r3, #80	; 0x50
 8019760:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019764:	461a      	mov	r2, r3
 8019766:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801976a:	33a0      	adds	r3, #160	; 0xa0
 801976c:	681b      	ldr	r3, [r3, #0]
 801976e:	fb03 f302 	mul.w	r3, r3, r2
 8019772:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8019776:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801977a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801977e:	4413      	add	r3, r2
 8019780:	f640 32b6 	movw	r2, #2998	; 0xbb6
 8019784:	fb02 f303 	mul.w	r3, r2, r3
 8019788:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 801978c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8019790:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019794:	4413      	add	r3, r2
 8019796:	035b      	lsls	r3, r3, #13
 8019798:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801979c:	4413      	add	r3, r2
 801979e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 80197a2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80197a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80197aa:	1ad3      	subs	r3, r2, r3
 80197ac:	035b      	lsls	r3, r3, #13
 80197ae:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 80197b2:	4413      	add	r3, r2
 80197b4:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 80197b8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80197bc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80197c0:	1ad2      	subs	r2, r2, r3
 80197c2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80197c6:	1ad3      	subs	r3, r2, r3
 80197c8:	009b      	lsls	r3, r3, #2
 80197ca:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 80197ce:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80197d2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80197d6:	4413      	add	r3, r2
 80197d8:	12da      	asrs	r2, r3, #11
 80197da:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80197de:	601a      	str	r2, [r3, #0]
    wsptr[6*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 80197e0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80197e4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80197e8:	1ad2      	subs	r2, r2, r3
 80197ea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80197ee:	3378      	adds	r3, #120	; 0x78
 80197f0:	12d2      	asrs	r2, r2, #11
 80197f2:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) (tmp11 + tmp1);
 80197f4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80197f8:	3318      	adds	r3, #24
 80197fa:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 80197fe:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8019802:	440a      	add	r2, r1
 8019804:	601a      	str	r2, [r3, #0]
    wsptr[6*4] = (int) (tmp11 - tmp1);
 8019806:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801980a:	3360      	adds	r3, #96	; 0x60
 801980c:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 8019810:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8019814:	1a8a      	subs	r2, r1, r2
 8019816:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 8019818:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 801981c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8019820:	441a      	add	r2, r3
 8019822:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019826:	3330      	adds	r3, #48	; 0x30
 8019828:	12d2      	asrs	r2, r2, #11
 801982a:	601a      	str	r2, [r3, #0]
    wsptr[6*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 801982c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8019830:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8019834:	1ad2      	subs	r2, r2, r3
 8019836:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801983a:	3348      	adds	r3, #72	; 0x48
 801983c:	12d2      	asrs	r2, r2, #11
 801983e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8019840:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019844:	3301      	adds	r3, #1
 8019846:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 801984a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801984e:	3302      	adds	r3, #2
 8019850:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8019854:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8019858:	3304      	adds	r3, #4
 801985a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 801985e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019862:	3304      	adds	r3, #4
 8019864:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8019868:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 801986c:	2b05      	cmp	r3, #5
 801986e:	f77f aef5 	ble.w	801965c <jpeg_idct_6x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array. */

  wsptr = workspace;
 8019872:	f107 0314 	add.w	r3, r7, #20
 8019876:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 801987a:	2300      	movs	r3, #0
 801987c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8019880:	e0f7      	b.n	8019a72 <jpeg_idct_6x6+0x44e>
    outptr = output_buf[ctr] + output_col;
 8019882:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019886:	009b      	lsls	r3, r3, #2
 8019888:	683a      	ldr	r2, [r7, #0]
 801988a:	4413      	add	r3, r2
 801988c:	681a      	ldr	r2, [r3, #0]
 801988e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8019892:	4413      	add	r3, r2
 8019894:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8019898:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801989c:	681b      	ldr	r3, [r3, #0]
 801989e:	3310      	adds	r3, #16
 80198a0:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp0 <<= CONST_BITS;
 80198a4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80198a8:	035b      	lsls	r3, r3, #13
 80198aa:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp2 = (INT32) wsptr[4];
 80198ae:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80198b2:	3310      	adds	r3, #16
 80198b4:	681b      	ldr	r3, [r3, #0]
 80198b6:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 80198ba:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80198be:	f241 62a1 	movw	r2, #5793	; 0x16a1
 80198c2:	fb02 f303 	mul.w	r3, r2, r3
 80198c6:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp1 = tmp0 + tmp10;
 80198ca:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80198ce:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80198d2:	4413      	add	r3, r2
 80198d4:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp11 = tmp0 - tmp10 - tmp10;
 80198d8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80198dc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80198e0:	1ad2      	subs	r2, r2, r3
 80198e2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80198e6:	1ad3      	subs	r3, r2, r3
 80198e8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp10 = (INT32) wsptr[2];
 80198ec:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80198f0:	3308      	adds	r3, #8
 80198f2:	681b      	ldr	r3, [r3, #0]
 80198f4:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 80198f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80198fc:	f242 7231 	movw	r2, #10033	; 0x2731
 8019900:	fb02 f303 	mul.w	r3, r2, r3
 8019904:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp10 = tmp1 + tmp0;
 8019908:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801990c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8019910:	4413      	add	r3, r2
 8019912:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp12 = tmp1 - tmp0;
 8019916:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801991a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 801991e:	1ad3      	subs	r3, r2, r3
 8019920:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8019924:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019928:	3304      	adds	r3, #4
 801992a:	681b      	ldr	r3, [r3, #0]
 801992c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z2 = (INT32) wsptr[3];
 8019930:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019934:	330c      	adds	r3, #12
 8019936:	681b      	ldr	r3, [r3, #0]
 8019938:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    z3 = (INT32) wsptr[5];
 801993c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019940:	3314      	adds	r3, #20
 8019942:	681b      	ldr	r3, [r3, #0]
 8019944:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8019948:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801994c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019950:	4413      	add	r3, r2
 8019952:	f640 32b6 	movw	r2, #2998	; 0xbb6
 8019956:	fb02 f303 	mul.w	r3, r2, r3
 801995a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 801995e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8019962:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019966:	4413      	add	r3, r2
 8019968:	035b      	lsls	r3, r3, #13
 801996a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801996e:	4413      	add	r3, r2
 8019970:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 8019974:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8019978:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801997c:	1ad3      	subs	r3, r2, r3
 801997e:	035b      	lsls	r3, r3, #13
 8019980:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8019984:	4413      	add	r3, r2
 8019986:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 801998a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801998e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019992:	1ad2      	subs	r2, r2, r3
 8019994:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019998:	1ad3      	subs	r3, r2, r3
 801999a:	035b      	lsls	r3, r3, #13
 801999c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80199a0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80199a4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80199a8:	4413      	add	r3, r2
 80199aa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80199ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 80199b0:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 80199b4:	4413      	add	r3, r2
 80199b6:	781a      	ldrb	r2, [r3, #0]
 80199b8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80199bc:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80199be:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80199c2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80199c6:	1ad3      	subs	r3, r2, r3
 80199c8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80199ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 80199ce:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 80199d2:	441a      	add	r2, r3
 80199d4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80199d8:	3305      	adds	r3, #5
 80199da:	7812      	ldrb	r2, [r2, #0]
 80199dc:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 80199de:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80199e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80199e6:	4413      	add	r3, r2
 80199e8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80199ea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 80199ee:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 80199f2:	441a      	add	r2, r3
 80199f4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80199f8:	3301      	adds	r3, #1
 80199fa:	7812      	ldrb	r2, [r2, #0]
 80199fc:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 80199fe:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8019a02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8019a06:	1ad3      	subs	r3, r2, r3
 8019a08:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019a0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8019a0e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8019a12:	441a      	add	r2, r3
 8019a14:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8019a18:	3304      	adds	r3, #4
 8019a1a:	7812      	ldrb	r2, [r2, #0]
 8019a1c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8019a1e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8019a22:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8019a26:	4413      	add	r3, r2
 8019a28:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019a2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8019a2e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8019a32:	441a      	add	r2, r3
 8019a34:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8019a38:	3302      	adds	r3, #2
 8019a3a:	7812      	ldrb	r2, [r2, #0]
 8019a3c:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8019a3e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8019a42:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8019a46:	1ad3      	subs	r3, r2, r3
 8019a48:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019a4a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8019a4e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8019a52:	441a      	add	r2, r3
 8019a54:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8019a58:	3303      	adds	r3, #3
 8019a5a:	7812      	ldrb	r2, [r2, #0]
 8019a5c:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8019a5e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8019a62:	3318      	adds	r3, #24
 8019a64:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  for (ctr = 0; ctr < 6; ctr++) {
 8019a68:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019a6c:	3301      	adds	r3, #1
 8019a6e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8019a72:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019a76:	2b05      	cmp	r3, #5
 8019a78:	f77f af03 	ble.w	8019882 <jpeg_idct_6x6+0x25e>
  }
}
 8019a7c:	bf00      	nop
 8019a7e:	bf00      	nop
 8019a80:	37e4      	adds	r7, #228	; 0xe4
 8019a82:	46bd      	mov	sp, r7
 8019a84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a88:	4770      	bx	lr
	...

08019a8c <jpeg_idct_5x5>:

GLOBAL(void)
jpeg_idct_5x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8019a8c:	b480      	push	{r7}
 8019a8e:	b0ad      	sub	sp, #180	; 0xb4
 8019a90:	af00      	add	r7, sp, #0
 8019a92:	60f8      	str	r0, [r7, #12]
 8019a94:	60b9      	str	r1, [r7, #8]
 8019a96:	607a      	str	r2, [r7, #4]
 8019a98:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8019a9a:	68fb      	ldr	r3, [r7, #12]
 8019a9c:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8019aa0:	3380      	adds	r3, #128	; 0x80
 8019aa2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  int workspace[5*5];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8019aa6:	687b      	ldr	r3, [r7, #4]
 8019aa8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8019aac:	68bb      	ldr	r3, [r7, #8]
 8019aae:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8019ab0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  wsptr = workspace;
 8019ab4:	f107 0314 	add.w	r3, r7, #20
 8019ab8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8019abc:	2300      	movs	r3, #0
 8019abe:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8019ac2:	e0dd      	b.n	8019c80 <jpeg_idct_5x5+0x1f4>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8019ac4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019ac8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019acc:	461a      	mov	r2, r3
 8019ace:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019ad2:	681b      	ldr	r3, [r3, #0]
 8019ad4:	fb03 f302 	mul.w	r3, r3, r2
 8019ad8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tmp12 <<= CONST_BITS;
 8019adc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8019ae0:	035b      	lsls	r3, r3, #13
 8019ae2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 8019ae6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8019aea:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8019aee:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8019af2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019af6:	3320      	adds	r3, #32
 8019af8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019afc:	461a      	mov	r2, r3
 8019afe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019b02:	3340      	adds	r3, #64	; 0x40
 8019b04:	681b      	ldr	r3, [r3, #0]
 8019b06:	fb03 f302 	mul.w	r3, r3, r2
 8019b0a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8019b0e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019b12:	3340      	adds	r3, #64	; 0x40
 8019b14:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019b18:	461a      	mov	r2, r3
 8019b1a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019b1e:	3380      	adds	r3, #128	; 0x80
 8019b20:	681b      	ldr	r3, [r3, #0]
 8019b22:	fb03 f302 	mul.w	r3, r3, r2
 8019b26:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 8019b2a:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8019b2e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019b32:	4413      	add	r3, r2
 8019b34:	f641 124c 	movw	r2, #6476	; 0x194c
 8019b38:	fb02 f303 	mul.w	r3, r2, r3
 8019b3c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 8019b40:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8019b44:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019b48:	1ad3      	subs	r3, r2, r3
 8019b4a:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 8019b4e:	fb02 f303 	mul.w	r3, r2, r3
 8019b52:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    z3 = tmp12 + z2;
 8019b56:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8019b5a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019b5e:	4413      	add	r3, r2
 8019b60:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    tmp10 = z3 + z1;
 8019b64:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8019b68:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8019b6c:	4413      	add	r3, r2
 8019b6e:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp11 = z3 - z1;
 8019b70:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8019b74:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8019b78:	1ad3      	subs	r3, r2, r3
 8019b7a:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp12 -= z2 << 2;
 8019b7c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019b80:	009b      	lsls	r3, r3, #2
 8019b82:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8019b86:	1ad3      	subs	r3, r2, r3
 8019b88:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8019b8c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019b90:	3310      	adds	r3, #16
 8019b92:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019b96:	461a      	mov	r2, r3
 8019b98:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019b9c:	3320      	adds	r3, #32
 8019b9e:	681b      	ldr	r3, [r3, #0]
 8019ba0:	fb03 f302 	mul.w	r3, r3, r2
 8019ba4:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8019ba8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019bac:	3330      	adds	r3, #48	; 0x30
 8019bae:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019bb2:	461a      	mov	r2, r3
 8019bb4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019bb8:	3360      	adds	r3, #96	; 0x60
 8019bba:	681b      	ldr	r3, [r3, #0]
 8019bbc:	fb03 f302 	mul.w	r3, r3, r2
 8019bc0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 8019bc4:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8019bc8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019bcc:	4413      	add	r3, r2
 8019bce:	f641 229a 	movw	r2, #6810	; 0x1a9a
 8019bd2:	fb02 f303 	mul.w	r3, r2, r3
 8019bd6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 8019bda:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019bde:	f241 0271 	movw	r2, #4209	; 0x1071
 8019be2:	fb02 f303 	mul.w	r3, r2, r3
 8019be6:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8019bea:	4413      	add	r3, r2
 8019bec:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 8019bf0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019bf4:	4a97      	ldr	r2, [pc, #604]	; (8019e54 <jpeg_idct_5x5+0x3c8>)
 8019bf6:	fb02 f303 	mul.w	r3, r2, r3
 8019bfa:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8019bfe:	4413      	add	r3, r2
 8019c00:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 8019c04:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8019c06:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8019c0a:	4413      	add	r3, r2
 8019c0c:	12da      	asrs	r2, r3, #11
 8019c0e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c12:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 8019c14:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8019c16:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8019c1a:	1ad2      	subs	r2, r2, r3
 8019c1c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c20:	3350      	adds	r3, #80	; 0x50
 8019c22:	12d2      	asrs	r2, r2, #11
 8019c24:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 8019c26:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8019c28:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019c2c:	441a      	add	r2, r3
 8019c2e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c32:	3314      	adds	r3, #20
 8019c34:	12d2      	asrs	r2, r2, #11
 8019c36:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 8019c38:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8019c3a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019c3e:	1ad2      	subs	r2, r2, r3
 8019c40:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c44:	333c      	adds	r3, #60	; 0x3c
 8019c46:	12d2      	asrs	r2, r2, #11
 8019c48:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 8019c4a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c4e:	3328      	adds	r3, #40	; 0x28
 8019c50:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8019c54:	12d2      	asrs	r2, r2, #11
 8019c56:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8019c58:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8019c5c:	3301      	adds	r3, #1
 8019c5e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8019c62:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8019c66:	3302      	adds	r3, #2
 8019c68:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8019c6c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019c70:	3304      	adds	r3, #4
 8019c72:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8019c76:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019c7a:	3304      	adds	r3, #4
 8019c7c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8019c80:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8019c84:	2b04      	cmp	r3, #4
 8019c86:	f77f af1d 	ble.w	8019ac4 <jpeg_idct_5x5+0x38>
  }

  /* Pass 2: process 5 rows from work array, store into output array. */

  wsptr = workspace;
 8019c8a:	f107 0314 	add.w	r3, r7, #20
 8019c8e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 8019c92:	2300      	movs	r3, #0
 8019c94:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8019c98:	e0d0      	b.n	8019e3c <jpeg_idct_5x5+0x3b0>
    outptr = output_buf[ctr] + output_col;
 8019c9a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8019c9e:	009b      	lsls	r3, r3, #2
 8019ca0:	683a      	ldr	r2, [r7, #0]
 8019ca2:	4413      	add	r3, r2
 8019ca4:	681a      	ldr	r2, [r3, #0]
 8019ca6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8019caa:	4413      	add	r3, r2
 8019cac:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8019cb0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019cb4:	681b      	ldr	r3, [r3, #0]
 8019cb6:	3310      	adds	r3, #16
 8019cb8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tmp12 <<= CONST_BITS;
 8019cbc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8019cc0:	035b      	lsls	r3, r3, #13
 8019cc2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tmp0 = (INT32) wsptr[2];
 8019cc6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019cca:	3308      	adds	r3, #8
 8019ccc:	681b      	ldr	r3, [r3, #0]
 8019cce:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    tmp1 = (INT32) wsptr[4];
 8019cd2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019cd6:	3310      	adds	r3, #16
 8019cd8:	681b      	ldr	r3, [r3, #0]
 8019cda:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */
 8019cde:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8019ce2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019ce6:	4413      	add	r3, r2
 8019ce8:	f641 124c 	movw	r2, #6476	; 0x194c
 8019cec:	fb02 f303 	mul.w	r3, r2, r3
 8019cf0:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */
 8019cf4:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8019cf8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019cfc:	1ad3      	subs	r3, r2, r3
 8019cfe:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 8019d02:	fb02 f303 	mul.w	r3, r2, r3
 8019d06:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    z3 = tmp12 + z2;
 8019d0a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8019d0e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019d12:	4413      	add	r3, r2
 8019d14:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    tmp10 = z3 + z1;
 8019d18:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8019d1c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8019d20:	4413      	add	r3, r2
 8019d22:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp11 = z3 - z1;
 8019d24:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8019d28:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8019d2c:	1ad3      	subs	r3, r2, r3
 8019d2e:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp12 -= z2 << 2;
 8019d30:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019d34:	009b      	lsls	r3, r3, #2
 8019d36:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8019d3a:	1ad3      	subs	r3, r2, r3
 8019d3c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Odd part */

    z2 = (INT32) wsptr[1];
 8019d40:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019d44:	3304      	adds	r3, #4
 8019d46:	681b      	ldr	r3, [r3, #0]
 8019d48:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    z3 = (INT32) wsptr[3];
 8019d4c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019d50:	330c      	adds	r3, #12
 8019d52:	681b      	ldr	r3, [r3, #0]
 8019d54:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */
 8019d58:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8019d5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019d60:	4413      	add	r3, r2
 8019d62:	f641 229a 	movw	r2, #6810	; 0x1a9a
 8019d66:	fb02 f303 	mul.w	r3, r2, r3
 8019d6a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */
 8019d6e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019d72:	f241 0271 	movw	r2, #4209	; 0x1071
 8019d76:	fb02 f303 	mul.w	r3, r2, r3
 8019d7a:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8019d7e:	4413      	add	r3, r2
 8019d80:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */
 8019d84:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019d88:	4a32      	ldr	r2, [pc, #200]	; (8019e54 <jpeg_idct_5x5+0x3c8>)
 8019d8a:	fb02 f303 	mul.w	r3, r2, r3
 8019d8e:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8019d92:	4413      	add	r3, r2
 8019d94:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8019d98:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8019d9a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8019d9e:	4413      	add	r3, r2
 8019da0:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019da2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8019da6:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019daa:	4413      	add	r3, r2
 8019dac:	781a      	ldrb	r2, [r3, #0]
 8019dae:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8019db2:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8019db4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8019db6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8019dba:	1ad3      	subs	r3, r2, r3
 8019dbc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019dbe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8019dc2:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019dc6:	441a      	add	r2, r3
 8019dc8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8019dcc:	3304      	adds	r3, #4
 8019dce:	7812      	ldrb	r2, [r2, #0]
 8019dd0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8019dd2:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8019dd4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019dd8:	4413      	add	r3, r2
 8019dda:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019ddc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8019de0:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019de4:	441a      	add	r2, r3
 8019de6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8019dea:	3301      	adds	r3, #1
 8019dec:	7812      	ldrb	r2, [r2, #0]
 8019dee:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8019df0:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8019df2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8019df6:	1ad3      	subs	r3, r2, r3
 8019df8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019dfa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8019dfe:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019e02:	441a      	add	r2, r3
 8019e04:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8019e08:	3303      	adds	r3, #3
 8019e0a:	7812      	ldrb	r2, [r2, #0]
 8019e0c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8019e0e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8019e12:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8019e14:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8019e18:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019e1c:	441a      	add	r2, r3
 8019e1e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8019e22:	3302      	adds	r3, #2
 8019e24:	7812      	ldrb	r2, [r2, #0]
 8019e26:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 8019e28:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8019e2c:	3314      	adds	r3, #20
 8019e2e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  for (ctr = 0; ctr < 5; ctr++) {
 8019e32:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8019e36:	3301      	adds	r3, #1
 8019e38:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8019e3c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8019e40:	2b04      	cmp	r3, #4
 8019e42:	f77f af2a 	ble.w	8019c9a <jpeg_idct_5x5+0x20e>
  }
}
 8019e46:	bf00      	nop
 8019e48:	bf00      	nop
 8019e4a:	37b4      	adds	r7, #180	; 0xb4
 8019e4c:	46bd      	mov	sp, r7
 8019e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e52:	4770      	bx	lr
 8019e54:	ffffba5c 	.word	0xffffba5c

08019e58 <jpeg_idct_4x4>:

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8019e58:	b480      	push	{r7}
 8019e5a:	b0a3      	sub	sp, #140	; 0x8c
 8019e5c:	af00      	add	r7, sp, #0
 8019e5e:	60f8      	str	r0, [r7, #12]
 8019e60:	60b9      	str	r1, [r7, #8]
 8019e62:	607a      	str	r2, [r7, #4]
 8019e64:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8019e66:	68fb      	ldr	r3, [r7, #12]
 8019e68:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8019e6c:	3380      	adds	r3, #128	; 0x80
 8019e6e:	677b      	str	r3, [r7, #116]	; 0x74
  int workspace[4*4];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8019e70:	687b      	ldr	r3, [r7, #4]
 8019e72:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8019e76:	68bb      	ldr	r3, [r7, #8]
 8019e78:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8019e7a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  wsptr = workspace;
 8019e7e:	f107 0314 	add.w	r3, r7, #20
 8019e82:	67fb      	str	r3, [r7, #124]	; 0x7c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8019e84:	2300      	movs	r3, #0
 8019e86:	67bb      	str	r3, [r7, #120]	; 0x78
 8019e88:	e07f      	b.n	8019f8a <jpeg_idct_4x4+0x132>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8019e8a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019e8e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019e92:	461a      	mov	r2, r3
 8019e94:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019e98:	681b      	ldr	r3, [r3, #0]
 8019e9a:	fb03 f302 	mul.w	r3, r3, r2
 8019e9e:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8019ea0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019ea4:	3320      	adds	r3, #32
 8019ea6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019eaa:	461a      	mov	r2, r3
 8019eac:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019eb0:	3340      	adds	r3, #64	; 0x40
 8019eb2:	681b      	ldr	r3, [r3, #0]
 8019eb4:	fb03 f302 	mul.w	r3, r3, r2
 8019eb8:	66bb      	str	r3, [r7, #104]	; 0x68
    
    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 8019eba:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8019ebc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019ebe:	4413      	add	r3, r2
 8019ec0:	009b      	lsls	r3, r3, #2
 8019ec2:	667b      	str	r3, [r7, #100]	; 0x64
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 8019ec4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8019ec6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019ec8:	1ad3      	subs	r3, r2, r3
 8019eca:	009b      	lsls	r3, r3, #2
 8019ecc:	663b      	str	r3, [r7, #96]	; 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8019ece:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019ed2:	3310      	adds	r3, #16
 8019ed4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019ed8:	461a      	mov	r2, r3
 8019eda:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019ede:	3320      	adds	r3, #32
 8019ee0:	681b      	ldr	r3, [r3, #0]
 8019ee2:	fb03 f302 	mul.w	r3, r3, r2
 8019ee6:	65fb      	str	r3, [r7, #92]	; 0x5c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8019ee8:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019eec:	3330      	adds	r3, #48	; 0x30
 8019eee:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019ef2:	461a      	mov	r2, r3
 8019ef4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019ef8:	3360      	adds	r3, #96	; 0x60
 8019efa:	681b      	ldr	r3, [r3, #0]
 8019efc:	fb03 f302 	mul.w	r3, r3, r2
 8019f00:	65bb      	str	r3, [r7, #88]	; 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 8019f02:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8019f04:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019f06:	4413      	add	r3, r2
 8019f08:	f241 1251 	movw	r2, #4433	; 0x1151
 8019f0c:	fb02 f303 	mul.w	r3, r2, r3
 8019f10:	657b      	str	r3, [r7, #84]	; 0x54
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8019f12:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019f14:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8019f18:	657b      	str	r3, [r7, #84]	; 0x54
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 8019f1a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019f1c:	f641 027e 	movw	r2, #6270	; 0x187e
 8019f20:	fb02 f203 	mul.w	r2, r2, r3
 8019f24:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019f26:	4413      	add	r3, r2
 8019f28:	12db      	asrs	r3, r3, #11
 8019f2a:	66fb      	str	r3, [r7, #108]	; 0x6c
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 8019f2c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019f2e:	4a58      	ldr	r2, [pc, #352]	; (801a090 <jpeg_idct_4x4+0x238>)
 8019f30:	fb02 f203 	mul.w	r2, r2, r3
 8019f34:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019f36:	4413      	add	r3, r2
 8019f38:	12db      	asrs	r3, r3, #11
 8019f3a:	66bb      	str	r3, [r7, #104]	; 0x68
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[4*0] = (int) (tmp10 + tmp0);
 8019f3c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8019f3e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019f40:	441a      	add	r2, r3
 8019f42:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019f44:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) (tmp10 - tmp0);
 8019f46:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019f48:	3330      	adds	r3, #48	; 0x30
 8019f4a:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8019f4c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8019f4e:	1a8a      	subs	r2, r1, r2
 8019f50:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) (tmp12 + tmp2);
 8019f52:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019f54:	3310      	adds	r3, #16
 8019f56:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8019f58:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019f5a:	440a      	add	r2, r1
 8019f5c:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) (tmp12 - tmp2);
 8019f5e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019f60:	3320      	adds	r3, #32
 8019f62:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8019f64:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019f66:	1a8a      	subs	r2, r1, r2
 8019f68:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8019f6a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019f6c:	3301      	adds	r3, #1
 8019f6e:	67bb      	str	r3, [r7, #120]	; 0x78
 8019f70:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8019f74:	3302      	adds	r3, #2
 8019f76:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8019f7a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8019f7e:	3304      	adds	r3, #4
 8019f80:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8019f84:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019f86:	3304      	adds	r3, #4
 8019f88:	67fb      	str	r3, [r7, #124]	; 0x7c
 8019f8a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019f8c:	2b03      	cmp	r3, #3
 8019f8e:	f77f af7c 	ble.w	8019e8a <jpeg_idct_4x4+0x32>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 8019f92:	f107 0314 	add.w	r3, r7, #20
 8019f96:	67fb      	str	r3, [r7, #124]	; 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 8019f98:	2300      	movs	r3, #0
 8019f9a:	67bb      	str	r3, [r7, #120]	; 0x78
 8019f9c:	e06e      	b.n	801a07c <jpeg_idct_4x4+0x224>
    outptr = output_buf[ctr] + output_col;
 8019f9e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019fa0:	009b      	lsls	r3, r3, #2
 8019fa2:	683a      	ldr	r2, [r7, #0]
 8019fa4:	4413      	add	r3, r2
 8019fa6:	681a      	ldr	r2, [r3, #0]
 8019fa8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8019fac:	4413      	add	r3, r2
 8019fae:	673b      	str	r3, [r7, #112]	; 0x70

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8019fb0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019fb2:	681b      	ldr	r3, [r3, #0]
 8019fb4:	3310      	adds	r3, #16
 8019fb6:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp2 = (INT32) wsptr[2];
 8019fb8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019fba:	3308      	adds	r3, #8
 8019fbc:	681b      	ldr	r3, [r3, #0]
 8019fbe:	66bb      	str	r3, [r7, #104]	; 0x68

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 8019fc0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8019fc2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019fc4:	4413      	add	r3, r2
 8019fc6:	035b      	lsls	r3, r3, #13
 8019fc8:	667b      	str	r3, [r7, #100]	; 0x64
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8019fca:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8019fcc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019fce:	1ad3      	subs	r3, r2, r3
 8019fd0:	035b      	lsls	r3, r3, #13
 8019fd2:	663b      	str	r3, [r7, #96]	; 0x60

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 8019fd4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019fd6:	3304      	adds	r3, #4
 8019fd8:	681b      	ldr	r3, [r3, #0]
 8019fda:	65fb      	str	r3, [r7, #92]	; 0x5c
    z3 = (INT32) wsptr[3];
 8019fdc:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019fde:	330c      	adds	r3, #12
 8019fe0:	681b      	ldr	r3, [r3, #0]
 8019fe2:	65bb      	str	r3, [r7, #88]	; 0x58

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 8019fe4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8019fe6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019fe8:	4413      	add	r3, r2
 8019fea:	f241 1251 	movw	r2, #4433	; 0x1151
 8019fee:	fb02 f303 	mul.w	r3, r2, r3
 8019ff2:	657b      	str	r3, [r7, #84]	; 0x54
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8019ff4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8019ff6:	f641 027e 	movw	r2, #6270	; 0x187e
 8019ffa:	fb02 f303 	mul.w	r3, r2, r3
 8019ffe:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801a000:	4413      	add	r3, r2
 801a002:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 801a004:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a006:	4a22      	ldr	r2, [pc, #136]	; (801a090 <jpeg_idct_4x4+0x238>)
 801a008:	fb02 f303 	mul.w	r3, r2, r3
 801a00c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801a00e:	4413      	add	r3, r2
 801a010:	66bb      	str	r3, [r7, #104]	; 0x68

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a012:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801a014:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a016:	4413      	add	r3, r2
 801a018:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a01a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a01e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801a020:	4413      	add	r3, r2
 801a022:	781a      	ldrb	r2, [r3, #0]
 801a024:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801a026:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a028:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801a02a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801a02c:	1ad3      	subs	r3, r2, r3
 801a02e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a030:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a034:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801a036:	441a      	add	r2, r3
 801a038:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801a03a:	3303      	adds	r3, #3
 801a03c:	7812      	ldrb	r2, [r2, #0]
 801a03e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801a040:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a042:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801a044:	4413      	add	r3, r2
 801a046:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a048:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801a04c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801a04e:	441a      	add	r2, r3
 801a050:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801a052:	3301      	adds	r3, #1
 801a054:	7812      	ldrb	r2, [r2, #0]
 801a056:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801a058:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a05a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801a05c:	1ad3      	subs	r3, r2, r3
 801a05e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a060:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801a064:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801a066:	441a      	add	r2, r3
 801a068:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801a06a:	3302      	adds	r3, #2
 801a06c:	7812      	ldrb	r2, [r2, #0]
 801a06e:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 801a070:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801a072:	3310      	adds	r3, #16
 801a074:	67fb      	str	r3, [r7, #124]	; 0x7c
  for (ctr = 0; ctr < 4; ctr++) {
 801a076:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801a078:	3301      	adds	r3, #1
 801a07a:	67bb      	str	r3, [r7, #120]	; 0x78
 801a07c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801a07e:	2b03      	cmp	r3, #3
 801a080:	dd8d      	ble.n	8019f9e <jpeg_idct_4x4+0x146>
  }
}
 801a082:	bf00      	nop
 801a084:	bf00      	nop
 801a086:	378c      	adds	r7, #140	; 0x8c
 801a088:	46bd      	mov	sp, r7
 801a08a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a08e:	4770      	bx	lr
 801a090:	ffffc4df 	.word	0xffffc4df

0801a094 <jpeg_idct_3x3>:

GLOBAL(void)
jpeg_idct_3x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801a094:	b480      	push	{r7}
 801a096:	b099      	sub	sp, #100	; 0x64
 801a098:	af00      	add	r7, sp, #0
 801a09a:	60f8      	str	r0, [r7, #12]
 801a09c:	60b9      	str	r1, [r7, #8]
 801a09e:	607a      	str	r2, [r7, #4]
 801a0a0:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp2, tmp10, tmp12;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801a0a2:	68fb      	ldr	r3, [r7, #12]
 801a0a4:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801a0a8:	3380      	adds	r3, #128	; 0x80
 801a0aa:	64fb      	str	r3, [r7, #76]	; 0x4c
  int workspace[3*3];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801a0ac:	687b      	ldr	r3, [r7, #4]
 801a0ae:	65fb      	str	r3, [r7, #92]	; 0x5c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801a0b0:	68bb      	ldr	r3, [r7, #8]
 801a0b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a0b4:	65bb      	str	r3, [r7, #88]	; 0x58
  wsptr = workspace;
 801a0b6:	f107 0314 	add.w	r3, r7, #20
 801a0ba:	657b      	str	r3, [r7, #84]	; 0x54
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 801a0bc:	2300      	movs	r3, #0
 801a0be:	653b      	str	r3, [r7, #80]	; 0x50
 801a0c0:	e059      	b.n	801a176 <jpeg_idct_3x3+0xe2>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801a0c2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a0c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a0c8:	461a      	mov	r2, r3
 801a0ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a0cc:	681b      	ldr	r3, [r3, #0]
 801a0ce:	fb03 f302 	mul.w	r3, r3, r2
 801a0d2:	647b      	str	r3, [r7, #68]	; 0x44
    tmp0 <<= CONST_BITS;
 801a0d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a0d6:	035b      	lsls	r3, r3, #13
 801a0d8:	647b      	str	r3, [r7, #68]	; 0x44
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801a0da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a0dc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801a0e0:	647b      	str	r3, [r7, #68]	; 0x44
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801a0e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a0e4:	3320      	adds	r3, #32
 801a0e6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a0ea:	461a      	mov	r2, r3
 801a0ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a0ee:	3340      	adds	r3, #64	; 0x40
 801a0f0:	681b      	ldr	r3, [r3, #0]
 801a0f2:	fb03 f302 	mul.w	r3, r3, r2
 801a0f6:	643b      	str	r3, [r7, #64]	; 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 801a0f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a0fa:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a0fe:	fb02 f303 	mul.w	r3, r2, r3
 801a102:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmp10 = tmp0 + tmp12;
 801a104:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a106:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a108:	4413      	add	r3, r2
 801a10a:	63bb      	str	r3, [r7, #56]	; 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 801a10c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a10e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a110:	1ad2      	subs	r2, r2, r3
 801a112:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a114:	1ad3      	subs	r3, r2, r3
 801a116:	643b      	str	r3, [r7, #64]	; 0x40

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801a118:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a11a:	3310      	adds	r3, #16
 801a11c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a120:	461a      	mov	r2, r3
 801a122:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a124:	3320      	adds	r3, #32
 801a126:	681b      	ldr	r3, [r3, #0]
 801a128:	fb03 f302 	mul.w	r3, r3, r2
 801a12c:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 801a12e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a130:	f242 7231 	movw	r2, #10033	; 0x2731
 801a134:	fb02 f303 	mul.w	r3, r2, r3
 801a138:	647b      	str	r3, [r7, #68]	; 0x44

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801a13a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a13c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a13e:	4413      	add	r3, r2
 801a140:	12da      	asrs	r2, r3, #11
 801a142:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a144:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801a146:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a148:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a14a:	1ad2      	subs	r2, r2, r3
 801a14c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a14e:	3318      	adds	r3, #24
 801a150:	12d2      	asrs	r2, r2, #11
 801a152:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 801a154:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a156:	330c      	adds	r3, #12
 801a158:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a15a:	12d2      	asrs	r2, r2, #11
 801a15c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 801a15e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a160:	3301      	adds	r3, #1
 801a162:	653b      	str	r3, [r7, #80]	; 0x50
 801a164:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a166:	3302      	adds	r3, #2
 801a168:	65fb      	str	r3, [r7, #92]	; 0x5c
 801a16a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a16c:	3304      	adds	r3, #4
 801a16e:	65bb      	str	r3, [r7, #88]	; 0x58
 801a170:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a172:	3304      	adds	r3, #4
 801a174:	657b      	str	r3, [r7, #84]	; 0x54
 801a176:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a178:	2b02      	cmp	r3, #2
 801a17a:	dda2      	ble.n	801a0c2 <jpeg_idct_3x3+0x2e>
  }

  /* Pass 2: process 3 rows from work array, store into output array. */

  wsptr = workspace;
 801a17c:	f107 0314 	add.w	r3, r7, #20
 801a180:	657b      	str	r3, [r7, #84]	; 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 801a182:	2300      	movs	r3, #0
 801a184:	653b      	str	r3, [r7, #80]	; 0x50
 801a186:	e053      	b.n	801a230 <jpeg_idct_3x3+0x19c>
    outptr = output_buf[ctr] + output_col;
 801a188:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a18a:	009b      	lsls	r3, r3, #2
 801a18c:	683a      	ldr	r2, [r7, #0]
 801a18e:	4413      	add	r3, r2
 801a190:	681a      	ldr	r2, [r3, #0]
 801a192:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801a194:	4413      	add	r3, r2
 801a196:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801a198:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a19a:	681b      	ldr	r3, [r3, #0]
 801a19c:	3310      	adds	r3, #16
 801a19e:	647b      	str	r3, [r7, #68]	; 0x44
    tmp0 <<= CONST_BITS;
 801a1a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a1a2:	035b      	lsls	r3, r3, #13
 801a1a4:	647b      	str	r3, [r7, #68]	; 0x44
    tmp2 = (INT32) wsptr[2];
 801a1a6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a1a8:	3308      	adds	r3, #8
 801a1aa:	681b      	ldr	r3, [r3, #0]
 801a1ac:	643b      	str	r3, [r7, #64]	; 0x40
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 801a1ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a1b0:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a1b4:	fb02 f303 	mul.w	r3, r2, r3
 801a1b8:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmp10 = tmp0 + tmp12;
 801a1ba:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a1bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a1be:	4413      	add	r3, r2
 801a1c0:	63bb      	str	r3, [r7, #56]	; 0x38
    tmp2 = tmp0 - tmp12 - tmp12;
 801a1c2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a1c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a1c6:	1ad2      	subs	r2, r2, r3
 801a1c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a1ca:	1ad3      	subs	r3, r2, r3
 801a1cc:	643b      	str	r3, [r7, #64]	; 0x40

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 801a1ce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a1d0:	3304      	adds	r3, #4
 801a1d2:	681b      	ldr	r3, [r3, #0]
 801a1d4:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 801a1d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a1d8:	f242 7231 	movw	r2, #10033	; 0x2731
 801a1dc:	fb02 f303 	mul.w	r3, r2, r3
 801a1e0:	647b      	str	r3, [r7, #68]	; 0x44

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a1e2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a1e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a1e6:	4413      	add	r3, r2
 801a1e8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a1ea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a1ee:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801a1f0:	4413      	add	r3, r2
 801a1f2:	781a      	ldrb	r2, [r3, #0]
 801a1f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a1f6:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a1f8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a1fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a1fc:	1ad3      	subs	r3, r2, r3
 801a1fe:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a200:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a204:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801a206:	441a      	add	r2, r3
 801a208:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a20a:	3302      	adds	r3, #2
 801a20c:	7812      	ldrb	r2, [r2, #0]
 801a20e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 801a210:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a212:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a214:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 801a218:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801a21a:	441a      	add	r2, r3
 801a21c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a21e:	3301      	adds	r3, #1
 801a220:	7812      	ldrb	r2, [r2, #0]
 801a222:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 801a224:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a226:	330c      	adds	r3, #12
 801a228:	657b      	str	r3, [r7, #84]	; 0x54
  for (ctr = 0; ctr < 3; ctr++) {
 801a22a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a22c:	3301      	adds	r3, #1
 801a22e:	653b      	str	r3, [r7, #80]	; 0x50
 801a230:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a232:	2b02      	cmp	r3, #2
 801a234:	dda8      	ble.n	801a188 <jpeg_idct_3x3+0xf4>
  }
}
 801a236:	bf00      	nop
 801a238:	bf00      	nop
 801a23a:	3764      	adds	r7, #100	; 0x64
 801a23c:	46bd      	mov	sp, r7
 801a23e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a242:	4770      	bx	lr

0801a244 <jpeg_idct_2x2>:

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801a244:	b480      	push	{r7}
 801a246:	b08f      	sub	sp, #60	; 0x3c
 801a248:	af00      	add	r7, sp, #0
 801a24a:	60f8      	str	r0, [r7, #12]
 801a24c:	60b9      	str	r1, [r7, #8]
 801a24e:	607a      	str	r2, [r7, #4]
 801a250:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801a252:	68fb      	ldr	r3, [r7, #12]
 801a254:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801a258:	3380      	adds	r3, #128	; 0x80
 801a25a:	637b      	str	r3, [r7, #52]	; 0x34
  SHIFT_TEMPS

  /* Pass 1: process columns from input. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801a25c:	68bb      	ldr	r3, [r7, #8]
 801a25e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a260:	633b      	str	r3, [r7, #48]	; 0x30

  /* Column 0 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801a262:	687b      	ldr	r3, [r7, #4]
 801a264:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a268:	461a      	mov	r2, r3
 801a26a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a26c:	681b      	ldr	r3, [r3, #0]
 801a26e:	fb03 f302 	mul.w	r3, r3, r2
 801a272:	62fb      	str	r3, [r7, #44]	; 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801a274:	687b      	ldr	r3, [r7, #4]
 801a276:	3310      	adds	r3, #16
 801a278:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a27c:	461a      	mov	r2, r3
 801a27e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a280:	3320      	adds	r3, #32
 801a282:	681b      	ldr	r3, [r3, #0]
 801a284:	fb03 f302 	mul.w	r3, r3, r2
 801a288:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Add fudge factor here for final descale. */
  tmp4 += ONE << 2;
 801a28a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a28c:	3304      	adds	r3, #4
 801a28e:	62fb      	str	r3, [r7, #44]	; 0x2c

  tmp0 = tmp4 + tmp5;
 801a290:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a292:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a294:	4413      	add	r3, r2
 801a296:	627b      	str	r3, [r7, #36]	; 0x24
  tmp2 = tmp4 - tmp5;
 801a298:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a29a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a29c:	1ad3      	subs	r3, r2, r3
 801a29e:	623b      	str	r3, [r7, #32]

  /* Column 1 */
  tmp4 = DEQUANTIZE(coef_block[DCTSIZE*0+1], quantptr[DCTSIZE*0+1]);
 801a2a0:	687b      	ldr	r3, [r7, #4]
 801a2a2:	3302      	adds	r3, #2
 801a2a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a2a8:	461a      	mov	r2, r3
 801a2aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a2ac:	3304      	adds	r3, #4
 801a2ae:	681b      	ldr	r3, [r3, #0]
 801a2b0:	fb03 f302 	mul.w	r3, r3, r2
 801a2b4:	62fb      	str	r3, [r7, #44]	; 0x2c
  tmp5 = DEQUANTIZE(coef_block[DCTSIZE*1+1], quantptr[DCTSIZE*1+1]);
 801a2b6:	687b      	ldr	r3, [r7, #4]
 801a2b8:	3312      	adds	r3, #18
 801a2ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a2be:	461a      	mov	r2, r3
 801a2c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a2c2:	3324      	adds	r3, #36	; 0x24
 801a2c4:	681b      	ldr	r3, [r3, #0]
 801a2c6:	fb03 f302 	mul.w	r3, r3, r2
 801a2ca:	62bb      	str	r3, [r7, #40]	; 0x28

  tmp1 = tmp4 + tmp5;
 801a2cc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a2ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a2d0:	4413      	add	r3, r2
 801a2d2:	61fb      	str	r3, [r7, #28]
  tmp3 = tmp4 - tmp5;
 801a2d4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a2d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a2d8:	1ad3      	subs	r3, r2, r3
 801a2da:	61bb      	str	r3, [r7, #24]

  /* Pass 2: process 2 rows, store into output array. */

  /* Row 0 */
  outptr = output_buf[0] + output_col;
 801a2dc:	683b      	ldr	r3, [r7, #0]
 801a2de:	681a      	ldr	r2, [r3, #0]
 801a2e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a2e2:	4413      	add	r3, r2
 801a2e4:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp0 + tmp1, 3) & RANGE_MASK];
 801a2e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a2e8:	69fb      	ldr	r3, [r7, #28]
 801a2ea:	4413      	add	r3, r2
 801a2ec:	10db      	asrs	r3, r3, #3
 801a2ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801a2f2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a2f4:	4413      	add	r3, r2
 801a2f6:	781a      	ldrb	r2, [r3, #0]
 801a2f8:	697b      	ldr	r3, [r7, #20]
 801a2fa:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp0 - tmp1, 3) & RANGE_MASK];
 801a2fc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a2fe:	69fb      	ldr	r3, [r7, #28]
 801a300:	1ad3      	subs	r3, r2, r3
 801a302:	10db      	asrs	r3, r3, #3
 801a304:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801a308:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a30a:	441a      	add	r2, r3
 801a30c:	697b      	ldr	r3, [r7, #20]
 801a30e:	3301      	adds	r3, #1
 801a310:	7812      	ldrb	r2, [r2, #0]
 801a312:	701a      	strb	r2, [r3, #0]

  /* Row 1 */
  outptr = output_buf[1] + output_col;
 801a314:	683b      	ldr	r3, [r7, #0]
 801a316:	3304      	adds	r3, #4
 801a318:	681a      	ldr	r2, [r3, #0]
 801a31a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a31c:	4413      	add	r3, r2
 801a31e:	617b      	str	r3, [r7, #20]

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp2 + tmp3, 3) & RANGE_MASK];
 801a320:	6a3a      	ldr	r2, [r7, #32]
 801a322:	69bb      	ldr	r3, [r7, #24]
 801a324:	4413      	add	r3, r2
 801a326:	10db      	asrs	r3, r3, #3
 801a328:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801a32c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a32e:	4413      	add	r3, r2
 801a330:	781a      	ldrb	r2, [r3, #0]
 801a332:	697b      	ldr	r3, [r7, #20]
 801a334:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2 - tmp3, 3) & RANGE_MASK];
 801a336:	6a3a      	ldr	r2, [r7, #32]
 801a338:	69bb      	ldr	r3, [r7, #24]
 801a33a:	1ad3      	subs	r3, r2, r3
 801a33c:	10db      	asrs	r3, r3, #3
 801a33e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801a342:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a344:	441a      	add	r2, r3
 801a346:	697b      	ldr	r3, [r7, #20]
 801a348:	3301      	adds	r3, #1
 801a34a:	7812      	ldrb	r2, [r2, #0]
 801a34c:	701a      	strb	r2, [r3, #0]
}
 801a34e:	bf00      	nop
 801a350:	373c      	adds	r7, #60	; 0x3c
 801a352:	46bd      	mov	sp, r7
 801a354:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a358:	4770      	bx	lr

0801a35a <jpeg_idct_1x1>:

GLOBAL(void)
jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801a35a:	b480      	push	{r7}
 801a35c:	b089      	sub	sp, #36	; 0x24
 801a35e:	af00      	add	r7, sp, #0
 801a360:	60f8      	str	r0, [r7, #12]
 801a362:	60b9      	str	r1, [r7, #8]
 801a364:	607a      	str	r2, [r7, #4]
 801a366:	603b      	str	r3, [r7, #0]
  int dcval;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801a368:	68fb      	ldr	r3, [r7, #12]
 801a36a:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801a36e:	3380      	adds	r3, #128	; 0x80
 801a370:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* 1x1 is trivial: just take the DC coefficient divided by 8. */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801a372:	68bb      	ldr	r3, [r7, #8]
 801a374:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a376:	61bb      	str	r3, [r7, #24]
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
 801a378:	687b      	ldr	r3, [r7, #4]
 801a37a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a37e:	461a      	mov	r2, r3
 801a380:	69bb      	ldr	r3, [r7, #24]
 801a382:	681b      	ldr	r3, [r3, #0]
 801a384:	fb03 f302 	mul.w	r3, r3, r2
 801a388:	617b      	str	r3, [r7, #20]
  dcval = (int) DESCALE((INT32) dcval, 3);
 801a38a:	697b      	ldr	r3, [r7, #20]
 801a38c:	3304      	adds	r3, #4
 801a38e:	10db      	asrs	r3, r3, #3
 801a390:	617b      	str	r3, [r7, #20]

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
 801a392:	697b      	ldr	r3, [r7, #20]
 801a394:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801a398:	69fa      	ldr	r2, [r7, #28]
 801a39a:	441a      	add	r2, r3
 801a39c:	683b      	ldr	r3, [r7, #0]
 801a39e:	6819      	ldr	r1, [r3, #0]
 801a3a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a3a2:	440b      	add	r3, r1
 801a3a4:	7812      	ldrb	r2, [r2, #0]
 801a3a6:	701a      	strb	r2, [r3, #0]
}
 801a3a8:	bf00      	nop
 801a3aa:	3724      	adds	r7, #36	; 0x24
 801a3ac:	46bd      	mov	sp, r7
 801a3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a3b2:	4770      	bx	lr

0801a3b4 <jpeg_idct_9x9>:

GLOBAL(void)
jpeg_idct_9x9 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801a3b4:	b490      	push	{r4, r7}
 801a3b6:	b0e0      	sub	sp, #384	; 0x180
 801a3b8:	af00      	add	r7, sp, #0
 801a3ba:	f107 040c 	add.w	r4, r7, #12
 801a3be:	6020      	str	r0, [r4, #0]
 801a3c0:	f107 0008 	add.w	r0, r7, #8
 801a3c4:	6001      	str	r1, [r0, #0]
 801a3c6:	1d39      	adds	r1, r7, #4
 801a3c8:	600a      	str	r2, [r1, #0]
 801a3ca:	463a      	mov	r2, r7
 801a3cc:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801a3ce:	f107 030c 	add.w	r3, r7, #12
 801a3d2:	681b      	ldr	r3, [r3, #0]
 801a3d4:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801a3d8:	3380      	adds	r3, #128	; 0x80
 801a3da:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
  int workspace[8*9];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801a3de:	1d3b      	adds	r3, r7, #4
 801a3e0:	681b      	ldr	r3, [r3, #0]
 801a3e2:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801a3e6:	f107 0308 	add.w	r3, r7, #8
 801a3ea:	681b      	ldr	r3, [r3, #0]
 801a3ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a3ee:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
  wsptr = workspace;
 801a3f2:	f107 0314 	add.w	r3, r7, #20
 801a3f6:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801a3fa:	2300      	movs	r3, #0
 801a3fc:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801a400:	e1a5      	b.n	801a74e <jpeg_idct_9x9+0x39a>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801a402:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a406:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a40a:	461a      	mov	r2, r3
 801a40c:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a410:	681b      	ldr	r3, [r3, #0]
 801a412:	fb03 f302 	mul.w	r3, r3, r2
 801a416:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp0 <<= CONST_BITS;
 801a41a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a41e:	035b      	lsls	r3, r3, #13
 801a420:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 801a424:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a428:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801a42c:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801a430:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a434:	3320      	adds	r3, #32
 801a436:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a43a:	461a      	mov	r2, r3
 801a43c:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a440:	3340      	adds	r3, #64	; 0x40
 801a442:	681b      	ldr	r3, [r3, #0]
 801a444:	fb03 f302 	mul.w	r3, r3, r2
 801a448:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801a44c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a450:	3340      	adds	r3, #64	; 0x40
 801a452:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a456:	461a      	mov	r2, r3
 801a458:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a45c:	3380      	adds	r3, #128	; 0x80
 801a45e:	681b      	ldr	r3, [r3, #0]
 801a460:	fb03 f302 	mul.w	r3, r3, r2
 801a464:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801a468:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a46c:	3360      	adds	r3, #96	; 0x60
 801a46e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a472:	461a      	mov	r2, r3
 801a474:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a478:	33c0      	adds	r3, #192	; 0xc0
 801a47a:	681b      	ldr	r3, [r3, #0]
 801a47c:	fb03 f302 	mul.w	r3, r3, r2
 801a480:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 801a484:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a488:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a48c:	fb02 f303 	mul.w	r3, r2, r3
 801a490:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp1 = tmp0 + tmp3;
 801a494:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801a498:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a49c:	4413      	add	r3, r2
 801a49e:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 801a4a2:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801a4a6:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a4aa:	1ad2      	subs	r2, r2, r3
 801a4ac:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a4b0:	1ad3      	subs	r3, r2, r3
 801a4b2:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 801a4b6:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a4ba:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a4be:	1ad3      	subs	r3, r2, r3
 801a4c0:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a4c4:	fb02 f303 	mul.w	r3, r2, r3
 801a4c8:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp11 = tmp2 + tmp0;
 801a4cc:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a4d0:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a4d4:	4413      	add	r3, r2
 801a4d6:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 801a4da:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a4de:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a4e2:	1ad2      	subs	r2, r2, r3
 801a4e4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a4e8:	1ad3      	subs	r3, r2, r3
 801a4ea:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 801a4ee:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a4f2:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a4f6:	4413      	add	r3, r2
 801a4f8:	f642 2287 	movw	r2, #10887	; 0x2a87
 801a4fc:	fb02 f303 	mul.w	r3, r2, r3
 801a500:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 801a504:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801a508:	f242 22ab 	movw	r2, #8875	; 0x22ab
 801a50c:	fb02 f303 	mul.w	r3, r2, r3
 801a510:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 801a514:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a518:	f240 72dc 	movw	r2, #2012	; 0x7dc
 801a51c:	fb02 f303 	mul.w	r3, r2, r3
 801a520:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 801a524:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a528:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a52c:	441a      	add	r2, r3
 801a52e:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a532:	1ad3      	subs	r3, r2, r3
 801a534:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 801a538:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a53c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a540:	1ad3      	subs	r3, r2, r3
 801a542:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a546:	4413      	add	r3, r2
 801a548:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 801a54c:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a550:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801a554:	1ad3      	subs	r3, r2, r3
 801a556:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801a55a:	4413      	add	r3, r2
 801a55c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801a560:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a564:	3310      	adds	r3, #16
 801a566:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a56a:	461a      	mov	r2, r3
 801a56c:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a570:	3320      	adds	r3, #32
 801a572:	681b      	ldr	r3, [r3, #0]
 801a574:	fb03 f302 	mul.w	r3, r3, r2
 801a578:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801a57c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a580:	3330      	adds	r3, #48	; 0x30
 801a582:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a586:	461a      	mov	r2, r3
 801a588:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a58c:	3360      	adds	r3, #96	; 0x60
 801a58e:	681b      	ldr	r3, [r3, #0]
 801a590:	fb03 f302 	mul.w	r3, r3, r2
 801a594:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801a598:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a59c:	3350      	adds	r3, #80	; 0x50
 801a59e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a5a2:	461a      	mov	r2, r3
 801a5a4:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a5a8:	33a0      	adds	r3, #160	; 0xa0
 801a5aa:	681b      	ldr	r3, [r3, #0]
 801a5ac:	fb03 f302 	mul.w	r3, r3, r2
 801a5b0:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801a5b4:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a5b8:	3370      	adds	r3, #112	; 0x70
 801a5ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a5be:	461a      	mov	r2, r3
 801a5c0:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a5c4:	33e0      	adds	r3, #224	; 0xe0
 801a5c6:	681b      	ldr	r3, [r3, #0]
 801a5c8:	fb03 f302 	mul.w	r3, r3, r2
 801a5cc:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 801a5d0:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a5d4:	4a64      	ldr	r2, [pc, #400]	; (801a768 <jpeg_idct_9x9+0x3b4>)
 801a5d6:	fb02 f303 	mul.w	r3, r2, r3
 801a5da:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 801a5de:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a5e2:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a5e6:	4413      	add	r3, r2
 801a5e8:	f641 5217 	movw	r2, #7447	; 0x1d17
 801a5ec:	fb02 f303 	mul.w	r3, r2, r3
 801a5f0:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 801a5f4:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a5f8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a5fc:	4413      	add	r3, r2
 801a5fe:	f640 727a 	movw	r2, #3962	; 0xf7a
 801a602:	fb02 f303 	mul.w	r3, r2, r3
 801a606:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp0 = tmp2 + tmp3 - z2;
 801a60a:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a60e:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a612:	441a      	add	r2, r3
 801a614:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a618:	1ad3      	subs	r3, r2, r3
 801a61a:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 801a61e:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801a622:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a626:	1ad3      	subs	r3, r2, r3
 801a628:	f642 4291 	movw	r2, #11409	; 0x2c91
 801a62c:	fb02 f303 	mul.w	r3, r2, r3
 801a630:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp2 += z2 - tmp1;
 801a634:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801a638:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a63c:	1ad3      	subs	r3, r2, r3
 801a63e:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a642:	4413      	add	r3, r2
 801a644:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 += z2 + tmp1;
 801a648:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801a64c:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a650:	4413      	add	r3, r2
 801a652:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801a656:	4413      	add	r3, r2
 801a658:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 801a65c:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a660:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a664:	1ad2      	subs	r2, r2, r3
 801a666:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a66a:	1ad3      	subs	r3, r2, r3
 801a66c:	f242 7231 	movw	r2, #10033	; 0x2731
 801a670:	fb02 f303 	mul.w	r3, r2, r3
 801a674:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 801a678:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801a67c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a680:	4413      	add	r3, r2
 801a682:	12da      	asrs	r2, r3, #11
 801a684:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a688:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 801a68a:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801a68e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a692:	1ad2      	subs	r2, r2, r3
 801a694:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a698:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801a69c:	12d2      	asrs	r2, r2, #11
 801a69e:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS-PASS1_BITS);
 801a6a0:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801a6a4:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a6a8:	441a      	add	r2, r3
 801a6aa:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a6ae:	3320      	adds	r3, #32
 801a6b0:	12d2      	asrs	r2, r2, #11
 801a6b2:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS-PASS1_BITS);
 801a6b4:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801a6b8:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a6bc:	1ad2      	subs	r2, r2, r3
 801a6be:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a6c2:	33e0      	adds	r3, #224	; 0xe0
 801a6c4:	12d2      	asrs	r2, r2, #11
 801a6c6:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 801a6c8:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801a6cc:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801a6d0:	441a      	add	r2, r3
 801a6d2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a6d6:	3340      	adds	r3, #64	; 0x40
 801a6d8:	12d2      	asrs	r2, r2, #11
 801a6da:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 801a6dc:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801a6e0:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801a6e4:	1ad2      	subs	r2, r2, r3
 801a6e6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a6ea:	33c0      	adds	r3, #192	; 0xc0
 801a6ec:	12d2      	asrs	r2, r2, #11
 801a6ee:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS-PASS1_BITS);
 801a6f0:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801a6f4:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a6f8:	441a      	add	r2, r3
 801a6fa:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a6fe:	3360      	adds	r3, #96	; 0x60
 801a700:	12d2      	asrs	r2, r2, #11
 801a702:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS-PASS1_BITS);
 801a704:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801a708:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a70c:	1ad2      	subs	r2, r2, r3
 801a70e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a712:	33a0      	adds	r3, #160	; 0xa0
 801a714:	12d2      	asrs	r2, r2, #11
 801a716:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp14, CONST_BITS-PASS1_BITS);
 801a718:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a71c:	3380      	adds	r3, #128	; 0x80
 801a71e:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801a722:	12d2      	asrs	r2, r2, #11
 801a724:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801a726:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801a72a:	3301      	adds	r3, #1
 801a72c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801a730:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801a734:	3302      	adds	r3, #2
 801a736:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 801a73a:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801a73e:	3304      	adds	r3, #4
 801a740:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 801a744:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a748:	3304      	adds	r3, #4
 801a74a:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 801a74e:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801a752:	2b07      	cmp	r3, #7
 801a754:	f77f ae55 	ble.w	801a402 <jpeg_idct_9x9+0x4e>
  }

  /* Pass 2: process 9 rows from work array, store into output array. */

  wsptr = workspace;
 801a758:	f107 0314 	add.w	r3, r7, #20
 801a75c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 801a760:	2300      	movs	r3, #0
 801a762:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801a766:	e19a      	b.n	801aa9e <jpeg_idct_9x9+0x6ea>
 801a768:	ffffd8cf 	.word	0xffffd8cf
    outptr = output_buf[ctr] + output_col;
 801a76c:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801a770:	009b      	lsls	r3, r3, #2
 801a772:	463a      	mov	r2, r7
 801a774:	6812      	ldr	r2, [r2, #0]
 801a776:	4413      	add	r3, r2
 801a778:	681a      	ldr	r2, [r3, #0]
 801a77a:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801a77e:	4413      	add	r3, r2
 801a780:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801a784:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a788:	681b      	ldr	r3, [r3, #0]
 801a78a:	3310      	adds	r3, #16
 801a78c:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp0 <<= CONST_BITS;
 801a790:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a794:	035b      	lsls	r3, r3, #13
 801a796:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164

    z1 = (INT32) wsptr[2];
 801a79a:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a79e:	3308      	adds	r3, #8
 801a7a0:	681b      	ldr	r3, [r3, #0]
 801a7a2:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = (INT32) wsptr[4];
 801a7a6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a7aa:	3310      	adds	r3, #16
 801a7ac:	681b      	ldr	r3, [r3, #0]
 801a7ae:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    z3 = (INT32) wsptr[6];
 801a7b2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a7b6:	3318      	adds	r3, #24
 801a7b8:	681b      	ldr	r3, [r3, #0]
 801a7ba:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */
 801a7be:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a7c2:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a7c6:	fb02 f303 	mul.w	r3, r2, r3
 801a7ca:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp1 = tmp0 + tmp3;
 801a7ce:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801a7d2:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a7d6:	4413      	add	r3, r2
 801a7d8:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp2 = tmp0 - tmp3 - tmp3;
 801a7dc:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801a7e0:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a7e4:	1ad2      	subs	r2, r2, r3
 801a7e6:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a7ea:	1ad3      	subs	r3, r2, r3
 801a7ec:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */
 801a7f0:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a7f4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a7f8:	1ad3      	subs	r3, r2, r3
 801a7fa:	f241 62a1 	movw	r2, #5793	; 0x16a1
 801a7fe:	fb02 f303 	mul.w	r3, r2, r3
 801a802:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp11 = tmp2 + tmp0;
 801a806:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a80a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a80e:	4413      	add	r3, r2
 801a810:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp14 = tmp2 - tmp0 - tmp0;
 801a814:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a818:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a81c:	1ad2      	subs	r2, r2, r3
 801a81e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a822:	1ad3      	subs	r3, r2, r3
 801a824:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */
 801a828:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a82c:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a830:	4413      	add	r3, r2
 801a832:	f642 2287 	movw	r2, #10887	; 0x2a87
 801a836:	fb02 f303 	mul.w	r3, r2, r3
 801a83a:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */
 801a83e:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801a842:	f242 22ab 	movw	r2, #8875	; 0x22ab
 801a846:	fb02 f303 	mul.w	r3, r2, r3
 801a84a:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */
 801a84e:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a852:	f240 72dc 	movw	r2, #2012	; 0x7dc
 801a856:	fb02 f303 	mul.w	r3, r2, r3
 801a85a:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    tmp10 = tmp1 + tmp0 - tmp3;
 801a85e:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a862:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a866:	441a      	add	r2, r3
 801a868:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a86c:	1ad3      	subs	r3, r2, r3
 801a86e:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    tmp12 = tmp1 - tmp0 + tmp2;
 801a872:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a876:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a87a:	1ad3      	subs	r3, r2, r3
 801a87c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a880:	4413      	add	r3, r2
 801a882:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    tmp13 = tmp1 - tmp2 + tmp3;
 801a886:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801a88a:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801a88e:	1ad3      	subs	r3, r2, r3
 801a890:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801a894:	4413      	add	r3, r2
 801a896:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801a89a:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a89e:	3304      	adds	r3, #4
 801a8a0:	681b      	ldr	r3, [r3, #0]
 801a8a2:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = (INT32) wsptr[3];
 801a8a6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a8aa:	330c      	adds	r3, #12
 801a8ac:	681b      	ldr	r3, [r3, #0]
 801a8ae:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    z3 = (INT32) wsptr[5];
 801a8b2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a8b6:	3314      	adds	r3, #20
 801a8b8:	681b      	ldr	r3, [r3, #0]
 801a8ba:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    z4 = (INT32) wsptr[7];
 801a8be:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801a8c2:	331c      	adds	r3, #28
 801a8c4:	681b      	ldr	r3, [r3, #0]
 801a8c6:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    z2 = MULTIPLY(z2, - FIX(1.224744871));           /* -c3 */
 801a8ca:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a8ce:	4a7a      	ldr	r2, [pc, #488]	; (801aab8 <jpeg_idct_9x9+0x704>)
 801a8d0:	fb02 f303 	mul.w	r3, r2, r3
 801a8d4:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c

    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */
 801a8d8:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a8dc:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a8e0:	4413      	add	r3, r2
 801a8e2:	f641 5217 	movw	r2, #7447	; 0x1d17
 801a8e6:	fb02 f303 	mul.w	r3, r2, r3
 801a8ea:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */
 801a8ee:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a8f2:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a8f6:	4413      	add	r3, r2
 801a8f8:	f640 727a 	movw	r2, #3962	; 0xf7a
 801a8fc:	fb02 f303 	mul.w	r3, r2, r3
 801a900:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp0 = tmp2 + tmp3 - z2;
 801a904:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a908:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801a90c:	441a      	add	r2, r3
 801a90e:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801a912:	1ad3      	subs	r3, r2, r3
 801a914:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */
 801a918:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801a91c:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a920:	1ad3      	subs	r3, r2, r3
 801a922:	f642 4291 	movw	r2, #11409	; 0x2c91
 801a926:	fb02 f303 	mul.w	r3, r2, r3
 801a92a:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp2 += z2 - tmp1;
 801a92e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801a932:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a936:	1ad3      	subs	r3, r2, r3
 801a938:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801a93c:	4413      	add	r3, r2
 801a93e:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp3 += z2 + tmp1;
 801a942:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801a946:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a94a:	4413      	add	r3, r2
 801a94c:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801a950:	4413      	add	r3, r2
 801a952:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */
 801a956:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801a95a:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801a95e:	1ad2      	subs	r2, r2, r3
 801a960:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a964:	1ad3      	subs	r3, r2, r3
 801a966:	f242 7231 	movw	r2, #10033	; 0x2731
 801a96a:	fb02 f303 	mul.w	r3, r2, r3
 801a96e:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a972:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801a976:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a97a:	4413      	add	r3, r2
 801a97c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a97e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 801a982:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801a986:	4413      	add	r3, r2
 801a988:	781a      	ldrb	r2, [r3, #0]
 801a98a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801a98e:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a990:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801a994:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a998:	1ad3      	subs	r3, r2, r3
 801a99a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a99c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 801a9a0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801a9a4:	441a      	add	r2, r3
 801a9a6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801a9aa:	3308      	adds	r3, #8
 801a9ac:	7812      	ldrb	r2, [r2, #0]
 801a9ae:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801a9b0:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801a9b4:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a9b8:	4413      	add	r3, r2
 801a9ba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a9bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 801a9c0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801a9c4:	441a      	add	r2, r3
 801a9c6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801a9ca:	3301      	adds	r3, #1
 801a9cc:	7812      	ldrb	r2, [r2, #0]
 801a9ce:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801a9d0:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801a9d4:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801a9d8:	1ad3      	subs	r3, r2, r3
 801a9da:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a9dc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 801a9e0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801a9e4:	441a      	add	r2, r3
 801a9e6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801a9ea:	3307      	adds	r3, #7
 801a9ec:	7812      	ldrb	r2, [r2, #0]
 801a9ee:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801a9f0:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801a9f4:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801a9f8:	4413      	add	r3, r2
 801a9fa:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801a9fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 801aa00:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801aa04:	441a      	add	r2, r3
 801aa06:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801aa0a:	3302      	adds	r3, #2
 801aa0c:	7812      	ldrb	r2, [r2, #0]
 801aa0e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801aa10:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801aa14:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801aa18:	1ad3      	subs	r3, r2, r3
 801aa1a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801aa1c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 801aa20:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801aa24:	441a      	add	r2, r3
 801aa26:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801aa2a:	3306      	adds	r3, #6
 801aa2c:	7812      	ldrb	r2, [r2, #0]
 801aa2e:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 801aa30:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801aa34:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801aa38:	4413      	add	r3, r2
 801aa3a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801aa3c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp3,
 801aa40:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801aa44:	441a      	add	r2, r3
 801aa46:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801aa4a:	3303      	adds	r3, #3
 801aa4c:	7812      	ldrb	r2, [r2, #0]
 801aa4e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 801aa50:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801aa54:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801aa58:	1ad3      	subs	r3, r2, r3
 801aa5a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801aa5c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp3,
 801aa60:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801aa64:	441a      	add	r2, r3
 801aa66:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801aa6a:	3305      	adds	r3, #5
 801aa6c:	7812      	ldrb	r2, [r2, #0]
 801aa6e:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 801aa70:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801aa74:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801aa76:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp14,
 801aa7a:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801aa7e:	441a      	add	r2, r3
 801aa80:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801aa84:	3304      	adds	r3, #4
 801aa86:	7812      	ldrb	r2, [r2, #0]
 801aa88:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801aa8a:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801aa8e:	3320      	adds	r3, #32
 801aa90:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = 0; ctr < 9; ctr++) {
 801aa94:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801aa98:	3301      	adds	r3, #1
 801aa9a:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801aa9e:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801aaa2:	2b08      	cmp	r3, #8
 801aaa4:	f77f ae62 	ble.w	801a76c <jpeg_idct_9x9+0x3b8>
  }
}
 801aaa8:	bf00      	nop
 801aaaa:	bf00      	nop
 801aaac:	f507 77c0 	add.w	r7, r7, #384	; 0x180
 801aab0:	46bd      	mov	sp, r7
 801aab2:	bc90      	pop	{r4, r7}
 801aab4:	4770      	bx	lr
 801aab6:	bf00      	nop
 801aab8:	ffffd8cf 	.word	0xffffd8cf

0801aabc <jpeg_idct_10x10>:

GLOBAL(void)
jpeg_idct_10x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801aabc:	b490      	push	{r4, r7}
 801aabe:	b0ea      	sub	sp, #424	; 0x1a8
 801aac0:	af00      	add	r7, sp, #0
 801aac2:	f107 040c 	add.w	r4, r7, #12
 801aac6:	6020      	str	r0, [r4, #0]
 801aac8:	f107 0008 	add.w	r0, r7, #8
 801aacc:	6001      	str	r1, [r0, #0]
 801aace:	1d39      	adds	r1, r7, #4
 801aad0:	600a      	str	r2, [r1, #0]
 801aad2:	463a      	mov	r2, r7
 801aad4:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801aad6:	f107 030c 	add.w	r3, r7, #12
 801aada:	681b      	ldr	r3, [r3, #0]
 801aadc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801aae0:	3380      	adds	r3, #128	; 0x80
 801aae2:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
  int workspace[8*10];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801aae6:	1d3b      	adds	r3, r7, #4
 801aae8:	681b      	ldr	r3, [r3, #0]
 801aaea:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801aaee:	f107 0308 	add.w	r3, r7, #8
 801aaf2:	681b      	ldr	r3, [r3, #0]
 801aaf4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801aaf6:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
  wsptr = workspace;
 801aafa:	f107 0314 	add.w	r3, r7, #20
 801aafe:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801ab02:	2300      	movs	r3, #0
 801ab04:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 801ab08:	e1d5      	b.n	801aeb6 <jpeg_idct_10x10+0x3fa>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801ab0a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ab0e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ab12:	461a      	mov	r2, r3
 801ab14:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801ab18:	681b      	ldr	r3, [r3, #0]
 801ab1a:	fb03 f302 	mul.w	r3, r3, r2
 801ab1e:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z3 <<= CONST_BITS;
 801ab22:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801ab26:	035b      	lsls	r3, r3, #13
 801ab28:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 801ab2c:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801ab30:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801ab34:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801ab38:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ab3c:	3340      	adds	r3, #64	; 0x40
 801ab3e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ab42:	461a      	mov	r2, r3
 801ab44:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801ab48:	3380      	adds	r3, #128	; 0x80
 801ab4a:	681b      	ldr	r3, [r3, #0]
 801ab4c:	fb03 f302 	mul.w	r3, r3, r2
 801ab50:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 801ab54:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801ab58:	f242 429d 	movw	r2, #9373	; 0x249d
 801ab5c:	fb02 f303 	mul.w	r3, r2, r3
 801ab60:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 801ab64:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801ab68:	f640 52fc 	movw	r2, #3580	; 0xdfc
 801ab6c:	fb02 f303 	mul.w	r3, r2, r3
 801ab70:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp10 = z3 + z1;
 801ab74:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801ab78:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801ab7c:	4413      	add	r3, r2
 801ab7e:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp11 = z3 - z2;
 801ab82:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801ab86:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801ab8a:	1ad3      	subs	r3, r2, r3
 801ab8c:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 801ab90:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801ab94:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801ab98:	1ad3      	subs	r3, r2, r3
 801ab9a:	005b      	lsls	r3, r3, #1
 801ab9c:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801aba0:	1ad3      	subs	r3, r2, r3
 801aba2:	12db      	asrs	r3, r3, #11
 801aba4:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801aba8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801abac:	3320      	adds	r3, #32
 801abae:	f9b3 3000 	ldrsh.w	r3, [r3]
 801abb2:	461a      	mov	r2, r3
 801abb4:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801abb8:	3340      	adds	r3, #64	; 0x40
 801abba:	681b      	ldr	r3, [r3, #0]
 801abbc:	fb03 f302 	mul.w	r3, r3, r2
 801abc0:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801abc4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801abc8:	3360      	adds	r3, #96	; 0x60
 801abca:	f9b3 3000 	ldrsh.w	r3, [r3]
 801abce:	461a      	mov	r2, r3
 801abd0:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801abd4:	33c0      	adds	r3, #192	; 0xc0
 801abd6:	681b      	ldr	r3, [r3, #0]
 801abd8:	fb03 f302 	mul.w	r3, r3, r2
 801abdc:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 801abe0:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801abe4:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801abe8:	4413      	add	r3, r2
 801abea:	f641 229a 	movw	r2, #6810	; 0x1a9a
 801abee:	fb02 f303 	mul.w	r3, r2, r3
 801abf2:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 801abf6:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801abfa:	f241 0271 	movw	r2, #4209	; 0x1071
 801abfe:	fb02 f303 	mul.w	r3, r2, r3
 801ac02:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801ac06:	4413      	add	r3, r2
 801ac08:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 801ac0c:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801ac10:	4aaf      	ldr	r2, [pc, #700]	; (801aed0 <jpeg_idct_10x10+0x414>)
 801ac12:	fb02 f303 	mul.w	r3, r2, r3
 801ac16:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801ac1a:	4413      	add	r3, r2
 801ac1c:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    tmp20 = tmp10 + tmp12;
 801ac20:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801ac24:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801ac28:	4413      	add	r3, r2
 801ac2a:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp24 = tmp10 - tmp12;
 801ac2e:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801ac32:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801ac36:	1ad3      	subs	r3, r2, r3
 801ac38:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp21 = tmp11 + tmp13;
 801ac3c:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801ac40:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ac44:	4413      	add	r3, r2
 801ac46:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp23 = tmp11 - tmp13;
 801ac4a:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801ac4e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ac52:	1ad3      	subs	r3, r2, r3
 801ac54:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ac58:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ac5c:	3310      	adds	r3, #16
 801ac5e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ac62:	461a      	mov	r2, r3
 801ac64:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801ac68:	3320      	adds	r3, #32
 801ac6a:	681b      	ldr	r3, [r3, #0]
 801ac6c:	fb03 f302 	mul.w	r3, r3, r2
 801ac70:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801ac74:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ac78:	3330      	adds	r3, #48	; 0x30
 801ac7a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ac7e:	461a      	mov	r2, r3
 801ac80:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801ac84:	3360      	adds	r3, #96	; 0x60
 801ac86:	681b      	ldr	r3, [r3, #0]
 801ac88:	fb03 f302 	mul.w	r3, r3, r2
 801ac8c:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801ac90:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ac94:	3350      	adds	r3, #80	; 0x50
 801ac96:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ac9a:	461a      	mov	r2, r3
 801ac9c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801aca0:	33a0      	adds	r3, #160	; 0xa0
 801aca2:	681b      	ldr	r3, [r3, #0]
 801aca4:	fb03 f302 	mul.w	r3, r3, r2
 801aca8:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801acac:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801acb0:	3370      	adds	r3, #112	; 0x70
 801acb2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801acb6:	461a      	mov	r2, r3
 801acb8:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801acbc:	33e0      	adds	r3, #224	; 0xe0
 801acbe:	681b      	ldr	r3, [r3, #0]
 801acc0:	fb03 f302 	mul.w	r3, r3, r2
 801acc4:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp11 = z2 + z4;
 801acc8:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801accc:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801acd0:	4413      	add	r3, r2
 801acd2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = z2 - z4;
 801acd6:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801acda:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801acde:	1ad3      	subs	r3, r2, r3
 801ace0:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 801ace4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ace8:	f640 12e3 	movw	r2, #2531	; 0x9e3
 801acec:	fb02 f303 	mul.w	r3, r2, r3
 801acf0:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
    z5 = z3 << CONST_BITS;
 801acf4:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801acf8:	035b      	lsls	r3, r3, #13
 801acfa:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 801acfe:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801ad02:	f641 626f 	movw	r2, #7791	; 0x1e6f
 801ad06:	fb02 f303 	mul.w	r3, r2, r3
 801ad0a:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z4 = z5 + tmp12;
 801ad0e:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801ad12:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801ad16:	4413      	add	r3, r2
 801ad18:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 801ad1c:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801ad20:	f642 42b3 	movw	r2, #11443	; 0x2cb3
 801ad24:	fb02 f203 	mul.w	r2, r2, r3
 801ad28:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801ad2c:	4413      	add	r3, r2
 801ad2e:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801ad32:	4413      	add	r3, r2
 801ad34:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 801ad38:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801ad3c:	f240 7214 	movw	r2, #1812	; 0x714
 801ad40:	fb02 f203 	mul.w	r2, r2, r3
 801ad44:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801ad48:	1ad3      	subs	r3, r2, r3
 801ad4a:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801ad4e:	4413      	add	r3, r2
 801ad50:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 801ad54:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801ad58:	f241 22cf 	movw	r2, #4815	; 0x12cf
 801ad5c:	fb02 f303 	mul.w	r3, r2, r3
 801ad60:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 801ad64:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801ad68:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801ad6c:	1ad2      	subs	r2, r2, r3
 801ad6e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ad72:	031b      	lsls	r3, r3, #12
 801ad74:	1ad3      	subs	r3, r2, r3
 801ad76:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 801ad7a:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801ad7e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ad82:	1ad2      	subs	r2, r2, r3
 801ad84:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801ad88:	1ad3      	subs	r3, r2, r3
 801ad8a:	009b      	lsls	r3, r3, #2
 801ad8c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 801ad90:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801ad94:	f642 0253 	movw	r2, #10323	; 0x2853
 801ad98:	fb02 f203 	mul.w	r2, r2, r3
 801ad9c:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801ada0:	1ad2      	subs	r2, r2, r3
 801ada2:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801ada6:	1ad3      	subs	r3, r2, r3
 801ada8:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 801adac:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801adb0:	f241 428c 	movw	r2, #5260	; 0x148c
 801adb4:	fb02 f203 	mul.w	r2, r2, r3
 801adb8:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801adbc:	1ad3      	subs	r3, r2, r3
 801adbe:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801adc2:	4413      	add	r3, r2
 801adc4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801adc8:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 801adcc:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801add0:	4413      	add	r3, r2
 801add2:	12da      	asrs	r2, r3, #11
 801add4:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801add8:	601a      	str	r2, [r3, #0]
    wsptr[8*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801adda:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 801adde:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801ade2:	1ad2      	subs	r2, r2, r3
 801ade4:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ade8:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801adec:	12d2      	asrs	r2, r2, #11
 801adee:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801adf0:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801adf4:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801adf8:	441a      	add	r2, r3
 801adfa:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801adfe:	3320      	adds	r3, #32
 801ae00:	12d2      	asrs	r2, r2, #11
 801ae02:	601a      	str	r2, [r3, #0]
    wsptr[8*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801ae04:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801ae08:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801ae0c:	1ad2      	subs	r2, r2, r3
 801ae0e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae12:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801ae16:	12d2      	asrs	r2, r2, #11
 801ae18:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp22 + tmp12);
 801ae1a:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae1e:	3340      	adds	r3, #64	; 0x40
 801ae20:	f8d7 1174 	ldr.w	r1, [r7, #372]	; 0x174
 801ae24:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 801ae28:	440a      	add	r2, r1
 801ae2a:	601a      	str	r2, [r3, #0]
    wsptr[8*7] = (int) (tmp22 - tmp12);
 801ae2c:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae30:	33e0      	adds	r3, #224	; 0xe0
 801ae32:	f8d7 1174 	ldr.w	r1, [r7, #372]	; 0x174
 801ae36:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 801ae3a:	1a8a      	subs	r2, r1, r2
 801ae3c:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801ae3e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801ae42:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ae46:	441a      	add	r2, r3
 801ae48:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae4c:	3360      	adds	r3, #96	; 0x60
 801ae4e:	12d2      	asrs	r2, r2, #11
 801ae50:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801ae52:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801ae56:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801ae5a:	1ad2      	subs	r2, r2, r3
 801ae5c:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae60:	33c0      	adds	r3, #192	; 0xc0
 801ae62:	12d2      	asrs	r2, r2, #11
 801ae64:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801ae66:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801ae6a:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801ae6e:	441a      	add	r2, r3
 801ae70:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae74:	3380      	adds	r3, #128	; 0x80
 801ae76:	12d2      	asrs	r2, r2, #11
 801ae78:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801ae7a:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801ae7e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801ae82:	1ad2      	subs	r2, r2, r3
 801ae84:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801ae88:	33a0      	adds	r3, #160	; 0xa0
 801ae8a:	12d2      	asrs	r2, r2, #11
 801ae8c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801ae8e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801ae92:	3301      	adds	r3, #1
 801ae94:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 801ae98:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ae9c:	3302      	adds	r3, #2
 801ae9e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 801aea2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801aea6:	3304      	adds	r3, #4
 801aea8:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
 801aeac:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801aeb0:	3304      	adds	r3, #4
 801aeb2:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
 801aeb6:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801aeba:	2b07      	cmp	r3, #7
 801aebc:	f77f ae25 	ble.w	801ab0a <jpeg_idct_10x10+0x4e>
  }

  /* Pass 2: process 10 rows from work array, store into output array. */

  wsptr = workspace;
 801aec0:	f107 0314 	add.w	r3, r7, #20
 801aec4:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 801aec8:	2300      	movs	r3, #0
 801aeca:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 801aece:	e1d0      	b.n	801b272 <jpeg_idct_10x10+0x7b6>
 801aed0:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 801aed4:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801aed8:	009b      	lsls	r3, r3, #2
 801aeda:	463a      	mov	r2, r7
 801aedc:	6812      	ldr	r2, [r2, #0]
 801aede:	4413      	add	r3, r2
 801aee0:	681a      	ldr	r2, [r3, #0]
 801aee2:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801aee6:	4413      	add	r3, r2
 801aee8:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801aeec:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801aef0:	681b      	ldr	r3, [r3, #0]
 801aef2:	3310      	adds	r3, #16
 801aef4:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z3 <<= CONST_BITS;
 801aef8:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801aefc:	035b      	lsls	r3, r3, #13
 801aefe:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z4 = (INT32) wsptr[4];
 801af02:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801af06:	3310      	adds	r3, #16
 801af08:	681b      	ldr	r3, [r3, #0]
 801af0a:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 801af0e:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801af12:	f242 429d 	movw	r2, #9373	; 0x249d
 801af16:	fb02 f303 	mul.w	r3, r2, r3
 801af1a:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 801af1e:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801af22:	f640 52fc 	movw	r2, #3580	; 0xdfc
 801af26:	fb02 f303 	mul.w	r3, r2, r3
 801af2a:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp10 = z3 + z1;
 801af2e:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801af32:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801af36:	4413      	add	r3, r2
 801af38:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp11 = z3 - z2;
 801af3c:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801af40:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801af44:	1ad3      	subs	r3, r2, r3
 801af46:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 801af4a:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801af4e:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801af52:	1ad3      	subs	r3, r2, r3
 801af54:	005b      	lsls	r3, r3, #1
 801af56:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801af5a:	1ad3      	subs	r3, r2, r3
 801af5c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174

    z2 = (INT32) wsptr[2];
 801af60:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801af64:	3308      	adds	r3, #8
 801af66:	681b      	ldr	r3, [r3, #0]
 801af68:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z3 = (INT32) wsptr[6];
 801af6c:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801af70:	3318      	adds	r3, #24
 801af72:	681b      	ldr	r3, [r3, #0]
 801af74:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 801af78:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801af7c:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801af80:	4413      	add	r3, r2
 801af82:	f641 229a 	movw	r2, #6810	; 0x1a9a
 801af86:	fb02 f303 	mul.w	r3, r2, r3
 801af8a:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 801af8e:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801af92:	f241 0271 	movw	r2, #4209	; 0x1071
 801af96:	fb02 f303 	mul.w	r3, r2, r3
 801af9a:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801af9e:	4413      	add	r3, r2
 801afa0:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 801afa4:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801afa8:	4ab8      	ldr	r2, [pc, #736]	; (801b28c <jpeg_idct_10x10+0x7d0>)
 801afaa:	fb02 f303 	mul.w	r3, r2, r3
 801afae:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801afb2:	4413      	add	r3, r2
 801afb4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    tmp20 = tmp10 + tmp12;
 801afb8:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801afbc:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801afc0:	4413      	add	r3, r2
 801afc2:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp24 = tmp10 - tmp12;
 801afc6:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801afca:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801afce:	1ad3      	subs	r3, r2, r3
 801afd0:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp21 = tmp11 + tmp13;
 801afd4:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801afd8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801afdc:	4413      	add	r3, r2
 801afde:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp23 = tmp11 - tmp13;
 801afe2:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801afe6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801afea:	1ad3      	subs	r3, r2, r3
 801afec:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801aff0:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801aff4:	3304      	adds	r3, #4
 801aff6:	681b      	ldr	r3, [r3, #0]
 801aff8:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    z2 = (INT32) wsptr[3];
 801affc:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801b000:	330c      	adds	r3, #12
 801b002:	681b      	ldr	r3, [r3, #0]
 801b004:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z3 = (INT32) wsptr[5];
 801b008:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801b00c:	3314      	adds	r3, #20
 801b00e:	681b      	ldr	r3, [r3, #0]
 801b010:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z3 <<= CONST_BITS;
 801b014:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b018:	035b      	lsls	r3, r3, #13
 801b01a:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    z4 = (INT32) wsptr[7];
 801b01e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801b022:	331c      	adds	r3, #28
 801b024:	681b      	ldr	r3, [r3, #0]
 801b026:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp11 = z2 + z4;
 801b02a:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b02e:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801b032:	4413      	add	r3, r2
 801b034:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = z2 - z4;
 801b038:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b03c:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801b040:	1ad3      	subs	r3, r2, r3
 801b042:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 801b046:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801b04a:	f640 12e3 	movw	r2, #2531	; 0x9e3
 801b04e:	fb02 f303 	mul.w	r3, r2, r3
 801b052:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 801b056:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b05a:	f641 626f 	movw	r2, #7791	; 0x1e6f
 801b05e:	fb02 f303 	mul.w	r3, r2, r3
 801b062:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z4 = z3 + tmp12;
 801b066:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801b06a:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801b06e:	4413      	add	r3, r2
 801b070:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 801b074:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801b078:	f642 42b3 	movw	r2, #11443	; 0x2cb3
 801b07c:	fb02 f203 	mul.w	r2, r2, r3
 801b080:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b084:	4413      	add	r3, r2
 801b086:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801b08a:	4413      	add	r3, r2
 801b08c:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 801b090:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801b094:	f240 7214 	movw	r2, #1812	; 0x714
 801b098:	fb02 f203 	mul.w	r2, r2, r3
 801b09c:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b0a0:	1ad3      	subs	r3, r2, r3
 801b0a2:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801b0a6:	4413      	add	r3, r2
 801b0a8:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 801b0ac:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b0b0:	f241 22cf 	movw	r2, #4815	; 0x12cf
 801b0b4:	fb02 f303 	mul.w	r3, r2, r3
 801b0b8:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 801b0bc:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801b0c0:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801b0c4:	1ad2      	subs	r2, r2, r3
 801b0c6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801b0ca:	031b      	lsls	r3, r3, #12
 801b0cc:	1ad3      	subs	r3, r2, r3
 801b0ce:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 801b0d2:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801b0d6:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801b0da:	1ad3      	subs	r3, r2, r3
 801b0dc:	035a      	lsls	r2, r3, #13
 801b0de:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b0e2:	1ad3      	subs	r3, r2, r3
 801b0e4:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 801b0e8:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801b0ec:	f642 0253 	movw	r2, #10323	; 0x2853
 801b0f0:	fb02 f203 	mul.w	r2, r2, r3
 801b0f4:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b0f8:	1ad2      	subs	r2, r2, r3
 801b0fa:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801b0fe:	1ad3      	subs	r3, r2, r3
 801b100:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 801b104:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 801b108:	f241 428c 	movw	r2, #5260	; 0x148c
 801b10c:	fb02 f203 	mul.w	r2, r2, r3
 801b110:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b114:	1ad3      	subs	r3, r2, r3
 801b116:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801b11a:	4413      	add	r3, r2
 801b11c:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801b120:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 801b124:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801b128:	4413      	add	r3, r2
 801b12a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b12c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801b130:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b134:	4413      	add	r3, r2
 801b136:	781a      	ldrb	r2, [r3, #0]
 801b138:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b13c:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801b13e:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 801b142:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801b146:	1ad3      	subs	r3, r2, r3
 801b148:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b14a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801b14e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b152:	441a      	add	r2, r3
 801b154:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b158:	3309      	adds	r3, #9
 801b15a:	7812      	ldrb	r2, [r2, #0]
 801b15c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801b15e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801b162:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b166:	4413      	add	r3, r2
 801b168:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b16a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801b16e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b172:	441a      	add	r2, r3
 801b174:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b178:	3301      	adds	r3, #1
 801b17a:	7812      	ldrb	r2, [r2, #0]
 801b17c:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801b17e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801b182:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b186:	1ad3      	subs	r3, r2, r3
 801b188:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b18a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801b18e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b192:	441a      	add	r2, r3
 801b194:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b198:	3308      	adds	r3, #8
 801b19a:	7812      	ldrb	r2, [r2, #0]
 801b19c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801b19e:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 801b1a2:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801b1a6:	4413      	add	r3, r2
 801b1a8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b1aa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801b1ae:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b1b2:	441a      	add	r2, r3
 801b1b4:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b1b8:	3302      	adds	r3, #2
 801b1ba:	7812      	ldrb	r2, [r2, #0]
 801b1bc:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801b1be:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 801b1c2:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801b1c6:	1ad3      	subs	r3, r2, r3
 801b1c8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b1ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801b1ce:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b1d2:	441a      	add	r2, r3
 801b1d4:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b1d8:	3307      	adds	r3, #7
 801b1da:	7812      	ldrb	r2, [r2, #0]
 801b1dc:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801b1de:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801b1e2:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801b1e6:	4413      	add	r3, r2
 801b1e8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b1ea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801b1ee:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b1f2:	441a      	add	r2, r3
 801b1f4:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b1f8:	3303      	adds	r3, #3
 801b1fa:	7812      	ldrb	r2, [r2, #0]
 801b1fc:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801b1fe:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801b202:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 801b206:	1ad3      	subs	r3, r2, r3
 801b208:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b20a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801b20e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b212:	441a      	add	r2, r3
 801b214:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b218:	3306      	adds	r3, #6
 801b21a:	7812      	ldrb	r2, [r2, #0]
 801b21c:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801b21e:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801b222:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801b226:	4413      	add	r3, r2
 801b228:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b22a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801b22e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b232:	441a      	add	r2, r3
 801b234:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b238:	3304      	adds	r3, #4
 801b23a:	7812      	ldrb	r2, [r2, #0]
 801b23c:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801b23e:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801b242:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801b246:	1ad3      	subs	r3, r2, r3
 801b248:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 801b24a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801b24e:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b252:	441a      	add	r2, r3
 801b254:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801b258:	3305      	adds	r3, #5
 801b25a:	7812      	ldrb	r2, [r2, #0]
 801b25c:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801b25e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 801b262:	3320      	adds	r3, #32
 801b264:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
  for (ctr = 0; ctr < 10; ctr++) {
 801b268:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801b26c:	3301      	adds	r3, #1
 801b26e:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 801b272:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801b276:	2b09      	cmp	r3, #9
 801b278:	f77f ae2c 	ble.w	801aed4 <jpeg_idct_10x10+0x418>
  }
}
 801b27c:	bf00      	nop
 801b27e:	bf00      	nop
 801b280:	f507 77d4 	add.w	r7, r7, #424	; 0x1a8
 801b284:	46bd      	mov	sp, r7
 801b286:	bc90      	pop	{r4, r7}
 801b288:	4770      	bx	lr
 801b28a:	bf00      	nop
 801b28c:	ffffba5c 	.word	0xffffba5c

0801b290 <jpeg_idct_11x11>:

GLOBAL(void)
jpeg_idct_11x11 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801b290:	b490      	push	{r4, r7}
 801b292:	b0f2      	sub	sp, #456	; 0x1c8
 801b294:	af00      	add	r7, sp, #0
 801b296:	f107 040c 	add.w	r4, r7, #12
 801b29a:	6020      	str	r0, [r4, #0]
 801b29c:	f107 0008 	add.w	r0, r7, #8
 801b2a0:	6001      	str	r1, [r0, #0]
 801b2a2:	1d39      	adds	r1, r7, #4
 801b2a4:	600a      	str	r2, [r1, #0]
 801b2a6:	463a      	mov	r2, r7
 801b2a8:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801b2aa:	f107 030c 	add.w	r3, r7, #12
 801b2ae:	681b      	ldr	r3, [r3, #0]
 801b2b0:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801b2b4:	3380      	adds	r3, #128	; 0x80
 801b2b6:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
  int workspace[8*11];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801b2ba:	1d3b      	adds	r3, r7, #4
 801b2bc:	681b      	ldr	r3, [r3, #0]
 801b2be:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801b2c2:	f107 0308 	add.w	r3, r7, #8
 801b2c6:	681b      	ldr	r3, [r3, #0]
 801b2c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801b2ca:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
  wsptr = workspace;
 801b2ce:	f107 0314 	add.w	r3, r7, #20
 801b2d2:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801b2d6:	2300      	movs	r3, #0
 801b2d8:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 801b2dc:	e22b      	b.n	801b736 <jpeg_idct_11x11+0x4a6>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801b2de:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b2e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b2e6:	461a      	mov	r2, r3
 801b2e8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b2ec:	681b      	ldr	r3, [r3, #0]
 801b2ee:	fb03 f302 	mul.w	r3, r3, r2
 801b2f2:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp10 <<= CONST_BITS;
 801b2f6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801b2fa:	035b      	lsls	r3, r3, #13
 801b2fc:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 801b300:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801b304:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801b308:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801b30c:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b310:	3320      	adds	r3, #32
 801b312:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b316:	461a      	mov	r2, r3
 801b318:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b31c:	3340      	adds	r3, #64	; 0x40
 801b31e:	681b      	ldr	r3, [r3, #0]
 801b320:	fb03 f302 	mul.w	r3, r3, r2
 801b324:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801b328:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b32c:	3340      	adds	r3, #64	; 0x40
 801b32e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b332:	461a      	mov	r2, r3
 801b334:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b338:	3380      	adds	r3, #128	; 0x80
 801b33a:	681b      	ldr	r3, [r3, #0]
 801b33c:	fb03 f302 	mul.w	r3, r3, r2
 801b340:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801b344:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b348:	3360      	adds	r3, #96	; 0x60
 801b34a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b34e:	461a      	mov	r2, r3
 801b350:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b354:	33c0      	adds	r3, #192	; 0xc0
 801b356:	681b      	ldr	r3, [r3, #0]
 801b358:	fb03 f302 	mul.w	r3, r3, r2
 801b35c:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 801b360:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b364:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b368:	1ad3      	subs	r3, r2, r3
 801b36a:	f245 127e 	movw	r2, #20862	; 0x517e
 801b36e:	fb02 f303 	mul.w	r3, r2, r3
 801b372:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 801b376:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b37a:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b37e:	1ad3      	subs	r3, r2, r3
 801b380:	f640 52c9 	movw	r2, #3529	; 0xdc9
 801b384:	fb02 f303 	mul.w	r3, r2, r3
 801b388:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    z4 = z1 + z3;
 801b38c:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b390:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b394:	4413      	add	r3, r2
 801b396:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 801b39a:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b39e:	4aec      	ldr	r2, [pc, #944]	; (801b750 <jpeg_idct_11x11+0x4c0>)
 801b3a0:	fb02 f303 	mul.w	r3, r2, r3
 801b3a4:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    z4 -= z2;
 801b3a8:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b3ac:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b3b0:	1ad3      	subs	r3, r2, r3
 801b3b2:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 801b3b6:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b3ba:	f642 326c 	movw	r2, #11116	; 0x2b6c
 801b3be:	fb02 f303 	mul.w	r3, r2, r3
 801b3c2:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801b3c6:	4413      	add	r3, r2
 801b3c8:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 801b3cc:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b3d0:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801b3d4:	441a      	add	r2, r3
 801b3d6:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b3da:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 801b3dc:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b3e0:	49dc      	ldr	r1, [pc, #880]	; (801b754 <jpeg_idct_11x11+0x4c4>)
 801b3e2:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 801b3e6:	4413      	add	r3, r2
 801b3e8:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 801b3ec:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b3f0:	f244 32b5 	movw	r2, #17333	; 0x43b5
 801b3f4:	fb02 f203 	mul.w	r2, r2, r3
 801b3f8:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b3fc:	4413      	add	r3, r2
 801b3fe:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b402:	4413      	add	r3, r2
 801b404:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 801b408:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b40c:	4ad2      	ldr	r2, [pc, #840]	; (801b758 <jpeg_idct_11x11+0x4c8>)
 801b40e:	fb02 f203 	mul.w	r2, r2, r3
 801b412:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b416:	4413      	add	r3, r2
 801b418:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801b41c:	4413      	add	r3, r2
 801b41e:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    tmp24 += tmp25;
 801b422:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b426:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b42a:	4413      	add	r3, r2
 801b42c:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 801b430:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b434:	4ac9      	ldr	r2, [pc, #804]	; (801b75c <jpeg_idct_11x11+0x4cc>)
 801b436:	fb02 f303 	mul.w	r3, r2, r3
 801b43a:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b43e:	4413      	add	r3, r2
 801b440:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 801b444:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b448:	f643 6239 	movw	r2, #15929	; 0x3e39
 801b44c:	fb02 f203 	mul.w	r2, r2, r3
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 801b450:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b454:	49c2      	ldr	r1, [pc, #776]	; (801b760 <jpeg_idct_11x11+0x4d0>)
 801b456:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 801b45a:	4413      	add	r3, r2
 801b45c:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b460:	4413      	add	r3, r2
 801b462:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 801b466:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b46a:	f46f 5235 	mvn.w	r2, #11584	; 0x2d40
 801b46e:	fb02 f303 	mul.w	r3, r2, r3
 801b472:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801b476:	4413      	add	r3, r2
 801b478:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801b47c:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b480:	3310      	adds	r3, #16
 801b482:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b486:	461a      	mov	r2, r3
 801b488:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b48c:	3320      	adds	r3, #32
 801b48e:	681b      	ldr	r3, [r3, #0]
 801b490:	fb03 f302 	mul.w	r3, r3, r2
 801b494:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801b498:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b49c:	3330      	adds	r3, #48	; 0x30
 801b49e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b4a2:	461a      	mov	r2, r3
 801b4a4:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b4a8:	3360      	adds	r3, #96	; 0x60
 801b4aa:	681b      	ldr	r3, [r3, #0]
 801b4ac:	fb03 f302 	mul.w	r3, r3, r2
 801b4b0:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801b4b4:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b4b8:	3350      	adds	r3, #80	; 0x50
 801b4ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b4be:	461a      	mov	r2, r3
 801b4c0:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b4c4:	33a0      	adds	r3, #160	; 0xa0
 801b4c6:	681b      	ldr	r3, [r3, #0]
 801b4c8:	fb03 f302 	mul.w	r3, r3, r2
 801b4cc:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801b4d0:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b4d4:	3370      	adds	r3, #112	; 0x70
 801b4d6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b4da:	461a      	mov	r2, r3
 801b4dc:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b4e0:	33e0      	adds	r3, #224	; 0xe0
 801b4e2:	681b      	ldr	r3, [r3, #0]
 801b4e4:	fb03 f302 	mul.w	r3, r3, r2
 801b4e8:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194

    tmp11 = z1 + z2;
 801b4ec:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b4f0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b4f4:	4413      	add	r3, r2
 801b4f6:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 801b4fa:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b4fe:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b502:	441a      	add	r2, r3
 801b504:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b508:	4413      	add	r3, r2
 801b50a:	f44f 624c 	mov.w	r2, #3264	; 0xcc0
 801b50e:	fb02 f303 	mul.w	r3, r2, r3
 801b512:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 801b516:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b51a:	f641 426a 	movw	r2, #7274	; 0x1c6a
 801b51e:	fb02 f303 	mul.w	r3, r2, r3
 801b522:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 801b526:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b52a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b52e:	4413      	add	r3, r2
 801b530:	f241 5274 	movw	r2, #5492	; 0x1574
 801b534:	fb02 f303 	mul.w	r3, r2, r3
 801b538:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 801b53c:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b540:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b544:	4413      	add	r3, r2
 801b546:	f640 32b8 	movw	r2, #3000	; 0xbb8
 801b54a:	fb02 f303 	mul.w	r3, r2, r3
 801b54e:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801b552:	4413      	add	r3, r2
 801b554:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 801b558:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b55c:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b560:	441a      	add	r2, r3
 801b562:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801b566:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 801b568:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b56c:	497d      	ldr	r1, [pc, #500]	; (801b764 <jpeg_idct_11x11+0x4d4>)
 801b56e:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 801b572:	4413      	add	r3, r2
 801b574:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 801b578:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b57c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b580:	4413      	add	r3, r2
 801b582:	4a79      	ldr	r2, [pc, #484]	; (801b768 <jpeg_idct_11x11+0x4d8>)
 801b584:	fb02 f303 	mul.w	r3, r2, r3
 801b588:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801b58c:	4413      	add	r3, r2
 801b58e:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 801b592:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b596:	f244 2258 	movw	r2, #16984	; 0x4258
 801b59a:	fb02 f203 	mul.w	r2, r2, r3
 801b59e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b5a2:	4413      	add	r3, r2
 801b5a4:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b5a8:	4413      	add	r3, r2
 801b5aa:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 801b5ae:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b5b2:	4a6e      	ldr	r2, [pc, #440]	; (801b76c <jpeg_idct_11x11+0x4dc>)
 801b5b4:	fb02 f203 	mul.w	r2, r2, r3
 801b5b8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b5bc:	4413      	add	r3, r2
 801b5be:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801b5c2:	4413      	add	r3, r2
 801b5c4:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 801b5c8:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b5cc:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b5d0:	4413      	add	r3, r2
 801b5d2:	4a67      	ldr	r2, [pc, #412]	; (801b770 <jpeg_idct_11x11+0x4e0>)
 801b5d4:	fb02 f303 	mul.w	r3, r2, r3
 801b5d8:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp11 += z1;
 801b5dc:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b5e0:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b5e4:	4413      	add	r3, r2
 801b5e6:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 801b5ea:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b5ee:	f244 3247 	movw	r2, #17223	; 0x4347
 801b5f2:	fb02 f203 	mul.w	r2, r2, r3
 801b5f6:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b5fa:	4413      	add	r3, r2
 801b5fc:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 801b600:	4413      	add	r3, r2
 801b602:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801b606:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b60a:	4a5a      	ldr	r2, [pc, #360]	; (801b774 <jpeg_idct_11x11+0x4e4>)
 801b60c:	fb02 f203 	mul.w	r2, r2, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 801b610:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b614:	f242 010b 	movw	r1, #8203	; 0x200b
 801b618:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801b61c:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 801b61e:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b622:	4955      	ldr	r1, [pc, #340]	; (801b778 <jpeg_idct_11x11+0x4e8>)
 801b624:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 801b628:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801b62a:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801b62e:	4413      	add	r3, r2
 801b630:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801b634:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b638:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801b63c:	4413      	add	r3, r2
 801b63e:	12da      	asrs	r2, r3, #11
 801b640:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b644:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801b646:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b64a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801b64e:	1ad2      	subs	r2, r2, r3
 801b650:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b654:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801b658:	12d2      	asrs	r2, r2, #11
 801b65a:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801b65c:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801b660:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b664:	441a      	add	r2, r3
 801b666:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b66a:	3320      	adds	r3, #32
 801b66c:	12d2      	asrs	r2, r2, #11
 801b66e:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801b670:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801b674:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b678:	1ad2      	subs	r2, r2, r3
 801b67a:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b67e:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801b682:	12d2      	asrs	r2, r2, #11
 801b684:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 801b686:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801b68a:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b68e:	441a      	add	r2, r3
 801b690:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b694:	3340      	adds	r3, #64	; 0x40
 801b696:	12d2      	asrs	r2, r2, #11
 801b698:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 801b69a:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801b69e:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b6a2:	1ad2      	subs	r2, r2, r3
 801b6a4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b6a8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801b6ac:	12d2      	asrs	r2, r2, #11
 801b6ae:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801b6b0:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801b6b4:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801b6b8:	441a      	add	r2, r3
 801b6ba:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b6be:	3360      	adds	r3, #96	; 0x60
 801b6c0:	12d2      	asrs	r2, r2, #11
 801b6c2:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801b6c4:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801b6c8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801b6cc:	1ad2      	subs	r2, r2, r3
 801b6ce:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b6d2:	33e0      	adds	r3, #224	; 0xe0
 801b6d4:	12d2      	asrs	r2, r2, #11
 801b6d6:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801b6d8:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b6dc:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801b6e0:	441a      	add	r2, r3
 801b6e2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b6e6:	3380      	adds	r3, #128	; 0x80
 801b6e8:	12d2      	asrs	r2, r2, #11
 801b6ea:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801b6ec:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b6f0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801b6f4:	1ad2      	subs	r2, r2, r3
 801b6f6:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b6fa:	33c0      	adds	r3, #192	; 0xc0
 801b6fc:	12d2      	asrs	r2, r2, #11
 801b6fe:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25, CONST_BITS-PASS1_BITS);
 801b700:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b704:	33a0      	adds	r3, #160	; 0xa0
 801b706:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
 801b70a:	12d2      	asrs	r2, r2, #11
 801b70c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801b70e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801b712:	3301      	adds	r3, #1
 801b714:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 801b718:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801b71c:	3302      	adds	r3, #2
 801b71e:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
 801b722:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801b726:	3304      	adds	r3, #4
 801b728:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
 801b72c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b730:	3304      	adds	r3, #4
 801b732:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
 801b736:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801b73a:	2b07      	cmp	r3, #7
 801b73c:	f77f adcf 	ble.w	801b2de <jpeg_idct_11x11+0x4e>
  }

  /* Pass 2: process 11 rows from work array, store into output array. */

  wsptr = workspace;
 801b740:	f107 0314 	add.w	r3, r7, #20
 801b744:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 801b748:	2300      	movs	r3, #0
 801b74a:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 801b74e:	e255      	b.n	801bbfc <jpeg_idct_11x11+0x96c>
 801b750:	ffffdb05 	.word	0xffffdb05
 801b754:	ffffc5b4 	.word	0xffffc5b4
 801b758:	ffffcf91 	.word	0xffffcf91
 801b75c:	ffffe6c3 	.word	0xffffe6c3
 801b760:	ffffd37d 	.word	0xffffd37d
 801b764:	ffffe276 	.word	0xffffe276
 801b768:	ffffdac9 	.word	0xffffdac9
 801b76c:	ffffd9da 	.word	0xffffd9da
 801b770:	ffffc675 	.word	0xffffc675
 801b774:	ffffd10d 	.word	0xffffd10d
 801b778:	ffffca16 	.word	0xffffca16
    outptr = output_buf[ctr] + output_col;
 801b77c:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801b780:	009b      	lsls	r3, r3, #2
 801b782:	463a      	mov	r2, r7
 801b784:	6812      	ldr	r2, [r2, #0]
 801b786:	4413      	add	r3, r2
 801b788:	681a      	ldr	r2, [r3, #0]
 801b78a:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801b78e:	4413      	add	r3, r2
 801b790:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801b794:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b798:	681b      	ldr	r3, [r3, #0]
 801b79a:	3310      	adds	r3, #16
 801b79c:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp10 <<= CONST_BITS;
 801b7a0:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801b7a4:	035b      	lsls	r3, r3, #13
 801b7a6:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac

    z1 = (INT32) wsptr[2];
 801b7aa:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b7ae:	3308      	adds	r3, #8
 801b7b0:	681b      	ldr	r3, [r3, #0]
 801b7b2:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    z2 = (INT32) wsptr[4];
 801b7b6:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b7ba:	3310      	adds	r3, #16
 801b7bc:	681b      	ldr	r3, [r3, #0]
 801b7be:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
    z3 = (INT32) wsptr[6];
 801b7c2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b7c6:	3318      	adds	r3, #24
 801b7c8:	681b      	ldr	r3, [r3, #0]
 801b7ca:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0

    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */
 801b7ce:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b7d2:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b7d6:	1ad3      	subs	r3, r2, r3
 801b7d8:	f245 127e 	movw	r2, #20862	; 0x517e
 801b7dc:	fb02 f303 	mul.w	r3, r2, r3
 801b7e0:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */
 801b7e4:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b7e8:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b7ec:	1ad3      	subs	r3, r2, r3
 801b7ee:	f640 52c9 	movw	r2, #3529	; 0xdc9
 801b7f2:	fb02 f303 	mul.w	r3, r2, r3
 801b7f6:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    z4 = z1 + z3;
 801b7fa:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b7fe:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b802:	4413      	add	r3, r2
 801b804:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp24 = MULTIPLY(z4, - FIX(1.155664402));        /* -(c2-c10) */
 801b808:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b80c:	4af0      	ldr	r2, [pc, #960]	; (801bbd0 <jpeg_idct_11x11+0x940>)
 801b80e:	fb02 f303 	mul.w	r3, r2, r3
 801b812:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    z4 -= z2;
 801b816:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801b81a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b81e:	1ad3      	subs	r3, r2, r3
 801b820:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */
 801b824:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b828:	f642 326c 	movw	r2, #11116	; 0x2b6c
 801b82c:	fb02 f303 	mul.w	r3, r2, r3
 801b830:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801b834:	4413      	add	r3, r2
 801b836:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
    tmp21 = tmp20 + tmp23 + tmp25 -
 801b83a:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b83e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801b842:	441a      	add	r2, r3
 801b844:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b848:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */
 801b84a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b84e:	49e1      	ldr	r1, [pc, #900]	; (801bbd4 <jpeg_idct_11x11+0x944>)
 801b850:	fb01 f303 	mul.w	r3, r1, r3
    tmp21 = tmp20 + tmp23 + tmp25 -
 801b854:	4413      	add	r3, r2
 801b856:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */
 801b85a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b85e:	f244 32b5 	movw	r2, #17333	; 0x43b5
 801b862:	fb02 f203 	mul.w	r2, r2, r3
 801b866:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b86a:	4413      	add	r3, r2
 801b86c:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801b870:	4413      	add	r3, r2
 801b872:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */
 801b876:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b87a:	4ad7      	ldr	r2, [pc, #860]	; (801bbd8 <jpeg_idct_11x11+0x948>)
 801b87c:	fb02 f203 	mul.w	r2, r2, r3
 801b880:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b884:	4413      	add	r3, r2
 801b886:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801b88a:	4413      	add	r3, r2
 801b88c:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    tmp24 += tmp25;
 801b890:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b894:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801b898:	4413      	add	r3, r2
 801b89a:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */
 801b89e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b8a2:	4ace      	ldr	r2, [pc, #824]	; (801bbdc <jpeg_idct_11x11+0x94c>)
 801b8a4:	fb02 f303 	mul.w	r3, r2, r3
 801b8a8:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b8ac:	4413      	add	r3, r2
 801b8ae:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 801b8b2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b8b6:	f643 6239 	movw	r2, #15929	; 0x3e39
 801b8ba:	fb02 f203 	mul.w	r2, r2, r3
	     MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */
 801b8be:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b8c2:	49c7      	ldr	r1, [pc, #796]	; (801bbe0 <jpeg_idct_11x11+0x950>)
 801b8c4:	fb01 f303 	mul.w	r3, r1, r3
    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */
 801b8c8:	4413      	add	r3, r2
 801b8ca:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801b8ce:	4413      	add	r3, r2
 801b8d0:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */
 801b8d4:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b8d8:	f46f 5235 	mvn.w	r2, #11584	; 0x2d40
 801b8dc:	fb02 f303 	mul.w	r3, r2, r3
 801b8e0:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801b8e4:	4413      	add	r3, r2
 801b8e6:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801b8ea:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b8ee:	3304      	adds	r3, #4
 801b8f0:	681b      	ldr	r3, [r3, #0]
 801b8f2:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    z2 = (INT32) wsptr[3];
 801b8f6:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b8fa:	330c      	adds	r3, #12
 801b8fc:	681b      	ldr	r3, [r3, #0]
 801b8fe:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
    z3 = (INT32) wsptr[5];
 801b902:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b906:	3314      	adds	r3, #20
 801b908:	681b      	ldr	r3, [r3, #0]
 801b90a:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    z4 = (INT32) wsptr[7];
 801b90e:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801b912:	331c      	adds	r3, #28
 801b914:	681b      	ldr	r3, [r3, #0]
 801b916:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194

    tmp11 = z1 + z2;
 801b91a:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b91e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b922:	4413      	add	r3, r2
 801b924:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */
 801b928:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b92c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b930:	441a      	add	r2, r3
 801b932:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b936:	4413      	add	r3, r2
 801b938:	f44f 624c 	mov.w	r2, #3264	; 0xcc0
 801b93c:	fb02 f303 	mul.w	r3, r2, r3
 801b940:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */
 801b944:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801b948:	f641 426a 	movw	r2, #7274	; 0x1c6a
 801b94c:	fb02 f303 	mul.w	r3, r2, r3
 801b950:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */
 801b954:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b958:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b95c:	4413      	add	r3, r2
 801b95e:	f241 5274 	movw	r2, #5492	; 0x1574
 801b962:	fb02 f303 	mul.w	r3, r2, r3
 801b966:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */
 801b96a:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801b96e:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b972:	4413      	add	r3, r2
 801b974:	f640 32b8 	movw	r2, #3000	; 0xbb8
 801b978:	fb02 f303 	mul.w	r3, r2, r3
 801b97c:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801b980:	4413      	add	r3, r2
 801b982:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
    tmp10 = tmp11 + tmp12 + tmp13 -
 801b986:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b98a:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801b98e:	441a      	add	r2, r3
 801b990:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801b994:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */
 801b996:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b99a:	4992      	ldr	r1, [pc, #584]	; (801bbe4 <jpeg_idct_11x11+0x954>)
 801b99c:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 801b9a0:	4413      	add	r3, r2
 801b9a2:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */
 801b9a6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b9aa:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b9ae:	4413      	add	r3, r2
 801b9b0:	4a8d      	ldr	r2, [pc, #564]	; (801bbe8 <jpeg_idct_11x11+0x958>)
 801b9b2:	fb02 f303 	mul.w	r3, r2, r3
 801b9b6:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801b9ba:	4413      	add	r3, r2
 801b9bc:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */
 801b9c0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801b9c4:	f244 2258 	movw	r2, #16984	; 0x4258
 801b9c8:	fb02 f203 	mul.w	r2, r2, r3
 801b9cc:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b9d0:	4413      	add	r3, r2
 801b9d2:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801b9d6:	4413      	add	r3, r2
 801b9d8:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */
 801b9dc:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801b9e0:	4a82      	ldr	r2, [pc, #520]	; (801bbec <jpeg_idct_11x11+0x95c>)
 801b9e2:	fb02 f203 	mul.w	r2, r2, r3
 801b9e6:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801b9ea:	4413      	add	r3, r2
 801b9ec:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 801b9f0:	4413      	add	r3, r2
 801b9f2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    z1    = MULTIPLY(z2 + z4, - FIX(1.798248910));       /* -(c1+c9) */
 801b9f6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801b9fa:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801b9fe:	4413      	add	r3, r2
 801ba00:	4a7b      	ldr	r2, [pc, #492]	; (801bbf0 <jpeg_idct_11x11+0x960>)
 801ba02:	fb02 f303 	mul.w	r3, r2, r3
 801ba06:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp11 += z1;
 801ba0a:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 801ba0e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801ba12:	4413      	add	r3, r2
 801ba14:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */
 801ba18:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801ba1c:	f244 3247 	movw	r2, #17223	; 0x4347
 801ba20:	fb02 f203 	mul.w	r2, r2, r3
 801ba24:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 801ba28:	4413      	add	r3, r2
 801ba2a:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 801ba2e:	4413      	add	r3, r2
 801ba30:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801ba34:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801ba38:	4a6e      	ldr	r2, [pc, #440]	; (801bbf4 <jpeg_idct_11x11+0x964>)
 801ba3a:	fb02 f203 	mul.w	r2, r2, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 801ba3e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801ba42:	f242 010b 	movw	r1, #8203	; 0x200b
 801ba46:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801ba4a:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */
 801ba4c:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801ba50:	4969      	ldr	r1, [pc, #420]	; (801bbf8 <jpeg_idct_11x11+0x968>)
 801ba52:	fb01 f303 	mul.w	r3, r1, r3
	     MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */
 801ba56:	4413      	add	r3, r2
    tmp14 += MULTIPLY(z2, - FIX(1.467221301)) +          /* -(c5+c9) */
 801ba58:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 801ba5c:	4413      	add	r3, r2
 801ba5e:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ba62:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801ba66:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801ba6a:	4413      	add	r3, r2
 801ba6c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ba6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ba72:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801ba76:	4413      	add	r3, r2
 801ba78:	781a      	ldrb	r2, [r3, #0]
 801ba7a:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801ba7e:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ba80:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801ba84:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 801ba88:	1ad3      	subs	r3, r2, r3
 801ba8a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ba8c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ba90:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801ba94:	441a      	add	r2, r3
 801ba96:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801ba9a:	330a      	adds	r3, #10
 801ba9c:	7812      	ldrb	r2, [r2, #0]
 801ba9e:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801baa0:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801baa4:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801baa8:	4413      	add	r3, r2
 801baaa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801baac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801bab0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bab4:	441a      	add	r2, r3
 801bab6:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801baba:	3301      	adds	r3, #1
 801babc:	7812      	ldrb	r2, [r2, #0]
 801babe:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801bac0:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 801bac4:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 801bac8:	1ad3      	subs	r3, r2, r3
 801baca:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bacc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801bad0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bad4:	441a      	add	r2, r3
 801bad6:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bada:	3309      	adds	r3, #9
 801badc:	7812      	ldrb	r2, [r2, #0]
 801bade:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801bae0:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801bae4:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801bae8:	4413      	add	r3, r2
 801baea:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801baec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801baf0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801baf4:	441a      	add	r2, r3
 801baf6:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bafa:	3302      	adds	r3, #2
 801bafc:	7812      	ldrb	r2, [r2, #0]
 801bafe:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801bb00:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
 801bb04:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801bb08:	1ad3      	subs	r3, r2, r3
 801bb0a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bb0c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801bb10:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bb14:	441a      	add	r2, r3
 801bb16:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bb1a:	3308      	adds	r3, #8
 801bb1c:	7812      	ldrb	r2, [r2, #0]
 801bb1e:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801bb20:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801bb24:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801bb28:	4413      	add	r3, r2
 801bb2a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bb2c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801bb30:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bb34:	441a      	add	r2, r3
 801bb36:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bb3a:	3303      	adds	r3, #3
 801bb3c:	7812      	ldrb	r2, [r2, #0]
 801bb3e:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801bb40:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 801bb44:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801bb48:	1ad3      	subs	r3, r2, r3
 801bb4a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bb4c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801bb50:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bb54:	441a      	add	r2, r3
 801bb56:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bb5a:	3307      	adds	r3, #7
 801bb5c:	7812      	ldrb	r2, [r2, #0]
 801bb5e:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801bb60:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801bb64:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801bb68:	4413      	add	r3, r2
 801bb6a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bb6c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801bb70:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bb74:	441a      	add	r2, r3
 801bb76:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bb7a:	3304      	adds	r3, #4
 801bb7c:	7812      	ldrb	r2, [r2, #0]
 801bb7e:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801bb80:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801bb84:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801bb88:	1ad3      	subs	r3, r2, r3
 801bb8a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bb8c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801bb90:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bb94:	441a      	add	r2, r3
 801bb96:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bb9a:	3306      	adds	r3, #6
 801bb9c:	7812      	ldrb	r2, [r2, #0]
 801bb9e:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 801bba0:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 801bba4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801bba6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25,
 801bbaa:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801bbae:	441a      	add	r2, r3
 801bbb0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 801bbb4:	3305      	adds	r3, #5
 801bbb6:	7812      	ldrb	r2, [r2, #0]
 801bbb8:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801bbba:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bbbe:	3320      	adds	r3, #32
 801bbc0:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
  for (ctr = 0; ctr < 11; ctr++) {
 801bbc4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bbc8:	3301      	adds	r3, #1
 801bbca:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 801bbce:	e015      	b.n	801bbfc <jpeg_idct_11x11+0x96c>
 801bbd0:	ffffdb05 	.word	0xffffdb05
 801bbd4:	ffffc5b4 	.word	0xffffc5b4
 801bbd8:	ffffcf91 	.word	0xffffcf91
 801bbdc:	ffffe6c3 	.word	0xffffe6c3
 801bbe0:	ffffd37d 	.word	0xffffd37d
 801bbe4:	ffffe276 	.word	0xffffe276
 801bbe8:	ffffdac9 	.word	0xffffdac9
 801bbec:	ffffd9da 	.word	0xffffd9da
 801bbf0:	ffffc675 	.word	0xffffc675
 801bbf4:	ffffd10d 	.word	0xffffd10d
 801bbf8:	ffffca16 	.word	0xffffca16
 801bbfc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bc00:	2b0a      	cmp	r3, #10
 801bc02:	f77f adbb 	ble.w	801b77c <jpeg_idct_11x11+0x4ec>
  }
}
 801bc06:	bf00      	nop
 801bc08:	bf00      	nop
 801bc0a:	f507 77e4 	add.w	r7, r7, #456	; 0x1c8
 801bc0e:	46bd      	mov	sp, r7
 801bc10:	bc90      	pop	{r4, r7}
 801bc12:	4770      	bx	lr

0801bc14 <jpeg_idct_12x12>:

GLOBAL(void)
jpeg_idct_12x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801bc14:	b490      	push	{r4, r7}
 801bc16:	b0fa      	sub	sp, #488	; 0x1e8
 801bc18:	af00      	add	r7, sp, #0
 801bc1a:	f107 040c 	add.w	r4, r7, #12
 801bc1e:	6020      	str	r0, [r4, #0]
 801bc20:	f107 0008 	add.w	r0, r7, #8
 801bc24:	6001      	str	r1, [r0, #0]
 801bc26:	1d39      	adds	r1, r7, #4
 801bc28:	600a      	str	r2, [r1, #0]
 801bc2a:	463a      	mov	r2, r7
 801bc2c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801bc2e:	f107 030c 	add.w	r3, r7, #12
 801bc32:	681b      	ldr	r3, [r3, #0]
 801bc34:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801bc38:	3380      	adds	r3, #128	; 0x80
 801bc3a:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
  int workspace[8*12];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801bc3e:	1d3b      	adds	r3, r7, #4
 801bc40:	681b      	ldr	r3, [r3, #0]
 801bc42:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801bc46:	f107 0308 	add.w	r3, r7, #8
 801bc4a:	681b      	ldr	r3, [r3, #0]
 801bc4c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801bc4e:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
  wsptr = workspace;
 801bc52:	f107 0310 	add.w	r3, r7, #16
 801bc56:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801bc5a:	2300      	movs	r3, #0
 801bc5c:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
 801bc60:	e218      	b.n	801c094 <jpeg_idct_12x12+0x480>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801bc62:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bc66:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc6a:	461a      	mov	r2, r3
 801bc6c:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bc70:	681b      	ldr	r3, [r3, #0]
 801bc72:	fb03 f302 	mul.w	r3, r3, r2
 801bc76:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    z3 <<= CONST_BITS;
 801bc7a:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801bc7e:	035b      	lsls	r3, r3, #13
 801bc80:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 801bc84:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801bc88:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801bc8c:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801bc90:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bc94:	3340      	adds	r3, #64	; 0x40
 801bc96:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc9a:	461a      	mov	r2, r3
 801bc9c:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bca0:	3380      	adds	r3, #128	; 0x80
 801bca2:	681b      	ldr	r3, [r3, #0]
 801bca4:	fb03 f302 	mul.w	r3, r3, r2
 801bca8:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 801bcac:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bcb0:	f242 7231 	movw	r2, #10033	; 0x2731
 801bcb4:	fb02 f303 	mul.w	r3, r2, r3
 801bcb8:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp10 = z3 + z4;
 801bcbc:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bcc0:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bcc4:	4413      	add	r3, r2
 801bcc6:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp11 = z3 - z4;
 801bcca:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bcce:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bcd2:	1ad3      	subs	r3, r2, r3
 801bcd4:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801bcd8:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bcdc:	3320      	adds	r3, #32
 801bcde:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bce2:	461a      	mov	r2, r3
 801bce4:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bce8:	3340      	adds	r3, #64	; 0x40
 801bcea:	681b      	ldr	r3, [r3, #0]
 801bcec:	fb03 f302 	mul.w	r3, r3, r2
 801bcf0:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 801bcf4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bcf8:	f642 32b6 	movw	r2, #11190	; 0x2bb6
 801bcfc:	fb02 f303 	mul.w	r3, r2, r3
 801bd00:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    z1 <<= CONST_BITS;
 801bd04:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bd08:	035b      	lsls	r3, r3, #13
 801bd0a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801bd0e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bd12:	3360      	adds	r3, #96	; 0x60
 801bd14:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd18:	461a      	mov	r2, r3
 801bd1a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bd1e:	33c0      	adds	r3, #192	; 0xc0
 801bd20:	681b      	ldr	r3, [r3, #0]
 801bd22:	fb03 f302 	mul.w	r3, r3, r2
 801bd26:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z2 <<= CONST_BITS;
 801bd2a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bd2e:	035b      	lsls	r3, r3, #13
 801bd30:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    tmp12 = z1 - z2;
 801bd34:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801bd38:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bd3c:	1ad3      	subs	r3, r2, r3
 801bd3e:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp21 = z3 + tmp12;
 801bd42:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bd46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bd4a:	4413      	add	r3, r2
 801bd4c:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
    tmp24 = z3 - tmp12;
 801bd50:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bd54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bd58:	1ad3      	subs	r3, r2, r3
 801bd5a:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac

    tmp12 = z4 + z2;
 801bd5e:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801bd62:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bd66:	4413      	add	r3, r2
 801bd68:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp20 = tmp10 + tmp12;
 801bd6c:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801bd70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bd74:	4413      	add	r3, r2
 801bd76:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp25 = tmp10 - tmp12;
 801bd7a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801bd7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bd82:	1ad3      	subs	r3, r2, r3
 801bd84:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4

    tmp12 = z4 - z1 - z2;
 801bd88:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801bd8c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bd90:	1ad2      	subs	r2, r2, r3
 801bd92:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bd96:	1ad3      	subs	r3, r2, r3
 801bd98:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp22 = tmp11 + tmp12;
 801bd9c:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801bda0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bda4:	4413      	add	r3, r2
 801bda6:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    tmp23 = tmp11 - tmp12;
 801bdaa:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801bdae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bdb2:	1ad3      	subs	r3, r2, r3
 801bdb4:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801bdb8:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bdbc:	3310      	adds	r3, #16
 801bdbe:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdc2:	461a      	mov	r2, r3
 801bdc4:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bdc8:	3320      	adds	r3, #32
 801bdca:	681b      	ldr	r3, [r3, #0]
 801bdcc:	fb03 f302 	mul.w	r3, r3, r2
 801bdd0:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801bdd4:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bdd8:	3330      	adds	r3, #48	; 0x30
 801bdda:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdde:	461a      	mov	r2, r3
 801bde0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801bde4:	3360      	adds	r3, #96	; 0x60
 801bde6:	681b      	ldr	r3, [r3, #0]
 801bde8:	fb03 f302 	mul.w	r3, r3, r2
 801bdec:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801bdf0:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801bdf4:	3350      	adds	r3, #80	; 0x50
 801bdf6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdfa:	461a      	mov	r2, r3
 801bdfc:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801be00:	33a0      	adds	r3, #160	; 0xa0
 801be02:	681b      	ldr	r3, [r3, #0]
 801be04:	fb03 f302 	mul.w	r3, r3, r2
 801be08:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801be0c:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801be10:	3370      	adds	r3, #112	; 0x70
 801be12:	f9b3 3000 	ldrsh.w	r3, [r3]
 801be16:	461a      	mov	r2, r3
 801be18:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801be1c:	33e0      	adds	r3, #224	; 0xe0
 801be1e:	681b      	ldr	r3, [r3, #0]
 801be20:	fb03 f302 	mul.w	r3, r3, r2
 801be24:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 801be28:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801be2c:	f642 12cf 	movw	r2, #10703	; 0x29cf
 801be30:	fb02 f303 	mul.w	r3, r2, r3
 801be34:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 801be38:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801be3c:	4a9c      	ldr	r2, [pc, #624]	; (801c0b0 <jpeg_idct_12x12+0x49c>)
 801be3e:	fb02 f303 	mul.w	r3, r2, r3
 801be42:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198

    tmp10 = z1 + z3;
 801be46:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801be4a:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801be4e:	4413      	add	r3, r2
 801be50:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 801be54:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801be58:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801be5c:	4413      	add	r3, r2
 801be5e:	f641 328d 	movw	r2, #7053	; 0x1b8d
 801be62:	fb02 f303 	mul.w	r3, r2, r3
 801be66:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 801be6a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801be6e:	f640 025b 	movw	r2, #2139	; 0x85b
 801be72:	fb02 f303 	mul.w	r3, r2, r3
 801be76:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801be7a:	4413      	add	r3, r2
 801be7c:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 801be80:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801be84:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801be88:	18d1      	adds	r1, r2, r3
 801be8a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801be8e:	4613      	mov	r3, r2
 801be90:	00db      	lsls	r3, r3, #3
 801be92:	4413      	add	r3, r2
 801be94:	021a      	lsls	r2, r3, #8
 801be96:	1ad3      	subs	r3, r2, r3
 801be98:	440b      	add	r3, r1
 801be9a:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 801be9e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bea2:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bea6:	4413      	add	r3, r2
 801bea8:	4a82      	ldr	r2, [pc, #520]	; (801c0b4 <jpeg_idct_12x12+0x4a0>)
 801beaa:	fb02 f303 	mul.w	r3, r2, r3
 801beae:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 801beb2:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801beb6:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801beba:	441a      	add	r2, r3
 801bebc:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801bec0:	497d      	ldr	r1, [pc, #500]	; (801c0b8 <jpeg_idct_12x12+0x4a4>)
 801bec2:	fb01 f303 	mul.w	r3, r1, r3
 801bec6:	4413      	add	r3, r2
 801bec8:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801becc:	4413      	add	r3, r2
 801bece:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 801bed2:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801bed6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801beda:	1ad2      	subs	r2, r2, r3
 801bedc:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bee0:	f243 21c6 	movw	r1, #12998	; 0x32c6
 801bee4:	fb01 f303 	mul.w	r3, r1, r3
 801bee8:	4413      	add	r3, r2
 801beea:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801beee:	4413      	add	r3, r2
 801bef0:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 801bef4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bef8:	4a70      	ldr	r2, [pc, #448]	; (801c0bc <jpeg_idct_12x12+0x4a8>)
 801befa:	fb02 f203 	mul.w	r2, r2, r3
 801befe:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801bf02:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 801bf04:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bf08:	496d      	ldr	r1, [pc, #436]	; (801c0c0 <jpeg_idct_12x12+0x4ac>)
 801bf0a:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 801bf0e:	4413      	add	r3, r2
 801bf10:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801bf14:	4413      	add	r3, r2
 801bf16:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194

    z1 -= z4;
 801bf1a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801bf1e:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801bf22:	1ad3      	subs	r3, r2, r3
 801bf24:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 -= z3;
 801bf28:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 801bf2c:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801bf30:	1ad3      	subs	r3, r2, r3
 801bf32:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 801bf36:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801bf3a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bf3e:	4413      	add	r3, r2
 801bf40:	f241 1251 	movw	r2, #4433	; 0x1151
 801bf44:	fb02 f303 	mul.w	r3, r2, r3
 801bf48:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 801bf4c:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801bf50:	f641 027e 	movw	r2, #6270	; 0x187e
 801bf54:	fb02 f303 	mul.w	r3, r2, r3
 801bf58:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bf5c:	4413      	add	r3, r2
 801bf5e:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 801bf62:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801bf66:	4a57      	ldr	r2, [pc, #348]	; (801c0c4 <jpeg_idct_12x12+0x4b0>)
 801bf68:	fb02 f303 	mul.w	r3, r2, r3
 801bf6c:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801bf70:	4413      	add	r3, r2
 801bf72:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801bf76:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801bf7a:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801bf7e:	4413      	add	r3, r2
 801bf80:	12da      	asrs	r2, r3, #11
 801bf82:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bf86:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801bf88:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801bf8c:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801bf90:	1ad2      	subs	r2, r2, r3
 801bf92:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bf96:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 801bf9a:	12d2      	asrs	r2, r2, #11
 801bf9c:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801bf9e:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 801bfa2:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801bfa6:	441a      	add	r2, r3
 801bfa8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bfac:	3320      	adds	r3, #32
 801bfae:	12d2      	asrs	r2, r2, #11
 801bfb0:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801bfb2:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 801bfb6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801bfba:	1ad2      	subs	r2, r2, r3
 801bfbc:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bfc0:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801bfc4:	12d2      	asrs	r2, r2, #11
 801bfc6:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 801bfc8:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 801bfcc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bfd0:	441a      	add	r2, r3
 801bfd2:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bfd6:	3340      	adds	r3, #64	; 0x40
 801bfd8:	12d2      	asrs	r2, r2, #11
 801bfda:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 801bfdc:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 801bfe0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801bfe4:	1ad2      	subs	r2, r2, r3
 801bfe6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801bfea:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801bfee:	12d2      	asrs	r2, r2, #11
 801bff0:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801bff2:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801bff6:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801bffa:	441a      	add	r2, r3
 801bffc:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c000:	3360      	adds	r3, #96	; 0x60
 801c002:	12d2      	asrs	r2, r2, #11
 801c004:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801c006:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801c00a:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801c00e:	1ad2      	subs	r2, r2, r3
 801c010:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c014:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801c018:	12d2      	asrs	r2, r2, #11
 801c01a:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801c01c:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801c020:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c024:	441a      	add	r2, r3
 801c026:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c02a:	3380      	adds	r3, #128	; 0x80
 801c02c:	12d2      	asrs	r2, r2, #11
 801c02e:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801c030:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801c034:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c038:	1ad2      	subs	r2, r2, r3
 801c03a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c03e:	33e0      	adds	r3, #224	; 0xe0
 801c040:	12d2      	asrs	r2, r2, #11
 801c042:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 801c044:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801c048:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801c04c:	441a      	add	r2, r3
 801c04e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c052:	33a0      	adds	r3, #160	; 0xa0
 801c054:	12d2      	asrs	r2, r2, #11
 801c056:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 801c058:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801c05c:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801c060:	1ad2      	subs	r2, r2, r3
 801c062:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c066:	33c0      	adds	r3, #192	; 0xc0
 801c068:	12d2      	asrs	r2, r2, #11
 801c06a:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801c06c:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c070:	3301      	adds	r3, #1
 801c072:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
 801c076:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c07a:	3302      	adds	r3, #2
 801c07c:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
 801c080:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c084:	3304      	adds	r3, #4
 801c086:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
 801c08a:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c08e:	3304      	adds	r3, #4
 801c090:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
 801c094:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c098:	2b07      	cmp	r3, #7
 801c09a:	f77f ade2 	ble.w	801bc62 <jpeg_idct_12x12+0x4e>
  }

  /* Pass 2: process 12 rows from work array, store into output array. */

  wsptr = workspace;
 801c09e:	f107 0310 	add.w	r3, r7, #16
 801c0a2:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 801c0a6:	2300      	movs	r3, #0
 801c0a8:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
 801c0ac:	e227      	b.n	801c4fe <jpeg_idct_12x12+0x8ea>
 801c0ae:	bf00      	nop
 801c0b0:	ffffeeaf 	.word	0xffffeeaf
 801c0b4:	ffffde8b 	.word	0xffffde8b
 801c0b8:	ffffd0b0 	.word	0xffffd0b0
 801c0bc:	ffffea5c 	.word	0xffffea5c
 801c0c0:	ffffc08c 	.word	0xffffc08c
 801c0c4:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 801c0c8:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c0cc:	009b      	lsls	r3, r3, #2
 801c0ce:	463a      	mov	r2, r7
 801c0d0:	6812      	ldr	r2, [r2, #0]
 801c0d2:	4413      	add	r3, r2
 801c0d4:	681a      	ldr	r2, [r3, #0]
 801c0d6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c0da:	4413      	add	r3, r2
 801c0dc:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801c0e0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c0e4:	681b      	ldr	r3, [r3, #0]
 801c0e6:	3310      	adds	r3, #16
 801c0e8:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    z3 <<= CONST_BITS;
 801c0ec:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801c0f0:	035b      	lsls	r3, r3, #13
 801c0f2:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc

    z4 = (INT32) wsptr[4];
 801c0f6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c0fa:	3310      	adds	r3, #16
 801c0fc:	681b      	ldr	r3, [r3, #0]
 801c0fe:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 801c102:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c106:	f242 7231 	movw	r2, #10033	; 0x2731
 801c10a:	fb02 f303 	mul.w	r3, r2, r3
 801c10e:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp10 = z3 + z4;
 801c112:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c116:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c11a:	4413      	add	r3, r2
 801c11c:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp11 = z3 - z4;
 801c120:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c124:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c128:	1ad3      	subs	r3, r2, r3
 801c12a:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0

    z1 = (INT32) wsptr[2];
 801c12e:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c132:	3308      	adds	r3, #8
 801c134:	681b      	ldr	r3, [r3, #0]
 801c136:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 801c13a:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801c13e:	f642 32b6 	movw	r2, #11190	; 0x2bb6
 801c142:	fb02 f303 	mul.w	r3, r2, r3
 801c146:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    z1 <<= CONST_BITS;
 801c14a:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801c14e:	035b      	lsls	r3, r3, #13
 801c150:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 = (INT32) wsptr[6];
 801c154:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c158:	3318      	adds	r3, #24
 801c15a:	681b      	ldr	r3, [r3, #0]
 801c15c:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z2 <<= CONST_BITS;
 801c160:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c164:	035b      	lsls	r3, r3, #13
 801c166:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    tmp12 = z1 - z2;
 801c16a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801c16e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c172:	1ad3      	subs	r3, r2, r3
 801c174:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp21 = z3 + tmp12;
 801c178:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c17c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c180:	4413      	add	r3, r2
 801c182:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
    tmp24 = z3 - tmp12;
 801c186:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c18a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c18e:	1ad3      	subs	r3, r2, r3
 801c190:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac

    tmp12 = z4 + z2;
 801c194:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801c198:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c19c:	4413      	add	r3, r2
 801c19e:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp20 = tmp10 + tmp12;
 801c1a2:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801c1a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c1aa:	4413      	add	r3, r2
 801c1ac:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp25 = tmp10 - tmp12;
 801c1b0:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801c1b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c1b8:	1ad3      	subs	r3, r2, r3
 801c1ba:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4

    tmp12 = z4 - z1 - z2;
 801c1be:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801c1c2:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801c1c6:	1ad2      	subs	r2, r2, r3
 801c1c8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c1cc:	1ad3      	subs	r3, r2, r3
 801c1ce:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp22 = tmp11 + tmp12;
 801c1d2:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801c1d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c1da:	4413      	add	r3, r2
 801c1dc:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    tmp23 = tmp11 - tmp12;
 801c1e0:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801c1e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c1e8:	1ad3      	subs	r3, r2, r3
 801c1ea:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801c1ee:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c1f2:	3304      	adds	r3, #4
 801c1f4:	681b      	ldr	r3, [r3, #0]
 801c1f6:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 = (INT32) wsptr[3];
 801c1fa:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c1fe:	330c      	adds	r3, #12
 801c200:	681b      	ldr	r3, [r3, #0]
 801c202:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z3 = (INT32) wsptr[5];
 801c206:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c20a:	3314      	adds	r3, #20
 801c20c:	681b      	ldr	r3, [r3, #0]
 801c20e:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    z4 = (INT32) wsptr[7];
 801c212:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c216:	331c      	adds	r3, #28
 801c218:	681b      	ldr	r3, [r3, #0]
 801c21a:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 801c21e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c222:	f642 12cf 	movw	r2, #10703	; 0x29cf
 801c226:	fb02 f303 	mul.w	r3, r2, r3
 801c22a:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 801c22e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c232:	4ab9      	ldr	r2, [pc, #740]	; (801c518 <jpeg_idct_12x12+0x904>)
 801c234:	fb02 f303 	mul.w	r3, r2, r3
 801c238:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198

    tmp10 = z1 + z3;
 801c23c:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801c240:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801c244:	4413      	add	r3, r2
 801c246:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 801c24a:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801c24e:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c252:	4413      	add	r3, r2
 801c254:	f641 328d 	movw	r2, #7053	; 0x1b8d
 801c258:	fb02 f303 	mul.w	r3, r2, r3
 801c25c:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 801c260:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801c264:	f640 025b 	movw	r2, #2139	; 0x85b
 801c268:	fb02 f303 	mul.w	r3, r2, r3
 801c26c:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801c270:	4413      	add	r3, r2
 801c272:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 801c276:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801c27a:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801c27e:	18d1      	adds	r1, r2, r3
 801c280:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801c284:	4613      	mov	r3, r2
 801c286:	00db      	lsls	r3, r3, #3
 801c288:	4413      	add	r3, r2
 801c28a:	021a      	lsls	r2, r3, #8
 801c28c:	1ad3      	subs	r3, r2, r3
 801c28e:	440b      	add	r3, r1
 801c290:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 801c294:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c298:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c29c:	4413      	add	r3, r2
 801c29e:	4a9f      	ldr	r2, [pc, #636]	; (801c51c <jpeg_idct_12x12+0x908>)
 801c2a0:	fb02 f303 	mul.w	r3, r2, r3
 801c2a4:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 801c2a8:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801c2ac:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c2b0:	441a      	add	r2, r3
 801c2b2:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801c2b6:	499a      	ldr	r1, [pc, #616]	; (801c520 <jpeg_idct_12x12+0x90c>)
 801c2b8:	fb01 f303 	mul.w	r3, r1, r3
 801c2bc:	4413      	add	r3, r2
 801c2be:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801c2c2:	4413      	add	r3, r2
 801c2c4:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 801c2c8:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801c2cc:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801c2d0:	1ad2      	subs	r2, r2, r3
 801c2d2:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c2d6:	f243 21c6 	movw	r1, #12998	; 0x32c6
 801c2da:	fb01 f303 	mul.w	r3, r1, r3
 801c2de:	4413      	add	r3, r2
 801c2e0:	f8d7 2190 	ldr.w	r2, [r7, #400]	; 0x190
 801c2e4:	4413      	add	r3, r2
 801c2e6:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 801c2ea:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801c2ee:	4a8d      	ldr	r2, [pc, #564]	; (801c524 <jpeg_idct_12x12+0x910>)
 801c2f0:	fb02 f203 	mul.w	r2, r2, r3
 801c2f4:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c2f8:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 801c2fa:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c2fe:	498a      	ldr	r1, [pc, #552]	; (801c528 <jpeg_idct_12x12+0x914>)
 801c300:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 801c304:	4413      	add	r3, r2
 801c306:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 801c30a:	4413      	add	r3, r2
 801c30c:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194

    z1 -= z4;
 801c310:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801c314:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 801c318:	1ad3      	subs	r3, r2, r3
 801c31a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 -= z3;
 801c31e:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 801c322:	f8d7 31cc 	ldr.w	r3, [r7, #460]	; 0x1cc
 801c326:	1ad3      	subs	r3, r2, r3
 801c328:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 801c32c:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801c330:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c334:	4413      	add	r3, r2
 801c336:	f241 1251 	movw	r2, #4433	; 0x1151
 801c33a:	fb02 f303 	mul.w	r3, r2, r3
 801c33e:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 801c342:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801c346:	f641 027e 	movw	r2, #6270	; 0x187e
 801c34a:	fb02 f303 	mul.w	r3, r2, r3
 801c34e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c352:	4413      	add	r3, r2
 801c354:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 801c358:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c35c:	4a73      	ldr	r2, [pc, #460]	; (801c52c <jpeg_idct_12x12+0x918>)
 801c35e:	fb02 f303 	mul.w	r3, r2, r3
 801c362:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c366:	4413      	add	r3, r2
 801c368:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801c36c:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801c370:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801c374:	4413      	add	r3, r2
 801c376:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c378:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801c37c:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c380:	4413      	add	r3, r2
 801c382:	781a      	ldrb	r2, [r3, #0]
 801c384:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c388:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801c38a:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 801c38e:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
 801c392:	1ad3      	subs	r3, r2, r3
 801c394:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c396:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801c39a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c39e:	441a      	add	r2, r3
 801c3a0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c3a4:	330b      	adds	r3, #11
 801c3a6:	7812      	ldrb	r2, [r2, #0]
 801c3a8:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801c3aa:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 801c3ae:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801c3b2:	4413      	add	r3, r2
 801c3b4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c3b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801c3ba:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c3be:	441a      	add	r2, r3
 801c3c0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c3c4:	3301      	adds	r3, #1
 801c3c6:	7812      	ldrb	r2, [r2, #0]
 801c3c8:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801c3ca:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 801c3ce:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 801c3d2:	1ad3      	subs	r3, r2, r3
 801c3d4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c3d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801c3da:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c3de:	441a      	add	r2, r3
 801c3e0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c3e4:	330a      	adds	r3, #10
 801c3e6:	7812      	ldrb	r2, [r2, #0]
 801c3e8:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801c3ea:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 801c3ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c3f2:	4413      	add	r3, r2
 801c3f4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c3f6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801c3fa:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c3fe:	441a      	add	r2, r3
 801c400:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c404:	3302      	adds	r3, #2
 801c406:	7812      	ldrb	r2, [r2, #0]
 801c408:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801c40a:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 801c40e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c412:	1ad3      	subs	r3, r2, r3
 801c414:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c416:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801c41a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c41e:	441a      	add	r2, r3
 801c420:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c424:	3309      	adds	r3, #9
 801c426:	7812      	ldrb	r2, [r2, #0]
 801c428:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801c42a:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801c42e:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801c432:	4413      	add	r3, r2
 801c434:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c436:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801c43a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c43e:	441a      	add	r2, r3
 801c440:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c444:	3303      	adds	r3, #3
 801c446:	7812      	ldrb	r2, [r2, #0]
 801c448:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801c44a:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 801c44e:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 801c452:	1ad3      	subs	r3, r2, r3
 801c454:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c456:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801c45a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c45e:	441a      	add	r2, r3
 801c460:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c464:	3308      	adds	r3, #8
 801c466:	7812      	ldrb	r2, [r2, #0]
 801c468:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801c46a:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801c46e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c472:	4413      	add	r3, r2
 801c474:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c476:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801c47a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c47e:	441a      	add	r2, r3
 801c480:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c484:	3304      	adds	r3, #4
 801c486:	7812      	ldrb	r2, [r2, #0]
 801c488:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801c48a:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 801c48e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 801c492:	1ad3      	subs	r3, r2, r3
 801c494:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c496:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801c49a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c49e:	441a      	add	r2, r3
 801c4a0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c4a4:	3307      	adds	r3, #7
 801c4a6:	7812      	ldrb	r2, [r2, #0]
 801c4a8:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801c4aa:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801c4ae:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801c4b2:	4413      	add	r3, r2
 801c4b4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c4b6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801c4ba:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c4be:	441a      	add	r2, r3
 801c4c0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c4c4:	3305      	adds	r3, #5
 801c4c6:	7812      	ldrb	r2, [r2, #0]
 801c4c8:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801c4ca:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 801c4ce:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 801c4d2:	1ad3      	subs	r3, r2, r3
 801c4d4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801c4d6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801c4da:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c4de:	441a      	add	r2, r3
 801c4e0:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801c4e4:	3306      	adds	r3, #6
 801c4e6:	7812      	ldrb	r2, [r2, #0]
 801c4e8:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801c4ea:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c4ee:	3320      	adds	r3, #32
 801c4f0:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
  for (ctr = 0; ctr < 12; ctr++) {
 801c4f4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c4f8:	3301      	adds	r3, #1
 801c4fa:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
 801c4fe:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c502:	2b0b      	cmp	r3, #11
 801c504:	f77f ade0 	ble.w	801c0c8 <jpeg_idct_12x12+0x4b4>
  }
}
 801c508:	bf00      	nop
 801c50a:	bf00      	nop
 801c50c:	f507 77f4 	add.w	r7, r7, #488	; 0x1e8
 801c510:	46bd      	mov	sp, r7
 801c512:	bc90      	pop	{r4, r7}
 801c514:	4770      	bx	lr
 801c516:	bf00      	nop
 801c518:	ffffeeaf 	.word	0xffffeeaf
 801c51c:	ffffde8b 	.word	0xffffde8b
 801c520:	ffffd0b0 	.word	0xffffd0b0
 801c524:	ffffea5c 	.word	0xffffea5c
 801c528:	ffffc08c 	.word	0xffffc08c
 801c52c:	ffffc4df 	.word	0xffffc4df

0801c530 <jpeg_idct_13x13>:

GLOBAL(void)
jpeg_idct_13x13 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801c530:	b490      	push	{r4, r7}
 801c532:	f5ad 7d04 	sub.w	sp, sp, #528	; 0x210
 801c536:	af00      	add	r7, sp, #0
 801c538:	f107 040c 	add.w	r4, r7, #12
 801c53c:	6020      	str	r0, [r4, #0]
 801c53e:	f107 0008 	add.w	r0, r7, #8
 801c542:	6001      	str	r1, [r0, #0]
 801c544:	1d39      	adds	r1, r7, #4
 801c546:	600a      	str	r2, [r1, #0]
 801c548:	463a      	mov	r2, r7
 801c54a:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801c54c:	f107 030c 	add.w	r3, r7, #12
 801c550:	681b      	ldr	r3, [r3, #0]
 801c552:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801c556:	3380      	adds	r3, #128	; 0x80
 801c558:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
  int workspace[8*13];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801c55c:	1d3b      	adds	r3, r7, #4
 801c55e:	681b      	ldr	r3, [r3, #0]
 801c560:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801c564:	f107 0308 	add.w	r3, r7, #8
 801c568:	681b      	ldr	r3, [r3, #0]
 801c56a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801c56c:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
  wsptr = workspace;
 801c570:	f107 0314 	add.w	r3, r7, #20
 801c574:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801c578:	2300      	movs	r3, #0
 801c57a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
 801c57e:	e29a      	b.n	801cab6 <jpeg_idct_13x13+0x586>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801c580:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c584:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c588:	461a      	mov	r2, r3
 801c58a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c58e:	681b      	ldr	r3, [r3, #0]
 801c590:	fb03 f302 	mul.w	r3, r3, r2
 801c594:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    z1 <<= CONST_BITS;
 801c598:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c59c:	035b      	lsls	r3, r3, #13
 801c59e:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 801c5a2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c5a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801c5aa:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801c5ae:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c5b2:	3320      	adds	r3, #32
 801c5b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c5b8:	461a      	mov	r2, r3
 801c5ba:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c5be:	3340      	adds	r3, #64	; 0x40
 801c5c0:	681b      	ldr	r3, [r3, #0]
 801c5c2:	fb03 f302 	mul.w	r3, r3, r2
 801c5c6:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801c5ca:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c5ce:	3340      	adds	r3, #64	; 0x40
 801c5d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c5d4:	461a      	mov	r2, r3
 801c5d6:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c5da:	3380      	adds	r3, #128	; 0x80
 801c5dc:	681b      	ldr	r3, [r3, #0]
 801c5de:	fb03 f302 	mul.w	r3, r3, r2
 801c5e2:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801c5e6:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c5ea:	3360      	adds	r3, #96	; 0x60
 801c5ec:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c5f0:	461a      	mov	r2, r3
 801c5f2:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c5f6:	33c0      	adds	r3, #192	; 0xc0
 801c5f8:	681b      	ldr	r3, [r3, #0]
 801c5fa:	fb03 f302 	mul.w	r3, r3, r2
 801c5fe:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8

    tmp10 = z3 + z4;
 801c602:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801c606:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c60a:	4413      	add	r3, r2
 801c60c:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp11 = z3 - z4;
 801c610:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801c614:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c618:	1ad3      	subs	r3, r2, r3
 801c61a:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 801c61e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c622:	f242 42f9 	movw	r2, #9465	; 0x24f9
 801c626:	fb02 f303 	mul.w	r3, r2, r3
 801c62a:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 801c62e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c632:	f240 3219 	movw	r2, #793	; 0x319
 801c636:	fb02 f303 	mul.w	r3, r2, r3
 801c63a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c63e:	4413      	add	r3, r2
 801c640:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 801c644:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c648:	f642 32f1 	movw	r2, #11249	; 0x2bf1
 801c64c:	fb02 f203 	mul.w	r2, r2, r3
 801c650:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c654:	4413      	add	r3, r2
 801c656:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c65a:	4413      	add	r3, r2
 801c65c:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 801c660:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c664:	f241 020c 	movw	r2, #4108	; 0x100c
 801c668:	fb02 f203 	mul.w	r2, r2, r3
 801c66c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c670:	1ad3      	subs	r3, r2, r3
 801c672:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c676:	4413      	add	r3, r2
 801c678:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 801c67c:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c680:	f44f 6222 	mov.w	r2, #2592	; 0xa20
 801c684:	fb02 f303 	mul.w	r3, r2, r3
 801c688:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 801c68c:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c690:	f640 7295 	movw	r2, #3989	; 0xf95
 801c694:	fb02 f303 	mul.w	r3, r2, r3
 801c698:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c69c:	4413      	add	r3, r2
 801c69e:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 801c6a2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c6a6:	f242 12e0 	movw	r2, #8672	; 0x21e0
 801c6aa:	fb02 f203 	mul.w	r2, r2, r3
 801c6ae:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c6b2:	1ad3      	subs	r3, r2, r3
 801c6b4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c6b8:	4413      	add	r3, r2
 801c6ba:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 801c6be:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c6c2:	4af1      	ldr	r2, [pc, #964]	; (801ca88 <jpeg_idct_13x13+0x558>)
 801c6c4:	fb02 f203 	mul.w	r2, r2, r3
 801c6c8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c6cc:	4413      	add	r3, r2
 801c6ce:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c6d2:	4413      	add	r3, r2
 801c6d4:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 801c6d8:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c6dc:	f640 52f2 	movw	r2, #3570	; 0xdf2
 801c6e0:	fb02 f303 	mul.w	r3, r2, r3
 801c6e4:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 801c6e8:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c6ec:	f641 52fe 	movw	r2, #7678	; 0x1dfe
 801c6f0:	fb02 f203 	mul.w	r2, r2, r3
 801c6f4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c6f8:	1ad3      	subs	r3, r2, r3
 801c6fa:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 801c6fe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c702:	4ae2      	ldr	r2, [pc, #904]	; (801ca8c <jpeg_idct_13x13+0x55c>)
 801c704:	fb02 f203 	mul.w	r2, r2, r3
 801c708:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c70c:	1ad2      	subs	r2, r2, r3
 801c70e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c712:	1ad3      	subs	r3, r2, r3
 801c714:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 801c718:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c71c:	4adc      	ldr	r2, [pc, #880]	; (801ca90 <jpeg_idct_13x13+0x560>)
 801c71e:	fb02 f203 	mul.w	r2, r2, r3
 801c722:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c726:	441a      	add	r2, r3
 801c728:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c72c:	1ad3      	subs	r3, r2, r3
 801c72e:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 801c732:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801c736:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c73a:	1ad3      	subs	r3, r2, r3
 801c73c:	f642 5241 	movw	r2, #11585	; 0x2d41
 801c740:	fb02 f303 	mul.w	r3, r2, r3
 801c744:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c748:	4413      	add	r3, r2
 801c74a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801c74e:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c752:	3310      	adds	r3, #16
 801c754:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c758:	461a      	mov	r2, r3
 801c75a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c75e:	3320      	adds	r3, #32
 801c760:	681b      	ldr	r3, [r3, #0]
 801c762:	fb03 f302 	mul.w	r3, r3, r2
 801c766:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801c76a:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c76e:	3330      	adds	r3, #48	; 0x30
 801c770:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c774:	461a      	mov	r2, r3
 801c776:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c77a:	3360      	adds	r3, #96	; 0x60
 801c77c:	681b      	ldr	r3, [r3, #0]
 801c77e:	fb03 f302 	mul.w	r3, r3, r2
 801c782:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801c786:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c78a:	3350      	adds	r3, #80	; 0x50
 801c78c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c790:	461a      	mov	r2, r3
 801c792:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c796:	33a0      	adds	r3, #160	; 0xa0
 801c798:	681b      	ldr	r3, [r3, #0]
 801c79a:	fb03 f302 	mul.w	r3, r3, r2
 801c79e:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801c7a2:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801c7a6:	3370      	adds	r3, #112	; 0x70
 801c7a8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801c7ac:	461a      	mov	r2, r3
 801c7ae:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801c7b2:	33e0      	adds	r3, #224	; 0xe0
 801c7b4:	681b      	ldr	r3, [r3, #0]
 801c7b6:	fb03 f302 	mul.w	r3, r3, r2
 801c7ba:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 801c7be:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c7c2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c7c6:	4413      	add	r3, r2
 801c7c8:	f642 2250 	movw	r2, #10832	; 0x2a50
 801c7cc:	fb02 f303 	mul.w	r3, r2, r3
 801c7d0:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 801c7d4:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c7d8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801c7dc:	4413      	add	r3, r2
 801c7de:	f242 523e 	movw	r2, #9534	; 0x253e
 801c7e2:	fb02 f303 	mul.w	r3, r2, r3
 801c7e6:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp15 = z1 + z4;
 801c7ea:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801c7ee:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c7f2:	4413      	add	r3, r2
 801c7f4:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 801c7f8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c7fc:	f641 6202 	movw	r2, #7682	; 0x1e02
 801c800:	fb02 f303 	mul.w	r3, r2, r3
 801c804:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 801c808:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801c80c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c810:	441a      	add	r2, r3
 801c812:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c816:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 801c818:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c81c:	499d      	ldr	r1, [pc, #628]	; (801ca94 <jpeg_idct_13x13+0x564>)
 801c81e:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 801c822:	4413      	add	r3, r2
 801c824:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 801c828:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801c82c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801c830:	4413      	add	r3, r2
 801c832:	4a99      	ldr	r2, [pc, #612]	; (801ca98 <jpeg_idct_13x13+0x568>)
 801c834:	fb02 f303 	mul.w	r3, r2, r3
 801c838:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 801c83c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c840:	f641 22cb 	movw	r2, #6859	; 0x1acb
 801c844:	fb02 f203 	mul.w	r2, r2, r3
 801c848:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c84c:	4413      	add	r3, r2
 801c84e:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801c852:	4413      	add	r3, r2
 801c854:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 801c858:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801c85c:	4a8f      	ldr	r2, [pc, #572]	; (801ca9c <jpeg_idct_13x13+0x56c>)
 801c85e:	fb02 f203 	mul.w	r2, r2, r3
 801c862:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c866:	4413      	add	r3, r2
 801c868:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801c86c:	4413      	add	r3, r2
 801c86e:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 801c872:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801c876:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c87a:	4413      	add	r3, r2
 801c87c:	4a88      	ldr	r2, [pc, #544]	; (801caa0 <jpeg_idct_13x13+0x570>)
 801c87e:	fb02 f303 	mul.w	r3, r2, r3
 801c882:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp11 += tmp14;
 801c886:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801c88a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c88e:	4413      	add	r3, r2
 801c890:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 801c894:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c898:	f244 6294 	movw	r2, #18068	; 0x4694
 801c89c:	fb02 f203 	mul.w	r2, r2, r3
 801c8a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c8a4:	4413      	add	r3, r2
 801c8a6:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c8aa:	4413      	add	r3, r2
 801c8ac:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 801c8b0:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801c8b4:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c8b8:	4413      	add	r3, r2
 801c8ba:	4a7a      	ldr	r2, [pc, #488]	; (801caa4 <jpeg_idct_13x13+0x574>)
 801c8bc:	fb02 f303 	mul.w	r3, r2, r3
 801c8c0:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp12 += tmp14;
 801c8c4:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801c8c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c8cc:	4413      	add	r3, r2
 801c8ce:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 += tmp14;
 801c8d2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801c8d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801c8da:	4413      	add	r3, r2
 801c8dc:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 801c8e0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c8e4:	f640 22d5 	movw	r2, #2773	; 0xad5
 801c8e8:	fb02 f303 	mul.w	r3, r2, r3
 801c8ec:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 801c8f0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c8f4:	f640 2233 	movw	r2, #2611	; 0xa33
 801c8f8:	fb02 f203 	mul.w	r2, r2, r3
 801c8fc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801c900:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 801c902:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c906:	4968      	ldr	r1, [pc, #416]	; (801caa8 <jpeg_idct_13x13+0x578>)
 801c908:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 801c90c:	4413      	add	r3, r2
 801c90e:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 801c912:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801c916:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801c91a:	1ad3      	subs	r3, r2, r3
 801c91c:	f641 6202 	movw	r2, #7682	; 0x1e02
 801c920:	fb02 f303 	mul.w	r3, r2, r3
 801c924:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp14 += z1;
 801c928:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801c92c:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c930:	4413      	add	r3, r2
 801c932:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 801c936:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801c93a:	f640 424e 	movw	r2, #3150	; 0xc4e
 801c93e:	fb02 f203 	mul.w	r2, r2, r3
 801c942:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801c946:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 801c948:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801c94c:	f46f 515f 	mvn.w	r1, #14272	; 0x37c0
 801c950:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 801c954:	4413      	add	r3, r2
 801c956:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 801c95a:	4413      	add	r3, r2
 801c95c:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801c960:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c964:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c968:	4413      	add	r3, r2
 801c96a:	12da      	asrs	r2, r3, #11
 801c96c:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c970:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801c972:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801c976:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801c97a:	1ad2      	subs	r2, r2, r3
 801c97c:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c980:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 801c984:	12d2      	asrs	r2, r2, #11
 801c986:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801c988:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c98c:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c990:	441a      	add	r2, r3
 801c992:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c996:	3320      	adds	r3, #32
 801c998:	12d2      	asrs	r2, r2, #11
 801c99a:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801c99c:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801c9a0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801c9a4:	1ad2      	subs	r2, r2, r3
 801c9a6:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c9aa:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 801c9ae:	12d2      	asrs	r2, r2, #11
 801c9b0:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 801c9b2:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801c9b6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c9ba:	441a      	add	r2, r3
 801c9bc:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c9c0:	3340      	adds	r3, #64	; 0x40
 801c9c2:	12d2      	asrs	r2, r2, #11
 801c9c4:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 801c9c6:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801c9ca:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801c9ce:	1ad2      	subs	r2, r2, r3
 801c9d0:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c9d4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801c9d8:	12d2      	asrs	r2, r2, #11
 801c9da:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801c9dc:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801c9e0:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c9e4:	441a      	add	r2, r3
 801c9e6:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c9ea:	3360      	adds	r3, #96	; 0x60
 801c9ec:	12d2      	asrs	r2, r2, #11
 801c9ee:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801c9f0:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801c9f4:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801c9f8:	1ad2      	subs	r2, r2, r3
 801c9fa:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801c9fe:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801ca02:	12d2      	asrs	r2, r2, #11
 801ca04:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801ca06:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801ca0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801ca0e:	441a      	add	r2, r3
 801ca10:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801ca14:	3380      	adds	r3, #128	; 0x80
 801ca16:	12d2      	asrs	r2, r2, #11
 801ca18:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801ca1a:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801ca1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801ca22:	1ad2      	subs	r2, r2, r3
 801ca24:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801ca28:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801ca2c:	12d2      	asrs	r2, r2, #11
 801ca2e:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 801ca30:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801ca34:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801ca38:	441a      	add	r2, r3
 801ca3a:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801ca3e:	33a0      	adds	r3, #160	; 0xa0
 801ca40:	12d2      	asrs	r2, r2, #11
 801ca42:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 801ca44:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801ca48:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801ca4c:	1ad2      	subs	r2, r2, r3
 801ca4e:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801ca52:	33e0      	adds	r3, #224	; 0xe0
 801ca54:	12d2      	asrs	r2, r2, #11
 801ca56:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26, CONST_BITS-PASS1_BITS);
 801ca58:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801ca5c:	33c0      	adds	r3, #192	; 0xc0
 801ca5e:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 801ca62:	12d2      	asrs	r2, r2, #11
 801ca64:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801ca66:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801ca6a:	3301      	adds	r3, #1
 801ca6c:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
 801ca70:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801ca74:	3302      	adds	r3, #2
 801ca76:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
 801ca7a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801ca7e:	3304      	adds	r3, #4
 801ca80:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
 801ca84:	e012      	b.n	801caac <jpeg_idct_13x13+0x57c>
 801ca86:	bf00      	nop
 801ca88:	ffffd7ee 	.word	0xffffd7ee
 801ca8c:	fffffa8c 	.word	0xfffffa8c
 801ca90:	ffffe64b 	.word	0xffffe64b
 801ca94:	ffffbf5b 	.word	0xffffbf5b
 801ca98:	fffff52b 	.word	0xfffff52b
 801ca9c:	ffffcdb1 	.word	0xffffcdb1
 801caa0:	ffffdac2 	.word	0xffffdac2
 801caa4:	ffffeaf8 	.word	0xffffeaf8
 801caa8:	fffff116 	.word	0xfffff116
 801caac:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cab0:	3304      	adds	r3, #4
 801cab2:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 801cab6:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801caba:	2b07      	cmp	r3, #7
 801cabc:	f77f ad60 	ble.w	801c580 <jpeg_idct_13x13+0x50>
  }

  /* Pass 2: process 13 rows from work array, store into output array. */

  wsptr = workspace;
 801cac0:	f107 0314 	add.w	r3, r7, #20
 801cac4:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 801cac8:	2300      	movs	r3, #0
 801caca:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
 801cace:	e2a0      	b.n	801d012 <jpeg_idct_13x13+0xae2>
    outptr = output_buf[ctr] + output_col;
 801cad0:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801cad4:	009b      	lsls	r3, r3, #2
 801cad6:	463a      	mov	r2, r7
 801cad8:	6812      	ldr	r2, [r2, #0]
 801cada:	4413      	add	r3, r2
 801cadc:	681a      	ldr	r2, [r3, #0]
 801cade:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801cae2:	4413      	add	r3, r2
 801cae4:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801cae8:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801caec:	681b      	ldr	r3, [r3, #0]
 801caee:	3310      	adds	r3, #16
 801caf0:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    z1 <<= CONST_BITS;
 801caf4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801caf8:	035b      	lsls	r3, r3, #13
 801cafa:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4

    z2 = (INT32) wsptr[2];
 801cafe:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cb02:	3308      	adds	r3, #8
 801cb04:	681b      	ldr	r3, [r3, #0]
 801cb06:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    z3 = (INT32) wsptr[4];
 801cb0a:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cb0e:	3310      	adds	r3, #16
 801cb10:	681b      	ldr	r3, [r3, #0]
 801cb12:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    z4 = (INT32) wsptr[6];
 801cb16:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cb1a:	3318      	adds	r3, #24
 801cb1c:	681b      	ldr	r3, [r3, #0]
 801cb1e:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8

    tmp10 = z3 + z4;
 801cb22:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801cb26:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801cb2a:	4413      	add	r3, r2
 801cb2c:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp11 = z3 - z4;
 801cb30:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801cb34:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801cb38:	1ad3      	subs	r3, r2, r3
 801cb3a:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0

    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */
 801cb3e:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801cb42:	f242 42f9 	movw	r2, #9465	; 0x24f9
 801cb46:	fb02 f303 	mul.w	r3, r2, r3
 801cb4a:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */
 801cb4e:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801cb52:	f240 3219 	movw	r2, #793	; 0x319
 801cb56:	fb02 f303 	mul.w	r3, r2, r3
 801cb5a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801cb5e:	4413      	add	r3, r2
 801cb60:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */
 801cb64:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cb68:	f642 32f1 	movw	r2, #11249	; 0x2bf1
 801cb6c:	fb02 f203 	mul.w	r2, r2, r3
 801cb70:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cb74:	4413      	add	r3, r2
 801cb76:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cb7a:	4413      	add	r3, r2
 801cb7c:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */
 801cb80:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cb84:	f241 020c 	movw	r2, #4108	; 0x100c
 801cb88:	fb02 f203 	mul.w	r2, r2, r3
 801cb8c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cb90:	1ad3      	subs	r3, r2, r3
 801cb92:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cb96:	4413      	add	r3, r2
 801cb98:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */
 801cb9c:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801cba0:	f44f 6222 	mov.w	r2, #2592	; 0xa20
 801cba4:	fb02 f303 	mul.w	r3, r2, r3
 801cba8:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */
 801cbac:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801cbb0:	f640 7295 	movw	r2, #3989	; 0xf95
 801cbb4:	fb02 f303 	mul.w	r3, r2, r3
 801cbb8:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801cbbc:	4413      	add	r3, r2
 801cbbe:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */
 801cbc2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cbc6:	f242 12e0 	movw	r2, #8672	; 0x21e0
 801cbca:	fb02 f203 	mul.w	r2, r2, r3
 801cbce:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cbd2:	1ad3      	subs	r3, r2, r3
 801cbd4:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cbd8:	4413      	add	r3, r2
 801cbda:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp25 = MULTIPLY(z2, - FIX(1.252223920)) + tmp12 + tmp13; /* c4 */
 801cbde:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cbe2:	4af2      	ldr	r2, [pc, #968]	; (801cfac <jpeg_idct_13x13+0xa7c>)
 801cbe4:	fb02 f203 	mul.w	r2, r2, r3
 801cbe8:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cbec:	4413      	add	r3, r2
 801cbee:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cbf2:	4413      	add	r3, r2
 801cbf4:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8

    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */
 801cbf8:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801cbfc:	f640 52f2 	movw	r2, #3570	; 0xdf2
 801cc00:	fb02 f303 	mul.w	r3, r2, r3
 801cc04:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */
 801cc08:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801cc0c:	f641 52fe 	movw	r2, #7678	; 0x1dfe
 801cc10:	fb02 f203 	mul.w	r2, r2, r3
 801cc14:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801cc18:	1ad3      	subs	r3, r2, r3
 801cc1a:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8

    tmp23 = MULTIPLY(z2, - FIX(0.170464608)) - tmp12 - tmp13; /* c12 */
 801cc1e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cc22:	4ae3      	ldr	r2, [pc, #908]	; (801cfb0 <jpeg_idct_13x13+0xa80>)
 801cc24:	fb02 f203 	mul.w	r2, r2, r3
 801cc28:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cc2c:	1ad2      	subs	r2, r2, r3
 801cc2e:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801cc32:	1ad3      	subs	r3, r2, r3
 801cc34:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp24 = MULTIPLY(z2, - FIX(0.803364869)) + tmp12 - tmp13; /* c8 */
 801cc38:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cc3c:	4add      	ldr	r2, [pc, #884]	; (801cfb4 <jpeg_idct_13x13+0xa84>)
 801cc3e:	fb02 f203 	mul.w	r2, r2, r3
 801cc42:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cc46:	441a      	add	r2, r3
 801cc48:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801cc4c:	1ad3      	subs	r3, r2, r3
 801cc4e:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0

    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */
 801cc52:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801cc56:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cc5a:	1ad3      	subs	r3, r2, r3
 801cc5c:	f642 5241 	movw	r2, #11585	; 0x2d41
 801cc60:	fb02 f303 	mul.w	r3, r2, r3
 801cc64:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801cc68:	4413      	add	r3, r2
 801cc6a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801cc6e:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cc72:	3304      	adds	r3, #4
 801cc74:	681b      	ldr	r3, [r3, #0]
 801cc76:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    z2 = (INT32) wsptr[3];
 801cc7a:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cc7e:	330c      	adds	r3, #12
 801cc80:	681b      	ldr	r3, [r3, #0]
 801cc82:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    z3 = (INT32) wsptr[5];
 801cc86:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cc8a:	3314      	adds	r3, #20
 801cc8c:	681b      	ldr	r3, [r3, #0]
 801cc8e:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    z4 = (INT32) wsptr[7];
 801cc92:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801cc96:	331c      	adds	r3, #28
 801cc98:	681b      	ldr	r3, [r3, #0]
 801cc9a:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8

    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */
 801cc9e:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801cca2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cca6:	4413      	add	r3, r2
 801cca8:	f642 2250 	movw	r2, #10832	; 0x2a50
 801ccac:	fb02 f303 	mul.w	r3, r2, r3
 801ccb0:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */
 801ccb4:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801ccb8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801ccbc:	4413      	add	r3, r2
 801ccbe:	f242 523e 	movw	r2, #9534	; 0x253e
 801ccc2:	fb02 f303 	mul.w	r3, r2, r3
 801ccc6:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp15 = z1 + z4;
 801ccca:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801ccce:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801ccd2:	4413      	add	r3, r2
 801ccd4:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */
 801ccd8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801ccdc:	f641 6202 	movw	r2, #7682	; 0x1e02
 801cce0:	fb02 f303 	mul.w	r3, r2, r3
 801cce4:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp10 = tmp11 + tmp12 + tmp13 -
 801cce8:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801ccec:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801ccf0:	441a      	add	r2, r3
 801ccf2:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801ccf6:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */
 801ccf8:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801ccfc:	49ae      	ldr	r1, [pc, #696]	; (801cfb8 <jpeg_idct_13x13+0xa88>)
 801ccfe:	fb01 f303 	mul.w	r3, r1, r3
    tmp10 = tmp11 + tmp12 + tmp13 -
 801cd02:	4413      	add	r3, r2
 801cd04:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp14 = MULTIPLY(z2 + z3, - FIX(0.338443458));   /* -c11 */
 801cd08:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801cd0c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801cd10:	4413      	add	r3, r2
 801cd12:	4aaa      	ldr	r2, [pc, #680]	; (801cfbc <jpeg_idct_13x13+0xa8c>)
 801cd14:	fb02 f303 	mul.w	r3, r2, r3
 801cd18:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */
 801cd1c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cd20:	f641 22cb 	movw	r2, #6859	; 0x1acb
 801cd24:	fb02 f203 	mul.w	r2, r2, r3
 801cd28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cd2c:	4413      	add	r3, r2
 801cd2e:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801cd32:	4413      	add	r3, r2
 801cd34:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */
 801cd38:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801cd3c:	4aa0      	ldr	r2, [pc, #640]	; (801cfc0 <jpeg_idct_13x13+0xa90>)
 801cd3e:	fb02 f203 	mul.w	r2, r2, r3
 801cd42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cd46:	4413      	add	r3, r2
 801cd48:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801cd4c:	4413      	add	r3, r2
 801cd4e:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp14 = MULTIPLY(z2 + z4, - FIX(1.163874945));   /* -c5 */
 801cd52:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801cd56:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801cd5a:	4413      	add	r3, r2
 801cd5c:	4a99      	ldr	r2, [pc, #612]	; (801cfc4 <jpeg_idct_13x13+0xa94>)
 801cd5e:	fb02 f303 	mul.w	r3, r2, r3
 801cd62:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp11 += tmp14;
 801cd66:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801cd6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cd6e:	4413      	add	r3, r2
 801cd70:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */
 801cd74:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801cd78:	f244 6294 	movw	r2, #18068	; 0x4694
 801cd7c:	fb02 f203 	mul.w	r2, r2, r3
 801cd80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cd84:	4413      	add	r3, r2
 801cd86:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cd8a:	4413      	add	r3, r2
 801cd8c:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp14 = MULTIPLY(z3 + z4, - FIX(0.657217813));   /* -c9 */
 801cd90:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801cd94:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801cd98:	4413      	add	r3, r2
 801cd9a:	4a8b      	ldr	r2, [pc, #556]	; (801cfc8 <jpeg_idct_13x13+0xa98>)
 801cd9c:	fb02 f303 	mul.w	r3, r2, r3
 801cda0:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp12 += tmp14;
 801cda4:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801cda8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cdac:	4413      	add	r3, r2
 801cdae:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp13 += tmp14;
 801cdb2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801cdb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cdba:	4413      	add	r3, r2
 801cdbc:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */
 801cdc0:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801cdc4:	f640 22d5 	movw	r2, #2773	; 0xad5
 801cdc8:	fb02 f303 	mul.w	r3, r2, r3
 801cdcc:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 801cdd0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801cdd4:	f640 2233 	movw	r2, #2611	; 0xa33
 801cdd8:	fb02 f203 	mul.w	r2, r2, r3
 801cddc:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801cde0:	441a      	add	r2, r3
	    MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */
 801cde2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cde6:	4979      	ldr	r1, [pc, #484]	; (801cfcc <jpeg_idct_13x13+0xa9c>)
 801cde8:	fb01 f303 	mul.w	r3, r1, r3
    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */
 801cdec:	4413      	add	r3, r2
 801cdee:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */
 801cdf2:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801cdf6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801cdfa:	1ad3      	subs	r3, r2, r3
 801cdfc:	f641 6202 	movw	r2, #7682	; 0x1e02
 801ce00:	fb02 f303 	mul.w	r3, r2, r3
 801ce04:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp14 += z1;
 801ce08:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 801ce0c:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801ce10:	4413      	add	r3, r2
 801ce12:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 801ce16:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801ce1a:	f640 424e 	movw	r2, #3150	; 0xc4e
 801ce1e:	fb02 f203 	mul.w	r2, r2, r3
 801ce22:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801ce26:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */
 801ce28:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801ce2c:	f46f 515f 	mvn.w	r1, #14272	; 0x37c0
 801ce30:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */
 801ce34:	4413      	add	r3, r2
 801ce36:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 801ce3a:	4413      	add	r3, r2
 801ce3c:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ce40:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801ce44:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801ce48:	4413      	add	r3, r2
 801ce4a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ce4c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801ce50:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ce54:	4413      	add	r3, r2
 801ce56:	781a      	ldrb	r2, [r3, #0]
 801ce58:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801ce5c:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ce5e:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801ce62:	f8d7 31e4 	ldr.w	r3, [r7, #484]	; 0x1e4
 801ce66:	1ad3      	subs	r3, r2, r3
 801ce68:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ce6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801ce6e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ce72:	441a      	add	r2, r3
 801ce74:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801ce78:	330c      	adds	r3, #12
 801ce7a:	7812      	ldrb	r2, [r2, #0]
 801ce7c:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801ce7e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801ce82:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801ce86:	4413      	add	r3, r2
 801ce88:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ce8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801ce8e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ce92:	441a      	add	r2, r3
 801ce94:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801ce98:	3301      	adds	r3, #1
 801ce9a:	7812      	ldrb	r2, [r2, #0]
 801ce9c:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801ce9e:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 801cea2:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801cea6:	1ad3      	subs	r3, r2, r3
 801cea8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ceaa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801ceae:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ceb2:	441a      	add	r2, r3
 801ceb4:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801ceb8:	330b      	adds	r3, #11
 801ceba:	7812      	ldrb	r2, [r2, #0]
 801cebc:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801cebe:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801cec2:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cec6:	4413      	add	r3, r2
 801cec8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ceca:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801cece:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ced2:	441a      	add	r2, r3
 801ced4:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801ced8:	3302      	adds	r3, #2
 801ceda:	7812      	ldrb	r2, [r2, #0]
 801cedc:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801cede:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801cee2:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 801cee6:	1ad3      	subs	r3, r2, r3
 801cee8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801ceea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801ceee:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cef2:	441a      	add	r2, r3
 801cef4:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cef8:	330a      	adds	r3, #10
 801cefa:	7812      	ldrb	r2, [r2, #0]
 801cefc:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801cefe:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801cf02:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801cf06:	4413      	add	r3, r2
 801cf08:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cf0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801cf0e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cf12:	441a      	add	r2, r3
 801cf14:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cf18:	3303      	adds	r3, #3
 801cf1a:	7812      	ldrb	r2, [r2, #0]
 801cf1c:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801cf1e:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 801cf22:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 801cf26:	1ad3      	subs	r3, r2, r3
 801cf28:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cf2a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801cf2e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cf32:	441a      	add	r2, r3
 801cf34:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cf38:	3309      	adds	r3, #9
 801cf3a:	7812      	ldrb	r2, [r2, #0]
 801cf3c:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801cf3e:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801cf42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cf46:	4413      	add	r3, r2
 801cf48:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cf4a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801cf4e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cf52:	441a      	add	r2, r3
 801cf54:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cf58:	3304      	adds	r3, #4
 801cf5a:	7812      	ldrb	r2, [r2, #0]
 801cf5c:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801cf5e:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 801cf62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801cf66:	1ad3      	subs	r3, r2, r3
 801cf68:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cf6a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801cf6e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cf72:	441a      	add	r2, r3
 801cf74:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cf78:	3308      	adds	r3, #8
 801cf7a:	7812      	ldrb	r2, [r2, #0]
 801cf7c:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801cf7e:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801cf82:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801cf86:	4413      	add	r3, r2
 801cf88:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cf8a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801cf8e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cf92:	441a      	add	r2, r3
 801cf94:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cf98:	3305      	adds	r3, #5
 801cf9a:	7812      	ldrb	r2, [r2, #0]
 801cf9c:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801cf9e:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 801cfa2:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801cfa6:	1ad3      	subs	r3, r2, r3
 801cfa8:	149b      	asrs	r3, r3, #18
 801cfaa:	e011      	b.n	801cfd0 <jpeg_idct_13x13+0xaa0>
 801cfac:	ffffd7ee 	.word	0xffffd7ee
 801cfb0:	fffffa8c 	.word	0xfffffa8c
 801cfb4:	ffffe64b 	.word	0xffffe64b
 801cfb8:	ffffbf5b 	.word	0xffffbf5b
 801cfbc:	fffff52b 	.word	0xfffff52b
 801cfc0:	ffffcdb1 	.word	0xffffcdb1
 801cfc4:	ffffdac2 	.word	0xffffdac2
 801cfc8:	ffffeaf8 	.word	0xffffeaf8
 801cfcc:	fffff116 	.word	0xfffff116
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cfd0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801cfd4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cfd8:	441a      	add	r2, r3
 801cfda:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cfde:	3307      	adds	r3, #7
 801cfe0:	7812      	ldrb	r2, [r2, #0]
 801cfe2:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 801cfe4:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 801cfe8:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801cfea:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26,
 801cfee:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801cff2:	441a      	add	r2, r3
 801cff4:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801cff8:	3306      	adds	r3, #6
 801cffa:	7812      	ldrb	r2, [r2, #0]
 801cffc:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801cffe:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801d002:	3320      	adds	r3, #32
 801d004:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
  for (ctr = 0; ctr < 13; ctr++) {
 801d008:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d00c:	3301      	adds	r3, #1
 801d00e:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
 801d012:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d016:	2b0c      	cmp	r3, #12
 801d018:	f77f ad5a 	ble.w	801cad0 <jpeg_idct_13x13+0x5a0>
  }
}
 801d01c:	bf00      	nop
 801d01e:	bf00      	nop
 801d020:	f507 7704 	add.w	r7, r7, #528	; 0x210
 801d024:	46bd      	mov	sp, r7
 801d026:	bc90      	pop	{r4, r7}
 801d028:	4770      	bx	lr
 801d02a:	bf00      	nop

0801d02c <jpeg_idct_14x14>:

GLOBAL(void)
jpeg_idct_14x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801d02c:	b490      	push	{r4, r7}
 801d02e:	f5ad 7d0c 	sub.w	sp, sp, #560	; 0x230
 801d032:	af00      	add	r7, sp, #0
 801d034:	f107 040c 	add.w	r4, r7, #12
 801d038:	6020      	str	r0, [r4, #0]
 801d03a:	f107 0008 	add.w	r0, r7, #8
 801d03e:	6001      	str	r1, [r0, #0]
 801d040:	1d39      	adds	r1, r7, #4
 801d042:	600a      	str	r2, [r1, #0]
 801d044:	463a      	mov	r2, r7
 801d046:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801d048:	f107 030c 	add.w	r3, r7, #12
 801d04c:	681b      	ldr	r3, [r3, #0]
 801d04e:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801d052:	3380      	adds	r3, #128	; 0x80
 801d054:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
  int workspace[8*14];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801d058:	1d3b      	adds	r3, r7, #4
 801d05a:	681b      	ldr	r3, [r3, #0]
 801d05c:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801d060:	f107 0308 	add.w	r3, r7, #8
 801d064:	681b      	ldr	r3, [r3, #0]
 801d066:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801d068:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
  wsptr = workspace;
 801d06c:	f107 0310 	add.w	r3, r7, #16
 801d070:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801d074:	2300      	movs	r3, #0
 801d076:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
 801d07a:	e269      	b.n	801d550 <jpeg_idct_14x14+0x524>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801d07c:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d080:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d084:	461a      	mov	r2, r3
 801d086:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d08a:	681b      	ldr	r3, [r3, #0]
 801d08c:	fb03 f302 	mul.w	r3, r3, r2
 801d090:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z1 <<= CONST_BITS;
 801d094:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d098:	035b      	lsls	r3, r3, #13
 801d09a:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 801d09e:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d0a2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801d0a6:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801d0aa:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d0ae:	3340      	adds	r3, #64	; 0x40
 801d0b0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d0b4:	461a      	mov	r2, r3
 801d0b6:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d0ba:	3380      	adds	r3, #128	; 0x80
 801d0bc:	681b      	ldr	r3, [r3, #0]
 801d0be:	fb03 f302 	mul.w	r3, r3, r2
 801d0c2:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 801d0c6:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d0ca:	f642 02c6 	movw	r2, #10438	; 0x28c6
 801d0ce:	fb02 f303 	mul.w	r3, r2, r3
 801d0d2:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 801d0d6:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d0da:	f640 2212 	movw	r2, #2578	; 0xa12
 801d0de:	fb02 f303 	mul.w	r3, r2, r3
 801d0e2:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 801d0e6:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d0ea:	f641 4237 	movw	r2, #7223	; 0x1c37
 801d0ee:	fb02 f303 	mul.w	r3, r2, r3
 801d0f2:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    tmp10 = z1 + z2;
 801d0f6:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d0fa:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d0fe:	4413      	add	r3, r2
 801d100:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp11 = z1 + z3;
 801d104:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d108:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d10c:	4413      	add	r3, r2
 801d10e:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 = z1 - z4;
 801d112:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d116:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d11a:	1ad3      	subs	r3, r2, r3
 801d11c:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 801d120:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801d124:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d128:	441a      	add	r2, r3
 801d12a:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d12e:	1ad3      	subs	r3, r2, r3
 801d130:	005b      	lsls	r3, r3, #1
 801d132:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d136:	1ad3      	subs	r3, r2, r3
 801d138:	12db      	asrs	r3, r3, #11
 801d13a:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801d13e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d142:	3320      	adds	r3, #32
 801d144:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d148:	461a      	mov	r2, r3
 801d14a:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d14e:	3340      	adds	r3, #64	; 0x40
 801d150:	681b      	ldr	r3, [r3, #0]
 801d152:	fb03 f302 	mul.w	r3, r3, r2
 801d156:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801d15a:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d15e:	3360      	adds	r3, #96	; 0x60
 801d160:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d164:	461a      	mov	r2, r3
 801d166:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d16a:	33c0      	adds	r3, #192	; 0xc0
 801d16c:	681b      	ldr	r3, [r3, #0]
 801d16e:	fb03 f302 	mul.w	r3, r3, r2
 801d172:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 801d176:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d17a:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d17e:	4413      	add	r3, r2
 801d180:	f242 3262 	movw	r2, #9058	; 0x2362
 801d184:	fb02 f303 	mul.w	r3, r2, r3
 801d188:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 801d18c:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d190:	f640 02bd 	movw	r2, #2237	; 0x8bd
 801d194:	fb02 f303 	mul.w	r3, r2, r3
 801d198:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d19c:	4413      	add	r3, r2
 801d19e:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 801d1a2:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d1a6:	4af1      	ldr	r2, [pc, #964]	; (801d56c <jpeg_idct_14x14+0x540>)
 801d1a8:	fb02 f303 	mul.w	r3, r2, r3
 801d1ac:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d1b0:	4413      	add	r3, r2
 801d1b2:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 801d1b6:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d1ba:	f241 32a3 	movw	r2, #5027	; 0x13a3
 801d1be:	fb02 f203 	mul.w	r2, r2, r3
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 801d1c2:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d1c6:	49ea      	ldr	r1, [pc, #936]	; (801d570 <jpeg_idct_14x14+0x544>)
 801d1c8:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 801d1cc:	4413      	add	r3, r2
 801d1ce:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec

    tmp20 = tmp10 + tmp13;
 801d1d2:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801d1d6:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d1da:	4413      	add	r3, r2
 801d1dc:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
    tmp26 = tmp10 - tmp13;
 801d1e0:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801d1e4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d1e8:	1ad3      	subs	r3, r2, r3
 801d1ea:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp21 = tmp11 + tmp14;
 801d1ee:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d1f2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d1f6:	4413      	add	r3, r2
 801d1f8:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp25 = tmp11 - tmp14;
 801d1fc:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d200:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d204:	1ad3      	subs	r3, r2, r3
 801d206:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp22 = tmp12 + tmp15;
 801d20a:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d20e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d212:	4413      	add	r3, r2
 801d214:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp24 = tmp12 - tmp15;
 801d218:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d21c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d220:	1ad3      	subs	r3, r2, r3
 801d222:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801d226:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d22a:	3310      	adds	r3, #16
 801d22c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d230:	461a      	mov	r2, r3
 801d232:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d236:	3320      	adds	r3, #32
 801d238:	681b      	ldr	r3, [r3, #0]
 801d23a:	fb03 f302 	mul.w	r3, r3, r2
 801d23e:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801d242:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d246:	3330      	adds	r3, #48	; 0x30
 801d248:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d24c:	461a      	mov	r2, r3
 801d24e:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d252:	3360      	adds	r3, #96	; 0x60
 801d254:	681b      	ldr	r3, [r3, #0]
 801d256:	fb03 f302 	mul.w	r3, r3, r2
 801d25a:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801d25e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d262:	3350      	adds	r3, #80	; 0x50
 801d264:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d268:	461a      	mov	r2, r3
 801d26a:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d26e:	33a0      	adds	r3, #160	; 0xa0
 801d270:	681b      	ldr	r3, [r3, #0]
 801d272:	fb03 f302 	mul.w	r3, r3, r2
 801d276:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801d27a:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d27e:	3370      	adds	r3, #112	; 0x70
 801d280:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d284:	461a      	mov	r2, r3
 801d286:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d28a:	33e0      	adds	r3, #224	; 0xe0
 801d28c:	681b      	ldr	r3, [r3, #0]
 801d28e:	fb03 f302 	mul.w	r3, r3, r2
 801d292:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    tmp13 = z4 << CONST_BITS;
 801d296:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d29a:	035b      	lsls	r3, r3, #13
 801d29c:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4

    tmp14 = z1 + z3;
 801d2a0:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d2a4:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d2a8:	4413      	add	r3, r2
 801d2aa:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 801d2ae:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d2b2:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d2b6:	4413      	add	r3, r2
 801d2b8:	f642 22b7 	movw	r2, #10935	; 0x2ab7
 801d2bc:	fb02 f303 	mul.w	r3, r2, r3
 801d2c0:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 801d2c4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d2c8:	f242 6252 	movw	r2, #9810	; 0x2652
 801d2cc:	fb02 f303 	mul.w	r3, r2, r3
 801d2d0:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 801d2d4:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d2d8:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d2dc:	441a      	add	r2, r3
 801d2de:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d2e2:	441a      	add	r2, r3
 801d2e4:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d2e8:	49a2      	ldr	r1, [pc, #648]	; (801d574 <jpeg_idct_14x14+0x548>)
 801d2ea:	fb01 f303 	mul.w	r3, r1, r3
 801d2ee:	4413      	add	r3, r2
 801d2f0:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 801d2f4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d2f8:	f641 0214 	movw	r2, #6164	; 0x1814
 801d2fc:	fb02 f303 	mul.w	r3, r2, r3
 801d300:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 801d304:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d308:	4a9b      	ldr	r2, [pc, #620]	; (801d578 <jpeg_idct_14x14+0x54c>)
 801d30a:	fb02 f303 	mul.w	r3, r2, r3
 801d30e:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801d312:	4413      	add	r3, r2
 801d314:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    z1    -= z2;
 801d318:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d31c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d320:	1ad3      	subs	r3, r2, r3
 801d322:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 801d326:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d32a:	f640 62f2 	movw	r2, #3826	; 0xef2
 801d32e:	fb02 f203 	mul.w	r2, r2, r3
 801d332:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d336:	1ad3      	subs	r3, r2, r3
 801d338:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    tmp16 += tmp15;
 801d33c:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801d340:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d344:	4413      	add	r3, r2
 801d346:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    z1    += z4;
 801d34a:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d34e:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d352:	4413      	add	r3, r2
 801d354:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 801d358:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801d35c:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d360:	4413      	add	r3, r2
 801d362:	f46f 62a2 	mvn.w	r2, #1296	; 0x510
 801d366:	fb02 f203 	mul.w	r2, r2, r3
 801d36a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d36e:	1ad3      	subs	r3, r2, r3
 801d370:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 801d374:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d378:	4a80      	ldr	r2, [pc, #512]	; (801d57c <jpeg_idct_14x14+0x550>)
 801d37a:	fb02 f203 	mul.w	r2, r2, r3
 801d37e:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d382:	4413      	add	r3, r2
 801d384:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d388:	4413      	add	r3, r2
 801d38a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 801d38e:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d392:	4a7b      	ldr	r2, [pc, #492]	; (801d580 <jpeg_idct_14x14+0x554>)
 801d394:	fb02 f203 	mul.w	r2, r2, r3
 801d398:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d39c:	4413      	add	r3, r2
 801d39e:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d3a2:	4413      	add	r3, r2
 801d3a4:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 801d3a8:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d3ac:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d3b0:	1ad3      	subs	r3, r2, r3
 801d3b2:	f642 42f8 	movw	r2, #11512	; 0x2cf8
 801d3b6:	fb02 f303 	mul.w	r3, r2, r3
 801d3ba:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 801d3be:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801d3c2:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d3c6:	441a      	add	r2, r3
 801d3c8:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d3cc:	496d      	ldr	r1, [pc, #436]	; (801d584 <jpeg_idct_14x14+0x558>)
 801d3ce:	fb01 f303 	mul.w	r3, r1, r3
 801d3d2:	4413      	add	r3, r2
 801d3d4:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801d3d8:	4413      	add	r3, r2
 801d3da:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 801d3de:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d3e2:	f241 5299 	movw	r2, #5529	; 0x1599
 801d3e6:	fb02 f203 	mul.w	r2, r2, r3
 801d3ea:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d3ee:	4413      	add	r3, r2
 801d3f0:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801d3f4:	4413      	add	r3, r2
 801d3f6:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec

    tmp13 = (z1 - z3) << PASS1_BITS;
 801d3fa:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d3fe:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d402:	1ad3      	subs	r3, r2, r3
 801d404:	009b      	lsls	r3, r3, #2
 801d406:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801d40a:	f8d7 21e8 	ldr.w	r2, [r7, #488]	; 0x1e8
 801d40e:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801d412:	4413      	add	r3, r2
 801d414:	12da      	asrs	r2, r3, #11
 801d416:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d41a:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801d41c:	f8d7 21e8 	ldr.w	r2, [r7, #488]	; 0x1e8
 801d420:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801d424:	1ad2      	subs	r2, r2, r3
 801d426:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d42a:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 801d42e:	12d2      	asrs	r2, r2, #11
 801d430:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801d432:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801d436:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d43a:	441a      	add	r2, r3
 801d43c:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d440:	3320      	adds	r3, #32
 801d442:	12d2      	asrs	r2, r2, #11
 801d444:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801d446:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801d44a:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d44e:	1ad2      	subs	r2, r2, r3
 801d450:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d454:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 801d458:	12d2      	asrs	r2, r2, #11
 801d45a:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 801d45c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801d460:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d464:	441a      	add	r2, r3
 801d466:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d46a:	3340      	adds	r3, #64	; 0x40
 801d46c:	12d2      	asrs	r2, r2, #11
 801d46e:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 801d470:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801d474:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d478:	1ad2      	subs	r2, r2, r3
 801d47a:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d47e:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 801d482:	12d2      	asrs	r2, r2, #11
 801d484:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) (tmp23 + tmp13);
 801d486:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d48a:	3360      	adds	r3, #96	; 0x60
 801d48c:	f8d7 11f8 	ldr.w	r1, [r7, #504]	; 0x1f8
 801d490:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801d494:	440a      	add	r2, r1
 801d496:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) (tmp23 - tmp13);
 801d498:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d49c:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801d4a0:	f8d7 11f8 	ldr.w	r1, [r7, #504]	; 0x1f8
 801d4a4:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801d4a8:	1a8a      	subs	r2, r1, r2
 801d4aa:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801d4ac:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801d4b0:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d4b4:	441a      	add	r2, r3
 801d4b6:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d4ba:	3380      	adds	r3, #128	; 0x80
 801d4bc:	12d2      	asrs	r2, r2, #11
 801d4be:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801d4c0:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801d4c4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d4c8:	1ad2      	subs	r2, r2, r3
 801d4ca:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d4ce:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801d4d2:	12d2      	asrs	r2, r2, #11
 801d4d4:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 801d4d6:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801d4da:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d4de:	441a      	add	r2, r3
 801d4e0:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d4e4:	33a0      	adds	r3, #160	; 0xa0
 801d4e6:	12d2      	asrs	r2, r2, #11
 801d4e8:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 801d4ea:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801d4ee:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d4f2:	1ad2      	subs	r2, r2, r3
 801d4f4:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d4f8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801d4fc:	12d2      	asrs	r2, r2, #11
 801d4fe:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 801d500:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 801d504:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801d508:	441a      	add	r2, r3
 801d50a:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d50e:	33c0      	adds	r3, #192	; 0xc0
 801d510:	12d2      	asrs	r2, r2, #11
 801d512:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 801d514:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 801d518:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801d51c:	1ad2      	subs	r2, r2, r3
 801d51e:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d522:	33e0      	adds	r3, #224	; 0xe0
 801d524:	12d2      	asrs	r2, r2, #11
 801d526:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801d528:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801d52c:	3301      	adds	r3, #1
 801d52e:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
 801d532:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801d536:	3302      	adds	r3, #2
 801d538:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
 801d53c:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801d540:	3304      	adds	r3, #4
 801d542:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
 801d546:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d54a:	3304      	adds	r3, #4
 801d54c:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
 801d550:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801d554:	2b07      	cmp	r3, #7
 801d556:	f77f ad91 	ble.w	801d07c <jpeg_idct_14x14+0x50>
  }

  /* Pass 2: process 14 rows from work array, store into output array. */

  wsptr = workspace;
 801d55a:	f107 0310 	add.w	r3, r7, #16
 801d55e:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 801d562:	2300      	movs	r3, #0
 801d564:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
 801d568:	e290      	b.n	801da8c <jpeg_idct_14x14+0xa60>
 801d56a:	bf00      	nop
 801d56c:	ffffc8fc 	.word	0xffffc8fc
 801d570:	ffffd3e1 	.word	0xffffd3e1
 801d574:	ffffdbf0 	.word	0xffffdbf0
 801d578:	ffffde0b 	.word	0xffffde0b
 801d57c:	fffff26e 	.word	0xfffff26e
 801d580:	ffffb409 	.word	0xffffb409
 801d584:	ffffc9e6 	.word	0xffffc9e6
    outptr = output_buf[ctr] + output_col;
 801d588:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801d58c:	009b      	lsls	r3, r3, #2
 801d58e:	463a      	mov	r2, r7
 801d590:	6812      	ldr	r2, [r2, #0]
 801d592:	4413      	add	r3, r2
 801d594:	681a      	ldr	r2, [r3, #0]
 801d596:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801d59a:	4413      	add	r3, r2
 801d59c:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801d5a0:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d5a4:	681b      	ldr	r3, [r3, #0]
 801d5a6:	3310      	adds	r3, #16
 801d5a8:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z1 <<= CONST_BITS;
 801d5ac:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d5b0:	035b      	lsls	r3, r3, #13
 801d5b2:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z4 = (INT32) wsptr[4];
 801d5b6:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d5ba:	3310      	adds	r3, #16
 801d5bc:	681b      	ldr	r3, [r3, #0]
 801d5be:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 801d5c2:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d5c6:	f642 02c6 	movw	r2, #10438	; 0x28c6
 801d5ca:	fb02 f303 	mul.w	r3, r2, r3
 801d5ce:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 801d5d2:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d5d6:	f640 2212 	movw	r2, #2578	; 0xa12
 801d5da:	fb02 f303 	mul.w	r3, r2, r3
 801d5de:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 801d5e2:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d5e6:	f641 4237 	movw	r2, #7223	; 0x1c37
 801d5ea:	fb02 f303 	mul.w	r3, r2, r3
 801d5ee:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    tmp10 = z1 + z2;
 801d5f2:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d5f6:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d5fa:	4413      	add	r3, r2
 801d5fc:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp11 = z1 + z3;
 801d600:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d604:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d608:	4413      	add	r3, r2
 801d60a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 = z1 - z4;
 801d60e:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d612:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d616:	1ad3      	subs	r3, r2, r3
 801d618:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 801d61c:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801d620:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d624:	441a      	add	r2, r3
 801d626:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d62a:	1ad3      	subs	r3, r2, r3
 801d62c:	005b      	lsls	r3, r3, #1
 801d62e:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d632:	1ad3      	subs	r3, r2, r3
 801d634:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8

    z1 = (INT32) wsptr[2];
 801d638:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d63c:	3308      	adds	r3, #8
 801d63e:	681b      	ldr	r3, [r3, #0]
 801d640:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z2 = (INT32) wsptr[6];
 801d644:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d648:	3318      	adds	r3, #24
 801d64a:	681b      	ldr	r3, [r3, #0]
 801d64c:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 801d650:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d654:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d658:	4413      	add	r3, r2
 801d65a:	f242 3262 	movw	r2, #9058	; 0x2362
 801d65e:	fb02 f303 	mul.w	r3, r2, r3
 801d662:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 801d666:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d66a:	f640 02bd 	movw	r2, #2237	; 0x8bd
 801d66e:	fb02 f303 	mul.w	r3, r2, r3
 801d672:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d676:	4413      	add	r3, r2
 801d678:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 801d67c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d680:	4af1      	ldr	r2, [pc, #964]	; (801da48 <jpeg_idct_14x14+0xa1c>)
 801d682:	fb02 f303 	mul.w	r3, r2, r3
 801d686:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d68a:	4413      	add	r3, r2
 801d68c:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 801d690:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d694:	f241 32a3 	movw	r2, #5027	; 0x13a3
 801d698:	fb02 f203 	mul.w	r2, r2, r3
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 801d69c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d6a0:	49ea      	ldr	r1, [pc, #936]	; (801da4c <jpeg_idct_14x14+0xa20>)
 801d6a2:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 801d6a6:	4413      	add	r3, r2
 801d6a8:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec

    tmp20 = tmp10 + tmp13;
 801d6ac:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801d6b0:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d6b4:	4413      	add	r3, r2
 801d6b6:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
    tmp26 = tmp10 - tmp13;
 801d6ba:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801d6be:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d6c2:	1ad3      	subs	r3, r2, r3
 801d6c4:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
    tmp21 = tmp11 + tmp14;
 801d6c8:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d6cc:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d6d0:	4413      	add	r3, r2
 801d6d2:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
    tmp25 = tmp11 - tmp14;
 801d6d6:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d6da:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d6de:	1ad3      	subs	r3, r2, r3
 801d6e0:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp22 = tmp12 + tmp15;
 801d6e4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d6e8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d6ec:	4413      	add	r3, r2
 801d6ee:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp24 = tmp12 - tmp15;
 801d6f2:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d6f6:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d6fa:	1ad3      	subs	r3, r2, r3
 801d6fc:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801d700:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d704:	3304      	adds	r3, #4
 801d706:	681b      	ldr	r3, [r3, #0]
 801d708:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    z2 = (INT32) wsptr[3];
 801d70c:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d710:	330c      	adds	r3, #12
 801d712:	681b      	ldr	r3, [r3, #0]
 801d714:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    z3 = (INT32) wsptr[5];
 801d718:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d71c:	3314      	adds	r3, #20
 801d71e:	681b      	ldr	r3, [r3, #0]
 801d720:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    z4 = (INT32) wsptr[7];
 801d724:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801d728:	331c      	adds	r3, #28
 801d72a:	681b      	ldr	r3, [r3, #0]
 801d72c:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    z4 <<= CONST_BITS;
 801d730:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d734:	035b      	lsls	r3, r3, #13
 801d736:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    tmp14 = z1 + z3;
 801d73a:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d73e:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d742:	4413      	add	r3, r2
 801d744:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 801d748:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d74c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d750:	4413      	add	r3, r2
 801d752:	f642 22b7 	movw	r2, #10935	; 0x2ab7
 801d756:	fb02 f303 	mul.w	r3, r2, r3
 801d75a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 801d75e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d762:	f242 6252 	movw	r2, #9810	; 0x2652
 801d766:	fb02 f303 	mul.w	r3, r2, r3
 801d76a:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 801d76e:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d772:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d776:	441a      	add	r2, r3
 801d778:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d77c:	441a      	add	r2, r3
 801d77e:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d782:	49b3      	ldr	r1, [pc, #716]	; (801da50 <jpeg_idct_14x14+0xa24>)
 801d784:	fb01 f303 	mul.w	r3, r1, r3
 801d788:	4413      	add	r3, r2
 801d78a:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 801d78e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d792:	f641 0214 	movw	r2, #6164	; 0x1814
 801d796:	fb02 f303 	mul.w	r3, r2, r3
 801d79a:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 801d79e:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d7a2:	4aac      	ldr	r2, [pc, #688]	; (801da54 <jpeg_idct_14x14+0xa28>)
 801d7a4:	fb02 f303 	mul.w	r3, r2, r3
 801d7a8:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801d7ac:	4413      	add	r3, r2
 801d7ae:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    z1    -= z2;
 801d7b2:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d7b6:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d7ba:	1ad3      	subs	r3, r2, r3
 801d7bc:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 801d7c0:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801d7c4:	f640 62f2 	movw	r2, #3826	; 0xef2
 801d7c8:	fb02 f203 	mul.w	r2, r2, r3
 801d7cc:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d7d0:	1ad3      	subs	r3, r2, r3
 801d7d2:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
    tmp16 += tmp15;
 801d7d6:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 801d7da:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d7de:	4413      	add	r3, r2
 801d7e0:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 801d7e4:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801d7e8:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d7ec:	4413      	add	r3, r2
 801d7ee:	f46f 62a2 	mvn.w	r2, #1296	; 0x510
 801d7f2:	fb02 f203 	mul.w	r2, r2, r3
 801d7f6:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d7fa:	1ad3      	subs	r3, r2, r3
 801d7fc:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 801d800:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d804:	4a94      	ldr	r2, [pc, #592]	; (801da58 <jpeg_idct_14x14+0xa2c>)
 801d806:	fb02 f203 	mul.w	r2, r2, r3
 801d80a:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d80e:	4413      	add	r3, r2
 801d810:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801d814:	4413      	add	r3, r2
 801d816:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 801d81a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d81e:	4a8f      	ldr	r2, [pc, #572]	; (801da5c <jpeg_idct_14x14+0xa30>)
 801d820:	fb02 f203 	mul.w	r2, r2, r3
 801d824:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d828:	4413      	add	r3, r2
 801d82a:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801d82e:	4413      	add	r3, r2
 801d830:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 801d834:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801d838:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d83c:	1ad3      	subs	r3, r2, r3
 801d83e:	f642 42f8 	movw	r2, #11512	; 0x2cf8
 801d842:	fb02 f303 	mul.w	r3, r2, r3
 801d846:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 801d84a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801d84e:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801d852:	441a      	add	r2, r3
 801d854:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d858:	4981      	ldr	r1, [pc, #516]	; (801da60 <jpeg_idct_14x14+0xa34>)
 801d85a:	fb01 f303 	mul.w	r3, r1, r3
 801d85e:	4413      	add	r3, r2
 801d860:	f8d7 21f0 	ldr.w	r2, [r7, #496]	; 0x1f0
 801d864:	4413      	add	r3, r2
 801d866:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 801d86a:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801d86e:	f241 5299 	movw	r2, #5529	; 0x1599
 801d872:	fb02 f203 	mul.w	r2, r2, r3
 801d876:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d87a:	4413      	add	r3, r2
 801d87c:	f8d7 21ec 	ldr.w	r2, [r7, #492]	; 0x1ec
 801d880:	4413      	add	r3, r2
 801d882:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 801d886:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801d88a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801d88e:	1ad3      	subs	r3, r2, r3
 801d890:	035b      	lsls	r3, r3, #13
 801d892:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801d896:	4413      	add	r3, r2
 801d898:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801d89c:	f8d7 21e8 	ldr.w	r2, [r7, #488]	; 0x1e8
 801d8a0:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801d8a4:	4413      	add	r3, r2
 801d8a6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d8a8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801d8ac:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d8b0:	4413      	add	r3, r2
 801d8b2:	781a      	ldrb	r2, [r3, #0]
 801d8b4:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d8b8:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801d8ba:	f8d7 21e8 	ldr.w	r2, [r7, #488]	; 0x1e8
 801d8be:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801d8c2:	1ad3      	subs	r3, r2, r3
 801d8c4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d8c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801d8ca:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d8ce:	441a      	add	r2, r3
 801d8d0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d8d4:	330d      	adds	r3, #13
 801d8d6:	7812      	ldrb	r2, [r2, #0]
 801d8d8:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801d8da:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801d8de:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d8e2:	4413      	add	r3, r2
 801d8e4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d8e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801d8ea:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d8ee:	441a      	add	r2, r3
 801d8f0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d8f4:	3301      	adds	r3, #1
 801d8f6:	7812      	ldrb	r2, [r2, #0]
 801d8f8:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801d8fa:	f8d7 21e0 	ldr.w	r2, [r7, #480]	; 0x1e0
 801d8fe:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801d902:	1ad3      	subs	r3, r2, r3
 801d904:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d906:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801d90a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d90e:	441a      	add	r2, r3
 801d910:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d914:	330c      	adds	r3, #12
 801d916:	7812      	ldrb	r2, [r2, #0]
 801d918:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801d91a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801d91e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d922:	4413      	add	r3, r2
 801d924:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d926:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801d92a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d92e:	441a      	add	r2, r3
 801d930:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d934:	3302      	adds	r3, #2
 801d936:	7812      	ldrb	r2, [r2, #0]
 801d938:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801d93a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 801d93e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801d942:	1ad3      	subs	r3, r2, r3
 801d944:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d946:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801d94a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d94e:	441a      	add	r2, r3
 801d950:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d954:	330b      	adds	r3, #11
 801d956:	7812      	ldrb	r2, [r2, #0]
 801d958:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801d95a:	f8d7 21f8 	ldr.w	r2, [r7, #504]	; 0x1f8
 801d95e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d962:	4413      	add	r3, r2
 801d964:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d966:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801d96a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d96e:	441a      	add	r2, r3
 801d970:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d974:	3303      	adds	r3, #3
 801d976:	7812      	ldrb	r2, [r2, #0]
 801d978:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801d97a:	f8d7 21f8 	ldr.w	r2, [r7, #504]	; 0x1f8
 801d97e:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801d982:	1ad3      	subs	r3, r2, r3
 801d984:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d986:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801d98a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d98e:	441a      	add	r2, r3
 801d990:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d994:	330a      	adds	r3, #10
 801d996:	7812      	ldrb	r2, [r2, #0]
 801d998:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801d99a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801d99e:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d9a2:	4413      	add	r3, r2
 801d9a4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d9a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801d9aa:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d9ae:	441a      	add	r2, r3
 801d9b0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d9b4:	3304      	adds	r3, #4
 801d9b6:	7812      	ldrb	r2, [r2, #0]
 801d9b8:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801d9ba:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 801d9be:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801d9c2:	1ad3      	subs	r3, r2, r3
 801d9c4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d9c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801d9ca:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d9ce:	441a      	add	r2, r3
 801d9d0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d9d4:	3309      	adds	r3, #9
 801d9d6:	7812      	ldrb	r2, [r2, #0]
 801d9d8:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801d9da:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801d9de:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801d9e2:	4413      	add	r3, r2
 801d9e4:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801d9e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801d9ea:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801d9ee:	441a      	add	r2, r3
 801d9f0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801d9f4:	3305      	adds	r3, #5
 801d9f6:	7812      	ldrb	r2, [r2, #0]
 801d9f8:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801d9fa:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 801d9fe:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801da02:	1ad3      	subs	r3, r2, r3
 801da04:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801da06:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801da0a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801da0e:	441a      	add	r2, r3
 801da10:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801da14:	3308      	adds	r3, #8
 801da16:	7812      	ldrb	r2, [r2, #0]
 801da18:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 801da1a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 801da1e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801da22:	4413      	add	r3, r2
 801da24:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801da26:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 801da2a:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801da2e:	441a      	add	r2, r3
 801da30:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801da34:	3306      	adds	r3, #6
 801da36:	7812      	ldrb	r2, [r2, #0]
 801da38:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 801da3a:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 801da3e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 801da42:	1ad3      	subs	r3, r2, r3
 801da44:	149b      	asrs	r3, r3, #18
 801da46:	e00d      	b.n	801da64 <jpeg_idct_14x14+0xa38>
 801da48:	ffffc8fc 	.word	0xffffc8fc
 801da4c:	ffffd3e1 	.word	0xffffd3e1
 801da50:	ffffdbf0 	.word	0xffffdbf0
 801da54:	ffffde0b 	.word	0xffffde0b
 801da58:	fffff26e 	.word	0xfffff26e
 801da5c:	ffffb409 	.word	0xffffb409
 801da60:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801da64:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 801da68:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801da6c:	441a      	add	r2, r3
 801da6e:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801da72:	3307      	adds	r3, #7
 801da74:	7812      	ldrb	r2, [r2, #0]
 801da76:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801da78:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801da7c:	3320      	adds	r3, #32
 801da7e:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
  for (ctr = 0; ctr < 14; ctr++) {
 801da82:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801da86:	3301      	adds	r3, #1
 801da88:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
 801da8c:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801da90:	2b0d      	cmp	r3, #13
 801da92:	f77f ad79 	ble.w	801d588 <jpeg_idct_14x14+0x55c>
  }
}
 801da96:	bf00      	nop
 801da98:	bf00      	nop
 801da9a:	f507 770c 	add.w	r7, r7, #560	; 0x230
 801da9e:	46bd      	mov	sp, r7
 801daa0:	bc90      	pop	{r4, r7}
 801daa2:	4770      	bx	lr

0801daa4 <jpeg_idct_15x15>:

GLOBAL(void)
jpeg_idct_15x15 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801daa4:	b490      	push	{r4, r7}
 801daa6:	f5ad 7d16 	sub.w	sp, sp, #600	; 0x258
 801daaa:	af00      	add	r7, sp, #0
 801daac:	f107 040c 	add.w	r4, r7, #12
 801dab0:	6020      	str	r0, [r4, #0]
 801dab2:	f107 0008 	add.w	r0, r7, #8
 801dab6:	6001      	str	r1, [r0, #0]
 801dab8:	1d39      	adds	r1, r7, #4
 801daba:	600a      	str	r2, [r1, #0]
 801dabc:	463a      	mov	r2, r7
 801dabe:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801dac0:	f107 030c 	add.w	r3, r7, #12
 801dac4:	681b      	ldr	r3, [r3, #0]
 801dac6:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801daca:	3380      	adds	r3, #128	; 0x80
 801dacc:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
  int workspace[8*15];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801dad0:	1d3b      	adds	r3, r7, #4
 801dad2:	681b      	ldr	r3, [r3, #0]
 801dad4:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801dad8:	f107 0308 	add.w	r3, r7, #8
 801dadc:	681b      	ldr	r3, [r3, #0]
 801dade:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801dae0:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
  wsptr = workspace;
 801dae4:	f107 0314 	add.w	r3, r7, #20
 801dae8:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801daec:	2300      	movs	r3, #0
 801daee:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
 801daf2:	e28d      	b.n	801e010 <jpeg_idct_15x15+0x56c>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801daf4:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801daf8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dafc:	461a      	mov	r2, r3
 801dafe:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801db02:	681b      	ldr	r3, [r3, #0]
 801db04:	fb03 f302 	mul.w	r3, r3, r2
 801db08:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z1 <<= CONST_BITS;
 801db0c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801db10:	035b      	lsls	r3, r3, #13
 801db12:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 801db16:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801db1a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801db1e:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801db22:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801db26:	3320      	adds	r3, #32
 801db28:	f9b3 3000 	ldrsh.w	r3, [r3]
 801db2c:	461a      	mov	r2, r3
 801db2e:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801db32:	3340      	adds	r3, #64	; 0x40
 801db34:	681b      	ldr	r3, [r3, #0]
 801db36:	fb03 f302 	mul.w	r3, r3, r2
 801db3a:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801db3e:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801db42:	3340      	adds	r3, #64	; 0x40
 801db44:	f9b3 3000 	ldrsh.w	r3, [r3]
 801db48:	461a      	mov	r2, r3
 801db4a:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801db4e:	3380      	adds	r3, #128	; 0x80
 801db50:	681b      	ldr	r3, [r3, #0]
 801db52:	fb03 f302 	mul.w	r3, r3, r2
 801db56:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801db5a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801db5e:	3360      	adds	r3, #96	; 0x60
 801db60:	f9b3 3000 	ldrsh.w	r3, [r3]
 801db64:	461a      	mov	r2, r3
 801db66:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801db6a:	33c0      	adds	r3, #192	; 0xc0
 801db6c:	681b      	ldr	r3, [r3, #0]
 801db6e:	fb03 f302 	mul.w	r3, r3, r2
 801db72:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 801db76:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801db7a:	f640 52fc 	movw	r2, #3580	; 0xdfc
 801db7e:	fb02 f303 	mul.w	r3, r2, r3
 801db82:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 801db86:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801db8a:	f242 429d 	movw	r2, #9373	; 0x249d
 801db8e:	fb02 f303 	mul.w	r3, r2, r3
 801db92:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp12 = z1 - tmp10;
 801db96:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801db9a:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801db9e:	1ad3      	subs	r3, r2, r3
 801dba0:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    tmp13 = z1 + tmp11;
 801dba4:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801dba8:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dbac:	4413      	add	r3, r2
 801dbae:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 801dbb2:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801dbb6:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dbba:	1ad3      	subs	r3, r2, r3
 801dbbc:	005b      	lsls	r3, r3, #1
 801dbbe:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801dbc2:	1ad3      	subs	r3, r2, r3
 801dbc4:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c

    z4 = z2 - z3;
 801dbc8:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801dbcc:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801dbd0:	1ad3      	subs	r3, r2, r3
 801dbd2:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z3 += z2;
 801dbd6:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801dbda:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801dbde:	4413      	add	r3, r2
 801dbe0:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 801dbe4:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801dbe8:	f642 22ce 	movw	r2, #10958	; 0x2ace
 801dbec:	fb02 f303 	mul.w	r3, r2, r3
 801dbf0:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 801dbf4:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801dbf8:	f44f 72bb 	mov.w	r2, #374	; 0x176
 801dbfc:	fb02 f303 	mul.w	r3, r2, r3
 801dc00:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 801dc04:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801dc08:	f642 6213 	movw	r2, #11795	; 0x2e13
 801dc0c:	fb02 f303 	mul.w	r3, r2, r3
 801dc10:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 801dc14:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801dc18:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dc1c:	4413      	add	r3, r2
 801dc1e:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801dc22:	4413      	add	r3, r2
 801dc24:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 801dc28:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801dc2c:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dc30:	1ad2      	subs	r2, r2, r3
 801dc32:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dc36:	4413      	add	r3, r2
 801dc38:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801dc3c:	4413      	add	r3, r2
 801dc3e:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 801dc42:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801dc46:	f241 1282 	movw	r2, #4482	; 0x1182
 801dc4a:	fb02 f303 	mul.w	r3, r2, r3
 801dc4e:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 801dc52:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801dc56:	f640 42c7 	movw	r2, #3271	; 0xcc7
 801dc5a:	fb02 f303 	mul.w	r3, r2, r3
 801dc5e:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 801dc62:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801dc66:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dc6a:	1ad2      	subs	r2, r2, r3
 801dc6c:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dc70:	1ad3      	subs	r3, r2, r3
 801dc72:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 801dc76:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801dc7a:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dc7e:	441a      	add	r2, r3
 801dc80:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dc84:	1ad2      	subs	r2, r2, r3
 801dc86:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801dc8a:	1ad3      	subs	r3, r2, r3
 801dc8c:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 801dc90:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801dc94:	f641 124c 	movw	r2, #6476	; 0x194c
 801dc98:	fb02 f303 	mul.w	r3, r2, r3
 801dc9c:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 801dca0:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801dca4:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 801dca8:	fb02 f303 	mul.w	r3, r2, r3
 801dcac:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 801dcb0:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801dcb4:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dcb8:	4413      	add	r3, r2
 801dcba:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801dcbe:	4413      	add	r3, r2
 801dcc0:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 801dcc4:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801dcc8:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801dccc:	1ad3      	subs	r3, r2, r3
 801dcce:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801dcd2:	4413      	add	r3, r2
 801dcd4:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    tmp11 += tmp11;
 801dcd8:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dcdc:	005b      	lsls	r3, r3, #1
 801dcde:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 801dce2:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801dce6:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dcea:	4413      	add	r3, r2
 801dcec:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 801dcf0:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801dcf4:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dcf8:	1ad2      	subs	r2, r2, r3
 801dcfa:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dcfe:	1ad3      	subs	r3, r2, r3
 801dd00:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801dd04:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801dd08:	3310      	adds	r3, #16
 801dd0a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd0e:	461a      	mov	r2, r3
 801dd10:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801dd14:	3320      	adds	r3, #32
 801dd16:	681b      	ldr	r3, [r3, #0]
 801dd18:	fb03 f302 	mul.w	r3, r3, r2
 801dd1c:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801dd20:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801dd24:	3330      	adds	r3, #48	; 0x30
 801dd26:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd2a:	461a      	mov	r2, r3
 801dd2c:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801dd30:	3360      	adds	r3, #96	; 0x60
 801dd32:	681b      	ldr	r3, [r3, #0]
 801dd34:	fb03 f302 	mul.w	r3, r3, r2
 801dd38:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801dd3c:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801dd40:	3350      	adds	r3, #80	; 0x50
 801dd42:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd46:	461a      	mov	r2, r3
 801dd48:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801dd4c:	33a0      	adds	r3, #160	; 0xa0
 801dd4e:	681b      	ldr	r3, [r3, #0]
 801dd50:	fb03 f302 	mul.w	r3, r3, r2
 801dd54:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 801dd58:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801dd5c:	f242 7231 	movw	r2, #10033	; 0x2731
 801dd60:	fb02 f303 	mul.w	r3, r2, r3
 801dd64:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801dd68:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801dd6c:	3370      	adds	r3, #112	; 0x70
 801dd6e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd72:	461a      	mov	r2, r3
 801dd74:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801dd78:	33e0      	adds	r3, #224	; 0xe0
 801dd7a:	681b      	ldr	r3, [r3, #0]
 801dd7c:	fb03 f302 	mul.w	r3, r3, r2
 801dd80:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp13 = z2 - z4;
 801dd84:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801dd88:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801dd8c:	1ad3      	subs	r3, r2, r3
 801dd8e:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 801dd92:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801dd96:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801dd9a:	4413      	add	r3, r2
 801dd9c:	f641 229a 	movw	r2, #6810	; 0x1a9a
 801dda0:	fb02 f303 	mul.w	r3, r2, r3
 801dda4:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 801dda8:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ddac:	f241 0271 	movw	r2, #4209	; 0x1071
 801ddb0:	fb02 f303 	mul.w	r3, r2, r3
 801ddb4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ddb8:	4413      	add	r3, r2
 801ddba:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 801ddbe:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801ddc2:	4a9a      	ldr	r2, [pc, #616]	; (801e02c <jpeg_idct_15x15+0x588>)
 801ddc4:	fb02 f303 	mul.w	r3, r2, r3
 801ddc8:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801ddcc:	4413      	add	r3, r2
 801ddce:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 801ddd2:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ddd6:	4a96      	ldr	r2, [pc, #600]	; (801e030 <jpeg_idct_15x15+0x58c>)
 801ddd8:	fb02 f303 	mul.w	r3, r2, r3
 801dddc:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 801dde0:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801dde4:	4a93      	ldr	r2, [pc, #588]	; (801e034 <jpeg_idct_15x15+0x590>)
 801dde6:	fb02 f303 	mul.w	r3, r2, r3
 801ddea:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    z2 = z1 - z4;
 801ddee:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801ddf2:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801ddf6:	1ad3      	subs	r3, r2, r3
 801ddf8:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 801ddfc:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801de00:	f642 5202 	movw	r2, #11522	; 0x2d02
 801de04:	fb02 f303 	mul.w	r3, r2, r3
 801de08:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801de0c:	4413      	add	r3, r2
 801de0e:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 801de12:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801de16:	f644 62a3 	movw	r2, #20131	; 0x4ea3
 801de1a:	fb02 f203 	mul.w	r2, r2, r3
 801de1e:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801de22:	441a      	add	r2, r3
 801de24:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801de28:	1ad3      	subs	r3, r2, r3
 801de2a:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 801de2e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801de32:	4a81      	ldr	r2, [pc, #516]	; (801e038 <jpeg_idct_15x15+0x594>)
 801de34:	fb02 f203 	mul.w	r2, r2, r3
 801de38:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801de3c:	4413      	add	r3, r2
 801de3e:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801de42:	4413      	add	r3, r2
 801de44:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 801de48:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801de4c:	f242 7231 	movw	r2, #10033	; 0x2731
 801de50:	fb02 f203 	mul.w	r2, r2, r3
 801de54:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801de58:	1ad3      	subs	r3, r2, r3
 801de5a:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 801de5e:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801de62:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801de66:	4413      	add	r3, r2
 801de68:	f241 2268 	movw	r2, #4712	; 0x1268
 801de6c:	fb02 f303 	mul.w	r3, r2, r3
 801de70:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 801de74:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801de78:	f640 7239 	movw	r2, #3897	; 0xf39
 801de7c:	fb02 f203 	mul.w	r2, r2, r3
 801de80:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801de84:	441a      	add	r2, r3
 801de86:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801de8a:	1ad3      	subs	r3, r2, r3
 801de8c:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801de90:	4413      	add	r3, r2
 801de92:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 801de96:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801de9a:	4a68      	ldr	r2, [pc, #416]	; (801e03c <jpeg_idct_15x15+0x598>)
 801de9c:	fb02 f203 	mul.w	r2, r2, r3
 801dea0:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801dea4:	441a      	add	r2, r3
 801dea6:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801deaa:	4413      	add	r3, r2
 801deac:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801deb0:	4413      	add	r3, r2
 801deb2:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 801deb6:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801deba:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801debe:	4413      	add	r3, r2
 801dec0:	12da      	asrs	r2, r3, #11
 801dec2:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801dec6:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 801dec8:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801decc:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801ded0:	1ad2      	subs	r2, r2, r3
 801ded2:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801ded6:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 801deda:	12d2      	asrs	r2, r2, #11
 801dedc:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 801dede:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801dee2:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801dee6:	441a      	add	r2, r3
 801dee8:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801deec:	3320      	adds	r3, #32
 801deee:	12d2      	asrs	r2, r2, #11
 801def0:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 801def2:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801def6:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801defa:	1ad2      	subs	r2, r2, r3
 801defc:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df00:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 801df04:	12d2      	asrs	r2, r2, #11
 801df06:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 801df08:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801df0c:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801df10:	441a      	add	r2, r3
 801df12:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df16:	3340      	adds	r3, #64	; 0x40
 801df18:	12d2      	asrs	r2, r2, #11
 801df1a:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 801df1c:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801df20:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801df24:	1ad2      	subs	r2, r2, r3
 801df26:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df2a:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 801df2e:	12d2      	asrs	r2, r2, #11
 801df30:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 801df32:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801df36:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801df3a:	441a      	add	r2, r3
 801df3c:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df40:	3360      	adds	r3, #96	; 0x60
 801df42:	12d2      	asrs	r2, r2, #11
 801df44:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 801df46:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801df4a:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801df4e:	1ad2      	subs	r2, r2, r3
 801df50:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df54:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 801df58:	12d2      	asrs	r2, r2, #11
 801df5a:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 801df5c:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801df60:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801df64:	441a      	add	r2, r3
 801df66:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df6a:	3380      	adds	r3, #128	; 0x80
 801df6c:	12d2      	asrs	r2, r2, #11
 801df6e:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 801df70:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801df74:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801df78:	1ad2      	subs	r2, r2, r3
 801df7a:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df7e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801df82:	12d2      	asrs	r2, r2, #11
 801df84:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 801df86:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801df8a:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801df8e:	441a      	add	r2, r3
 801df90:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801df94:	33a0      	adds	r3, #160	; 0xa0
 801df96:	12d2      	asrs	r2, r2, #11
 801df98:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 801df9a:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801df9e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801dfa2:	1ad2      	subs	r2, r2, r3
 801dfa4:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801dfa8:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801dfac:	12d2      	asrs	r2, r2, #11
 801dfae:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 801dfb0:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801dfb4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801dfb8:	441a      	add	r2, r3
 801dfba:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801dfbe:	33c0      	adds	r3, #192	; 0xc0
 801dfc0:	12d2      	asrs	r2, r2, #11
 801dfc2:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 801dfc4:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801dfc8:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801dfcc:	1ad2      	subs	r2, r2, r3
 801dfce:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801dfd2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801dfd6:	12d2      	asrs	r2, r2, #11
 801dfd8:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27, CONST_BITS-PASS1_BITS);
 801dfda:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801dfde:	33e0      	adds	r3, #224	; 0xe0
 801dfe0:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 801dfe4:	12d2      	asrs	r2, r2, #11
 801dfe6:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801dfe8:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801dfec:	3301      	adds	r3, #1
 801dfee:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
 801dff2:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801dff6:	3302      	adds	r3, #2
 801dff8:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
 801dffc:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e000:	3304      	adds	r3, #4
 801e002:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
 801e006:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e00a:	3304      	adds	r3, #4
 801e00c:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
 801e010:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e014:	2b07      	cmp	r3, #7
 801e016:	f77f ad6d 	ble.w	801daf4 <jpeg_idct_15x15+0x50>
  }

  /* Pass 2: process 15 rows from work array, store into output array. */

  wsptr = workspace;
 801e01a:	f107 0314 	add.w	r3, r7, #20
 801e01e:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 801e022:	2300      	movs	r3, #0
 801e024:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
 801e028:	e2a9      	b.n	801e57e <jpeg_idct_15x15+0xada>
 801e02a:	bf00      	nop
 801e02c:	ffffba5c 	.word	0xffffba5c
 801e030:	ffffe566 	.word	0xffffe566
 801e034:	ffffd4f6 	.word	0xffffd4f6
 801e038:	ffffdc67 	.word	0xffffdc67
 801e03c:	ffffe42f 	.word	0xffffe42f
    outptr = output_buf[ctr] + output_col;
 801e040:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e044:	009b      	lsls	r3, r3, #2
 801e046:	463a      	mov	r2, r7
 801e048:	6812      	ldr	r2, [r2, #0]
 801e04a:	4413      	add	r3, r2
 801e04c:	681a      	ldr	r2, [r3, #0]
 801e04e:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801e052:	4413      	add	r3, r2
 801e054:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801e058:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e05c:	681b      	ldr	r3, [r3, #0]
 801e05e:	3310      	adds	r3, #16
 801e060:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z1 <<= CONST_BITS;
 801e064:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e068:	035b      	lsls	r3, r3, #13
 801e06a:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c

    z2 = (INT32) wsptr[2];
 801e06e:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e072:	3308      	adds	r3, #8
 801e074:	681b      	ldr	r3, [r3, #0]
 801e076:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z3 = (INT32) wsptr[4];
 801e07a:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e07e:	3310      	adds	r3, #16
 801e080:	681b      	ldr	r3, [r3, #0]
 801e082:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z4 = (INT32) wsptr[6];
 801e086:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e08a:	3318      	adds	r3, #24
 801e08c:	681b      	ldr	r3, [r3, #0]
 801e08e:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */
 801e092:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e096:	f640 52fc 	movw	r2, #3580	; 0xdfc
 801e09a:	fb02 f303 	mul.w	r3, r2, r3
 801e09e:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */
 801e0a2:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e0a6:	f242 429d 	movw	r2, #9373	; 0x249d
 801e0aa:	fb02 f303 	mul.w	r3, r2, r3
 801e0ae:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp12 = z1 - tmp10;
 801e0b2:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e0b6:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e0ba:	1ad3      	subs	r3, r2, r3
 801e0bc:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    tmp13 = z1 + tmp11;
 801e0c0:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e0c4:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e0c8:	4413      	add	r3, r2
 801e0ca:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    z1 -= (tmp11 - tmp10) << 1;             /* c0 = (c6-c12)*2 */
 801e0ce:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801e0d2:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e0d6:	1ad3      	subs	r3, r2, r3
 801e0d8:	005b      	lsls	r3, r3, #1
 801e0da:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e0de:	1ad3      	subs	r3, r2, r3
 801e0e0:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c

    z4 = z2 - z3;
 801e0e4:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e0e8:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e0ec:	1ad3      	subs	r3, r2, r3
 801e0ee:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z3 += z2;
 801e0f2:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801e0f6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e0fa:	4413      	add	r3, r2
 801e0fc:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */
 801e100:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e104:	f642 22ce 	movw	r2, #10958	; 0x2ace
 801e108:	fb02 f303 	mul.w	r3, r2, r3
 801e10c:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */
 801e110:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e114:	f44f 72bb 	mov.w	r2, #374	; 0x176
 801e118:	fb02 f303 	mul.w	r3, r2, r3
 801e11c:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */
 801e120:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e124:	f642 6213 	movw	r2, #11795	; 0x2e13
 801e128:	fb02 f303 	mul.w	r3, r2, r3
 801e12c:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    tmp20 = tmp13 + tmp10 + tmp11;
 801e130:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801e134:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e138:	4413      	add	r3, r2
 801e13a:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801e13e:	4413      	add	r3, r2
 801e140:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    tmp23 = tmp12 - tmp10 + tmp11 + z2;
 801e144:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801e148:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e14c:	1ad2      	subs	r2, r2, r3
 801e14e:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e152:	4413      	add	r3, r2
 801e154:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e158:	4413      	add	r3, r2
 801e15a:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218

    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */
 801e15e:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e162:	f241 1282 	movw	r2, #4482	; 0x1182
 801e166:	fb02 f303 	mul.w	r3, r2, r3
 801e16a:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */
 801e16e:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e172:	f640 42c7 	movw	r2, #3271	; 0xcc7
 801e176:	fb02 f303 	mul.w	r3, r2, r3
 801e17a:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp25 = tmp13 - tmp10 - tmp11;
 801e17e:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801e182:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e186:	1ad2      	subs	r2, r2, r3
 801e188:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e18c:	1ad3      	subs	r3, r2, r3
 801e18e:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp26 = tmp12 + tmp10 - tmp11 - z2;
 801e192:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801e196:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e19a:	441a      	add	r2, r3
 801e19c:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e1a0:	1ad2      	subs	r2, r2, r3
 801e1a2:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e1a6:	1ad3      	subs	r3, r2, r3
 801e1a8:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */
 801e1ac:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e1b0:	f641 124c 	movw	r2, #6476	; 0x194c
 801e1b4:	fb02 f303 	mul.w	r3, r2, r3
 801e1b8:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */
 801e1bc:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e1c0:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 801e1c4:	fb02 f303 	mul.w	r3, r2, r3
 801e1c8:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228

    tmp21 = tmp12 + tmp10 + tmp11;
 801e1cc:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801e1d0:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e1d4:	4413      	add	r3, r2
 801e1d6:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801e1da:	4413      	add	r3, r2
 801e1dc:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    tmp24 = tmp13 - tmp10 + tmp11;
 801e1e0:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801e1e4:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e1e8:	1ad3      	subs	r3, r2, r3
 801e1ea:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801e1ee:	4413      	add	r3, r2
 801e1f0:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
    tmp11 += tmp11;
 801e1f4:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e1f8:	005b      	lsls	r3, r3, #1
 801e1fa:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */
 801e1fe:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e202:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e206:	4413      	add	r3, r2
 801e208:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */
 801e20c:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e210:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e214:	1ad2      	subs	r2, r2, r3
 801e216:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e21a:	1ad3      	subs	r3, r2, r3
 801e21c:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801e220:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e224:	3304      	adds	r3, #4
 801e226:	681b      	ldr	r3, [r3, #0]
 801e228:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z2 = (INT32) wsptr[3];
 801e22c:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e230:	330c      	adds	r3, #12
 801e232:	681b      	ldr	r3, [r3, #0]
 801e234:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = (INT32) wsptr[5];
 801e238:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e23c:	3314      	adds	r3, #20
 801e23e:	681b      	ldr	r3, [r3, #0]
 801e240:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */
 801e244:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e248:	f242 7231 	movw	r2, #10033	; 0x2731
 801e24c:	fb02 f303 	mul.w	r3, r2, r3
 801e250:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z4 = (INT32) wsptr[7];
 801e254:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e258:	331c      	adds	r3, #28
 801e25a:	681b      	ldr	r3, [r3, #0]
 801e25c:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp13 = z2 - z4;
 801e260:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e264:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e268:	1ad3      	subs	r3, r2, r3
 801e26a:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */
 801e26e:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e272:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801e276:	4413      	add	r3, r2
 801e278:	f641 229a 	movw	r2, #6810	; 0x1a9a
 801e27c:	fb02 f303 	mul.w	r3, r2, r3
 801e280:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */
 801e284:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e288:	f241 0271 	movw	r2, #4209	; 0x1071
 801e28c:	fb02 f303 	mul.w	r3, r2, r3
 801e290:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801e294:	4413      	add	r3, r2
 801e296:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */
 801e29a:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801e29e:	4abe      	ldr	r2, [pc, #760]	; (801e598 <jpeg_idct_15x15+0xaf4>)
 801e2a0:	fb02 f303 	mul.w	r3, r2, r3
 801e2a4:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801e2a8:	4413      	add	r3, r2
 801e2aa:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8

    tmp13 = MULTIPLY(z2, - FIX(0.831253876));               /* -c9 */
 801e2ae:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e2b2:	4aba      	ldr	r2, [pc, #744]	; (801e59c <jpeg_idct_15x15+0xaf8>)
 801e2b4:	fb02 f303 	mul.w	r3, r2, r3
 801e2b8:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 = MULTIPLY(z2, - FIX(1.344997024));               /* -c3 */
 801e2bc:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e2c0:	4ab7      	ldr	r2, [pc, #732]	; (801e5a0 <jpeg_idct_15x15+0xafc>)
 801e2c2:	fb02 f303 	mul.w	r3, r2, r3
 801e2c6:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
    z2 = z1 - z4;
 801e2ca:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e2ce:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e2d2:	1ad3      	subs	r3, r2, r3
 801e2d4:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */
 801e2d8:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e2dc:	f642 5202 	movw	r2, #11522	; 0x2d02
 801e2e0:	fb02 f303 	mul.w	r3, r2, r3
 801e2e4:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801e2e8:	4413      	add	r3, r2
 801e2ea:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224

    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */
 801e2ee:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e2f2:	f644 62a3 	movw	r2, #20131	; 0x4ea3
 801e2f6:	fb02 f203 	mul.w	r2, r2, r3
 801e2fa:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801e2fe:	441a      	add	r2, r3
 801e300:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801e304:	1ad3      	subs	r3, r2, r3
 801e306:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */
 801e30a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e30e:	4aa5      	ldr	r2, [pc, #660]	; (801e5a4 <jpeg_idct_15x15+0xb00>)
 801e310:	fb02 f203 	mul.w	r2, r2, r3
 801e314:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801e318:	4413      	add	r3, r2
 801e31a:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801e31e:	4413      	add	r3, r2
 801e320:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */
 801e324:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e328:	f242 7231 	movw	r2, #10033	; 0x2731
 801e32c:	fb02 f203 	mul.w	r2, r2, r3
 801e330:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e334:	1ad3      	subs	r3, r2, r3
 801e336:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */
 801e33a:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e33e:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e342:	4413      	add	r3, r2
 801e344:	f241 2268 	movw	r2, #4712	; 0x1268
 801e348:	fb02 f303 	mul.w	r3, r2, r3
 801e34c:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */
 801e350:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e354:	f640 7239 	movw	r2, #3897	; 0xf39
 801e358:	fb02 f203 	mul.w	r2, r2, r3
 801e35c:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e360:	441a      	add	r2, r3
 801e362:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e366:	1ad3      	subs	r3, r2, r3
 801e368:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801e36c:	4413      	add	r3, r2
 801e36e:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */
 801e372:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e376:	4a8c      	ldr	r2, [pc, #560]	; (801e5a8 <jpeg_idct_15x15+0xb04>)
 801e378:	fb02 f203 	mul.w	r2, r2, r3
 801e37c:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e380:	441a      	add	r2, r3
 801e382:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e386:	4413      	add	r3, r2
 801e388:	f8d7 21fc 	ldr.w	r2, [r7, #508]	; 0x1fc
 801e38c:	4413      	add	r3, r2
 801e38e:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801e392:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801e396:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e39a:	4413      	add	r3, r2
 801e39c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e39e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 801e3a2:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e3a6:	4413      	add	r3, r2
 801e3a8:	781a      	ldrb	r2, [r3, #0]
 801e3aa:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e3ae:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801e3b0:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801e3b4:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801e3b8:	1ad3      	subs	r3, r2, r3
 801e3ba:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e3bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 801e3c0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e3c4:	441a      	add	r2, r3
 801e3c6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e3ca:	330e      	adds	r3, #14
 801e3cc:	7812      	ldrb	r2, [r2, #0]
 801e3ce:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801e3d0:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801e3d4:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e3d8:	4413      	add	r3, r2
 801e3da:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e3dc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 801e3e0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e3e4:	441a      	add	r2, r3
 801e3e6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e3ea:	3301      	adds	r3, #1
 801e3ec:	7812      	ldrb	r2, [r2, #0]
 801e3ee:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801e3f0:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801e3f4:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801e3f8:	1ad3      	subs	r3, r2, r3
 801e3fa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e3fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 801e400:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e404:	441a      	add	r2, r3
 801e406:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e40a:	330d      	adds	r3, #13
 801e40c:	7812      	ldrb	r2, [r2, #0]
 801e40e:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801e410:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801e414:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801e418:	4413      	add	r3, r2
 801e41a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e41c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 801e420:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e424:	441a      	add	r2, r3
 801e426:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e42a:	3302      	adds	r3, #2
 801e42c:	7812      	ldrb	r2, [r2, #0]
 801e42e:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801e430:	f8d7 2204 	ldr.w	r2, [r7, #516]	; 0x204
 801e434:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801e438:	1ad3      	subs	r3, r2, r3
 801e43a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e43c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 801e440:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e444:	441a      	add	r2, r3
 801e446:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e44a:	330c      	adds	r3, #12
 801e44c:	7812      	ldrb	r2, [r2, #0]
 801e44e:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801e450:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801e454:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801e458:	4413      	add	r3, r2
 801e45a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e45c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 801e460:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e464:	441a      	add	r2, r3
 801e466:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e46a:	3303      	adds	r3, #3
 801e46c:	7812      	ldrb	r2, [r2, #0]
 801e46e:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801e470:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801e474:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801e478:	1ad3      	subs	r3, r2, r3
 801e47a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e47c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 801e480:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e484:	441a      	add	r2, r3
 801e486:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e48a:	330b      	adds	r3, #11
 801e48c:	7812      	ldrb	r2, [r2, #0]
 801e48e:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801e490:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801e494:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801e498:	4413      	add	r3, r2
 801e49a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e49c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 801e4a0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e4a4:	441a      	add	r2, r3
 801e4a6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e4aa:	3304      	adds	r3, #4
 801e4ac:	7812      	ldrb	r2, [r2, #0]
 801e4ae:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801e4b0:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
 801e4b4:	f8d7 31f8 	ldr.w	r3, [r7, #504]	; 0x1f8
 801e4b8:	1ad3      	subs	r3, r2, r3
 801e4ba:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e4bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 801e4c0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e4c4:	441a      	add	r2, r3
 801e4c6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e4ca:	330a      	adds	r3, #10
 801e4cc:	7812      	ldrb	r2, [r2, #0]
 801e4ce:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801e4d0:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801e4d4:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801e4d8:	4413      	add	r3, r2
 801e4da:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e4dc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 801e4e0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e4e4:	441a      	add	r2, r3
 801e4e6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e4ea:	3305      	adds	r3, #5
 801e4ec:	7812      	ldrb	r2, [r2, #0]
 801e4ee:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801e4f0:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801e4f4:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801e4f8:	1ad3      	subs	r3, r2, r3
 801e4fa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e4fc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 801e500:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e504:	441a      	add	r2, r3
 801e506:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e50a:	3309      	adds	r3, #9
 801e50c:	7812      	ldrb	r2, [r2, #0]
 801e50e:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 801e510:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801e514:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801e518:	4413      	add	r3, r2
 801e51a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e51c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 801e520:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e524:	441a      	add	r2, r3
 801e526:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e52a:	3306      	adds	r3, #6
 801e52c:	7812      	ldrb	r2, [r2, #0]
 801e52e:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 801e530:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801e534:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801e538:	1ad3      	subs	r3, r2, r3
 801e53a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e53c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 801e540:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e544:	441a      	add	r2, r3
 801e546:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e54a:	3308      	adds	r3, #8
 801e54c:	7812      	ldrb	r2, [r2, #0]
 801e54e:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 801e550:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801e554:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801e556:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27,
 801e55a:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e55e:	441a      	add	r2, r3
 801e560:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801e564:	3307      	adds	r3, #7
 801e566:	7812      	ldrb	r2, [r2, #0]
 801e568:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801e56a:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801e56e:	3320      	adds	r3, #32
 801e570:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
  for (ctr = 0; ctr < 15; ctr++) {
 801e574:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e578:	3301      	adds	r3, #1
 801e57a:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
 801e57e:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e582:	2b0e      	cmp	r3, #14
 801e584:	f77f ad5c 	ble.w	801e040 <jpeg_idct_15x15+0x59c>
  }
}
 801e588:	bf00      	nop
 801e58a:	bf00      	nop
 801e58c:	f507 7716 	add.w	r7, r7, #600	; 0x258
 801e590:	46bd      	mov	sp, r7
 801e592:	bc90      	pop	{r4, r7}
 801e594:	4770      	bx	lr
 801e596:	bf00      	nop
 801e598:	ffffba5c 	.word	0xffffba5c
 801e59c:	ffffe566 	.word	0xffffe566
 801e5a0:	ffffd4f6 	.word	0xffffd4f6
 801e5a4:	ffffdc67 	.word	0xffffdc67
 801e5a8:	ffffe42f 	.word	0xffffe42f

0801e5ac <jpeg_idct_16x16>:

GLOBAL(void)
jpeg_idct_16x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801e5ac:	b490      	push	{r4, r7}
 801e5ae:	f5ad 7d1e 	sub.w	sp, sp, #632	; 0x278
 801e5b2:	af00      	add	r7, sp, #0
 801e5b4:	f107 040c 	add.w	r4, r7, #12
 801e5b8:	6020      	str	r0, [r4, #0]
 801e5ba:	f107 0008 	add.w	r0, r7, #8
 801e5be:	6001      	str	r1, [r0, #0]
 801e5c0:	1d39      	adds	r1, r7, #4
 801e5c2:	600a      	str	r2, [r1, #0]
 801e5c4:	463a      	mov	r2, r7
 801e5c6:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801e5c8:	f107 030c 	add.w	r3, r7, #12
 801e5cc:	681b      	ldr	r3, [r3, #0]
 801e5ce:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801e5d2:	3380      	adds	r3, #128	; 0x80
 801e5d4:	f8c7 3264 	str.w	r3, [r7, #612]	; 0x264
  int workspace[8*16];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 801e5d8:	1d3b      	adds	r3, r7, #4
 801e5da:	681b      	ldr	r3, [r3, #0]
 801e5dc:	f8c7 3274 	str.w	r3, [r7, #628]	; 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801e5e0:	f107 0308 	add.w	r3, r7, #8
 801e5e4:	681b      	ldr	r3, [r3, #0]
 801e5e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801e5e8:	f8c7 3270 	str.w	r3, [r7, #624]	; 0x270
  wsptr = workspace;
 801e5ec:	f107 0310 	add.w	r3, r7, #16
 801e5f0:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801e5f4:	2300      	movs	r3, #0
 801e5f6:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 801e5fa:	e30b      	b.n	801ec14 <jpeg_idct_16x16+0x668>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801e5fc:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e600:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e604:	461a      	mov	r2, r3
 801e606:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e60a:	681b      	ldr	r3, [r3, #0]
 801e60c:	fb03 f302 	mul.w	r3, r3, r2
 801e610:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp0 <<= CONST_BITS;
 801e614:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801e618:	035b      	lsls	r3, r3, #13
 801e61a:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    /* Add fudge factor here for final descale. */
    tmp0 += 1 << (CONST_BITS-PASS1_BITS-1);
 801e61e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801e622:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801e626:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801e62a:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e62e:	3340      	adds	r3, #64	; 0x40
 801e630:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e634:	461a      	mov	r2, r3
 801e636:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e63a:	3380      	adds	r3, #128	; 0x80
 801e63c:	681b      	ldr	r3, [r3, #0]
 801e63e:	fb03 f302 	mul.w	r3, r3, r2
 801e642:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 801e646:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e64a:	f642 12cf 	movw	r2, #10703	; 0x29cf
 801e64e:	fb02 f303 	mul.w	r3, r2, r3
 801e652:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 801e656:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e65a:	f241 1251 	movw	r2, #4433	; 0x1151
 801e65e:	fb02 f303 	mul.w	r3, r2, r3
 801e662:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250

    tmp10 = tmp0 + tmp1;
 801e666:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801e66a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801e66e:	4413      	add	r3, r2
 801e670:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 = tmp0 - tmp1;
 801e674:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801e678:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801e67c:	1ad3      	subs	r3, r2, r3
 801e67e:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 = tmp0 + tmp2;
 801e682:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801e686:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e68a:	4413      	add	r3, r2
 801e68c:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp13 = tmp0 - tmp2;
 801e690:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801e694:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e698:	1ad3      	subs	r3, r2, r3
 801e69a:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801e69e:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e6a2:	3320      	adds	r3, #32
 801e6a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e6a8:	461a      	mov	r2, r3
 801e6aa:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e6ae:	3340      	adds	r3, #64	; 0x40
 801e6b0:	681b      	ldr	r3, [r3, #0]
 801e6b2:	fb03 f302 	mul.w	r3, r3, r2
 801e6b6:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801e6ba:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e6be:	3360      	adds	r3, #96	; 0x60
 801e6c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e6c4:	461a      	mov	r2, r3
 801e6c6:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e6ca:	33c0      	adds	r3, #192	; 0xc0
 801e6cc:	681b      	ldr	r3, [r3, #0]
 801e6ce:	fb03 f302 	mul.w	r3, r3, r2
 801e6d2:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z3 = z1 - z2;
 801e6d6:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e6da:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e6de:	1ad3      	subs	r3, r2, r3
 801e6e0:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 801e6e4:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e6e8:	f640 02d4 	movw	r2, #2260	; 0x8d4
 801e6ec:	fb02 f303 	mul.w	r3, r2, r3
 801e6f0:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 801e6f4:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e6f8:	f642 4263 	movw	r2, #11363	; 0x2c63
 801e6fc:	fb02 f303 	mul.w	r3, r2, r3
 801e700:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 801e704:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e708:	f245 2203 	movw	r2, #20995	; 0x5203
 801e70c:	fb02 f303 	mul.w	r3, r2, r3
 801e710:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e714:	4413      	add	r3, r2
 801e716:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 801e71a:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e71e:	f641 42cd 	movw	r2, #7373	; 0x1ccd
 801e722:	fb02 f303 	mul.w	r3, r2, r3
 801e726:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801e72a:	4413      	add	r3, r2
 801e72c:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 801e730:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e734:	4af4      	ldr	r2, [pc, #976]	; (801eb08 <jpeg_idct_16x16+0x55c>)
 801e736:	fb02 f303 	mul.w	r3, r2, r3
 801e73a:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e73e:	4413      	add	r3, r2
 801e740:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 801e744:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e748:	4af0      	ldr	r2, [pc, #960]	; (801eb0c <jpeg_idct_16x16+0x560>)
 801e74a:	fb02 f303 	mul.w	r3, r2, r3
 801e74e:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801e752:	4413      	add	r3, r2
 801e754:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp20 = tmp10 + tmp0;
 801e758:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801e75c:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801e760:	4413      	add	r3, r2
 801e762:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp27 = tmp10 - tmp0;
 801e766:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801e76a:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801e76e:	1ad3      	subs	r3, r2, r3
 801e770:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp21 = tmp12 + tmp1;
 801e774:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e778:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801e77c:	4413      	add	r3, r2
 801e77e:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    tmp26 = tmp12 - tmp1;
 801e782:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e786:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801e78a:	1ad3      	subs	r3, r2, r3
 801e78c:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp22 = tmp13 + tmp2;
 801e790:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801e794:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e798:	4413      	add	r3, r2
 801e79a:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    tmp25 = tmp13 - tmp2;
 801e79e:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801e7a2:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e7a6:	1ad3      	subs	r3, r2, r3
 801e7a8:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    tmp23 = tmp11 + tmp3;
 801e7ac:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801e7b0:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e7b4:	4413      	add	r3, r2
 801e7b6:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp24 = tmp11 - tmp3;
 801e7ba:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801e7be:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e7c2:	1ad3      	subs	r3, r2, r3
 801e7c4:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801e7c8:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e7cc:	3310      	adds	r3, #16
 801e7ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e7d2:	461a      	mov	r2, r3
 801e7d4:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e7d8:	3320      	adds	r3, #32
 801e7da:	681b      	ldr	r3, [r3, #0]
 801e7dc:	fb03 f302 	mul.w	r3, r3, r2
 801e7e0:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801e7e4:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e7e8:	3330      	adds	r3, #48	; 0x30
 801e7ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e7ee:	461a      	mov	r2, r3
 801e7f0:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e7f4:	3360      	adds	r3, #96	; 0x60
 801e7f6:	681b      	ldr	r3, [r3, #0]
 801e7f8:	fb03 f302 	mul.w	r3, r3, r2
 801e7fc:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801e800:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e804:	3350      	adds	r3, #80	; 0x50
 801e806:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e80a:	461a      	mov	r2, r3
 801e80c:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e810:	33a0      	adds	r3, #160	; 0xa0
 801e812:	681b      	ldr	r3, [r3, #0]
 801e814:	fb03 f302 	mul.w	r3, r3, r2
 801e818:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801e81c:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801e820:	3370      	adds	r3, #112	; 0x70
 801e822:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e826:	461a      	mov	r2, r3
 801e828:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801e82c:	33e0      	adds	r3, #224	; 0xe0
 801e82e:	681b      	ldr	r3, [r3, #0]
 801e830:	fb03 f302 	mul.w	r3, r3, r2
 801e834:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234

    tmp11 = z1 + z3;
 801e838:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e83c:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e840:	4413      	add	r3, r2
 801e842:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 801e846:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e84a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e84e:	4413      	add	r3, r2
 801e850:	f642 324e 	movw	r2, #11086	; 0x2b4e
 801e854:	fb02 f303 	mul.w	r3, r2, r3
 801e858:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 801e85c:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e860:	f242 72e9 	movw	r2, #10217	; 0x27e9
 801e864:	fb02 f303 	mul.w	r3, r2, r3
 801e868:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 801e86c:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e870:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e874:	4413      	add	r3, r2
 801e876:	f242 22fc 	movw	r2, #8956	; 0x22fc
 801e87a:	fb02 f303 	mul.w	r3, r2, r3
 801e87e:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 801e882:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e886:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e88a:	1ad3      	subs	r3, r2, r3
 801e88c:	f641 42b6 	movw	r2, #7350	; 0x1cb6
 801e890:	fb02 f303 	mul.w	r3, r2, r3
 801e894:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 801e898:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e89c:	f241 5255 	movw	r2, #5461	; 0x1555
 801e8a0:	fb02 f303 	mul.w	r3, r2, r3
 801e8a4:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 801e8a8:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801e8ac:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e8b0:	1ad3      	subs	r3, r2, r3
 801e8b2:	f640 5223 	movw	r2, #3363	; 0xd23
 801e8b6:	fb02 f303 	mul.w	r3, r2, r3
 801e8ba:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 801e8be:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801e8c2:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801e8c6:	441a      	add	r2, r3
 801e8c8:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801e8cc:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 801e8ce:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e8d2:	498f      	ldr	r1, [pc, #572]	; (801eb10 <jpeg_idct_16x16+0x564>)
 801e8d4:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 801e8d8:	4413      	add	r3, r2
 801e8da:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 801e8de:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801e8e2:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801e8e6:	441a      	add	r2, r3
 801e8e8:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801e8ec:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 801e8ee:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e8f2:	4988      	ldr	r1, [pc, #544]	; (801eb14 <jpeg_idct_16x16+0x568>)
 801e8f4:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 801e8f8:	4413      	add	r3, r2
 801e8fa:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 801e8fe:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e902:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e906:	4413      	add	r3, r2
 801e908:	f44f 628e 	mov.w	r2, #1136	; 0x470
 801e90c:	fb02 f303 	mul.w	r3, r2, r3
 801e910:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 801e914:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e918:	f240 224d 	movw	r2, #589	; 0x24d
 801e91c:	fb02 f203 	mul.w	r2, r2, r3
 801e920:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e924:	4413      	add	r3, r2
 801e926:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801e92a:	4413      	add	r3, r2
 801e92c:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 801e930:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e934:	4a78      	ldr	r2, [pc, #480]	; (801eb18 <jpeg_idct_16x16+0x56c>)
 801e936:	fb02 f203 	mul.w	r2, r2, r3
 801e93a:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e93e:	4413      	add	r3, r2
 801e940:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 801e944:	4413      	add	r3, r2
 801e946:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 801e94a:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801e94e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e952:	1ad3      	subs	r3, r2, r3
 801e954:	f642 5209 	movw	r2, #11529	; 0x2d09
 801e958:	fb02 f303 	mul.w	r3, r2, r3
 801e95c:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 801e960:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801e964:	4a6d      	ldr	r2, [pc, #436]	; (801eb1c <jpeg_idct_16x16+0x570>)
 801e966:	fb02 f203 	mul.w	r2, r2, r3
 801e96a:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e96e:	4413      	add	r3, r2
 801e970:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801e974:	4413      	add	r3, r2
 801e976:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 801e97a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e97e:	f643 721a 	movw	r2, #16154	; 0x3f1a
 801e982:	fb02 f203 	mul.w	r2, r2, r3
 801e986:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e98a:	4413      	add	r3, r2
 801e98c:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801e990:	4413      	add	r3, r2
 801e992:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    z2    += z4;
 801e996:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801e99a:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e99e:	4413      	add	r3, r2
 801e9a0:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 801e9a4:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e9a8:	4a5d      	ldr	r2, [pc, #372]	; (801eb20 <jpeg_idct_16x16+0x574>)
 801e9aa:	fb02 f303 	mul.w	r3, r2, r3
 801e9ae:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1  += z1;
 801e9b2:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801e9b6:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e9ba:	4413      	add	r3, r2
 801e9bc:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 801e9c0:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e9c4:	f242 2218 	movw	r2, #8728	; 0x2218
 801e9c8:	fb02 f203 	mul.w	r2, r2, r3
 801e9cc:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801e9d0:	4413      	add	r3, r2
 801e9d2:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801e9d6:	4413      	add	r3, r2
 801e9d8:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 801e9dc:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e9e0:	4a50      	ldr	r2, [pc, #320]	; (801eb24 <jpeg_idct_16x16+0x578>)
 801e9e2:	fb02 f303 	mul.w	r3, r2, r3
 801e9e6:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 801e9ea:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801e9ee:	f246 4285 	movw	r2, #25733	; 0x6485
 801e9f2:	fb02 f203 	mul.w	r2, r2, r3
 801e9f6:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801e9fa:	4413      	add	r3, r2
 801e9fc:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801ea00:	4413      	add	r3, r2
 801ea02:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp12 += z2;
 801ea06:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801ea0a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ea0e:	4413      	add	r3, r2
 801ea10:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 801ea14:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801ea18:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801ea1c:	4413      	add	r3, r2
 801ea1e:	4a42      	ldr	r2, [pc, #264]	; (801eb28 <jpeg_idct_16x16+0x57c>)
 801ea20:	fb02 f303 	mul.w	r3, r2, r3
 801ea24:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp2  += z2;
 801ea28:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 801ea2c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ea30:	4413      	add	r3, r2
 801ea32:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  += z2;
 801ea36:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801ea3a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ea3e:	4413      	add	r3, r2
 801ea40:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 801ea44:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801ea48:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ea4c:	1ad3      	subs	r3, r2, r3
 801ea4e:	f640 5223 	movw	r2, #3363	; 0xd23
 801ea52:	fb02 f303 	mul.w	r3, r2, r3
 801ea56:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp10 += z2;
 801ea5a:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801ea5e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ea62:	4413      	add	r3, r2
 801ea64:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 += z2;
 801ea68:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801ea6c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ea70:	4413      	add	r3, r2
 801ea72:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 801ea76:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801ea7a:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801ea7e:	4413      	add	r3, r2
 801ea80:	12da      	asrs	r2, r3, #11
 801ea82:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ea86:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 801ea88:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801ea8c:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801ea90:	1ad2      	subs	r2, r2, r3
 801ea92:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ea96:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
 801ea9a:	12d2      	asrs	r2, r2, #11
 801ea9c:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 801ea9e:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801eaa2:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801eaa6:	441a      	add	r2, r3
 801eaa8:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eaac:	3320      	adds	r3, #32
 801eaae:	12d2      	asrs	r2, r2, #11
 801eab0:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 801eab2:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801eab6:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801eaba:	1ad2      	subs	r2, r2, r3
 801eabc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eac0:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 801eac4:	12d2      	asrs	r2, r2, #11
 801eac6:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 801eac8:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801eacc:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801ead0:	441a      	add	r2, r3
 801ead2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ead6:	3340      	adds	r3, #64	; 0x40
 801ead8:	12d2      	asrs	r2, r2, #11
 801eada:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 801eadc:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801eae0:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801eae4:	1ad2      	subs	r2, r2, r3
 801eae6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eaea:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 801eaee:	12d2      	asrs	r2, r2, #11
 801eaf0:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 801eaf2:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801eaf6:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801eafa:	441a      	add	r2, r3
 801eafc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb00:	3360      	adds	r3, #96	; 0x60
 801eb02:	12d2      	asrs	r2, r2, #11
 801eb04:	e012      	b.n	801eb2c <jpeg_idct_16x16+0x580>
 801eb06:	bf00      	nop
 801eb08:	ffffecc2 	.word	0xffffecc2
 801eb0c:	ffffefb0 	.word	0xffffefb0
 801eb10:	ffffb6d6 	.word	0xffffb6d6
 801eb14:	ffffc542 	.word	0xffffc542
 801eb18:	ffffdbfa 	.word	0xffffdbfa
 801eb1c:	ffffe77a 	.word	0xffffe77a
 801eb20:	ffffeaab 	.word	0xffffeaab
 801eb24:	ffffd817 	.word	0xffffd817
 801eb28:	ffffd4b2 	.word	0xffffd4b2
 801eb2c:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 801eb2e:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801eb32:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801eb36:	1ad2      	subs	r2, r2, r3
 801eb38:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb3c:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 801eb40:	12d2      	asrs	r2, r2, #11
 801eb42:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 801eb44:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801eb48:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801eb4c:	441a      	add	r2, r3
 801eb4e:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb52:	3380      	adds	r3, #128	; 0x80
 801eb54:	12d2      	asrs	r2, r2, #11
 801eb56:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 801eb58:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801eb5c:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801eb60:	1ad2      	subs	r2, r2, r3
 801eb62:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb66:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 801eb6a:	12d2      	asrs	r2, r2, #11
 801eb6c:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 801eb6e:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801eb72:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801eb76:	441a      	add	r2, r3
 801eb78:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb7c:	33a0      	adds	r3, #160	; 0xa0
 801eb7e:	12d2      	asrs	r2, r2, #11
 801eb80:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 801eb82:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801eb86:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801eb8a:	1ad2      	subs	r2, r2, r3
 801eb8c:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eb90:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 801eb94:	12d2      	asrs	r2, r2, #11
 801eb96:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 801eb98:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801eb9c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801eba0:	441a      	add	r2, r3
 801eba2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801eba6:	33c0      	adds	r3, #192	; 0xc0
 801eba8:	12d2      	asrs	r2, r2, #11
 801ebaa:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 801ebac:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801ebb0:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801ebb4:	1ad2      	subs	r2, r2, r3
 801ebb6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ebba:	f503 7390 	add.w	r3, r3, #288	; 0x120
 801ebbe:	12d2      	asrs	r2, r2, #11
 801ebc0:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 801ebc2:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801ebc6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ebca:	441a      	add	r2, r3
 801ebcc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ebd0:	33e0      	adds	r3, #224	; 0xe0
 801ebd2:	12d2      	asrs	r2, r2, #11
 801ebd4:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 801ebd6:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801ebda:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ebde:	1ad2      	subs	r2, r2, r3
 801ebe0:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ebe4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801ebe8:	12d2      	asrs	r2, r2, #11
 801ebea:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801ebec:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 801ebf0:	3301      	adds	r3, #1
 801ebf2:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 801ebf6:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 801ebfa:	3302      	adds	r3, #2
 801ebfc:	f8c7 3274 	str.w	r3, [r7, #628]	; 0x274
 801ec00:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 801ec04:	3304      	adds	r3, #4
 801ec06:	f8c7 3270 	str.w	r3, [r7, #624]	; 0x270
 801ec0a:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ec0e:	3304      	adds	r3, #4
 801ec10:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
 801ec14:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 801ec18:	2b07      	cmp	r3, #7
 801ec1a:	f77f acef 	ble.w	801e5fc <jpeg_idct_16x16+0x50>
  }

  /* Pass 2: process 16 rows from work array, store into output array. */

  wsptr = workspace;
 801ec1e:	f107 0310 	add.w	r3, r7, #16
 801ec22:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 801ec26:	2300      	movs	r3, #0
 801ec28:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 801ec2c:	e320      	b.n	801f270 <jpeg_idct_16x16+0xcc4>
    outptr = output_buf[ctr] + output_col;
 801ec2e:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 801ec32:	009b      	lsls	r3, r3, #2
 801ec34:	463a      	mov	r2, r7
 801ec36:	6812      	ldr	r2, [r2, #0]
 801ec38:	4413      	add	r3, r2
 801ec3a:	681a      	ldr	r2, [r3, #0]
 801ec3c:	f8d7 3280 	ldr.w	r3, [r7, #640]	; 0x280
 801ec40:	4413      	add	r3, r2
 801ec42:	f8c7 3260 	str.w	r3, [r7, #608]	; 0x260

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801ec46:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ec4a:	681b      	ldr	r3, [r3, #0]
 801ec4c:	3310      	adds	r3, #16
 801ec4e:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp0 <<= CONST_BITS;
 801ec52:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801ec56:	035b      	lsls	r3, r3, #13
 801ec58:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c

    z1 = (INT32) wsptr[4];
 801ec5c:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ec60:	3310      	adds	r3, #16
 801ec62:	681b      	ldr	r3, [r3, #0]
 801ec64:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 801ec68:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ec6c:	f642 12cf 	movw	r2, #10703	; 0x29cf
 801ec70:	fb02 f303 	mul.w	r3, r2, r3
 801ec74:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 801ec78:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ec7c:	f241 1251 	movw	r2, #4433	; 0x1151
 801ec80:	fb02 f303 	mul.w	r3, r2, r3
 801ec84:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250

    tmp10 = tmp0 + tmp1;
 801ec88:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801ec8c:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801ec90:	4413      	add	r3, r2
 801ec92:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 = tmp0 - tmp1;
 801ec96:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801ec9a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801ec9e:	1ad3      	subs	r3, r2, r3
 801eca0:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 = tmp0 + tmp2;
 801eca4:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801eca8:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801ecac:	4413      	add	r3, r2
 801ecae:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp13 = tmp0 - tmp2;
 801ecb2:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 801ecb6:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801ecba:	1ad3      	subs	r3, r2, r3
 801ecbc:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240

    z1 = (INT32) wsptr[2];
 801ecc0:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ecc4:	3308      	adds	r3, #8
 801ecc6:	681b      	ldr	r3, [r3, #0]
 801ecc8:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z2 = (INT32) wsptr[6];
 801eccc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ecd0:	3318      	adds	r3, #24
 801ecd2:	681b      	ldr	r3, [r3, #0]
 801ecd4:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z3 = z1 - z2;
 801ecd8:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801ecdc:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ece0:	1ad3      	subs	r3, r2, r3
 801ece2:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 801ece6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ecea:	f640 02d4 	movw	r2, #2260	; 0x8d4
 801ecee:	fb02 f303 	mul.w	r3, r2, r3
 801ecf2:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 801ecf6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ecfa:	f642 4263 	movw	r2, #11363	; 0x2c63
 801ecfe:	fb02 f303 	mul.w	r3, r2, r3
 801ed02:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 801ed06:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ed0a:	f245 2203 	movw	r2, #20995	; 0x5203
 801ed0e:	fb02 f303 	mul.w	r3, r2, r3
 801ed12:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801ed16:	4413      	add	r3, r2
 801ed18:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 801ed1c:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ed20:	f641 42cd 	movw	r2, #7373	; 0x1ccd
 801ed24:	fb02 f303 	mul.w	r3, r2, r3
 801ed28:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801ed2c:	4413      	add	r3, r2
 801ed2e:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 801ed32:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ed36:	4af4      	ldr	r2, [pc, #976]	; (801f108 <jpeg_idct_16x16+0xb5c>)
 801ed38:	fb02 f303 	mul.w	r3, r2, r3
 801ed3c:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801ed40:	4413      	add	r3, r2
 801ed42:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 801ed46:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ed4a:	4af0      	ldr	r2, [pc, #960]	; (801f10c <jpeg_idct_16x16+0xb60>)
 801ed4c:	fb02 f303 	mul.w	r3, r2, r3
 801ed50:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801ed54:	4413      	add	r3, r2
 801ed56:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp20 = tmp10 + tmp0;
 801ed5a:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801ed5e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801ed62:	4413      	add	r3, r2
 801ed64:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp27 = tmp10 - tmp0;
 801ed68:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801ed6c:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801ed70:	1ad3      	subs	r3, r2, r3
 801ed72:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp21 = tmp12 + tmp1;
 801ed76:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801ed7a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801ed7e:	4413      	add	r3, r2
 801ed80:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    tmp26 = tmp12 - tmp1;
 801ed84:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801ed88:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801ed8c:	1ad3      	subs	r3, r2, r3
 801ed8e:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp22 = tmp13 + tmp2;
 801ed92:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801ed96:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801ed9a:	4413      	add	r3, r2
 801ed9c:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    tmp25 = tmp13 - tmp2;
 801eda0:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801eda4:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801eda8:	1ad3      	subs	r3, r2, r3
 801edaa:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    tmp23 = tmp11 + tmp3;
 801edae:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801edb2:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801edb6:	4413      	add	r3, r2
 801edb8:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp24 = tmp11 - tmp3;
 801edbc:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801edc0:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801edc4:	1ad3      	subs	r3, r2, r3
 801edc6:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801edca:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801edce:	3304      	adds	r3, #4
 801edd0:	681b      	ldr	r3, [r3, #0]
 801edd2:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z2 = (INT32) wsptr[3];
 801edd6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801edda:	330c      	adds	r3, #12
 801eddc:	681b      	ldr	r3, [r3, #0]
 801edde:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z3 = (INT32) wsptr[5];
 801ede2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801ede6:	3314      	adds	r3, #20
 801ede8:	681b      	ldr	r3, [r3, #0]
 801edea:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    z4 = (INT32) wsptr[7];
 801edee:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801edf2:	331c      	adds	r3, #28
 801edf4:	681b      	ldr	r3, [r3, #0]
 801edf6:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234

    tmp11 = z1 + z3;
 801edfa:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801edfe:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ee02:	4413      	add	r3, r2
 801ee04:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 801ee08:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801ee0c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ee10:	4413      	add	r3, r2
 801ee12:	f642 324e 	movw	r2, #11086	; 0x2b4e
 801ee16:	fb02 f303 	mul.w	r3, r2, r3
 801ee1a:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 801ee1e:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801ee22:	f242 72e9 	movw	r2, #10217	; 0x27e9
 801ee26:	fb02 f303 	mul.w	r3, r2, r3
 801ee2a:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 801ee2e:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801ee32:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801ee36:	4413      	add	r3, r2
 801ee38:	f242 22fc 	movw	r2, #8956	; 0x22fc
 801ee3c:	fb02 f303 	mul.w	r3, r2, r3
 801ee40:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 801ee44:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801ee48:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801ee4c:	1ad3      	subs	r3, r2, r3
 801ee4e:	f641 42b6 	movw	r2, #7350	; 0x1cb6
 801ee52:	fb02 f303 	mul.w	r3, r2, r3
 801ee56:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 801ee5a:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801ee5e:	f241 5255 	movw	r2, #5461	; 0x1555
 801ee62:	fb02 f303 	mul.w	r3, r2, r3
 801ee66:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 801ee6a:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 801ee6e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ee72:	1ad3      	subs	r3, r2, r3
 801ee74:	f640 5223 	movw	r2, #3363	; 0xd23
 801ee78:	fb02 f303 	mul.w	r3, r2, r3
 801ee7c:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp0  = tmp1 + tmp2 + tmp3 -
 801ee80:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801ee84:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801ee88:	441a      	add	r2, r3
 801ee8a:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801ee8e:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 801ee90:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ee94:	499e      	ldr	r1, [pc, #632]	; (801f110 <jpeg_idct_16x16+0xb64>)
 801ee96:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 801ee9a:	4413      	add	r3, r2
 801ee9c:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp13 = tmp10 + tmp11 + tmp12 -
 801eea0:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801eea4:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801eea8:	441a      	add	r2, r3
 801eeaa:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801eeae:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 801eeb0:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801eeb4:	4997      	ldr	r1, [pc, #604]	; (801f114 <jpeg_idct_16x16+0xb68>)
 801eeb6:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 801eeba:	4413      	add	r3, r2
 801eebc:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 801eec0:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801eec4:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801eec8:	4413      	add	r3, r2
 801eeca:	f44f 628e 	mov.w	r2, #1136	; 0x470
 801eece:	fb02 f303 	mul.w	r3, r2, r3
 801eed2:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 801eed6:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801eeda:	f240 224d 	movw	r2, #589	; 0x24d
 801eede:	fb02 f203 	mul.w	r2, r2, r3
 801eee2:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801eee6:	4413      	add	r3, r2
 801eee8:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801eeec:	4413      	add	r3, r2
 801eeee:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 801eef2:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801eef6:	4a88      	ldr	r2, [pc, #544]	; (801f118 <jpeg_idct_16x16+0xb6c>)
 801eef8:	fb02 f203 	mul.w	r2, r2, r3
 801eefc:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ef00:	4413      	add	r3, r2
 801ef02:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 801ef06:	4413      	add	r3, r2
 801ef08:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 801ef0c:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801ef10:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ef14:	1ad3      	subs	r3, r2, r3
 801ef16:	f642 5209 	movw	r2, #11529	; 0x2d09
 801ef1a:	fb02 f303 	mul.w	r3, r2, r3
 801ef1e:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 801ef22:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ef26:	4a7d      	ldr	r2, [pc, #500]	; (801f11c <jpeg_idct_16x16+0xb70>)
 801ef28:	fb02 f203 	mul.w	r2, r2, r3
 801ef2c:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ef30:	4413      	add	r3, r2
 801ef32:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801ef36:	4413      	add	r3, r2
 801ef38:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 801ef3c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ef40:	f643 721a 	movw	r2, #16154	; 0x3f1a
 801ef44:	fb02 f203 	mul.w	r2, r2, r3
 801ef48:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ef4c:	4413      	add	r3, r2
 801ef4e:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801ef52:	4413      	add	r3, r2
 801ef54:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    z2    += z4;
 801ef58:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801ef5c:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801ef60:	4413      	add	r3, r2
 801ef62:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 801ef66:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801ef6a:	4a6d      	ldr	r2, [pc, #436]	; (801f120 <jpeg_idct_16x16+0xb74>)
 801ef6c:	fb02 f303 	mul.w	r3, r2, r3
 801ef70:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    tmp1  += z1;
 801ef74:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 801ef78:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ef7c:	4413      	add	r3, r2
 801ef7e:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 801ef82:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801ef86:	f242 2218 	movw	r2, #8728	; 0x2218
 801ef8a:	fb02 f203 	mul.w	r2, r2, r3
 801ef8e:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 801ef92:	4413      	add	r3, r2
 801ef94:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801ef98:	4413      	add	r3, r2
 801ef9a:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 801ef9e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801efa2:	4a60      	ldr	r2, [pc, #384]	; (801f124 <jpeg_idct_16x16+0xb78>)
 801efa4:	fb02 f303 	mul.w	r3, r2, r3
 801efa8:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 801efac:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801efb0:	f246 4285 	movw	r2, #25733	; 0x6485
 801efb4:	fb02 f203 	mul.w	r2, r2, r3
 801efb8:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801efbc:	4413      	add	r3, r2
 801efbe:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801efc2:	4413      	add	r3, r2
 801efc4:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp12 += z2;
 801efc8:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 801efcc:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801efd0:	4413      	add	r3, r2
 801efd2:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 801efd6:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 801efda:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801efde:	4413      	add	r3, r2
 801efe0:	4a51      	ldr	r2, [pc, #324]	; (801f128 <jpeg_idct_16x16+0xb7c>)
 801efe2:	fb02 f303 	mul.w	r3, r2, r3
 801efe6:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp2  += z2;
 801efea:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 801efee:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801eff2:	4413      	add	r3, r2
 801eff4:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  += z2;
 801eff8:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801effc:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801f000:	4413      	add	r3, r2
 801f002:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 801f006:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801f00a:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801f00e:	1ad3      	subs	r3, r2, r3
 801f010:	f640 5223 	movw	r2, #3363	; 0xd23
 801f014:	fb02 f303 	mul.w	r3, r2, r3
 801f018:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp10 += z2;
 801f01c:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801f020:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801f024:	4413      	add	r3, r2
 801f026:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp11 += z2;
 801f02a:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801f02e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 801f032:	4413      	add	r3, r2
 801f034:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 801f038:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801f03c:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801f040:	4413      	add	r3, r2
 801f042:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f044:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 801f048:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f04c:	4413      	add	r3, r2
 801f04e:	781a      	ldrb	r2, [r3, #0]
 801f050:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f054:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 801f056:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801f05a:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 801f05e:	1ad3      	subs	r3, r2, r3
 801f060:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f062:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 801f066:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f06a:	441a      	add	r2, r3
 801f06c:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f070:	330f      	adds	r3, #15
 801f072:	7812      	ldrb	r2, [r2, #0]
 801f074:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 801f076:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801f07a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801f07e:	4413      	add	r3, r2
 801f080:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f082:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 801f086:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f08a:	441a      	add	r2, r3
 801f08c:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f090:	3301      	adds	r3, #1
 801f092:	7812      	ldrb	r2, [r2, #0]
 801f094:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 801f096:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801f09a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 801f09e:	1ad3      	subs	r3, r2, r3
 801f0a0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f0a2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 801f0a6:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f0aa:	441a      	add	r2, r3
 801f0ac:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f0b0:	330e      	adds	r3, #14
 801f0b2:	7812      	ldrb	r2, [r2, #0]
 801f0b4:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 801f0b6:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801f0ba:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801f0be:	4413      	add	r3, r2
 801f0c0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f0c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 801f0c6:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f0ca:	441a      	add	r2, r3
 801f0cc:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f0d0:	3302      	adds	r3, #2
 801f0d2:	7812      	ldrb	r2, [r2, #0]
 801f0d4:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 801f0d6:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801f0da:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 801f0de:	1ad3      	subs	r3, r2, r3
 801f0e0:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f0e2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 801f0e6:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f0ea:	441a      	add	r2, r3
 801f0ec:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f0f0:	330d      	adds	r3, #13
 801f0f2:	7812      	ldrb	r2, [r2, #0]
 801f0f4:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 801f0f6:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801f0fa:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801f0fe:	4413      	add	r3, r2
 801f100:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f102:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801f106:	e011      	b.n	801f12c <jpeg_idct_16x16+0xb80>
 801f108:	ffffecc2 	.word	0xffffecc2
 801f10c:	ffffefb0 	.word	0xffffefb0
 801f110:	ffffb6d6 	.word	0xffffb6d6
 801f114:	ffffc542 	.word	0xffffc542
 801f118:	ffffdbfa 	.word	0xffffdbfa
 801f11c:	ffffe77a 	.word	0xffffe77a
 801f120:	ffffeaab 	.word	0xffffeaab
 801f124:	ffffd817 	.word	0xffffd817
 801f128:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 801f12c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f130:	441a      	add	r2, r3
 801f132:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f136:	3303      	adds	r3, #3
 801f138:	7812      	ldrb	r2, [r2, #0]
 801f13a:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 801f13c:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801f140:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801f144:	1ad3      	subs	r3, r2, r3
 801f146:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f148:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 801f14c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f150:	441a      	add	r2, r3
 801f152:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f156:	330c      	adds	r3, #12
 801f158:	7812      	ldrb	r2, [r2, #0]
 801f15a:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 801f15c:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801f160:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801f164:	4413      	add	r3, r2
 801f166:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f168:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 801f16c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f170:	441a      	add	r2, r3
 801f172:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f176:	3304      	adds	r3, #4
 801f178:	7812      	ldrb	r2, [r2, #0]
 801f17a:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 801f17c:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801f180:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801f184:	1ad3      	subs	r3, r2, r3
 801f186:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f188:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 801f18c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f190:	441a      	add	r2, r3
 801f192:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f196:	330b      	adds	r3, #11
 801f198:	7812      	ldrb	r2, [r2, #0]
 801f19a:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 801f19c:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801f1a0:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801f1a4:	4413      	add	r3, r2
 801f1a6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f1a8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 801f1ac:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f1b0:	441a      	add	r2, r3
 801f1b2:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f1b6:	3305      	adds	r3, #5
 801f1b8:	7812      	ldrb	r2, [r2, #0]
 801f1ba:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 801f1bc:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801f1c0:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 801f1c4:	1ad3      	subs	r3, r2, r3
 801f1c6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f1c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 801f1cc:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f1d0:	441a      	add	r2, r3
 801f1d2:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f1d6:	330a      	adds	r3, #10
 801f1d8:	7812      	ldrb	r2, [r2, #0]
 801f1da:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 801f1dc:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801f1e0:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801f1e4:	4413      	add	r3, r2
 801f1e6:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f1e8:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 801f1ec:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f1f0:	441a      	add	r2, r3
 801f1f2:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f1f6:	3306      	adds	r3, #6
 801f1f8:	7812      	ldrb	r2, [r2, #0]
 801f1fa:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 801f1fc:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 801f200:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801f204:	1ad3      	subs	r3, r2, r3
 801f206:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f208:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 801f20c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f210:	441a      	add	r2, r3
 801f212:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f216:	3309      	adds	r3, #9
 801f218:	7812      	ldrb	r2, [r2, #0]
 801f21a:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 801f21c:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801f220:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801f224:	4413      	add	r3, r2
 801f226:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f228:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 801f22c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f230:	441a      	add	r2, r3
 801f232:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f236:	3307      	adds	r3, #7
 801f238:	7812      	ldrb	r2, [r2, #0]
 801f23a:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 801f23c:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801f240:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801f244:	1ad3      	subs	r3, r2, r3
 801f246:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801f248:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 801f24c:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 801f250:	441a      	add	r2, r3
 801f252:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 801f256:	3308      	adds	r3, #8
 801f258:	7812      	ldrb	r2, [r2, #0]
 801f25a:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801f25c:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 801f260:	3320      	adds	r3, #32
 801f262:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 801f266:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 801f26a:	3301      	adds	r3, #1
 801f26c:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 801f270:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 801f274:	2b0f      	cmp	r3, #15
 801f276:	f77f acda 	ble.w	801ec2e <jpeg_idct_16x16+0x682>
  }
}
 801f27a:	bf00      	nop
 801f27c:	bf00      	nop
 801f27e:	f507 771e 	add.w	r7, r7, #632	; 0x278
 801f282:	46bd      	mov	sp, r7
 801f284:	bc90      	pop	{r4, r7}
 801f286:	4770      	bx	lr

0801f288 <jpeg_idct_16x8>:

GLOBAL(void)
jpeg_idct_16x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801f288:	b490      	push	{r4, r7}
 801f28a:	b0e0      	sub	sp, #384	; 0x180
 801f28c:	af00      	add	r7, sp, #0
 801f28e:	f107 040c 	add.w	r4, r7, #12
 801f292:	6020      	str	r0, [r4, #0]
 801f294:	f107 0008 	add.w	r0, r7, #8
 801f298:	6001      	str	r1, [r0, #0]
 801f29a:	1d39      	adds	r1, r7, #4
 801f29c:	600a      	str	r2, [r1, #0]
 801f29e:	463a      	mov	r2, r7
 801f2a0:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801f2a2:	f107 030c 	add.w	r3, r7, #12
 801f2a6:	681b      	ldr	r3, [r3, #0]
 801f2a8:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801f2ac:	3380      	adds	r3, #128	; 0x80
 801f2ae:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 801f2b2:	1d3b      	adds	r3, r7, #4
 801f2b4:	681b      	ldr	r3, [r3, #0]
 801f2b6:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801f2ba:	f107 0308 	add.w	r3, r7, #8
 801f2be:	681b      	ldr	r3, [r3, #0]
 801f2c0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801f2c2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
  wsptr = workspace;
 801f2c6:	f107 0314 	add.w	r3, r7, #20
 801f2ca:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801f2ce:	2308      	movs	r3, #8
 801f2d0:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801f2d4:	e238      	b.n	801f748 <jpeg_idct_16x8+0x4c0>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */
    
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f2d6:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f2da:	3310      	adds	r3, #16
 801f2dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f2e0:	2b00      	cmp	r3, #0
 801f2e2:	d175      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
 801f2e4:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f2e8:	3320      	adds	r3, #32
 801f2ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f2ee:	2b00      	cmp	r3, #0
 801f2f0:	d16e      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f2f2:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f2f6:	3330      	adds	r3, #48	; 0x30
 801f2f8:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 801f2fc:	2b00      	cmp	r3, #0
 801f2fe:	d167      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f300:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f304:	3340      	adds	r3, #64	; 0x40
 801f306:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f30a:	2b00      	cmp	r3, #0
 801f30c:	d160      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f30e:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f312:	3350      	adds	r3, #80	; 0x50
 801f314:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 801f318:	2b00      	cmp	r3, #0
 801f31a:	d159      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f31c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f320:	3360      	adds	r3, #96	; 0x60
 801f322:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f326:	2b00      	cmp	r3, #0
 801f328:	d152      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
	inptr[DCTSIZE*7] == 0) {
 801f32a:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f32e:	3370      	adds	r3, #112	; 0x70
 801f330:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 801f334:	2b00      	cmp	r3, #0
 801f336:	d14b      	bne.n	801f3d0 <jpeg_idct_16x8+0x148>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 801f338:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f33c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f340:	461a      	mov	r2, r3
 801f342:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f346:	681b      	ldr	r3, [r3, #0]
 801f348:	fb03 f302 	mul.w	r3, r3, r2
 801f34c:	009b      	lsls	r3, r3, #2
 801f34e:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
      
      wsptr[DCTSIZE*0] = dcval;
 801f352:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f356:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f35a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*1] = dcval;
 801f35c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f360:	3320      	adds	r3, #32
 801f362:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f366:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*2] = dcval;
 801f368:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f36c:	3340      	adds	r3, #64	; 0x40
 801f36e:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f372:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*3] = dcval;
 801f374:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f378:	3360      	adds	r3, #96	; 0x60
 801f37a:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f37e:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*4] = dcval;
 801f380:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f384:	3380      	adds	r3, #128	; 0x80
 801f386:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f38a:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*5] = dcval;
 801f38c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f390:	33a0      	adds	r3, #160	; 0xa0
 801f392:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f396:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*6] = dcval;
 801f398:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f39c:	33c0      	adds	r3, #192	; 0xc0
 801f39e:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f3a2:	601a      	str	r2, [r3, #0]
      wsptr[DCTSIZE*7] = dcval;
 801f3a4:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f3a8:	33e0      	adds	r3, #224	; 0xe0
 801f3aa:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 801f3ae:	601a      	str	r2, [r3, #0]
      
      inptr++;			/* advance pointers to next column */
 801f3b0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f3b4:	3302      	adds	r3, #2
 801f3b6:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
      quantptr++;
 801f3ba:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f3be:	3304      	adds	r3, #4
 801f3c0:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
      wsptr++;
 801f3c4:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f3c8:	3304      	adds	r3, #4
 801f3ca:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
      continue;
 801f3ce:	e1b6      	b.n	801f73e <jpeg_idct_16x8+0x4b6>
    }
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801f3d0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f3d4:	3320      	adds	r3, #32
 801f3d6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f3da:	461a      	mov	r2, r3
 801f3dc:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f3e0:	3340      	adds	r3, #64	; 0x40
 801f3e2:	681b      	ldr	r3, [r3, #0]
 801f3e4:	fb03 f302 	mul.w	r3, r3, r2
 801f3e8:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801f3ec:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f3f0:	3360      	adds	r3, #96	; 0x60
 801f3f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f3f6:	461a      	mov	r2, r3
 801f3f8:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f3fc:	33c0      	adds	r3, #192	; 0xc0
 801f3fe:	681b      	ldr	r3, [r3, #0]
 801f400:	fb03 f302 	mul.w	r3, r3, r2
 801f404:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 801f408:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801f40c:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f410:	4413      	add	r3, r2
 801f412:	f241 1251 	movw	r2, #4433	; 0x1151
 801f416:	fb02 f303 	mul.w	r3, r2, r3
 801f41a:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 801f41e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f422:	f641 027e 	movw	r2, #6270	; 0x187e
 801f426:	fb02 f303 	mul.w	r3, r2, r3
 801f42a:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f42e:	4413      	add	r3, r2
 801f430:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 801f434:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f438:	4aca      	ldr	r2, [pc, #808]	; (801f764 <jpeg_idct_16x8+0x4dc>)
 801f43a:	fb02 f303 	mul.w	r3, r2, r3
 801f43e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f442:	4413      	add	r3, r2
 801f444:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801f448:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f44c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f450:	461a      	mov	r2, r3
 801f452:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f456:	681b      	ldr	r3, [r3, #0]
 801f458:	fb03 f302 	mul.w	r3, r3, r2
 801f45c:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801f460:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f464:	3340      	adds	r3, #64	; 0x40
 801f466:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f46a:	461a      	mov	r2, r3
 801f46c:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f470:	3380      	adds	r3, #128	; 0x80
 801f472:	681b      	ldr	r3, [r3, #0]
 801f474:	fb03 f302 	mul.w	r3, r3, r2
 801f478:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z2 <<= CONST_BITS;
 801f47c:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f480:	035b      	lsls	r3, r3, #13
 801f482:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 <<= CONST_BITS;
 801f486:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f48a:	035b      	lsls	r3, r3, #13
 801f48c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 801f490:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f494:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801f498:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    tmp0 = z2 + z3;
 801f49c:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801f4a0:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f4a4:	4413      	add	r3, r2
 801f4a6:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp1 = z2 - z3;
 801f4aa:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801f4ae:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f4b2:	1ad3      	subs	r3, r2, r3
 801f4b4:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    
    tmp10 = tmp0 + tmp2;
 801f4b8:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f4bc:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f4c0:	4413      	add	r3, r2
 801f4c2:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp13 = tmp0 - tmp2;
 801f4c6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f4ca:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f4ce:	1ad3      	subs	r3, r2, r3
 801f4d0:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    tmp11 = tmp1 + tmp3;
 801f4d4:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f4d8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f4dc:	4413      	add	r3, r2
 801f4de:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 = tmp1 - tmp3;
 801f4e2:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f4e6:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f4ea:	1ad3      	subs	r3, r2, r3
 801f4ec:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 801f4f0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f4f4:	3370      	adds	r3, #112	; 0x70
 801f4f6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f4fa:	461a      	mov	r2, r3
 801f4fc:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f500:	33e0      	adds	r3, #224	; 0xe0
 801f502:	681b      	ldr	r3, [r3, #0]
 801f504:	fb03 f302 	mul.w	r3, r3, r2
 801f508:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801f50c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f510:	3350      	adds	r3, #80	; 0x50
 801f512:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f516:	461a      	mov	r2, r3
 801f518:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f51c:	33a0      	adds	r3, #160	; 0xa0
 801f51e:	681b      	ldr	r3, [r3, #0]
 801f520:	fb03 f302 	mul.w	r3, r3, r2
 801f524:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801f528:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f52c:	3330      	adds	r3, #48	; 0x30
 801f52e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f532:	461a      	mov	r2, r3
 801f534:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f538:	3360      	adds	r3, #96	; 0x60
 801f53a:	681b      	ldr	r3, [r3, #0]
 801f53c:	fb03 f302 	mul.w	r3, r3, r2
 801f540:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801f544:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f548:	3310      	adds	r3, #16
 801f54a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f54e:	461a      	mov	r2, r3
 801f550:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f554:	3320      	adds	r3, #32
 801f556:	681b      	ldr	r3, [r3, #0]
 801f558:	fb03 f302 	mul.w	r3, r3, r2
 801f55c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    
    z2 = tmp0 + tmp2;
 801f560:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f564:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f568:	4413      	add	r3, r2
 801f56a:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = tmp1 + tmp3;
 801f56e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f572:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f576:	4413      	add	r3, r2
 801f578:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 801f57c:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801f580:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f584:	4413      	add	r3, r2
 801f586:	f242 52a1 	movw	r2, #9633	; 0x25a1
 801f58a:	fb02 f303 	mul.w	r3, r2, r3
 801f58e:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 801f592:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f596:	4a74      	ldr	r2, [pc, #464]	; (801f768 <jpeg_idct_16x8+0x4e0>)
 801f598:	fb02 f303 	mul.w	r3, r2, r3
 801f59c:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 801f5a0:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f5a4:	4a71      	ldr	r2, [pc, #452]	; (801f76c <jpeg_idct_16x8+0x4e4>)
 801f5a6:	fb02 f303 	mul.w	r3, r2, r3
 801f5aa:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z2 += z1;
 801f5ae:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801f5b2:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f5b6:	4413      	add	r3, r2
 801f5b8:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 += z1;
 801f5bc:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801f5c0:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f5c4:	4413      	add	r3, r2
 801f5c6:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 801f5ca:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f5ce:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f5d2:	4413      	add	r3, r2
 801f5d4:	4a66      	ldr	r2, [pc, #408]	; (801f770 <jpeg_idct_16x8+0x4e8>)
 801f5d6:	fb02 f303 	mul.w	r3, r2, r3
 801f5da:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 801f5de:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f5e2:	f640 128e 	movw	r2, #2446	; 0x98e
 801f5e6:	fb02 f303 	mul.w	r3, r2, r3
 801f5ea:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 801f5ee:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f5f2:	f243 020b 	movw	r2, #12299	; 0x300b
 801f5f6:	fb02 f303 	mul.w	r3, r2, r3
 801f5fa:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp0 += z1 + z2;
 801f5fe:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f602:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f606:	4413      	add	r3, r2
 801f608:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f60c:	4413      	add	r3, r2
 801f60e:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp3 += z1 + z3;
 801f612:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f616:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f61a:	4413      	add	r3, r2
 801f61c:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801f620:	4413      	add	r3, r2
 801f622:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 801f626:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f62a:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f62e:	4413      	add	r3, r2
 801f630:	4a50      	ldr	r2, [pc, #320]	; (801f774 <jpeg_idct_16x8+0x4ec>)
 801f632:	fb02 f303 	mul.w	r3, r2, r3
 801f636:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 801f63a:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f63e:	f244 12b3 	movw	r2, #16819	; 0x41b3
 801f642:	fb02 f303 	mul.w	r3, r2, r3
 801f646:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 801f64a:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f64e:	f246 2254 	movw	r2, #25172	; 0x6254
 801f652:	fb02 f303 	mul.w	r3, r2, r3
 801f656:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp1 += z1 + z3;
 801f65a:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f65e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f662:	4413      	add	r3, r2
 801f664:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f668:	4413      	add	r3, r2
 801f66a:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2 += z1 + z2;
 801f66e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f672:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f676:	4413      	add	r3, r2
 801f678:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801f67c:	4413      	add	r3, r2
 801f67e:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    wsptr[DCTSIZE*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 801f682:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801f686:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f68a:	4413      	add	r3, r2
 801f68c:	12da      	asrs	r2, r3, #11
 801f68e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f692:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 801f694:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801f698:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f69c:	1ad2      	subs	r2, r2, r3
 801f69e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f6a2:	33e0      	adds	r3, #224	; 0xe0
 801f6a4:	12d2      	asrs	r2, r2, #11
 801f6a6:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 801f6a8:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801f6ac:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f6b0:	441a      	add	r2, r3
 801f6b2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f6b6:	3320      	adds	r3, #32
 801f6b8:	12d2      	asrs	r2, r2, #11
 801f6ba:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 801f6bc:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801f6c0:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f6c4:	1ad2      	subs	r2, r2, r3
 801f6c6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f6ca:	33c0      	adds	r3, #192	; 0xc0
 801f6cc:	12d2      	asrs	r2, r2, #11
 801f6ce:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 801f6d0:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801f6d4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f6d8:	441a      	add	r2, r3
 801f6da:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f6de:	3340      	adds	r3, #64	; 0x40
 801f6e0:	12d2      	asrs	r2, r2, #11
 801f6e2:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 801f6e4:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801f6e8:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f6ec:	1ad2      	subs	r2, r2, r3
 801f6ee:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f6f2:	33a0      	adds	r3, #160	; 0xa0
 801f6f4:	12d2      	asrs	r2, r2, #11
 801f6f6:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 801f6f8:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801f6fc:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f700:	441a      	add	r2, r3
 801f702:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f706:	3360      	adds	r3, #96	; 0x60
 801f708:	12d2      	asrs	r2, r2, #11
 801f70a:	601a      	str	r2, [r3, #0]
    wsptr[DCTSIZE*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 801f70c:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801f710:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f714:	1ad2      	subs	r2, r2, r3
 801f716:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f71a:	3380      	adds	r3, #128	; 0x80
 801f71c:	12d2      	asrs	r2, r2, #11
 801f71e:	601a      	str	r2, [r3, #0]
    
    inptr++;			/* advance pointers to next column */
 801f720:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 801f724:	3302      	adds	r3, #2
 801f726:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
    quantptr++;
 801f72a:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 801f72e:	3304      	adds	r3, #4
 801f730:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
    wsptr++;
 801f734:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f738:	3304      	adds	r3, #4
 801f73a:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
 801f73e:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801f742:	3b01      	subs	r3, #1
 801f744:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801f748:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801f74c:	2b00      	cmp	r3, #0
 801f74e:	f73f adc2 	bgt.w	801f2d6 <jpeg_idct_16x8+0x4e>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  wsptr = workspace;
 801f752:	f107 0314 	add.w	r3, r7, #20
 801f756:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 801f75a:	2300      	movs	r3, #0
 801f75c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801f760:	e32c      	b.n	801fdbc <jpeg_idct_16x8+0xb34>
 801f762:	bf00      	nop
 801f764:	ffffc4df 	.word	0xffffc4df
 801f768:	ffffc13b 	.word	0xffffc13b
 801f76c:	fffff384 	.word	0xfffff384
 801f770:	ffffe333 	.word	0xffffe333
 801f774:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 801f778:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801f77c:	009b      	lsls	r3, r3, #2
 801f77e:	463a      	mov	r2, r7
 801f780:	6812      	ldr	r2, [r2, #0]
 801f782:	4413      	add	r3, r2
 801f784:	681a      	ldr	r2, [r3, #0]
 801f786:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 801f78a:	4413      	add	r3, r2
 801f78c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 801f790:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f794:	681b      	ldr	r3, [r3, #0]
 801f796:	3310      	adds	r3, #16
 801f798:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp0 <<= CONST_BITS;
 801f79c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f7a0:	035b      	lsls	r3, r3, #13
 801f7a2:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164

    z1 = (INT32) wsptr[4];
 801f7a6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f7aa:	3310      	adds	r3, #16
 801f7ac:	681b      	ldr	r3, [r3, #0]
 801f7ae:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 801f7b2:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f7b6:	f642 12cf 	movw	r2, #10703	; 0x29cf
 801f7ba:	fb02 f303 	mul.w	r3, r2, r3
 801f7be:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 801f7c2:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f7c6:	f241 1251 	movw	r2, #4433	; 0x1151
 801f7ca:	fb02 f303 	mul.w	r3, r2, r3
 801f7ce:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    tmp10 = tmp0 + tmp1;
 801f7d2:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f7d6:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f7da:	4413      	add	r3, r2
 801f7dc:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp11 = tmp0 - tmp1;
 801f7e0:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f7e4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f7e8:	1ad3      	subs	r3, r2, r3
 801f7ea:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 = tmp0 + tmp2;
 801f7ee:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f7f2:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f7f6:	4413      	add	r3, r2
 801f7f8:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp13 = tmp0 - tmp2;
 801f7fc:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 801f800:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f804:	1ad3      	subs	r3, r2, r3
 801f806:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148

    z1 = (INT32) wsptr[2];
 801f80a:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f80e:	3308      	adds	r3, #8
 801f810:	681b      	ldr	r3, [r3, #0]
 801f812:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = (INT32) wsptr[6];
 801f816:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f81a:	3318      	adds	r3, #24
 801f81c:	681b      	ldr	r3, [r3, #0]
 801f81e:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = z1 - z2;
 801f822:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f826:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f82a:	1ad3      	subs	r3, r2, r3
 801f82c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 801f830:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f834:	f640 02d4 	movw	r2, #2260	; 0x8d4
 801f838:	fb02 f303 	mul.w	r3, r2, r3
 801f83c:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 801f840:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f844:	f642 4263 	movw	r2, #11363	; 0x2c63
 801f848:	fb02 f303 	mul.w	r3, r2, r3
 801f84c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 801f850:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f854:	f245 2203 	movw	r2, #20995	; 0x5203
 801f858:	fb02 f303 	mul.w	r3, r2, r3
 801f85c:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801f860:	4413      	add	r3, r2
 801f862:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 801f866:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f86a:	f641 42cd 	movw	r2, #7373	; 0x1ccd
 801f86e:	fb02 f303 	mul.w	r3, r2, r3
 801f872:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801f876:	4413      	add	r3, r2
 801f878:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 801f87c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f880:	4af4      	ldr	r2, [pc, #976]	; (801fc54 <jpeg_idct_16x8+0x9cc>)
 801f882:	fb02 f303 	mul.w	r3, r2, r3
 801f886:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801f88a:	4413      	add	r3, r2
 801f88c:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 801f890:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f894:	4af0      	ldr	r2, [pc, #960]	; (801fc58 <jpeg_idct_16x8+0x9d0>)
 801f896:	fb02 f303 	mul.w	r3, r2, r3
 801f89a:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801f89e:	4413      	add	r3, r2
 801f8a0:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    tmp20 = tmp10 + tmp0;
 801f8a4:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801f8a8:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f8ac:	4413      	add	r3, r2
 801f8ae:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp27 = tmp10 - tmp0;
 801f8b2:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801f8b6:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801f8ba:	1ad3      	subs	r3, r2, r3
 801f8bc:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tmp21 = tmp12 + tmp1;
 801f8c0:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801f8c4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f8c8:	4413      	add	r3, r2
 801f8ca:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp26 = tmp12 - tmp1;
 801f8ce:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801f8d2:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801f8d6:	1ad3      	subs	r3, r2, r3
 801f8d8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    tmp22 = tmp13 + tmp2;
 801f8dc:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801f8e0:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f8e4:	4413      	add	r3, r2
 801f8e6:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp25 = tmp13 - tmp2;
 801f8ea:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 801f8ee:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f8f2:	1ad3      	subs	r3, r2, r3
 801f8f4:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp23 = tmp11 + tmp3;
 801f8f8:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801f8fc:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f900:	4413      	add	r3, r2
 801f902:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp24 = tmp11 - tmp3;
 801f906:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801f90a:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f90e:	1ad3      	subs	r3, r2, r3
 801f910:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Odd part */

    z1 = (INT32) wsptr[1];
 801f914:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f918:	3304      	adds	r3, #4
 801f91a:	681b      	ldr	r3, [r3, #0]
 801f91c:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    z2 = (INT32) wsptr[3];
 801f920:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f924:	330c      	adds	r3, #12
 801f926:	681b      	ldr	r3, [r3, #0]
 801f928:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z3 = (INT32) wsptr[5];
 801f92c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f930:	3314      	adds	r3, #20
 801f932:	681b      	ldr	r3, [r3, #0]
 801f934:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
    z4 = (INT32) wsptr[7];
 801f938:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801f93c:	331c      	adds	r3, #28
 801f93e:	681b      	ldr	r3, [r3, #0]
 801f940:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    tmp11 = z1 + z3;
 801f944:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f948:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801f94c:	4413      	add	r3, r2
 801f94e:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 801f952:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f956:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f95a:	4413      	add	r3, r2
 801f95c:	f642 324e 	movw	r2, #11086	; 0x2b4e
 801f960:	fb02 f303 	mul.w	r3, r2, r3
 801f964:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 801f968:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801f96c:	f242 72e9 	movw	r2, #10217	; 0x27e9
 801f970:	fb02 f303 	mul.w	r3, r2, r3
 801f974:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 801f978:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f97c:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801f980:	4413      	add	r3, r2
 801f982:	f242 22fc 	movw	r2, #8956	; 0x22fc
 801f986:	fb02 f303 	mul.w	r3, r2, r3
 801f98a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 801f98e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f992:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801f996:	1ad3      	subs	r3, r2, r3
 801f998:	f641 42b6 	movw	r2, #7350	; 0x1cb6
 801f99c:	fb02 f303 	mul.w	r3, r2, r3
 801f9a0:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 801f9a4:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801f9a8:	f241 5255 	movw	r2, #5461	; 0x1555
 801f9ac:	fb02 f303 	mul.w	r3, r2, r3
 801f9b0:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 801f9b4:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 801f9b8:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801f9bc:	1ad3      	subs	r3, r2, r3
 801f9be:	f640 5223 	movw	r2, #3363	; 0xd23
 801f9c2:	fb02 f303 	mul.w	r3, r2, r3
 801f9c6:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp0  = tmp1 + tmp2 + tmp3 -
 801f9ca:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801f9ce:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801f9d2:	441a      	add	r2, r3
 801f9d4:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801f9d8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 801f9da:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f9de:	499f      	ldr	r1, [pc, #636]	; (801fc5c <jpeg_idct_16x8+0x9d4>)
 801f9e0:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 801f9e4:	4413      	add	r3, r2
 801f9e6:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp13 = tmp10 + tmp11 + tmp12 -
 801f9ea:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801f9ee:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801f9f2:	441a      	add	r2, r3
 801f9f4:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801f9f8:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 801f9fa:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801f9fe:	4998      	ldr	r1, [pc, #608]	; (801fc60 <jpeg_idct_16x8+0x9d8>)
 801fa00:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 801fa04:	4413      	add	r3, r2
 801fa06:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 801fa0a:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801fa0e:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801fa12:	4413      	add	r3, r2
 801fa14:	f44f 628e 	mov.w	r2, #1136	; 0x470
 801fa18:	fb02 f303 	mul.w	r3, r2, r3
 801fa1c:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 801fa20:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fa24:	f240 224d 	movw	r2, #589	; 0x24d
 801fa28:	fb02 f203 	mul.w	r2, r2, r3
 801fa2c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fa30:	4413      	add	r3, r2
 801fa32:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801fa36:	4413      	add	r3, r2
 801fa38:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 801fa3c:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801fa40:	4a88      	ldr	r2, [pc, #544]	; (801fc64 <jpeg_idct_16x8+0x9dc>)
 801fa42:	fb02 f203 	mul.w	r2, r2, r3
 801fa46:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fa4a:	4413      	add	r3, r2
 801fa4c:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801fa50:	4413      	add	r3, r2
 801fa52:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 801fa56:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801fa5a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fa5e:	1ad3      	subs	r3, r2, r3
 801fa60:	f642 5209 	movw	r2, #11529	; 0x2d09
 801fa64:	fb02 f303 	mul.w	r3, r2, r3
 801fa68:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 801fa6c:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801fa70:	4a7d      	ldr	r2, [pc, #500]	; (801fc68 <jpeg_idct_16x8+0x9e0>)
 801fa72:	fb02 f203 	mul.w	r2, r2, r3
 801fa76:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fa7a:	4413      	add	r3, r2
 801fa7c:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801fa80:	4413      	add	r3, r2
 801fa82:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 801fa86:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fa8a:	f643 721a 	movw	r2, #16154	; 0x3f1a
 801fa8e:	fb02 f203 	mul.w	r2, r2, r3
 801fa92:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fa96:	4413      	add	r3, r2
 801fa98:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801fa9c:	4413      	add	r3, r2
 801fa9e:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    z2    += z4;
 801faa2:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 801faa6:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801faaa:	4413      	add	r3, r2
 801faac:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 801fab0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fab4:	4a6d      	ldr	r2, [pc, #436]	; (801fc6c <jpeg_idct_16x8+0x9e4>)
 801fab6:	fb02 f303 	mul.w	r3, r2, r3
 801faba:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp1  += z1;
 801fabe:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 801fac2:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fac6:	4413      	add	r3, r2
 801fac8:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 801facc:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801fad0:	f242 2218 	movw	r2, #8728	; 0x2218
 801fad4:	fb02 f203 	mul.w	r2, r2, r3
 801fad8:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 801fadc:	4413      	add	r3, r2
 801fade:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801fae2:	4413      	add	r3, r2
 801fae4:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 801fae8:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801faec:	4a60      	ldr	r2, [pc, #384]	; (801fc70 <jpeg_idct_16x8+0x9e8>)
 801faee:	fb02 f303 	mul.w	r3, r2, r3
 801faf2:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 801faf6:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801fafa:	f246 4285 	movw	r2, #25733	; 0x6485
 801fafe:	fb02 f203 	mul.w	r2, r2, r3
 801fb02:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb06:	4413      	add	r3, r2
 801fb08:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801fb0c:	4413      	add	r3, r2
 801fb0e:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp12 += z2;
 801fb12:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 801fb16:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb1a:	4413      	add	r3, r2
 801fb1c:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 801fb20:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 801fb24:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 801fb28:	4413      	add	r3, r2
 801fb2a:	4a52      	ldr	r2, [pc, #328]	; (801fc74 <jpeg_idct_16x8+0x9ec>)
 801fb2c:	fb02 f303 	mul.w	r3, r2, r3
 801fb30:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    tmp2  += z2;
 801fb34:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 801fb38:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb3c:	4413      	add	r3, r2
 801fb3e:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp3  += z2;
 801fb42:	f8d7 2138 	ldr.w	r2, [r7, #312]	; 0x138
 801fb46:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb4a:	4413      	add	r3, r2
 801fb4c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 801fb50:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 801fb54:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801fb58:	1ad3      	subs	r3, r2, r3
 801fb5a:	f640 5223 	movw	r2, #3363	; 0xd23
 801fb5e:	fb02 f303 	mul.w	r3, r2, r3
 801fb62:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    tmp10 += z2;
 801fb66:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 801fb6a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb6e:	4413      	add	r3, r2
 801fb70:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    tmp11 += z2;
 801fb74:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 801fb78:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801fb7c:	4413      	add	r3, r2
 801fb7e:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 801fb82:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801fb86:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801fb8a:	4413      	add	r3, r2
 801fb8c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fb8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp0,
 801fb92:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fb96:	4413      	add	r3, r2
 801fb98:	781a      	ldrb	r2, [r3, #0]
 801fb9a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fb9e:	701a      	strb	r2, [r3, #0]
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 801fba0:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801fba4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801fba8:	1ad3      	subs	r3, r2, r3
 801fbaa:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fbac:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[15] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp0,
 801fbb0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fbb4:	441a      	add	r2, r3
 801fbb6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fbba:	330f      	adds	r3, #15
 801fbbc:	7812      	ldrb	r2, [r2, #0]
 801fbbe:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 801fbc0:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 801fbc4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801fbc8:	4413      	add	r3, r2
 801fbca:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fbcc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp1,
 801fbd0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fbd4:	441a      	add	r2, r3
 801fbd6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fbda:	3301      	adds	r3, #1
 801fbdc:	7812      	ldrb	r2, [r2, #0]
 801fbde:	701a      	strb	r2, [r3, #0]
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 801fbe0:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 801fbe4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 801fbe8:	1ad3      	subs	r3, r2, r3
 801fbea:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fbec:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[14] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp1,
 801fbf0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fbf4:	441a      	add	r2, r3
 801fbf6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fbfa:	330e      	adds	r3, #14
 801fbfc:	7812      	ldrb	r2, [r2, #0]
 801fbfe:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 801fc00:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 801fc04:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801fc08:	4413      	add	r3, r2
 801fc0a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fc0c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp2,
 801fc10:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fc14:	441a      	add	r2, r3
 801fc16:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fc1a:	3302      	adds	r3, #2
 801fc1c:	7812      	ldrb	r2, [r2, #0]
 801fc1e:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 801fc20:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 801fc24:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 801fc28:	1ad3      	subs	r3, r2, r3
 801fc2a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fc2c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp2,
 801fc30:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fc34:	441a      	add	r2, r3
 801fc36:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fc3a:	330d      	adds	r3, #13
 801fc3c:	7812      	ldrb	r2, [r2, #0]
 801fc3e:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 801fc40:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 801fc44:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801fc48:	4413      	add	r3, r2
 801fc4a:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fc4c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801fc50:	e012      	b.n	801fc78 <jpeg_idct_16x8+0x9f0>
 801fc52:	bf00      	nop
 801fc54:	ffffecc2 	.word	0xffffecc2
 801fc58:	ffffefb0 	.word	0xffffefb0
 801fc5c:	ffffb6d6 	.word	0xffffb6d6
 801fc60:	ffffc542 	.word	0xffffc542
 801fc64:	ffffdbfa 	.word	0xffffdbfa
 801fc68:	ffffe77a 	.word	0xffffe77a
 801fc6c:	ffffeaab 	.word	0xffffeaab
 801fc70:	ffffd817 	.word	0xffffd817
 801fc74:	ffffd4b2 	.word	0xffffd4b2
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp3,
 801fc78:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fc7c:	441a      	add	r2, r3
 801fc7e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fc82:	3303      	adds	r3, #3
 801fc84:	7812      	ldrb	r2, [r2, #0]
 801fc86:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 801fc88:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 801fc8c:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801fc90:	1ad3      	subs	r3, r2, r3
 801fc92:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fc94:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp3,
 801fc98:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fc9c:	441a      	add	r2, r3
 801fc9e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fca2:	330c      	adds	r3, #12
 801fca4:	7812      	ldrb	r2, [r2, #0]
 801fca6:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 801fca8:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801fcac:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801fcb0:	4413      	add	r3, r2
 801fcb2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fcb4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp10,
 801fcb8:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fcbc:	441a      	add	r2, r3
 801fcbe:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fcc2:	3304      	adds	r3, #4
 801fcc4:	7812      	ldrb	r2, [r2, #0]
 801fcc6:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 801fcc8:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801fccc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 801fcd0:	1ad3      	subs	r3, r2, r3
 801fcd2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fcd4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp10,
 801fcd8:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fcdc:	441a      	add	r2, r3
 801fcde:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fce2:	330b      	adds	r3, #11
 801fce4:	7812      	ldrb	r2, [r2, #0]
 801fce6:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 801fce8:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 801fcec:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801fcf0:	4413      	add	r3, r2
 801fcf2:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fcf4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp11,
 801fcf8:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fcfc:	441a      	add	r2, r3
 801fcfe:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fd02:	3305      	adds	r3, #5
 801fd04:	7812      	ldrb	r2, [r2, #0]
 801fd06:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 801fd08:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 801fd0c:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 801fd10:	1ad3      	subs	r3, r2, r3
 801fd12:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fd14:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp11,
 801fd18:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fd1c:	441a      	add	r2, r3
 801fd1e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fd22:	330a      	adds	r3, #10
 801fd24:	7812      	ldrb	r2, [r2, #0]
 801fd26:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 801fd28:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801fd2c:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fd30:	4413      	add	r3, r2
 801fd32:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fd34:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp12,
 801fd38:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fd3c:	441a      	add	r2, r3
 801fd3e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fd42:	3306      	adds	r3, #6
 801fd44:	7812      	ldrb	r2, [r2, #0]
 801fd46:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 801fd48:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801fd4c:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fd50:	1ad3      	subs	r3, r2, r3
 801fd52:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fd54:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp12,
 801fd58:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fd5c:	441a      	add	r2, r3
 801fd5e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fd62:	3309      	adds	r3, #9
 801fd64:	7812      	ldrb	r2, [r2, #0]
 801fd66:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 801fd68:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 801fd6c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fd70:	4413      	add	r3, r2
 801fd72:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fd74:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp27 + tmp13,
 801fd78:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fd7c:	441a      	add	r2, r3
 801fd7e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fd82:	3307      	adds	r3, #7
 801fd84:	7812      	ldrb	r2, [r2, #0]
 801fd86:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 801fd88:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 801fd8c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fd90:	1ad3      	subs	r3, r2, r3
 801fd92:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 801fd94:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp27 - tmp13,
 801fd98:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 801fd9c:	441a      	add	r2, r3
 801fd9e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801fda2:	3308      	adds	r3, #8
 801fda4:	7812      	ldrb	r2, [r2, #0]
 801fda6:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 801fda8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801fdac:	3320      	adds	r3, #32
 801fdae:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  for (ctr = 0; ctr < 8; ctr++) {
 801fdb2:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801fdb6:	3301      	adds	r3, #1
 801fdb8:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 801fdbc:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 801fdc0:	2b07      	cmp	r3, #7
 801fdc2:	f77f acd9 	ble.w	801f778 <jpeg_idct_16x8+0x4f0>
  }
}
 801fdc6:	bf00      	nop
 801fdc8:	bf00      	nop
 801fdca:	f507 77c0 	add.w	r7, r7, #384	; 0x180
 801fdce:	46bd      	mov	sp, r7
 801fdd0:	bc90      	pop	{r4, r7}
 801fdd2:	4770      	bx	lr

0801fdd4 <jpeg_idct_14x7>:

GLOBAL(void)
jpeg_idct_14x7 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 801fdd4:	b490      	push	{r4, r7}
 801fdd6:	b0d4      	sub	sp, #336	; 0x150
 801fdd8:	af00      	add	r7, sp, #0
 801fdda:	f107 040c 	add.w	r4, r7, #12
 801fdde:	6020      	str	r0, [r4, #0]
 801fde0:	f107 0008 	add.w	r0, r7, #8
 801fde4:	6001      	str	r1, [r0, #0]
 801fde6:	1d39      	adds	r1, r7, #4
 801fde8:	600a      	str	r2, [r1, #0]
 801fdea:	463a      	mov	r2, r7
 801fdec:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 801fdee:	f107 030c 	add.w	r3, r7, #12
 801fdf2:	681b      	ldr	r3, [r3, #0]
 801fdf4:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 801fdf8:	3380      	adds	r3, #128	; 0x80
 801fdfa:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  inptr = coef_block;
 801fdfe:	1d3b      	adds	r3, r7, #4
 801fe00:	681b      	ldr	r3, [r3, #0]
 801fe02:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 801fe06:	f107 0308 	add.w	r3, r7, #8
 801fe0a:	681b      	ldr	r3, [r3, #0]
 801fe0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801fe0e:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
  wsptr = workspace;
 801fe12:	f107 0310 	add.w	r3, r7, #16
 801fe16:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 801fe1a:	2300      	movs	r3, #0
 801fe1c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 801fe20:	e17a      	b.n	8020118 <jpeg_idct_14x7+0x344>
    /* Even part */

    tmp23 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 801fe22:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fe26:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe2a:	461a      	mov	r2, r3
 801fe2c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fe30:	681b      	ldr	r3, [r3, #0]
 801fe32:	fb03 f302 	mul.w	r3, r3, r2
 801fe36:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
    tmp23 <<= CONST_BITS;
 801fe3a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 801fe3e:	035b      	lsls	r3, r3, #13
 801fe40:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
    /* Add fudge factor here for final descale. */
    tmp23 += ONE << (CONST_BITS-PASS1_BITS-1);
 801fe44:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 801fe48:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801fe4c:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 801fe50:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fe54:	3320      	adds	r3, #32
 801fe56:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe5a:	461a      	mov	r2, r3
 801fe5c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fe60:	3340      	adds	r3, #64	; 0x40
 801fe62:	681b      	ldr	r3, [r3, #0]
 801fe64:	fb03 f302 	mul.w	r3, r3, r2
 801fe68:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 801fe6c:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fe70:	3340      	adds	r3, #64	; 0x40
 801fe72:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe76:	461a      	mov	r2, r3
 801fe78:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fe7c:	3380      	adds	r3, #128	; 0x80
 801fe7e:	681b      	ldr	r3, [r3, #0]
 801fe80:	fb03 f302 	mul.w	r3, r3, r2
 801fe84:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 801fe88:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801fe8c:	3360      	adds	r3, #96	; 0x60
 801fe8e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe92:	461a      	mov	r2, r3
 801fe94:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801fe98:	33c0      	adds	r3, #192	; 0xc0
 801fe9a:	681b      	ldr	r3, [r3, #0]
 801fe9c:	fb03 f302 	mul.w	r3, r3, r2
 801fea0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 801fea4:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 801fea8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801feac:	1ad3      	subs	r3, r2, r3
 801feae:	f641 4237 	movw	r2, #7223	; 0x1c37
 801feb2:	fb02 f303 	mul.w	r3, r2, r3
 801feb6:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 801feba:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801febe:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801fec2:	1ad3      	subs	r3, r2, r3
 801fec4:	f640 2212 	movw	r2, #2578	; 0xa12
 801fec8:	fb02 f303 	mul.w	r3, r2, r3
 801fecc:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 801fed0:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 801fed4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 801fed8:	441a      	add	r2, r3
 801feda:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 801fede:	441a      	add	r2, r3
 801fee0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801fee4:	4993      	ldr	r1, [pc, #588]	; (8020134 <jpeg_idct_14x7+0x360>)
 801fee6:	fb01 f303 	mul.w	r3, r1, r3
 801feea:	4413      	add	r3, r2
 801feec:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp10 = z1 + z3;
 801fef0:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801fef4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801fef8:	4413      	add	r3, r2
 801fefa:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    z2 -= tmp10;
 801fefe:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 801ff02:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801ff06:	1ad3      	subs	r3, r2, r3
 801ff08:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 801ff0c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801ff10:	f642 02c6 	movw	r2, #10438	; 0x28c6
 801ff14:	fb02 f303 	mul.w	r3, r2, r3
 801ff18:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801ff1c:	4413      	add	r3, r2
 801ff1e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 801ff22:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801ff26:	f46f 721f 	mvn.w	r2, #636	; 0x27c
 801ff2a:	fb02 f203 	mul.w	r2, r2, r3
 801ff2e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801ff32:	4413      	add	r3, r2
 801ff34:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 801ff38:	4413      	add	r3, r2
 801ff3a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 801ff3e:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801ff42:	4a7d      	ldr	r2, [pc, #500]	; (8020138 <jpeg_idct_14x7+0x364>)
 801ff44:	fb02 f203 	mul.w	r2, r2, r3
 801ff48:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 801ff4c:	4413      	add	r3, r2
 801ff4e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 801ff52:	4413      	add	r3, r2
 801ff54:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 801ff58:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801ff5c:	f642 5241 	movw	r2, #11585	; 0x2d41
 801ff60:	fb02 f303 	mul.w	r3, r2, r3
 801ff64:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 801ff68:	4413      	add	r3, r2
 801ff6a:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 801ff6e:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801ff72:	3310      	adds	r3, #16
 801ff74:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ff78:	461a      	mov	r2, r3
 801ff7a:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801ff7e:	3320      	adds	r3, #32
 801ff80:	681b      	ldr	r3, [r3, #0]
 801ff82:	fb03 f302 	mul.w	r3, r3, r2
 801ff86:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 801ff8a:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801ff8e:	3330      	adds	r3, #48	; 0x30
 801ff90:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ff94:	461a      	mov	r2, r3
 801ff96:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801ff9a:	3360      	adds	r3, #96	; 0x60
 801ff9c:	681b      	ldr	r3, [r3, #0]
 801ff9e:	fb03 f302 	mul.w	r3, r3, r2
 801ffa2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 801ffa6:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 801ffaa:	3350      	adds	r3, #80	; 0x50
 801ffac:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ffb0:	461a      	mov	r2, r3
 801ffb2:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801ffb6:	33a0      	adds	r3, #160	; 0xa0
 801ffb8:	681b      	ldr	r3, [r3, #0]
 801ffba:	fb03 f302 	mul.w	r3, r3, r2
 801ffbe:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 801ffc2:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801ffc6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801ffca:	4413      	add	r3, r2
 801ffcc:	f641 52ef 	movw	r2, #7663	; 0x1def
 801ffd0:	fb02 f303 	mul.w	r3, r2, r3
 801ffd4:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 801ffd8:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 801ffdc:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801ffe0:	1ad3      	subs	r3, r2, r3
 801ffe2:	f240 5273 	movw	r2, #1395	; 0x573
 801ffe6:	fb02 f303 	mul.w	r3, r2, r3
 801ffea:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp10 = tmp11 - tmp12;
 801ffee:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 801fff2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 801fff6:	1ad3      	subs	r3, r2, r3
 801fff8:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp11 += tmp12;
 801fffc:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8020000:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020004:	4413      	add	r3, r2
 8020006:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 802000a:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 802000e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8020012:	4413      	add	r3, r2
 8020014:	4a49      	ldr	r2, [pc, #292]	; (802013c <jpeg_idct_14x7+0x368>)
 8020016:	fb02 f303 	mul.w	r3, r2, r3
 802001a:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp11 += tmp12;
 802001e:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8020022:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020026:	4413      	add	r3, r2
 8020028:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 802002c:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8020030:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8020034:	4413      	add	r3, r2
 8020036:	f241 32a3 	movw	r2, #5027	; 0x13a3
 802003a:	fb02 f303 	mul.w	r3, r2, r3
 802003e:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    tmp10 += z2;
 8020042:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8020046:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 802004a:	4413      	add	r3, r2
 802004c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 8020050:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8020054:	f643 32de 	movw	r2, #15326	; 0x3bde
 8020058:	fb02 f203 	mul.w	r2, r2, r3
 802005c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020060:	4413      	add	r3, r2
 8020062:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8020066:	4413      	add	r3, r2
 8020068:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 802006c:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8020070:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8020074:	4413      	add	r3, r2
 8020076:	12da      	asrs	r2, r3, #11
 8020078:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 802007c:	601a      	str	r2, [r3, #0]
    wsptr[8*6] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 802007e:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8020082:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8020086:	1ad2      	subs	r2, r2, r3
 8020088:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 802008c:	33c0      	adds	r3, #192	; 0xc0
 802008e:	12d2      	asrs	r2, r2, #11
 8020090:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8020092:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020096:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 802009a:	441a      	add	r2, r3
 802009c:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80200a0:	3320      	adds	r3, #32
 80200a2:	12d2      	asrs	r2, r2, #11
 80200a4:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 80200a6:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80200aa:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80200ae:	1ad2      	subs	r2, r2, r3
 80200b0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80200b4:	33a0      	adds	r3, #160	; 0xa0
 80200b6:	12d2      	asrs	r2, r2, #11
 80200b8:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 80200ba:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80200be:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80200c2:	441a      	add	r2, r3
 80200c4:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80200c8:	3340      	adds	r3, #64	; 0x40
 80200ca:	12d2      	asrs	r2, r2, #11
 80200cc:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 80200ce:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80200d2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80200d6:	1ad2      	subs	r2, r2, r3
 80200d8:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80200dc:	3380      	adds	r3, #128	; 0x80
 80200de:	12d2      	asrs	r2, r2, #11
 80200e0:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp23, CONST_BITS-PASS1_BITS);
 80200e2:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80200e6:	3360      	adds	r3, #96	; 0x60
 80200e8:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 80200ec:	12d2      	asrs	r2, r2, #11
 80200ee:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80200f0:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 80200f4:	3301      	adds	r3, #1
 80200f6:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 80200fa:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 80200fe:	3302      	adds	r3, #2
 8020100:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
 8020104:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8020108:	3304      	adds	r3, #4
 802010a:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
 802010e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8020112:	3304      	adds	r3, #4
 8020114:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
 8020118:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 802011c:	2b07      	cmp	r3, #7
 802011e:	f77f ae80 	ble.w	801fe22 <jpeg_idct_14x7+0x4e>
  }

  /* Pass 2: process 7 rows from work array, store into output array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  wsptr = workspace;
 8020122:	f107 0310 	add.w	r3, r7, #16
 8020126:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 802012a:	2300      	movs	r3, #0
 802012c:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 8020130:	e288      	b.n	8020644 <jpeg_idct_14x7+0x870>
 8020132:	bf00      	nop
 8020134:	ffffc515 	.word	0xffffc515
 8020138:	ffffb0f1 	.word	0xffffb0f1
 802013c:	ffffd3e1 	.word	0xffffd3e1
    outptr = output_buf[ctr] + output_col;
 8020140:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8020144:	009b      	lsls	r3, r3, #2
 8020146:	463a      	mov	r2, r7
 8020148:	6812      	ldr	r2, [r2, #0]
 802014a:	4413      	add	r3, r2
 802014c:	681a      	ldr	r2, [r3, #0]
 802014e:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 8020152:	4413      	add	r3, r2
 8020154:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    /* Even part */

    /* Add fudge factor here for final descale. */
    z1 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8020158:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 802015c:	681b      	ldr	r3, [r3, #0]
 802015e:	3310      	adds	r3, #16
 8020160:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z1 <<= CONST_BITS;
 8020164:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8020168:	035b      	lsls	r3, r3, #13
 802016a:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z4 = (INT32) wsptr[4];
 802016e:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8020172:	3310      	adds	r3, #16
 8020174:	681b      	ldr	r3, [r3, #0]
 8020176:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 802017a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 802017e:	f642 02c6 	movw	r2, #10438	; 0x28c6
 8020182:	fb02 f303 	mul.w	r3, r2, r3
 8020186:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 802018a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 802018e:	f640 2212 	movw	r2, #2578	; 0xa12
 8020192:	fb02 f303 	mul.w	r3, r2, r3
 8020196:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 802019a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 802019e:	f641 4237 	movw	r2, #7223	; 0x1c37
 80201a2:	fb02 f303 	mul.w	r3, r2, r3
 80201a6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    tmp10 = z1 + z2;
 80201aa:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80201ae:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80201b2:	4413      	add	r3, r2
 80201b4:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp11 = z1 + z3;
 80201b8:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80201bc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80201c0:	4413      	add	r3, r2
 80201c2:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp12 = z1 - z4;
 80201c6:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80201ca:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80201ce:	1ad3      	subs	r3, r2, r3
 80201d0:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

    tmp23 = z1 - ((z2 + z3 - z4) << 1);          /* c0 = (c4+c12-c8)*2 */
 80201d4:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 80201d8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80201dc:	441a      	add	r2, r3
 80201de:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80201e2:	1ad3      	subs	r3, r2, r3
 80201e4:	005b      	lsls	r3, r3, #1
 80201e6:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80201ea:	1ad3      	subs	r3, r2, r3
 80201ec:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    z1 = (INT32) wsptr[2];
 80201f0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80201f4:	3308      	adds	r3, #8
 80201f6:	681b      	ldr	r3, [r3, #0]
 80201f8:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z2 = (INT32) wsptr[6];
 80201fc:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8020200:	3318      	adds	r3, #24
 8020202:	681b      	ldr	r3, [r3, #0]
 8020204:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 8020208:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 802020c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020210:	4413      	add	r3, r2
 8020212:	f242 3262 	movw	r2, #9058	; 0x2362
 8020216:	fb02 f303 	mul.w	r3, r2, r3
 802021a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 802021e:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8020222:	f640 02bd 	movw	r2, #2237	; 0x8bd
 8020226:	fb02 f303 	mul.w	r3, r2, r3
 802022a:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 802022e:	4413      	add	r3, r2
 8020230:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8020234:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020238:	4af1      	ldr	r2, [pc, #964]	; (8020600 <jpeg_idct_14x7+0x82c>)
 802023a:	fb02 f303 	mul.w	r3, r2, r3
 802023e:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8020242:	4413      	add	r3, r2
 8020244:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8020248:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 802024c:	f241 32a3 	movw	r2, #5027	; 0x13a3
 8020250:	fb02 f203 	mul.w	r2, r2, r3
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 8020254:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020258:	49ea      	ldr	r1, [pc, #936]	; (8020604 <jpeg_idct_14x7+0x830>)
 802025a:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 802025e:	4413      	add	r3, r2
 8020260:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    tmp20 = tmp10 + tmp13;
 8020264:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8020268:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802026c:	4413      	add	r3, r2
 802026e:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    tmp26 = tmp10 - tmp13;
 8020272:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 8020276:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802027a:	1ad3      	subs	r3, r2, r3
 802027c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp21 = tmp11 + tmp14;
 8020280:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8020284:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020288:	4413      	add	r3, r2
 802028a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp25 = tmp11 - tmp14;
 802028e:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8020292:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020296:	1ad3      	subs	r3, r2, r3
 8020298:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp22 = tmp12 + tmp15;
 802029c:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 80202a0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80202a4:	4413      	add	r3, r2
 80202a6:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp24 = tmp12 - tmp15;
 80202aa:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 80202ae:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80202b2:	1ad3      	subs	r3, r2, r3
 80202b4:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80202b8:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80202bc:	3304      	adds	r3, #4
 80202be:	681b      	ldr	r3, [r3, #0]
 80202c0:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    z2 = (INT32) wsptr[3];
 80202c4:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80202c8:	330c      	adds	r3, #12
 80202ca:	681b      	ldr	r3, [r3, #0]
 80202cc:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    z3 = (INT32) wsptr[5];
 80202d0:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80202d4:	3314      	adds	r3, #20
 80202d6:	681b      	ldr	r3, [r3, #0]
 80202d8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    z4 = (INT32) wsptr[7];
 80202dc:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 80202e0:	331c      	adds	r3, #28
 80202e2:	681b      	ldr	r3, [r3, #0]
 80202e4:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    z4 <<= CONST_BITS;
 80202e8:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80202ec:	035b      	lsls	r3, r3, #13
 80202ee:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130

    tmp14 = z1 + z3;
 80202f2:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80202f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80202fa:	4413      	add	r3, r2
 80202fc:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8020300:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8020304:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020308:	4413      	add	r3, r2
 802030a:	f642 22b7 	movw	r2, #10935	; 0x2ab7
 802030e:	fb02 f303 	mul.w	r3, r2, r3
 8020312:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 8020316:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 802031a:	f242 6252 	movw	r2, #9810	; 0x2652
 802031e:	fb02 f303 	mul.w	r3, r2, r3
 8020322:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 8020326:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 802032a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802032e:	441a      	add	r2, r3
 8020330:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8020334:	441a      	add	r2, r3
 8020336:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 802033a:	49b3      	ldr	r1, [pc, #716]	; (8020608 <jpeg_idct_14x7+0x834>)
 802033c:	fb01 f303 	mul.w	r3, r1, r3
 8020340:	4413      	add	r3, r2
 8020342:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 8020346:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 802034a:	f641 0214 	movw	r2, #6164	; 0x1814
 802034e:	fb02 f303 	mul.w	r3, r2, r3
 8020352:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 8020356:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 802035a:	4aac      	ldr	r2, [pc, #688]	; (802060c <jpeg_idct_14x7+0x838>)
 802035c:	fb02 f303 	mul.w	r3, r2, r3
 8020360:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8020364:	4413      	add	r3, r2
 8020366:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    z1    -= z2;
 802036a:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 802036e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020372:	1ad3      	subs	r3, r2, r3
 8020374:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */
 8020378:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 802037c:	f640 62f2 	movw	r2, #3826	; 0xef2
 8020380:	fb02 f203 	mul.w	r2, r2, r3
 8020384:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8020388:	1ad3      	subs	r3, r2, r3
 802038a:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    tmp16 += tmp15;
 802038e:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8020392:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8020396:	4413      	add	r3, r2
 8020398:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    tmp13 = MULTIPLY(z2 + z3, - FIX(0.158341681)) - z4;    /* -c13 */
 802039c:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 80203a0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80203a4:	4413      	add	r3, r2
 80203a6:	f46f 62a2 	mvn.w	r2, #1296	; 0x510
 80203aa:	fb02 f203 	mul.w	r2, r2, r3
 80203ae:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80203b2:	1ad3      	subs	r3, r2, r3
 80203b4:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */
 80203b8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80203bc:	4a94      	ldr	r2, [pc, #592]	; (8020610 <jpeg_idct_14x7+0x83c>)
 80203be:	fb02 f203 	mul.w	r2, r2, r3
 80203c2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80203c6:	4413      	add	r3, r2
 80203c8:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 80203cc:	4413      	add	r3, r2
 80203ce:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */
 80203d2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80203d6:	4a8f      	ldr	r2, [pc, #572]	; (8020614 <jpeg_idct_14x7+0x840>)
 80203d8:	fb02 f203 	mul.w	r2, r2, r3
 80203dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80203e0:	4413      	add	r3, r2
 80203e2:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 80203e6:	4413      	add	r3, r2
 80203e8:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 80203ec:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 80203f0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80203f4:	1ad3      	subs	r3, r2, r3
 80203f6:	f642 42f8 	movw	r2, #11512	; 0x2cf8
 80203fa:	fb02 f303 	mul.w	r3, r2, r3
 80203fe:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8020402:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020406:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 802040a:	441a      	add	r2, r3
 802040c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8020410:	4981      	ldr	r1, [pc, #516]	; (8020618 <jpeg_idct_14x7+0x844>)
 8020412:	fb01 f303 	mul.w	r3, r1, r3
 8020416:	4413      	add	r3, r2
 8020418:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 802041c:	4413      	add	r3, r2
 802041e:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */
 8020422:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8020426:	f241 5299 	movw	r2, #5529	; 0x1599
 802042a:	fb02 f203 	mul.w	r2, r2, r3
 802042e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8020432:	4413      	add	r3, r2
 8020434:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020438:	4413      	add	r3, r2
 802043a:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    tmp13 = ((z1 - z3) << CONST_BITS) + z4;
 802043e:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8020442:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8020446:	1ad3      	subs	r3, r2, r3
 8020448:	035b      	lsls	r3, r3, #13
 802044a:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 802044e:	4413      	add	r3, r2
 8020450:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8020454:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8020458:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802045c:	4413      	add	r3, r2
 802045e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020460:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8020464:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020468:	4413      	add	r3, r2
 802046a:	781a      	ldrb	r2, [r3, #0]
 802046c:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8020470:	701a      	strb	r2, [r3, #0]
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8020472:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8020476:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802047a:	1ad3      	subs	r3, r2, r3
 802047c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802047e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[13] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8020482:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020486:	441a      	add	r2, r3
 8020488:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802048c:	330d      	adds	r3, #13
 802048e:	7812      	ldrb	r2, [r2, #0]
 8020490:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8020492:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020496:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 802049a:	4413      	add	r3, r2
 802049c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802049e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80204a2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80204a6:	441a      	add	r2, r3
 80204a8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80204ac:	3301      	adds	r3, #1
 80204ae:	7812      	ldrb	r2, [r2, #0]
 80204b0:	701a      	strb	r2, [r3, #0]
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80204b2:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80204b6:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80204ba:	1ad3      	subs	r3, r2, r3
 80204bc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80204be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[12] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 80204c2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80204c6:	441a      	add	r2, r3
 80204c8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80204cc:	330c      	adds	r3, #12
 80204ce:	7812      	ldrb	r2, [r2, #0]
 80204d0:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80204d2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80204d6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80204da:	4413      	add	r3, r2
 80204dc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80204de:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 80204e2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80204e6:	441a      	add	r2, r3
 80204e8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80204ec:	3302      	adds	r3, #2
 80204ee:	7812      	ldrb	r2, [r2, #0]
 80204f0:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80204f2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80204f6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80204fa:	1ad3      	subs	r3, r2, r3
 80204fc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80204fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8020502:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020506:	441a      	add	r2, r3
 8020508:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802050c:	330b      	adds	r3, #11
 802050e:	7812      	ldrb	r2, [r2, #0]
 8020510:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020512:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8020516:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802051a:	4413      	add	r3, r2
 802051c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802051e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020522:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020526:	441a      	add	r2, r3
 8020528:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802052c:	3303      	adds	r3, #3
 802052e:	7812      	ldrb	r2, [r2, #0]
 8020530:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020532:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8020536:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802053a:	1ad3      	subs	r3, r2, r3
 802053c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802053e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020542:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020546:	441a      	add	r2, r3
 8020548:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802054c:	330a      	adds	r3, #10
 802054e:	7812      	ldrb	r2, [r2, #0]
 8020550:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020552:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8020556:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 802055a:	4413      	add	r3, r2
 802055c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802055e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020562:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020566:	441a      	add	r2, r3
 8020568:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802056c:	3304      	adds	r3, #4
 802056e:	7812      	ldrb	r2, [r2, #0]
 8020570:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020572:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8020576:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 802057a:	1ad3      	subs	r3, r2, r3
 802057c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802057e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020582:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020586:	441a      	add	r2, r3
 8020588:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802058c:	3309      	adds	r3, #9
 802058e:	7812      	ldrb	r2, [r2, #0]
 8020590:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8020592:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020596:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 802059a:	4413      	add	r3, r2
 802059c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802059e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 80205a2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80205a6:	441a      	add	r2, r3
 80205a8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80205ac:	3305      	adds	r3, #5
 80205ae:	7812      	ldrb	r2, [r2, #0]
 80205b0:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80205b2:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 80205b6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80205ba:	1ad3      	subs	r3, r2, r3
 80205bc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80205be:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 80205c2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80205c6:	441a      	add	r2, r3
 80205c8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80205cc:	3308      	adds	r3, #8
 80205ce:	7812      	ldrb	r2, [r2, #0]
 80205d0:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 80205d2:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80205d6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80205da:	4413      	add	r3, r2
 80205dc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 80205de:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp26 + tmp16,
 80205e2:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 80205e6:	441a      	add	r2, r3
 80205e8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80205ec:	3306      	adds	r3, #6
 80205ee:	7812      	ldrb	r2, [r2, #0]
 80205f0:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 80205f2:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80205f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80205fa:	1ad3      	subs	r3, r2, r3
 80205fc:	149b      	asrs	r3, r3, #18
 80205fe:	e00d      	b.n	802061c <jpeg_idct_14x7+0x848>
 8020600:	ffffc8fc 	.word	0xffffc8fc
 8020604:	ffffd3e1 	.word	0xffffd3e1
 8020608:	ffffdbf0 	.word	0xffffdbf0
 802060c:	ffffde0b 	.word	0xffffde0b
 8020610:	fffff26e 	.word	0xfffff26e
 8020614:	ffffb409 	.word	0xffffb409
 8020618:	ffffc9e6 	.word	0xffffc9e6
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 802061c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp26 - tmp16,
 8020620:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8020624:	441a      	add	r2, r3
 8020626:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802062a:	3307      	adds	r3, #7
 802062c:	7812      	ldrb	r2, [r2, #0]
 802062e:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8020630:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8020634:	3320      	adds	r3, #32
 8020636:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
  for (ctr = 0; ctr < 7; ctr++) {
 802063a:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 802063e:	3301      	adds	r3, #1
 8020640:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 8020644:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8020648:	2b06      	cmp	r3, #6
 802064a:	f77f ad79 	ble.w	8020140 <jpeg_idct_14x7+0x36c>
  }
}
 802064e:	bf00      	nop
 8020650:	bf00      	nop
 8020652:	f507 77a8 	add.w	r7, r7, #336	; 0x150
 8020656:	46bd      	mov	sp, r7
 8020658:	bc90      	pop	{r4, r7}
 802065a:	4770      	bx	lr

0802065c <jpeg_idct_12x6>:

GLOBAL(void)
jpeg_idct_12x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 802065c:	b490      	push	{r4, r7}
 802065e:	b0ca      	sub	sp, #296	; 0x128
 8020660:	af00      	add	r7, sp, #0
 8020662:	f107 040c 	add.w	r4, r7, #12
 8020666:	6020      	str	r0, [r4, #0]
 8020668:	f107 0008 	add.w	r0, r7, #8
 802066c:	6001      	str	r1, [r0, #0]
 802066e:	1d39      	adds	r1, r7, #4
 8020670:	600a      	str	r2, [r1, #0]
 8020672:	463a      	mov	r2, r7
 8020674:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8020676:	f107 030c 	add.w	r3, r7, #12
 802067a:	681b      	ldr	r3, [r3, #0]
 802067c:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8020680:	3380      	adds	r3, #128	; 0x80
 8020682:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 8020686:	1d3b      	adds	r3, r7, #4
 8020688:	681b      	ldr	r3, [r3, #0]
 802068a:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802068e:	f107 0308 	add.w	r3, r7, #8
 8020692:	681b      	ldr	r3, [r3, #0]
 8020694:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8020696:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  wsptr = workspace;
 802069a:	f107 0310 	add.w	r3, r7, #16
 802069e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 80206a2:	2300      	movs	r3, #0
 80206a4:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 80206a8:	e105      	b.n	80208b6 <jpeg_idct_12x6+0x25a>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 80206aa:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80206ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 80206b2:	461a      	mov	r2, r3
 80206b4:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80206b8:	681b      	ldr	r3, [r3, #0]
 80206ba:	fb03 f302 	mul.w	r3, r3, r2
 80206be:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp10 <<= CONST_BITS;
 80206c2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80206c6:	035b      	lsls	r3, r3, #13
 80206c8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    /* Add fudge factor here for final descale. */
    tmp10 += ONE << (CONST_BITS-PASS1_BITS-1);
 80206cc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80206d0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80206d4:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp12 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 80206d8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80206dc:	3340      	adds	r3, #64	; 0x40
 80206de:	f9b3 3000 	ldrsh.w	r3, [r3]
 80206e2:	461a      	mov	r2, r3
 80206e4:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80206e8:	3380      	adds	r3, #128	; 0x80
 80206ea:	681b      	ldr	r3, [r3, #0]
 80206ec:	fb03 f302 	mul.w	r3, r3, r2
 80206f0:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 80206f4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80206f8:	f241 62a1 	movw	r2, #5793	; 0x16a1
 80206fc:	fb02 f303 	mul.w	r3, r2, r3
 8020700:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp11 = tmp10 + tmp20;
 8020704:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8020708:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802070c:	4413      	add	r3, r2
 802070e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp21 = RIGHT_SHIFT(tmp10 - tmp20 - tmp20, CONST_BITS-PASS1_BITS);
 8020712:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8020716:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802071a:	1ad2      	subs	r2, r2, r3
 802071c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8020720:	1ad3      	subs	r3, r2, r3
 8020722:	12db      	asrs	r3, r3, #11
 8020724:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    tmp20 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8020728:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802072c:	3320      	adds	r3, #32
 802072e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020732:	461a      	mov	r2, r3
 8020734:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8020738:	3340      	adds	r3, #64	; 0x40
 802073a:	681b      	ldr	r3, [r3, #0]
 802073c:	fb03 f302 	mul.w	r3, r3, r2
 8020740:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 8020744:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8020748:	f242 7231 	movw	r2, #10033	; 0x2731
 802074c:	fb02 f303 	mul.w	r3, r2, r3
 8020750:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp20 = tmp11 + tmp10;
 8020754:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020758:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 802075c:	4413      	add	r3, r2
 802075e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp22 = tmp11 - tmp10;
 8020762:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020766:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 802076a:	1ad3      	subs	r3, r2, r3
 802076c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8020770:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8020774:	3310      	adds	r3, #16
 8020776:	f9b3 3000 	ldrsh.w	r3, [r3]
 802077a:	461a      	mov	r2, r3
 802077c:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8020780:	3320      	adds	r3, #32
 8020782:	681b      	ldr	r3, [r3, #0]
 8020784:	fb03 f302 	mul.w	r3, r3, r2
 8020788:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 802078c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8020790:	3330      	adds	r3, #48	; 0x30
 8020792:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020796:	461a      	mov	r2, r3
 8020798:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 802079c:	3360      	adds	r3, #96	; 0x60
 802079e:	681b      	ldr	r3, [r3, #0]
 80207a0:	fb03 f302 	mul.w	r3, r3, r2
 80207a4:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 80207a8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80207ac:	3350      	adds	r3, #80	; 0x50
 80207ae:	f9b3 3000 	ldrsh.w	r3, [r3]
 80207b2:	461a      	mov	r2, r3
 80207b4:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80207b8:	33a0      	adds	r3, #160	; 0xa0
 80207ba:	681b      	ldr	r3, [r3, #0]
 80207bc:	fb03 f302 	mul.w	r3, r3, r2
 80207c0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 80207c4:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 80207c8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80207cc:	4413      	add	r3, r2
 80207ce:	f640 32b6 	movw	r2, #2998	; 0xbb6
 80207d2:	fb02 f303 	mul.w	r3, r2, r3
 80207d6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 80207da:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 80207de:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80207e2:	4413      	add	r3, r2
 80207e4:	035b      	lsls	r3, r3, #13
 80207e6:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80207ea:	4413      	add	r3, r2
 80207ec:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 80207f0:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 80207f4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80207f8:	1ad3      	subs	r3, r2, r3
 80207fa:	035b      	lsls	r3, r3, #13
 80207fc:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020800:	4413      	add	r3, r2
 8020802:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp11 = (z1 - z2 - z3) << PASS1_BITS;
 8020806:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 802080a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 802080e:	1ad2      	subs	r2, r2, r3
 8020810:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8020814:	1ad3      	subs	r3, r2, r3
 8020816:	009b      	lsls	r3, r3, #2
 8020818:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 802081c:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8020820:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8020824:	4413      	add	r3, r2
 8020826:	12da      	asrs	r2, r3, #11
 8020828:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802082c:	601a      	str	r2, [r3, #0]
    wsptr[8*5] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 802082e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8020832:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8020836:	1ad2      	subs	r2, r2, r3
 8020838:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802083c:	33a0      	adds	r3, #160	; 0xa0
 802083e:	12d2      	asrs	r2, r2, #11
 8020840:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp21 + tmp11);
 8020842:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020846:	3320      	adds	r3, #32
 8020848:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 802084c:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020850:	440a      	add	r2, r1
 8020852:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) (tmp21 - tmp11);
 8020854:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020858:	3380      	adds	r3, #128	; 0x80
 802085a:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 802085e:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8020862:	1a8a      	subs	r2, r1, r2
 8020864:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8020866:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802086a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802086e:	441a      	add	r2, r3
 8020870:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020874:	3340      	adds	r3, #64	; 0x40
 8020876:	12d2      	asrs	r2, r2, #11
 8020878:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802087a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802087e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020882:	1ad2      	subs	r2, r2, r3
 8020884:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020888:	3360      	adds	r3, #96	; 0x60
 802088a:	12d2      	asrs	r2, r2, #11
 802088c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802088e:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8020892:	3301      	adds	r3, #1
 8020894:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 8020898:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802089c:	3302      	adds	r3, #2
 802089e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80208a2:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80208a6:	3304      	adds	r3, #4
 80208a8:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 80208ac:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80208b0:	3304      	adds	r3, #4
 80208b2:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 80208b6:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 80208ba:	2b07      	cmp	r3, #7
 80208bc:	f77f aef5 	ble.w	80206aa <jpeg_idct_12x6+0x4e>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  wsptr = workspace;
 80208c0:	f107 0310 	add.w	r3, r7, #16
 80208c4:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 80208c8:	2300      	movs	r3, #0
 80208ca:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 80208ce:	e21a      	b.n	8020d06 <jpeg_idct_12x6+0x6aa>
    outptr = output_buf[ctr] + output_col;
 80208d0:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 80208d4:	009b      	lsls	r3, r3, #2
 80208d6:	463a      	mov	r2, r7
 80208d8:	6812      	ldr	r2, [r2, #0]
 80208da:	4413      	add	r3, r2
 80208dc:	681a      	ldr	r2, [r3, #0]
 80208de:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80208e2:	4413      	add	r3, r2
 80208e4:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80208e8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80208ec:	681b      	ldr	r3, [r3, #0]
 80208ee:	3310      	adds	r3, #16
 80208f0:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    z3 <<= CONST_BITS;
 80208f4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80208f8:	035b      	lsls	r3, r3, #13
 80208fa:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    z4 = (INT32) wsptr[4];
 80208fe:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020902:	3310      	adds	r3, #16
 8020904:	681b      	ldr	r3, [r3, #0]
 8020906:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 802090a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 802090e:	f242 7231 	movw	r2, #10033	; 0x2731
 8020912:	fb02 f303 	mul.w	r3, r2, r3
 8020916:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

    tmp10 = z3 + z4;
 802091a:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 802091e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020922:	4413      	add	r3, r2
 8020924:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp11 = z3 - z4;
 8020928:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 802092c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020930:	1ad3      	subs	r3, r2, r3
 8020932:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    z1 = (INT32) wsptr[2];
 8020936:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802093a:	3308      	adds	r3, #8
 802093c:	681b      	ldr	r3, [r3, #0]
 802093e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8020942:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020946:	f642 32b6 	movw	r2, #11190	; 0x2bb6
 802094a:	fb02 f303 	mul.w	r3, r2, r3
 802094e:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    z1 <<= CONST_BITS;
 8020952:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020956:	035b      	lsls	r3, r3, #13
 8020958:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    z2 = (INT32) wsptr[6];
 802095c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020960:	3318      	adds	r3, #24
 8020962:	681b      	ldr	r3, [r3, #0]
 8020964:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z2 <<= CONST_BITS;
 8020968:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 802096c:	035b      	lsls	r3, r3, #13
 802096e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8

    tmp12 = z1 - z2;
 8020972:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020976:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 802097a:	1ad3      	subs	r3, r2, r3
 802097c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp21 = z3 + tmp12;
 8020980:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020984:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020988:	4413      	add	r3, r2
 802098a:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    tmp24 = z3 - tmp12;
 802098e:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020992:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020996:	1ad3      	subs	r3, r2, r3
 8020998:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec

    tmp12 = z4 + z2;
 802099c:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 80209a0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80209a4:	4413      	add	r3, r2
 80209a6:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp20 = tmp10 + tmp12;
 80209aa:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80209ae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80209b2:	4413      	add	r3, r2
 80209b4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp25 = tmp10 - tmp12;
 80209b8:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80209bc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80209c0:	1ad3      	subs	r3, r2, r3
 80209c2:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    tmp12 = z4 - z1 - z2;
 80209c6:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 80209ca:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80209ce:	1ad2      	subs	r2, r2, r3
 80209d0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80209d4:	1ad3      	subs	r3, r2, r3
 80209d6:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp22 = tmp11 + tmp12;
 80209da:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80209de:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80209e2:	4413      	add	r3, r2
 80209e4:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    tmp23 = tmp11 - tmp12;
 80209e8:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80209ec:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80209f0:	1ad3      	subs	r3, r2, r3
 80209f2:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80209f6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80209fa:	3304      	adds	r3, #4
 80209fc:	681b      	ldr	r3, [r3, #0]
 80209fe:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    z2 = (INT32) wsptr[3];
 8020a02:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020a06:	330c      	adds	r3, #12
 8020a08:	681b      	ldr	r3, [r3, #0]
 8020a0a:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z3 = (INT32) wsptr[5];
 8020a0e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020a12:	3314      	adds	r3, #20
 8020a14:	681b      	ldr	r3, [r3, #0]
 8020a16:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    z4 = (INT32) wsptr[7];
 8020a1a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020a1e:	331c      	adds	r3, #28
 8020a20:	681b      	ldr	r3, [r3, #0]
 8020a22:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 8020a26:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020a2a:	f642 12cf 	movw	r2, #10703	; 0x29cf
 8020a2e:	fb02 f303 	mul.w	r3, r2, r3
 8020a32:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 8020a36:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020a3a:	4ab9      	ldr	r2, [pc, #740]	; (8020d20 <jpeg_idct_12x6+0x6c4>)
 8020a3c:	fb02 f303 	mul.w	r3, r2, r3
 8020a40:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8

    tmp10 = z1 + z3;
 8020a44:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020a48:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8020a4c:	4413      	add	r3, r2
 8020a4e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 8020a52:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8020a56:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020a5a:	4413      	add	r3, r2
 8020a5c:	f641 328d 	movw	r2, #7053	; 0x1b8d
 8020a60:	fb02 f303 	mul.w	r3, r2, r3
 8020a64:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 8020a68:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8020a6c:	f640 025b 	movw	r2, #2139	; 0x85b
 8020a70:	fb02 f303 	mul.w	r3, r2, r3
 8020a74:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8020a78:	4413      	add	r3, r2
 8020a7a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 8020a7e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8020a82:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8020a86:	18d1      	adds	r1, r2, r3
 8020a88:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020a8c:	4613      	mov	r3, r2
 8020a8e:	00db      	lsls	r3, r3, #3
 8020a90:	4413      	add	r3, r2
 8020a92:	021a      	lsls	r2, r3, #8
 8020a94:	1ad3      	subs	r3, r2, r3
 8020a96:	440b      	add	r3, r1
 8020a98:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 8020a9c:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020aa0:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020aa4:	4413      	add	r3, r2
 8020aa6:	4a9f      	ldr	r2, [pc, #636]	; (8020d24 <jpeg_idct_12x6+0x6c8>)
 8020aa8:	fb02 f303 	mul.w	r3, r2, r3
 8020aac:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 8020ab0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8020ab4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020ab8:	441a      	add	r2, r3
 8020aba:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8020abe:	499a      	ldr	r1, [pc, #616]	; (8020d28 <jpeg_idct_12x6+0x6cc>)
 8020ac0:	fb01 f303 	mul.w	r3, r1, r3
 8020ac4:	4413      	add	r3, r2
 8020ac6:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8020aca:	4413      	add	r3, r2
 8020acc:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8020ad0:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8020ad4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8020ad8:	1ad2      	subs	r2, r2, r3
 8020ada:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020ade:	f243 21c6 	movw	r1, #12998	; 0x32c6
 8020ae2:	fb01 f303 	mul.w	r3, r1, r3
 8020ae6:	4413      	add	r3, r2
 8020ae8:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8020aec:	4413      	add	r3, r2
 8020aee:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8020af2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020af6:	4a8d      	ldr	r2, [pc, #564]	; (8020d2c <jpeg_idct_12x6+0x6d0>)
 8020af8:	fb02 f203 	mul.w	r2, r2, r3
 8020afc:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020b00:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8020b02:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020b06:	498a      	ldr	r1, [pc, #552]	; (8020d30 <jpeg_idct_12x6+0x6d4>)
 8020b08:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8020b0c:	4413      	add	r3, r2
 8020b0e:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8020b12:	4413      	add	r3, r2
 8020b14:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4

    z1 -= z4;
 8020b18:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020b1c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020b20:	1ad3      	subs	r3, r2, r3
 8020b22:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    z2 -= z3;
 8020b26:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8020b2a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8020b2e:	1ad3      	subs	r3, r2, r3
 8020b30:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8020b34:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8020b38:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020b3c:	4413      	add	r3, r2
 8020b3e:	f241 1251 	movw	r2, #4433	; 0x1151
 8020b42:	fb02 f303 	mul.w	r3, r2, r3
 8020b46:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 8020b4a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020b4e:	f641 027e 	movw	r2, #6270	; 0x187e
 8020b52:	fb02 f303 	mul.w	r3, r2, r3
 8020b56:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020b5a:	4413      	add	r3, r2
 8020b5c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 8020b60:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020b64:	4a73      	ldr	r2, [pc, #460]	; (8020d34 <jpeg_idct_12x6+0x6d8>)
 8020b66:	fb02 f303 	mul.w	r3, r2, r3
 8020b6a:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8020b6e:	4413      	add	r3, r2
 8020b70:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8

    /* Final output stage */

    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8020b74:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8020b78:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8020b7c:	4413      	add	r3, r2
 8020b7e:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020b80:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0]  = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8020b84:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020b88:	4413      	add	r3, r2
 8020b8a:	781a      	ldrb	r2, [r3, #0]
 8020b8c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020b90:	701a      	strb	r2, [r3, #0]
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8020b92:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8020b96:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8020b9a:	1ad3      	subs	r3, r2, r3
 8020b9c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020b9e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[11] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8020ba2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020ba6:	441a      	add	r2, r3
 8020ba8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020bac:	330b      	adds	r3, #11
 8020bae:	7812      	ldrb	r2, [r2, #0]
 8020bb0:	701a      	strb	r2, [r3, #0]
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8020bb2:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8020bb6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8020bba:	4413      	add	r3, r2
 8020bbc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020bbe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1]  = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8020bc2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020bc6:	441a      	add	r2, r3
 8020bc8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020bcc:	3301      	adds	r3, #1
 8020bce:	7812      	ldrb	r2, [r2, #0]
 8020bd0:	701a      	strb	r2, [r3, #0]
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8020bd2:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8020bd6:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8020bda:	1ad3      	subs	r3, r2, r3
 8020bdc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020bde:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[10] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8020be2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020be6:	441a      	add	r2, r3
 8020be8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020bec:	330a      	adds	r3, #10
 8020bee:	7812      	ldrb	r2, [r2, #0]
 8020bf0:	701a      	strb	r2, [r3, #0]
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8020bf2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8020bf6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020bfa:	4413      	add	r3, r2
 8020bfc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020bfe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2]  = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8020c02:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020c06:	441a      	add	r2, r3
 8020c08:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020c0c:	3302      	adds	r3, #2
 8020c0e:	7812      	ldrb	r2, [r2, #0]
 8020c10:	701a      	strb	r2, [r3, #0]
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8020c12:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8020c16:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020c1a:	1ad3      	subs	r3, r2, r3
 8020c1c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020c1e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9]  = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8020c22:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020c26:	441a      	add	r2, r3
 8020c28:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020c2c:	3309      	adds	r3, #9
 8020c2e:	7812      	ldrb	r2, [r2, #0]
 8020c30:	701a      	strb	r2, [r3, #0]
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020c32:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8020c36:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8020c3a:	4413      	add	r3, r2
 8020c3c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020c3e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3]  = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8020c42:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020c46:	441a      	add	r2, r3
 8020c48:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020c4c:	3303      	adds	r3, #3
 8020c4e:	7812      	ldrb	r2, [r2, #0]
 8020c50:	701a      	strb	r2, [r3, #0]
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020c52:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8020c56:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8020c5a:	1ad3      	subs	r3, r2, r3
 8020c5c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020c5e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8]  = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8020c62:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020c66:	441a      	add	r2, r3
 8020c68:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020c6c:	3308      	adds	r3, #8
 8020c6e:	7812      	ldrb	r2, [r2, #0]
 8020c70:	701a      	strb	r2, [r3, #0]
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020c72:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8020c76:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020c7a:	4413      	add	r3, r2
 8020c7c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020c7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4]  = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 8020c82:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020c86:	441a      	add	r2, r3
 8020c88:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020c8c:	3304      	adds	r3, #4
 8020c8e:	7812      	ldrb	r2, [r2, #0]
 8020c90:	701a      	strb	r2, [r3, #0]
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020c92:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8020c96:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020c9a:	1ad3      	subs	r3, r2, r3
 8020c9c:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020c9e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7]  = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 8020ca2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020ca6:	441a      	add	r2, r3
 8020ca8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020cac:	3307      	adds	r3, #7
 8020cae:	7812      	ldrb	r2, [r2, #0]
 8020cb0:	701a      	strb	r2, [r3, #0]
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8020cb2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020cb6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8020cba:	4413      	add	r3, r2
 8020cbc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020cbe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5]  = range_limit[(int) RIGHT_SHIFT(tmp25 + tmp15,
 8020cc2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020cc6:	441a      	add	r2, r3
 8020cc8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020ccc:	3305      	adds	r3, #5
 8020cce:	7812      	ldrb	r2, [r2, #0]
 8020cd0:	701a      	strb	r2, [r3, #0]
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8020cd2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020cd6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8020cda:	1ad3      	subs	r3, r2, r3
 8020cdc:	149b      	asrs	r3, r3, #18
					       CONST_BITS+PASS1_BITS+3)
			     & RANGE_MASK];
 8020cde:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6]  = range_limit[(int) RIGHT_SHIFT(tmp25 - tmp15,
 8020ce2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020ce6:	441a      	add	r2, r3
 8020ce8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8020cec:	3306      	adds	r3, #6
 8020cee:	7812      	ldrb	r2, [r2, #0]
 8020cf0:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 8020cf2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020cf6:	3320      	adds	r3, #32
 8020cf8:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  for (ctr = 0; ctr < 6; ctr++) {
 8020cfc:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8020d00:	3301      	adds	r3, #1
 8020d02:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 8020d06:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8020d0a:	2b05      	cmp	r3, #5
 8020d0c:	f77f ade0 	ble.w	80208d0 <jpeg_idct_12x6+0x274>
  }
}
 8020d10:	bf00      	nop
 8020d12:	bf00      	nop
 8020d14:	f507 7794 	add.w	r7, r7, #296	; 0x128
 8020d18:	46bd      	mov	sp, r7
 8020d1a:	bc90      	pop	{r4, r7}
 8020d1c:	4770      	bx	lr
 8020d1e:	bf00      	nop
 8020d20:	ffffeeaf 	.word	0xffffeeaf
 8020d24:	ffffde8b 	.word	0xffffde8b
 8020d28:	ffffd0b0 	.word	0xffffd0b0
 8020d2c:	ffffea5c 	.word	0xffffea5c
 8020d30:	ffffc08c 	.word	0xffffc08c
 8020d34:	ffffc4df 	.word	0xffffc4df

08020d38 <jpeg_idct_10x5>:

GLOBAL(void)
jpeg_idct_10x5 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8020d38:	b480      	push	{r7}
 8020d3a:	b0c1      	sub	sp, #260	; 0x104
 8020d3c:	af00      	add	r7, sp, #0
 8020d3e:	60f8      	str	r0, [r7, #12]
 8020d40:	60b9      	str	r1, [r7, #8]
 8020d42:	607a      	str	r2, [r7, #4]
 8020d44:	463a      	mov	r2, r7
 8020d46:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8020d48:	68fb      	ldr	r3, [r7, #12]
 8020d4a:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8020d4e:	3380      	adds	r3, #128	; 0x80
 8020d50:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  inptr = coef_block;
 8020d54:	687b      	ldr	r3, [r7, #4]
 8020d56:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8020d5a:	68bb      	ldr	r3, [r7, #8]
 8020d5c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8020d5e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
  wsptr = workspace;
 8020d62:	f107 0310 	add.w	r3, r7, #16
 8020d66:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020d6a:	2300      	movs	r3, #0
 8020d6c:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8020d70:	e0e3      	b.n	8020f3a <jpeg_idct_10x5+0x202>
    /* Even part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8020d72:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020d76:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020d7a:	461a      	mov	r2, r3
 8020d7c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020d80:	681b      	ldr	r3, [r3, #0]
 8020d82:	fb03 f302 	mul.w	r3, r3, r2
 8020d86:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
    tmp12 <<= CONST_BITS;
 8020d8a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8020d8e:	035b      	lsls	r3, r3, #13
 8020d90:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
    /* Add fudge factor here for final descale. */
    tmp12 += ONE << (CONST_BITS-PASS1_BITS-1);
 8020d94:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8020d98:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8020d9c:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
    tmp13 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8020da0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020da4:	3320      	adds	r3, #32
 8020da6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020daa:	461a      	mov	r2, r3
 8020dac:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020db0:	3340      	adds	r3, #64	; 0x40
 8020db2:	681b      	ldr	r3, [r3, #0]
 8020db4:	fb03 f302 	mul.w	r3, r3, r2
 8020db8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp14 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8020dbc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020dc0:	3340      	adds	r3, #64	; 0x40
 8020dc2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020dc6:	461a      	mov	r2, r3
 8020dc8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020dcc:	3380      	adds	r3, #128	; 0x80
 8020dce:	681b      	ldr	r3, [r3, #0]
 8020dd0:	fb03 f302 	mul.w	r3, r3, r2
 8020dd4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 8020dd8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8020ddc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8020de0:	4413      	add	r3, r2
 8020de2:	f641 124c 	movw	r2, #6476	; 0x194c
 8020de6:	fb02 f303 	mul.w	r3, r2, r3
 8020dea:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 8020dee:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8020df2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8020df6:	1ad3      	subs	r3, r2, r3
 8020df8:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 8020dfc:	fb02 f303 	mul.w	r3, r2, r3
 8020e00:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z3 = tmp12 + z2;
 8020e04:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 8020e08:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020e0c:	4413      	add	r3, r2
 8020e0e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    tmp10 = z3 + z1;
 8020e12:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020e16:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8020e1a:	4413      	add	r3, r2
 8020e1c:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    tmp11 = z3 - z1;
 8020e20:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020e24:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8020e28:	1ad3      	subs	r3, r2, r3
 8020e2a:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    tmp12 -= z2 << 2;
 8020e2e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020e32:	009b      	lsls	r3, r3, #2
 8020e34:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 8020e38:	1ad3      	subs	r3, r2, r3
 8020e3a:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

    /* Odd part */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8020e3e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020e42:	3310      	adds	r3, #16
 8020e44:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020e48:	461a      	mov	r2, r3
 8020e4a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020e4e:	3320      	adds	r3, #32
 8020e50:	681b      	ldr	r3, [r3, #0]
 8020e52:	fb03 f302 	mul.w	r3, r3, r2
 8020e56:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8020e5a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020e5e:	3330      	adds	r3, #48	; 0x30
 8020e60:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020e64:	461a      	mov	r2, r3
 8020e66:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020e6a:	3360      	adds	r3, #96	; 0x60
 8020e6c:	681b      	ldr	r3, [r3, #0]
 8020e6e:	fb03 f302 	mul.w	r3, r3, r2
 8020e72:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 8020e76:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8020e7a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8020e7e:	4413      	add	r3, r2
 8020e80:	f641 229a 	movw	r2, #6810	; 0x1a9a
 8020e84:	fb02 f303 	mul.w	r3, r2, r3
 8020e88:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 8020e8c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020e90:	f241 0271 	movw	r2, #4209	; 0x1071
 8020e94:	fb02 f303 	mul.w	r3, r2, r3
 8020e98:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8020e9c:	4413      	add	r3, r2
 8020e9e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 8020ea2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8020ea6:	4a2b      	ldr	r2, [pc, #172]	; (8020f54 <jpeg_idct_10x5+0x21c>)
 8020ea8:	fb02 f303 	mul.w	r3, r2, r3
 8020eac:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8020eb0:	4413      	add	r3, r2
 8020eb2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Final output stage */

    wsptr[8*0] = (int) RIGHT_SHIFT(tmp10 + tmp13, CONST_BITS-PASS1_BITS);
 8020eb6:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8020eba:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8020ebe:	4413      	add	r3, r2
 8020ec0:	12da      	asrs	r2, r3, #11
 8020ec2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020ec6:	601a      	str	r2, [r3, #0]
    wsptr[8*4] = (int) RIGHT_SHIFT(tmp10 - tmp13, CONST_BITS-PASS1_BITS);
 8020ec8:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8020ecc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8020ed0:	1ad2      	subs	r2, r2, r3
 8020ed2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020ed6:	3380      	adds	r3, #128	; 0x80
 8020ed8:	12d2      	asrs	r2, r2, #11
 8020eda:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) RIGHT_SHIFT(tmp11 + tmp14, CONST_BITS-PASS1_BITS);
 8020edc:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8020ee0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8020ee4:	441a      	add	r2, r3
 8020ee6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020eea:	3320      	adds	r3, #32
 8020eec:	12d2      	asrs	r2, r2, #11
 8020eee:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) RIGHT_SHIFT(tmp11 - tmp14, CONST_BITS-PASS1_BITS);
 8020ef0:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8020ef4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8020ef8:	1ad2      	subs	r2, r2, r3
 8020efa:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020efe:	3360      	adds	r3, #96	; 0x60
 8020f00:	12d2      	asrs	r2, r2, #11
 8020f02:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) RIGHT_SHIFT(tmp12, CONST_BITS-PASS1_BITS);
 8020f04:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020f08:	3340      	adds	r3, #64	; 0x40
 8020f0a:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 8020f0e:	12d2      	asrs	r2, r2, #11
 8020f10:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8020f12:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8020f16:	3301      	adds	r3, #1
 8020f18:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8020f1c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8020f20:	3302      	adds	r3, #2
 8020f22:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8020f26:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8020f2a:	3304      	adds	r3, #4
 8020f2c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8020f30:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020f34:	3304      	adds	r3, #4
 8020f36:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 8020f3a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8020f3e:	2b07      	cmp	r3, #7
 8020f40:	f77f af17 	ble.w	8020d72 <jpeg_idct_10x5+0x3a>
  }

  /* Pass 2: process 5 rows from work array, store into output array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  wsptr = workspace;
 8020f44:	f107 0310 	add.w	r3, r7, #16
 8020f48:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 8020f4c:	2300      	movs	r3, #0
 8020f4e:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8020f52:	e1d0      	b.n	80212f6 <jpeg_idct_10x5+0x5be>
 8020f54:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 8020f58:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8020f5c:	009b      	lsls	r3, r3, #2
 8020f5e:	463a      	mov	r2, r7
 8020f60:	6812      	ldr	r2, [r2, #0]
 8020f62:	4413      	add	r3, r2
 8020f64:	681a      	ldr	r2, [r3, #0]
 8020f66:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8020f6a:	4413      	add	r3, r2
 8020f6c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

    /* Even part */

    /* Add fudge factor here for final descale. */
    z3 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8020f70:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020f74:	681b      	ldr	r3, [r3, #0]
 8020f76:	3310      	adds	r3, #16
 8020f78:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    z3 <<= CONST_BITS;
 8020f7c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8020f80:	035b      	lsls	r3, r3, #13
 8020f82:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    z4 = (INT32) wsptr[4];
 8020f86:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020f8a:	3310      	adds	r3, #16
 8020f8c:	681b      	ldr	r3, [r3, #0]
 8020f8e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 8020f92:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8020f96:	f242 429d 	movw	r2, #9373	; 0x249d
 8020f9a:	fb02 f303 	mul.w	r3, r2, r3
 8020f9e:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 8020fa2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8020fa6:	f640 52fc 	movw	r2, #3580	; 0xdfc
 8020faa:	fb02 f303 	mul.w	r3, r2, r3
 8020fae:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    tmp10 = z3 + z1;
 8020fb2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020fb6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8020fba:	4413      	add	r3, r2
 8020fbc:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    tmp11 = z3 - z2;
 8020fc0:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020fc4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020fc8:	1ad3      	subs	r3, r2, r3
 8020fca:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

    tmp22 = z3 - ((z1 - z2) << 1);               /* c0 = (c4-c8)*2 */
 8020fce:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8020fd2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8020fd6:	1ad3      	subs	r3, r2, r3
 8020fd8:	005b      	lsls	r3, r3, #1
 8020fda:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8020fde:	1ad3      	subs	r3, r2, r3
 8020fe0:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc

    z2 = (INT32) wsptr[2];
 8020fe4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020fe8:	3308      	adds	r3, #8
 8020fea:	681b      	ldr	r3, [r3, #0]
 8020fec:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z3 = (INT32) wsptr[6];
 8020ff0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8020ff4:	3318      	adds	r3, #24
 8020ff6:	681b      	ldr	r3, [r3, #0]
 8020ff8:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8020ffc:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8021000:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8021004:	4413      	add	r3, r2
 8021006:	f641 229a 	movw	r2, #6810	; 0x1a9a
 802100a:	fb02 f303 	mul.w	r3, r2, r3
 802100e:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 8021012:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8021016:	f241 0271 	movw	r2, #4209	; 0x1071
 802101a:	fb02 f303 	mul.w	r3, r2, r3
 802101e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8021022:	4413      	add	r3, r2
 8021024:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 8021028:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802102c:	4ab8      	ldr	r2, [pc, #736]	; (8021310 <jpeg_idct_10x5+0x5d8>)
 802102e:	fb02 f303 	mul.w	r3, r2, r3
 8021032:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8021036:	4413      	add	r3, r2
 8021038:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

    tmp20 = tmp10 + tmp12;
 802103c:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8021040:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8021044:	4413      	add	r3, r2
 8021046:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    tmp24 = tmp10 - tmp12;
 802104a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 802104e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8021052:	1ad3      	subs	r3, r2, r3
 8021054:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp21 = tmp11 + tmp13;
 8021058:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 802105c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8021060:	4413      	add	r3, r2
 8021062:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp23 = tmp11 - tmp13;
 8021066:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 802106a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 802106e:	1ad3      	subs	r3, r2, r3
 8021070:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8021074:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8021078:	3304      	adds	r3, #4
 802107a:	681b      	ldr	r3, [r3, #0]
 802107c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    z2 = (INT32) wsptr[3];
 8021080:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8021084:	330c      	adds	r3, #12
 8021086:	681b      	ldr	r3, [r3, #0]
 8021088:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z3 = (INT32) wsptr[5];
 802108c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8021090:	3314      	adds	r3, #20
 8021092:	681b      	ldr	r3, [r3, #0]
 8021094:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    z3 <<= CONST_BITS;
 8021098:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802109c:	035b      	lsls	r3, r3, #13
 802109e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    z4 = (INT32) wsptr[7];
 80210a2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80210a6:	331c      	adds	r3, #28
 80210a8:	681b      	ldr	r3, [r3, #0]
 80210aa:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    tmp11 = z2 + z4;
 80210ae:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 80210b2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80210b6:	4413      	add	r3, r2
 80210b8:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    tmp13 = z2 - z4;
 80210bc:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 80210c0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80210c4:	1ad3      	subs	r3, r2, r3
 80210c6:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 80210ca:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80210ce:	f640 12e3 	movw	r2, #2531	; 0x9e3
 80210d2:	fb02 f303 	mul.w	r3, r2, r3
 80210d6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 80210da:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80210de:	f641 626f 	movw	r2, #7791	; 0x1e6f
 80210e2:	fb02 f303 	mul.w	r3, r2, r3
 80210e6:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z4 = z3 + tmp12;
 80210ea:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 80210ee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80210f2:	4413      	add	r3, r2
 80210f4:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 80210f8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80210fc:	f642 42b3 	movw	r2, #11443	; 0x2cb3
 8021100:	fb02 f203 	mul.w	r2, r2, r3
 8021104:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8021108:	4413      	add	r3, r2
 802110a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802110e:	4413      	add	r3, r2
 8021110:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 8021114:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8021118:	f240 7214 	movw	r2, #1812	; 0x714
 802111c:	fb02 f203 	mul.w	r2, r2, r3
 8021120:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8021124:	1ad3      	subs	r3, r2, r3
 8021126:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802112a:	4413      	add	r3, r2
 802112c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 8021130:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8021134:	f241 22cf 	movw	r2, #4815	; 0x12cf
 8021138:	fb02 f303 	mul.w	r3, r2, r3
 802113c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    z4 = z3 - tmp12 - (tmp13 << (CONST_BITS - 1));
 8021140:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8021144:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8021148:	1ad2      	subs	r2, r2, r3
 802114a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 802114e:	031b      	lsls	r3, r3, #12
 8021150:	1ad3      	subs	r3, r2, r3
 8021152:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    tmp12 = ((z1 - tmp13) << CONST_BITS) - z3;
 8021156:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 802115a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 802115e:	1ad3      	subs	r3, r2, r3
 8021160:	035a      	lsls	r2, r3, #13
 8021162:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8021166:	1ad3      	subs	r3, r2, r3
 8021168:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 802116c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8021170:	f642 0253 	movw	r2, #10323	; 0x2853
 8021174:	fb02 f203 	mul.w	r2, r2, r3
 8021178:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 802117c:	1ad2      	subs	r2, r2, r3
 802117e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8021182:	1ad3      	subs	r3, r2, r3
 8021184:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 8021188:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 802118c:	f241 428c 	movw	r2, #5260	; 0x148c
 8021190:	fb02 f203 	mul.w	r2, r2, r3
 8021194:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8021198:	1ad3      	subs	r3, r2, r3
 802119a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802119e:	4413      	add	r3, r2
 80211a0:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80211a4:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80211a8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80211ac:	4413      	add	r3, r2
 80211ae:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80211b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 80211b4:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80211b8:	4413      	add	r3, r2
 80211ba:	781a      	ldrb	r2, [r3, #0]
 80211bc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80211c0:	701a      	strb	r2, [r3, #0]
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80211c2:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80211c6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80211ca:	1ad3      	subs	r3, r2, r3
 80211cc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80211ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[9] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 80211d2:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80211d6:	441a      	add	r2, r3
 80211d8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80211dc:	3309      	adds	r3, #9
 80211de:	7812      	ldrb	r2, [r2, #0]
 80211e0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80211e2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 80211e6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80211ea:	4413      	add	r3, r2
 80211ec:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80211ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 80211f2:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80211f6:	441a      	add	r2, r3
 80211f8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80211fc:	3301      	adds	r3, #1
 80211fe:	7812      	ldrb	r2, [r2, #0]
 8021200:	701a      	strb	r2, [r3, #0]
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8021202:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8021206:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 802120a:	1ad3      	subs	r3, r2, r3
 802120c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802120e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[8] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8021212:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8021216:	441a      	add	r2, r3
 8021218:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802121c:	3308      	adds	r3, #8
 802121e:	7812      	ldrb	r2, [r2, #0]
 8021220:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8021222:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8021226:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802122a:	4413      	add	r3, r2
 802122c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802122e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8021232:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8021236:	441a      	add	r2, r3
 8021238:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802123c:	3302      	adds	r3, #2
 802123e:	7812      	ldrb	r2, [r2, #0]
 8021240:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8021242:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8021246:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802124a:	1ad3      	subs	r3, r2, r3
 802124c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802124e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8021252:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8021256:	441a      	add	r2, r3
 8021258:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802125c:	3307      	adds	r3, #7
 802125e:	7812      	ldrb	r2, [r2, #0]
 8021260:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8021262:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8021266:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 802126a:	4413      	add	r3, r2
 802126c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802126e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23 + tmp13,
 8021272:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8021276:	441a      	add	r2, r3
 8021278:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802127c:	3303      	adds	r3, #3
 802127e:	7812      	ldrb	r2, [r2, #0]
 8021280:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8021282:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8021286:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 802128a:	1ad3      	subs	r3, r2, r3
 802128c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802128e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp23 - tmp13,
 8021292:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 8021296:	441a      	add	r2, r3
 8021298:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802129c:	3306      	adds	r3, #6
 802129e:	7812      	ldrb	r2, [r2, #0]
 80212a0:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80212a2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80212a6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80212aa:	4413      	add	r3, r2
 80212ac:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80212ae:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp24 + tmp14,
 80212b2:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80212b6:	441a      	add	r2, r3
 80212b8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80212bc:	3304      	adds	r3, #4
 80212be:	7812      	ldrb	r2, [r2, #0]
 80212c0:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80212c2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80212c6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80212ca:	1ad3      	subs	r3, r2, r3
 80212cc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80212ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp24 - tmp14,
 80212d2:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80212d6:	441a      	add	r2, r3
 80212d8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80212dc:	3305      	adds	r3, #5
 80212de:	7812      	ldrb	r2, [r2, #0]
 80212e0:	701a      	strb	r2, [r3, #0]

    wsptr += 8;		/* advance pointer to next row */
 80212e2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80212e6:	3320      	adds	r3, #32
 80212e8:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
  for (ctr = 0; ctr < 5; ctr++) {
 80212ec:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80212f0:	3301      	adds	r3, #1
 80212f2:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 80212f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80212fa:	2b04      	cmp	r3, #4
 80212fc:	f77f ae2c 	ble.w	8020f58 <jpeg_idct_10x5+0x220>
  }
}
 8021300:	bf00      	nop
 8021302:	bf00      	nop
 8021304:	f507 7782 	add.w	r7, r7, #260	; 0x104
 8021308:	46bd      	mov	sp, r7
 802130a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802130e:	4770      	bx	lr
 8021310:	ffffba5c 	.word	0xffffba5c

08021314 <jpeg_idct_8x4>:

GLOBAL(void)
jpeg_idct_8x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021314:	b480      	push	{r7}
 8021316:	b0b7      	sub	sp, #220	; 0xdc
 8021318:	af00      	add	r7, sp, #0
 802131a:	60f8      	str	r0, [r7, #12]
 802131c:	60b9      	str	r1, [r7, #8]
 802131e:	607a      	str	r2, [r7, #4]
 8021320:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021322:	68fb      	ldr	r3, [r7, #12]
 8021324:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8021328:	3380      	adds	r3, #128	; 0x80
 802132a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  inptr = coef_block;
 802132e:	687b      	ldr	r3, [r7, #4]
 8021330:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021334:	68bb      	ldr	r3, [r7, #8]
 8021336:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8021338:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  wsptr = workspace;
 802133c:	f107 0314 	add.w	r3, r7, #20
 8021340:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021344:	2300      	movs	r3, #0
 8021346:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 802134a:	e0a4      	b.n	8021496 <jpeg_idct_8x4+0x182>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802134c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8021350:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021354:	461a      	mov	r2, r3
 8021356:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 802135a:	681b      	ldr	r3, [r3, #0]
 802135c:	fb03 f302 	mul.w	r3, r3, r2
 8021360:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8021364:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8021368:	3320      	adds	r3, #32
 802136a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802136e:	461a      	mov	r2, r3
 8021370:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8021374:	3340      	adds	r3, #64	; 0x40
 8021376:	681b      	ldr	r3, [r3, #0]
 8021378:	fb03 f302 	mul.w	r3, r3, r2
 802137c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    tmp10 = (tmp0 + tmp2) << PASS1_BITS;
 8021380:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8021384:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8021388:	4413      	add	r3, r2
 802138a:	009b      	lsls	r3, r3, #2
 802138c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    tmp12 = (tmp0 - tmp2) << PASS1_BITS;
 8021390:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8021394:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8021398:	1ad3      	subs	r3, r2, r3
 802139a:	009b      	lsls	r3, r3, #2
 802139c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80213a0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80213a4:	3310      	adds	r3, #16
 80213a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80213aa:	461a      	mov	r2, r3
 80213ac:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80213b0:	3320      	adds	r3, #32
 80213b2:	681b      	ldr	r3, [r3, #0]
 80213b4:	fb03 f302 	mul.w	r3, r3, r2
 80213b8:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80213bc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80213c0:	3330      	adds	r3, #48	; 0x30
 80213c2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80213c6:	461a      	mov	r2, r3
 80213c8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80213cc:	3360      	adds	r3, #96	; 0x60
 80213ce:	681b      	ldr	r3, [r3, #0]
 80213d0:	fb03 f302 	mul.w	r3, r3, r2
 80213d4:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);               /* c6 */
 80213d8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80213dc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80213e0:	4413      	add	r3, r2
 80213e2:	f241 1251 	movw	r2, #4433	; 0x1151
 80213e6:	fb02 f303 	mul.w	r3, r2, r3
 80213ea:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 80213ee:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80213f2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80213f6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp0 = RIGHT_SHIFT(z1 + MULTIPLY(z2, FIX_0_765366865), /* c2-c6 */
 80213fa:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80213fe:	f641 027e 	movw	r2, #6270	; 0x187e
 8021402:	fb02 f203 	mul.w	r2, r2, r3
 8021406:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 802140a:	4413      	add	r3, r2
 802140c:	12db      	asrs	r3, r3, #11
 802140e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
		       CONST_BITS-PASS1_BITS);
    tmp2 = RIGHT_SHIFT(z1 - MULTIPLY(z3, FIX_1_847759065), /* c2+c6 */
 8021412:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8021416:	4a26      	ldr	r2, [pc, #152]	; (80214b0 <jpeg_idct_8x4+0x19c>)
 8021418:	fb02 f203 	mul.w	r2, r2, r3
 802141c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8021420:	4413      	add	r3, r2
 8021422:	12db      	asrs	r3, r3, #11
 8021424:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
		       CONST_BITS-PASS1_BITS);

    /* Final output stage */

    wsptr[8*0] = (int) (tmp10 + tmp0);
 8021428:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 802142c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8021430:	441a      	add	r2, r3
 8021432:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021436:	601a      	str	r2, [r3, #0]
    wsptr[8*3] = (int) (tmp10 - tmp0);
 8021438:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 802143c:	3360      	adds	r3, #96	; 0x60
 802143e:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8021442:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8021446:	1a8a      	subs	r2, r1, r2
 8021448:	601a      	str	r2, [r3, #0]
    wsptr[8*1] = (int) (tmp12 + tmp2);
 802144a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 802144e:	3320      	adds	r3, #32
 8021450:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8021454:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8021458:	440a      	add	r2, r1
 802145a:	601a      	str	r2, [r3, #0]
    wsptr[8*2] = (int) (tmp12 - tmp2);
 802145c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021460:	3340      	adds	r3, #64	; 0x40
 8021462:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8021466:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 802146a:	1a8a      	subs	r2, r1, r2
 802146c:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 802146e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8021472:	3301      	adds	r3, #1
 8021474:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8021478:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 802147c:	3302      	adds	r3, #2
 802147e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8021482:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8021486:	3304      	adds	r3, #4
 8021488:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 802148c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021490:	3304      	adds	r3, #4
 8021492:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8021496:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802149a:	2b07      	cmp	r3, #7
 802149c:	f77f af56 	ble.w	802134c <jpeg_idct_8x4+0x38>

  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 80214a0:	f107 0314 	add.w	r3, r7, #20
 80214a4:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 80214a8:	2300      	movs	r3, #0
 80214aa:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 80214ae:	e1a2      	b.n	80217f6 <jpeg_idct_8x4+0x4e2>
 80214b0:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 80214b4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80214b8:	009b      	lsls	r3, r3, #2
 80214ba:	683a      	ldr	r2, [r7, #0]
 80214bc:	4413      	add	r3, r2
 80214be:	681a      	ldr	r2, [r3, #0]
 80214c0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80214c4:	4413      	add	r3, r2
 80214c6:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = (INT32) wsptr[2];
 80214ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80214ce:	3308      	adds	r3, #8
 80214d0:	681b      	ldr	r3, [r3, #0]
 80214d2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 = (INT32) wsptr[6];
 80214d6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80214da:	3318      	adds	r3, #24
 80214dc:	681b      	ldr	r3, [r3, #0]
 80214de:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 80214e2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80214e6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80214ea:	4413      	add	r3, r2
 80214ec:	f241 1251 	movw	r2, #4433	; 0x1151
 80214f0:	fb02 f303 	mul.w	r3, r2, r3
 80214f4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 80214f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80214fc:	f641 027e 	movw	r2, #6270	; 0x187e
 8021500:	fb02 f303 	mul.w	r3, r2, r3
 8021504:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8021508:	4413      	add	r3, r2
 802150a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 802150e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8021512:	4abf      	ldr	r2, [pc, #764]	; (8021810 <jpeg_idct_8x4+0x4fc>)
 8021514:	fb02 f303 	mul.w	r3, r2, r3
 8021518:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 802151c:	4413      	add	r3, r2
 802151e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8021522:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021526:	681b      	ldr	r3, [r3, #0]
 8021528:	3310      	adds	r3, #16
 802152a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 = (INT32) wsptr[4];
 802152e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021532:	3310      	adds	r3, #16
 8021534:	681b      	ldr	r3, [r3, #0]
 8021536:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    
    tmp0 = (z2 + z3) << CONST_BITS;
 802153a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 802153e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8021542:	4413      	add	r3, r2
 8021544:	035b      	lsls	r3, r3, #13
 8021546:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    tmp1 = (z2 - z3) << CONST_BITS;
 802154a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 802154e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8021552:	1ad3      	subs	r3, r2, r3
 8021554:	035b      	lsls	r3, r3, #13
 8021556:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    
    tmp10 = tmp0 + tmp2;
 802155a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 802155e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8021562:	4413      	add	r3, r2
 8021564:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    tmp13 = tmp0 - tmp2;
 8021568:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 802156c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8021570:	1ad3      	subs	r3, r2, r3
 8021572:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    tmp11 = tmp1 + tmp3;
 8021576:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 802157a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 802157e:	4413      	add	r3, r2
 8021580:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    tmp12 = tmp1 - tmp3;
 8021584:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8021588:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 802158c:	1ad3      	subs	r3, r2, r3
 802158e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = (INT32) wsptr[7];
 8021592:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8021596:	331c      	adds	r3, #28
 8021598:	681b      	ldr	r3, [r3, #0]
 802159a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    tmp1 = (INT32) wsptr[5];
 802159e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80215a2:	3314      	adds	r3, #20
 80215a4:	681b      	ldr	r3, [r3, #0]
 80215a6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp2 = (INT32) wsptr[3];
 80215aa:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80215ae:	330c      	adds	r3, #12
 80215b0:	681b      	ldr	r3, [r3, #0]
 80215b2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    tmp3 = (INT32) wsptr[1];
 80215b6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80215ba:	3304      	adds	r3, #4
 80215bc:	681b      	ldr	r3, [r3, #0]
 80215be:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    z2 = tmp0 + tmp2;
 80215c2:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 80215c6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80215ca:	4413      	add	r3, r2
 80215cc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 = tmp1 + tmp3;
 80215d0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80215d4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80215d8:	4413      	add	r3, r2
 80215da:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 80215de:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80215e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80215e6:	4413      	add	r3, r2
 80215e8:	f242 52a1 	movw	r2, #9633	; 0x25a1
 80215ec:	fb02 f303 	mul.w	r3, r2, r3
 80215f0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80215f4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80215f8:	4a86      	ldr	r2, [pc, #536]	; (8021814 <jpeg_idct_8x4+0x500>)
 80215fa:	fb02 f303 	mul.w	r3, r2, r3
 80215fe:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 8021602:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8021606:	4a84      	ldr	r2, [pc, #528]	; (8021818 <jpeg_idct_8x4+0x504>)
 8021608:	fb02 f303 	mul.w	r3, r2, r3
 802160c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    z2 += z1;
 8021610:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8021614:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8021618:	4413      	add	r3, r2
 802161a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    z3 += z1;
 802161e:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8021622:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8021626:	4413      	add	r3, r2
 8021628:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 802162c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8021630:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8021634:	4413      	add	r3, r2
 8021636:	4a79      	ldr	r2, [pc, #484]	; (802181c <jpeg_idct_8x4+0x508>)
 8021638:	fb02 f303 	mul.w	r3, r2, r3
 802163c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8021640:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8021644:	f640 128e 	movw	r2, #2446	; 0x98e
 8021648:	fb02 f303 	mul.w	r3, r2, r3
 802164c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8021650:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8021654:	f243 020b 	movw	r2, #12299	; 0x300b
 8021658:	fb02 f303 	mul.w	r3, r2, r3
 802165c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    tmp0 += z1 + z2;
 8021660:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8021664:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8021668:	4413      	add	r3, r2
 802166a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 802166e:	4413      	add	r3, r2
 8021670:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    tmp3 += z1 + z3;
 8021674:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8021678:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 802167c:	4413      	add	r3, r2
 802167e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8021682:	4413      	add	r3, r2
 8021684:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8021688:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 802168c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8021690:	4413      	add	r3, r2
 8021692:	4a63      	ldr	r2, [pc, #396]	; (8021820 <jpeg_idct_8x4+0x50c>)
 8021694:	fb02 f303 	mul.w	r3, r2, r3
 8021698:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 802169c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80216a0:	f244 12b3 	movw	r2, #16819	; 0x41b3
 80216a4:	fb02 f303 	mul.w	r3, r2, r3
 80216a8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 80216ac:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80216b0:	f246 2254 	movw	r2, #25172	; 0x6254
 80216b4:	fb02 f303 	mul.w	r3, r2, r3
 80216b8:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
    tmp1 += z1 + z3;
 80216bc:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80216c0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80216c4:	4413      	add	r3, r2
 80216c6:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80216ca:	4413      	add	r3, r2
 80216cc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp2 += z1 + z2;
 80216d0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80216d4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80216d8:	4413      	add	r3, r2
 80216da:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80216de:	4413      	add	r3, r2
 80216e0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80216e4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 80216e8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80216ec:	4413      	add	r3, r2
 80216ee:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80216f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80216f4:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80216f8:	4413      	add	r3, r2
 80216fa:	781a      	ldrb	r2, [r3, #0]
 80216fc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8021700:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8021702:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8021706:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 802170a:	1ad3      	subs	r3, r2, r3
 802170c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802170e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 8021712:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8021716:	441a      	add	r2, r3
 8021718:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 802171c:	3307      	adds	r3, #7
 802171e:	7812      	ldrb	r2, [r2, #0]
 8021720:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8021722:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8021726:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802172a:	4413      	add	r3, r2
 802172c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802172e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8021732:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8021736:	441a      	add	r2, r3
 8021738:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 802173c:	3301      	adds	r3, #1
 802173e:	7812      	ldrb	r2, [r2, #0]
 8021740:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8021742:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8021746:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802174a:	1ad3      	subs	r3, r2, r3
 802174c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802174e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8021752:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8021756:	441a      	add	r2, r3
 8021758:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 802175c:	3306      	adds	r3, #6
 802175e:	7812      	ldrb	r2, [r2, #0]
 8021760:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8021762:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8021766:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 802176a:	4413      	add	r3, r2
 802176c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802176e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8021772:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8021776:	441a      	add	r2, r3
 8021778:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 802177c:	3302      	adds	r3, #2
 802177e:	7812      	ldrb	r2, [r2, #0]
 8021780:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8021782:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8021786:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 802178a:	1ad3      	subs	r3, r2, r3
 802178c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802178e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8021792:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8021796:	441a      	add	r2, r3
 8021798:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 802179c:	3305      	adds	r3, #5
 802179e:	7812      	ldrb	r2, [r2, #0]
 80217a0:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 80217a2:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80217a6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80217aa:	4413      	add	r3, r2
 80217ac:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80217ae:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 80217b2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80217b6:	441a      	add	r2, r3
 80217b8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80217bc:	3303      	adds	r3, #3
 80217be:	7812      	ldrb	r2, [r2, #0]
 80217c0:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 80217c2:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80217c6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80217ca:	1ad3      	subs	r3, r2, r3
 80217cc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80217ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 80217d2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80217d6:	441a      	add	r2, r3
 80217d8:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80217dc:	3304      	adds	r3, #4
 80217de:	7812      	ldrb	r2, [r2, #0]
 80217e0:	701a      	strb	r2, [r3, #0]

    wsptr += DCTSIZE;		/* advance pointer to next row */
 80217e2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80217e6:	3320      	adds	r3, #32
 80217e8:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 0; ctr < 4; ctr++) {
 80217ec:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80217f0:	3301      	adds	r3, #1
 80217f2:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 80217f6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80217fa:	2b03      	cmp	r3, #3
 80217fc:	f77f ae5a 	ble.w	80214b4 <jpeg_idct_8x4+0x1a0>
  }
}
 8021800:	bf00      	nop
 8021802:	bf00      	nop
 8021804:	37dc      	adds	r7, #220	; 0xdc
 8021806:	46bd      	mov	sp, r7
 8021808:	f85d 7b04 	ldr.w	r7, [sp], #4
 802180c:	4770      	bx	lr
 802180e:	bf00      	nop
 8021810:	ffffc4df 	.word	0xffffc4df
 8021814:	ffffc13b 	.word	0xffffc13b
 8021818:	fffff384 	.word	0xfffff384
 802181c:	ffffe333 	.word	0xffffe333
 8021820:	ffffadfd 	.word	0xffffadfd

08021824 <jpeg_idct_6x3>:

GLOBAL(void)
jpeg_idct_6x3 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021824:	b480      	push	{r7}
 8021826:	b0a7      	sub	sp, #156	; 0x9c
 8021828:	af00      	add	r7, sp, #0
 802182a:	60f8      	str	r0, [r7, #12]
 802182c:	60b9      	str	r1, [r7, #8]
 802182e:	607a      	str	r2, [r7, #4]
 8021830:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021832:	68fb      	ldr	r3, [r7, #12]
 8021834:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8021838:	3380      	adds	r3, #128	; 0x80
 802183a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  inptr = coef_block;
 802183e:	687b      	ldr	r3, [r7, #4]
 8021840:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021844:	68bb      	ldr	r3, [r7, #8]
 8021846:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8021848:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  wsptr = workspace;
 802184c:	f107 0314 	add.w	r3, r7, #20
 8021850:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8021854:	2300      	movs	r3, #0
 8021856:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 802185a:	e06a      	b.n	8021932 <jpeg_idct_6x3+0x10e>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802185c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8021860:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021864:	461a      	mov	r2, r3
 8021866:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 802186a:	681b      	ldr	r3, [r3, #0]
 802186c:	fb03 f302 	mul.w	r3, r3, r2
 8021870:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp0 <<= CONST_BITS;
 8021872:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8021874:	035b      	lsls	r3, r3, #13
 8021876:	67fb      	str	r3, [r7, #124]	; 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021878:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802187a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 802187e:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8021880:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8021884:	3320      	adds	r3, #32
 8021886:	f9b3 3000 	ldrsh.w	r3, [r3]
 802188a:	461a      	mov	r2, r3
 802188c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8021890:	3340      	adds	r3, #64	; 0x40
 8021892:	681b      	ldr	r3, [r3, #0]
 8021894:	fb03 f302 	mul.w	r3, r3, r2
 8021898:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802189a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 802189c:	f241 62a1 	movw	r2, #5793	; 0x16a1
 80218a0:	fb02 f303 	mul.w	r3, r2, r3
 80218a4:	66bb      	str	r3, [r7, #104]	; 0x68
    tmp10 = tmp0 + tmp12;
 80218a6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80218a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80218aa:	4413      	add	r3, r2
 80218ac:	677b      	str	r3, [r7, #116]	; 0x74
    tmp2 = tmp0 - tmp12 - tmp12;
 80218ae:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80218b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80218b2:	1ad2      	subs	r2, r2, r3
 80218b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80218b6:	1ad3      	subs	r3, r2, r3
 80218b8:	67bb      	str	r3, [r7, #120]	; 0x78

    /* Odd part */

    tmp12 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80218ba:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80218be:	3310      	adds	r3, #16
 80218c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80218c4:	461a      	mov	r2, r3
 80218c6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80218ca:	3320      	adds	r3, #32
 80218cc:	681b      	ldr	r3, [r3, #0]
 80218ce:	fb03 f302 	mul.w	r3, r3, r2
 80218d2:	66bb      	str	r3, [r7, #104]	; 0x68
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 80218d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80218d6:	f242 7231 	movw	r2, #10033	; 0x2731
 80218da:	fb02 f303 	mul.w	r3, r2, r3
 80218de:	67fb      	str	r3, [r7, #124]	; 0x7c

    /* Final output stage */

    wsptr[6*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 80218e0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80218e2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80218e4:	4413      	add	r3, r2
 80218e6:	12da      	asrs	r2, r3, #11
 80218e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80218ec:	601a      	str	r2, [r3, #0]
    wsptr[6*2] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 80218ee:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80218f0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80218f2:	1ad2      	subs	r2, r2, r3
 80218f4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80218f8:	3330      	adds	r3, #48	; 0x30
 80218fa:	12d2      	asrs	r2, r2, #11
 80218fc:	601a      	str	r2, [r3, #0]
    wsptr[6*1] = (int) RIGHT_SHIFT(tmp2, CONST_BITS-PASS1_BITS);
 80218fe:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8021902:	3318      	adds	r3, #24
 8021904:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8021906:	12d2      	asrs	r2, r2, #11
 8021908:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 802190a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 802190e:	3301      	adds	r3, #1
 8021910:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8021914:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8021918:	3302      	adds	r3, #2
 802191a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 802191e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8021922:	3304      	adds	r3, #4
 8021924:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8021928:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 802192c:	3304      	adds	r3, #4
 802192e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8021932:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8021936:	2b05      	cmp	r3, #5
 8021938:	dd90      	ble.n	802185c <jpeg_idct_6x3+0x38>
  }
  
  /* Pass 2: process 3 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 802193a:	f107 0314 	add.w	r3, r7, #20
 802193e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8021942:	2300      	movs	r3, #0
 8021944:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8021948:	e0c3      	b.n	8021ad2 <jpeg_idct_6x3+0x2ae>
    outptr = output_buf[ctr] + output_col;
 802194a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 802194e:	009b      	lsls	r3, r3, #2
 8021950:	683a      	ldr	r2, [r7, #0]
 8021952:	4413      	add	r3, r2
 8021954:	681a      	ldr	r2, [r3, #0]
 8021956:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802195a:	4413      	add	r3, r2
 802195c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8021960:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8021964:	681b      	ldr	r3, [r3, #0]
 8021966:	3310      	adds	r3, #16
 8021968:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp0 <<= CONST_BITS;
 802196a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802196c:	035b      	lsls	r3, r3, #13
 802196e:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = (INT32) wsptr[4];
 8021970:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8021974:	3310      	adds	r3, #16
 8021976:	681b      	ldr	r3, [r3, #0]
 8021978:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 802197a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 802197c:	f241 62a1 	movw	r2, #5793	; 0x16a1
 8021980:	fb02 f303 	mul.w	r3, r2, r3
 8021984:	677b      	str	r3, [r7, #116]	; 0x74
    tmp1 = tmp0 + tmp10;
 8021986:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8021988:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 802198a:	4413      	add	r3, r2
 802198c:	673b      	str	r3, [r7, #112]	; 0x70
    tmp11 = tmp0 - tmp10 - tmp10;
 802198e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8021990:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8021992:	1ad2      	subs	r2, r2, r3
 8021994:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8021996:	1ad3      	subs	r3, r2, r3
 8021998:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp10 = (INT32) wsptr[2];
 802199a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 802199e:	3308      	adds	r3, #8
 80219a0:	681b      	ldr	r3, [r3, #0]
 80219a2:	677b      	str	r3, [r7, #116]	; 0x74
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 80219a4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80219a6:	f242 7231 	movw	r2, #10033	; 0x2731
 80219aa:	fb02 f303 	mul.w	r3, r2, r3
 80219ae:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp10 = tmp1 + tmp0;
 80219b0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80219b2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80219b4:	4413      	add	r3, r2
 80219b6:	677b      	str	r3, [r7, #116]	; 0x74
    tmp12 = tmp1 - tmp0;
 80219b8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80219ba:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80219bc:	1ad3      	subs	r3, r2, r3
 80219be:	66bb      	str	r3, [r7, #104]	; 0x68

    /* Odd part */

    z1 = (INT32) wsptr[1];
 80219c0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80219c4:	3304      	adds	r3, #4
 80219c6:	681b      	ldr	r3, [r3, #0]
 80219c8:	667b      	str	r3, [r7, #100]	; 0x64
    z2 = (INT32) wsptr[3];
 80219ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80219ce:	330c      	adds	r3, #12
 80219d0:	681b      	ldr	r3, [r3, #0]
 80219d2:	663b      	str	r3, [r7, #96]	; 0x60
    z3 = (INT32) wsptr[5];
 80219d4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80219d8:	3314      	adds	r3, #20
 80219da:	681b      	ldr	r3, [r3, #0]
 80219dc:	65fb      	str	r3, [r7, #92]	; 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 80219de:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80219e0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80219e2:	4413      	add	r3, r2
 80219e4:	f640 32b6 	movw	r2, #2998	; 0xbb6
 80219e8:	fb02 f303 	mul.w	r3, r2, r3
 80219ec:	673b      	str	r3, [r7, #112]	; 0x70
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 80219ee:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80219f0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80219f2:	4413      	add	r3, r2
 80219f4:	035b      	lsls	r3, r3, #13
 80219f6:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80219f8:	4413      	add	r3, r2
 80219fa:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 80219fc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80219fe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8021a00:	1ad3      	subs	r3, r2, r3
 8021a02:	035b      	lsls	r3, r3, #13
 8021a04:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8021a06:	4413      	add	r3, r2
 8021a08:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp1 = (z1 - z2 - z3) << CONST_BITS;
 8021a0a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8021a0c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8021a0e:	1ad2      	subs	r2, r2, r3
 8021a10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021a12:	1ad3      	subs	r3, r2, r3
 8021a14:	035b      	lsls	r3, r3, #13
 8021a16:	673b      	str	r3, [r7, #112]	; 0x70

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021a18:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8021a1a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8021a1c:	4413      	add	r3, r2
 8021a1e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021a20:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021a24:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021a28:	4413      	add	r3, r2
 8021a2a:	781a      	ldrb	r2, [r3, #0]
 8021a2c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021a30:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021a32:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8021a34:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8021a36:	1ad3      	subs	r3, r2, r3
 8021a38:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021a3a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021a3e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021a42:	441a      	add	r2, r3
 8021a44:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021a48:	3305      	adds	r3, #5
 8021a4a:	7812      	ldrb	r2, [r2, #0]
 8021a4c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8021a4e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8021a50:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8021a52:	4413      	add	r3, r2
 8021a54:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021a56:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp1,
 8021a5a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021a5e:	441a      	add	r2, r3
 8021a60:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021a64:	3301      	adds	r3, #1
 8021a66:	7812      	ldrb	r2, [r2, #0]
 8021a68:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8021a6a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8021a6c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8021a6e:	1ad3      	subs	r3, r2, r3
 8021a70:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021a72:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp1,
 8021a76:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021a7a:	441a      	add	r2, r3
 8021a7c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021a80:	3304      	adds	r3, #4
 8021a82:	7812      	ldrb	r2, [r2, #0]
 8021a84:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021a86:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8021a88:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8021a8a:	4413      	add	r3, r2
 8021a8c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021a8e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021a92:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021a96:	441a      	add	r2, r3
 8021a98:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021a9c:	3302      	adds	r3, #2
 8021a9e:	7812      	ldrb	r2, [r2, #0]
 8021aa0:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021aa2:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8021aa4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8021aa6:	1ad3      	subs	r3, r2, r3
 8021aa8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8021aaa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021aae:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8021ab2:	441a      	add	r2, r3
 8021ab4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8021ab8:	3303      	adds	r3, #3
 8021aba:	7812      	ldrb	r2, [r2, #0]
 8021abc:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 8021abe:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8021ac2:	3318      	adds	r3, #24
 8021ac4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 3; ctr++) {
 8021ac8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8021acc:	3301      	adds	r3, #1
 8021ace:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8021ad2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8021ad6:	2b02      	cmp	r3, #2
 8021ad8:	f77f af37 	ble.w	802194a <jpeg_idct_6x3+0x126>
  }
}
 8021adc:	bf00      	nop
 8021ade:	bf00      	nop
 8021ae0:	379c      	adds	r7, #156	; 0x9c
 8021ae2:	46bd      	mov	sp, r7
 8021ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021ae8:	4770      	bx	lr
	...

08021aec <jpeg_idct_4x2>:

GLOBAL(void)
jpeg_idct_4x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021aec:	b480      	push	{r7}
 8021aee:	b09b      	sub	sp, #108	; 0x6c
 8021af0:	af00      	add	r7, sp, #0
 8021af2:	60f8      	str	r0, [r7, #12]
 8021af4:	60b9      	str	r1, [r7, #8]
 8021af6:	607a      	str	r2, [r7, #4]
 8021af8:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021afa:	68fb      	ldr	r3, [r7, #12]
 8021afc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8021b00:	3380      	adds	r3, #128	; 0x80
 8021b02:	657b      	str	r3, [r7, #84]	; 0x54
  INT32 workspace[4*2];	/* buffers data between passes */
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
 8021b04:	687b      	ldr	r3, [r7, #4]
 8021b06:	667b      	str	r3, [r7, #100]	; 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021b08:	68bb      	ldr	r3, [r7, #8]
 8021b0a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8021b0c:	663b      	str	r3, [r7, #96]	; 0x60
  wsptr = workspace;
 8021b0e:	f107 0314 	add.w	r3, r7, #20
 8021b12:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8021b14:	2300      	movs	r3, #0
 8021b16:	65bb      	str	r3, [r7, #88]	; 0x58
 8021b18:	e02a      	b.n	8021b70 <jpeg_idct_4x2+0x84>
    /* Even part */

    tmp10 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021b1a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8021b1c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021b20:	461a      	mov	r2, r3
 8021b22:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8021b24:	681b      	ldr	r3, [r3, #0]
 8021b26:	fb03 f302 	mul.w	r3, r3, r2
 8021b2a:	647b      	str	r3, [r7, #68]	; 0x44

    /* Odd part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8021b2c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8021b2e:	3310      	adds	r3, #16
 8021b30:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021b34:	461a      	mov	r2, r3
 8021b36:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8021b38:	3320      	adds	r3, #32
 8021b3a:	681b      	ldr	r3, [r3, #0]
 8021b3c:	fb03 f302 	mul.w	r3, r3, r2
 8021b40:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Final output stage */

    wsptr[4*0] = tmp10 + tmp0;
 8021b42:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8021b44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8021b46:	441a      	add	r2, r3
 8021b48:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021b4a:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = tmp10 - tmp0;
 8021b4c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021b4e:	3310      	adds	r3, #16
 8021b50:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8021b52:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8021b54:	1a8a      	subs	r2, r1, r2
 8021b56:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 4; ctr++, inptr++, quantptr++, wsptr++) {
 8021b58:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8021b5a:	3301      	adds	r3, #1
 8021b5c:	65bb      	str	r3, [r7, #88]	; 0x58
 8021b5e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8021b60:	3302      	adds	r3, #2
 8021b62:	667b      	str	r3, [r7, #100]	; 0x64
 8021b64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8021b66:	3304      	adds	r3, #4
 8021b68:	663b      	str	r3, [r7, #96]	; 0x60
 8021b6a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021b6c:	3304      	adds	r3, #4
 8021b6e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8021b70:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8021b72:	2b03      	cmp	r3, #3
 8021b74:	ddd1      	ble.n	8021b1a <jpeg_idct_4x2+0x2e>

  /* Pass 2: process 2 rows from work array, store into output array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  wsptr = workspace;
 8021b76:	f107 0314 	add.w	r3, r7, #20
 8021b7a:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8021b7c:	2300      	movs	r3, #0
 8021b7e:	65bb      	str	r3, [r7, #88]	; 0x58
 8021b80:	e06a      	b.n	8021c58 <jpeg_idct_4x2+0x16c>
    outptr = output_buf[ctr] + output_col;
 8021b82:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8021b84:	009b      	lsls	r3, r3, #2
 8021b86:	683a      	ldr	r2, [r7, #0]
 8021b88:	4413      	add	r3, r2
 8021b8a:	681a      	ldr	r2, [r3, #0]
 8021b8c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8021b8e:	4413      	add	r3, r2
 8021b90:	653b      	str	r3, [r7, #80]	; 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = wsptr[0] + (ONE << 2);
 8021b92:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021b94:	681b      	ldr	r3, [r3, #0]
 8021b96:	3304      	adds	r3, #4
 8021b98:	64fb      	str	r3, [r7, #76]	; 0x4c
    tmp2 = wsptr[2];
 8021b9a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021b9c:	689b      	ldr	r3, [r3, #8]
 8021b9e:	64bb      	str	r3, [r7, #72]	; 0x48

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 8021ba0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8021ba2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8021ba4:	4413      	add	r3, r2
 8021ba6:	035b      	lsls	r3, r3, #13
 8021ba8:	647b      	str	r3, [r7, #68]	; 0x44
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8021baa:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8021bac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8021bae:	1ad3      	subs	r3, r2, r3
 8021bb0:	035b      	lsls	r3, r3, #13
 8021bb2:	643b      	str	r3, [r7, #64]	; 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = wsptr[1];
 8021bb4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021bb6:	685b      	ldr	r3, [r3, #4]
 8021bb8:	63fb      	str	r3, [r7, #60]	; 0x3c
    z3 = wsptr[3];
 8021bba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021bbc:	68db      	ldr	r3, [r3, #12]
 8021bbe:	63bb      	str	r3, [r7, #56]	; 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 8021bc0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021bc2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021bc4:	4413      	add	r3, r2
 8021bc6:	f241 1251 	movw	r2, #4433	; 0x1151
 8021bca:	fb02 f303 	mul.w	r3, r2, r3
 8021bce:	637b      	str	r3, [r7, #52]	; 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8021bd0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021bd2:	f641 027e 	movw	r2, #6270	; 0x187e
 8021bd6:	fb02 f303 	mul.w	r3, r2, r3
 8021bda:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8021bdc:	4413      	add	r3, r2
 8021bde:	64fb      	str	r3, [r7, #76]	; 0x4c
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 8021be0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021be2:	4a22      	ldr	r2, [pc, #136]	; (8021c6c <jpeg_idct_4x2+0x180>)
 8021be4:	fb02 f303 	mul.w	r3, r2, r3
 8021be8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8021bea:	4413      	add	r3, r2
 8021bec:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021bee:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8021bf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8021bf2:	4413      	add	r3, r2
 8021bf4:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8021bf6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8021bfa:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8021bfc:	4413      	add	r3, r2
 8021bfe:	781a      	ldrb	r2, [r3, #0]
 8021c00:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8021c02:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021c04:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8021c06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8021c08:	1ad3      	subs	r3, r2, r3
 8021c0a:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8021c0c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8021c10:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8021c12:	441a      	add	r2, r3
 8021c14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8021c16:	3303      	adds	r3, #3
 8021c18:	7812      	ldrb	r2, [r2, #0]
 8021c1a:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021c1c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8021c1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8021c20:	4413      	add	r3, r2
 8021c22:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8021c24:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8021c28:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8021c2a:	441a      	add	r2, r3
 8021c2c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8021c2e:	3301      	adds	r3, #1
 8021c30:	7812      	ldrb	r2, [r2, #0]
 8021c32:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021c34:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8021c36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8021c38:	1ad3      	subs	r3, r2, r3
 8021c3a:	141b      	asrs	r3, r3, #16
					      CONST_BITS+3)
			    & RANGE_MASK];
 8021c3c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 8021c40:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8021c42:	441a      	add	r2, r3
 8021c44:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8021c46:	3302      	adds	r3, #2
 8021c48:	7812      	ldrb	r2, [r2, #0]
 8021c4a:	701a      	strb	r2, [r3, #0]

    wsptr += 4;		/* advance pointer to next row */
 8021c4c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8021c4e:	3310      	adds	r3, #16
 8021c50:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 2; ctr++) {
 8021c52:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8021c54:	3301      	adds	r3, #1
 8021c56:	65bb      	str	r3, [r7, #88]	; 0x58
 8021c58:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8021c5a:	2b01      	cmp	r3, #1
 8021c5c:	dd91      	ble.n	8021b82 <jpeg_idct_4x2+0x96>
  }
}
 8021c5e:	bf00      	nop
 8021c60:	bf00      	nop
 8021c62:	376c      	adds	r7, #108	; 0x6c
 8021c64:	46bd      	mov	sp, r7
 8021c66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021c6a:	4770      	bx	lr
 8021c6c:	ffffc4df 	.word	0xffffc4df

08021c70 <jpeg_idct_2x1>:

GLOBAL(void)
jpeg_idct_2x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021c70:	b480      	push	{r7}
 8021c72:	b08b      	sub	sp, #44	; 0x2c
 8021c74:	af00      	add	r7, sp, #0
 8021c76:	60f8      	str	r0, [r7, #12]
 8021c78:	60b9      	str	r1, [r7, #8]
 8021c7a:	607a      	str	r2, [r7, #4]
 8021c7c:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021c7e:	68fb      	ldr	r3, [r7, #12]
 8021c80:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8021c84:	3380      	adds	r3, #128	; 0x80
 8021c86:	627b      	str	r3, [r7, #36]	; 0x24

  /* Pass 1: empty. */

  /* Pass 2: process 1 row from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021c88:	68bb      	ldr	r3, [r7, #8]
 8021c8a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8021c8c:	623b      	str	r3, [r7, #32]
  outptr = output_buf[0] + output_col;
 8021c8e:	683b      	ldr	r3, [r7, #0]
 8021c90:	681a      	ldr	r2, [r3, #0]
 8021c92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021c94:	4413      	add	r3, r2
 8021c96:	61fb      	str	r3, [r7, #28]

  /* Even part */

  tmp10 = DEQUANTIZE(coef_block[0], quantptr[0]);
 8021c98:	687b      	ldr	r3, [r7, #4]
 8021c9a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021c9e:	461a      	mov	r2, r3
 8021ca0:	6a3b      	ldr	r3, [r7, #32]
 8021ca2:	681b      	ldr	r3, [r3, #0]
 8021ca4:	fb03 f302 	mul.w	r3, r3, r2
 8021ca8:	61bb      	str	r3, [r7, #24]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 8021caa:	69bb      	ldr	r3, [r7, #24]
 8021cac:	3304      	adds	r3, #4
 8021cae:	61bb      	str	r3, [r7, #24]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[1], quantptr[1]);
 8021cb0:	687b      	ldr	r3, [r7, #4]
 8021cb2:	3302      	adds	r3, #2
 8021cb4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021cb8:	461a      	mov	r2, r3
 8021cba:	6a3b      	ldr	r3, [r7, #32]
 8021cbc:	3304      	adds	r3, #4
 8021cbe:	681b      	ldr	r3, [r3, #0]
 8021cc0:	fb03 f302 	mul.w	r3, r3, r2
 8021cc4:	617b      	str	r3, [r7, #20]

  /* Final output stage */

  outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3) & RANGE_MASK];
 8021cc6:	69ba      	ldr	r2, [r7, #24]
 8021cc8:	697b      	ldr	r3, [r7, #20]
 8021cca:	4413      	add	r3, r2
 8021ccc:	10db      	asrs	r3, r3, #3
 8021cce:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021cd2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021cd4:	4413      	add	r3, r2
 8021cd6:	781a      	ldrb	r2, [r3, #0]
 8021cd8:	69fb      	ldr	r3, [r7, #28]
 8021cda:	701a      	strb	r2, [r3, #0]
  outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3) & RANGE_MASK];
 8021cdc:	69ba      	ldr	r2, [r7, #24]
 8021cde:	697b      	ldr	r3, [r7, #20]
 8021ce0:	1ad3      	subs	r3, r2, r3
 8021ce2:	10db      	asrs	r3, r3, #3
 8021ce4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021ce8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021cea:	441a      	add	r2, r3
 8021cec:	69fb      	ldr	r3, [r7, #28]
 8021cee:	3301      	adds	r3, #1
 8021cf0:	7812      	ldrb	r2, [r2, #0]
 8021cf2:	701a      	strb	r2, [r3, #0]
}
 8021cf4:	bf00      	nop
 8021cf6:	372c      	adds	r7, #44	; 0x2c
 8021cf8:	46bd      	mov	sp, r7
 8021cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021cfe:	4770      	bx	lr

08021d00 <jpeg_idct_8x16>:

GLOBAL(void)
jpeg_idct_8x16 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8021d00:	b490      	push	{r4, r7}
 8021d02:	f5ad 7d1e 	sub.w	sp, sp, #632	; 0x278
 8021d06:	af00      	add	r7, sp, #0
 8021d08:	f107 040c 	add.w	r4, r7, #12
 8021d0c:	6020      	str	r0, [r4, #0]
 8021d0e:	f107 0008 	add.w	r0, r7, #8
 8021d12:	6001      	str	r1, [r0, #0]
 8021d14:	1d39      	adds	r1, r7, #4
 8021d16:	600a      	str	r2, [r1, #0]
 8021d18:	463a      	mov	r2, r7
 8021d1a:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8021d1c:	f107 030c 	add.w	r3, r7, #12
 8021d20:	681b      	ldr	r3, [r3, #0]
 8021d22:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8021d26:	3380      	adds	r3, #128	; 0x80
 8021d28:	f8c7 3264 	str.w	r3, [r7, #612]	; 0x264
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 16-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/32).
   */
  inptr = coef_block;
 8021d2c:	1d3b      	adds	r3, r7, #4
 8021d2e:	681b      	ldr	r3, [r3, #0]
 8021d30:	f8c7 3274 	str.w	r3, [r7, #628]	; 0x274
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8021d34:	f107 0308 	add.w	r3, r7, #8
 8021d38:	681b      	ldr	r3, [r3, #0]
 8021d3a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8021d3c:	f8c7 3270 	str.w	r3, [r7, #624]	; 0x270
  wsptr = workspace;
 8021d40:	f107 0310 	add.w	r3, r7, #16
 8021d44:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8021d48:	2300      	movs	r3, #0
 8021d4a:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 8021d4e:	e30b      	b.n	8022368 <jpeg_idct_8x16+0x668>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8021d50:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021d54:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021d58:	461a      	mov	r2, r3
 8021d5a:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021d5e:	681b      	ldr	r3, [r3, #0]
 8021d60:	fb03 f302 	mul.w	r3, r3, r2
 8021d64:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp0 <<= CONST_BITS;
 8021d68:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 8021d6c:	035b      	lsls	r3, r3, #13
 8021d6e:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 8021d72:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 8021d76:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8021d7a:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248

    z1 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8021d7e:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021d82:	3340      	adds	r3, #64	; 0x40
 8021d84:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021d88:	461a      	mov	r2, r3
 8021d8a:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021d8e:	3380      	adds	r3, #128	; 0x80
 8021d90:	681b      	ldr	r3, [r3, #0]
 8021d92:	fb03 f302 	mul.w	r3, r3, r2
 8021d96:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */
 8021d9a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8021d9e:	f642 12cf 	movw	r2, #10703	; 0x29cf
 8021da2:	fb02 f303 	mul.w	r3, r2, r3
 8021da6:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */
 8021daa:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8021dae:	f241 1251 	movw	r2, #4433	; 0x1151
 8021db2:	fb02 f303 	mul.w	r3, r2, r3
 8021db6:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250

    tmp10 = tmp0 + tmp1;
 8021dba:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8021dbe:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8021dc2:	4413      	add	r3, r2
 8021dc4:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    tmp11 = tmp0 - tmp1;
 8021dc8:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8021dcc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8021dd0:	1ad3      	subs	r3, r2, r3
 8021dd2:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 = tmp0 + tmp2;
 8021dd6:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8021dda:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8021dde:	4413      	add	r3, r2
 8021de0:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    tmp13 = tmp0 - tmp2;
 8021de4:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8021de8:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8021dec:	1ad3      	subs	r3, r2, r3
 8021dee:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8021df2:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021df6:	3320      	adds	r3, #32
 8021df8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021dfc:	461a      	mov	r2, r3
 8021dfe:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021e02:	3340      	adds	r3, #64	; 0x40
 8021e04:	681b      	ldr	r3, [r3, #0]
 8021e06:	fb03 f302 	mul.w	r3, r3, r2
 8021e0a:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8021e0e:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021e12:	3360      	adds	r3, #96	; 0x60
 8021e14:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021e18:	461a      	mov	r2, r3
 8021e1a:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021e1e:	33c0      	adds	r3, #192	; 0xc0
 8021e20:	681b      	ldr	r3, [r3, #0]
 8021e22:	fb03 f302 	mul.w	r3, r3, r2
 8021e26:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = z1 - z2;
 8021e2a:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8021e2e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8021e32:	1ad3      	subs	r3, r2, r3
 8021e34:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */
 8021e38:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8021e3c:	f640 02d4 	movw	r2, #2260	; 0x8d4
 8021e40:	fb02 f303 	mul.w	r3, r2, r3
 8021e44:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */
 8021e48:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8021e4c:	f642 4263 	movw	r2, #11363	; 0x2c63
 8021e50:	fb02 f303 	mul.w	r3, r2, r3
 8021e54:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258

    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */
 8021e58:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8021e5c:	f245 2203 	movw	r2, #20995	; 0x5203
 8021e60:	fb02 f303 	mul.w	r3, r2, r3
 8021e64:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 8021e68:	4413      	add	r3, r2
 8021e6a:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */
 8021e6e:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8021e72:	f641 42cd 	movw	r2, #7373	; 0x1ccd
 8021e76:	fb02 f303 	mul.w	r3, r2, r3
 8021e7a:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 8021e7e:	4413      	add	r3, r2
 8021e80:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */
 8021e84:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8021e88:	4af4      	ldr	r2, [pc, #976]	; (802225c <jpeg_idct_8x16+0x55c>)
 8021e8a:	fb02 f303 	mul.w	r3, r2, r3
 8021e8e:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 8021e92:	4413      	add	r3, r2
 8021e94:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */
 8021e98:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8021e9c:	4af0      	ldr	r2, [pc, #960]	; (8022260 <jpeg_idct_8x16+0x560>)
 8021e9e:	fb02 f303 	mul.w	r3, r2, r3
 8021ea2:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 8021ea6:	4413      	add	r3, r2
 8021ea8:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c

    tmp20 = tmp10 + tmp0;
 8021eac:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 8021eb0:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 8021eb4:	4413      	add	r3, r2
 8021eb6:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
    tmp27 = tmp10 - tmp0;
 8021eba:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 8021ebe:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 8021ec2:	1ad3      	subs	r3, r2, r3
 8021ec4:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    tmp21 = tmp12 + tmp1;
 8021ec8:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 8021ecc:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8021ed0:	4413      	add	r3, r2
 8021ed2:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
    tmp26 = tmp12 - tmp1;
 8021ed6:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 8021eda:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8021ede:	1ad3      	subs	r3, r2, r3
 8021ee0:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    tmp22 = tmp13 + tmp2;
 8021ee4:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 8021ee8:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8021eec:	4413      	add	r3, r2
 8021eee:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    tmp25 = tmp13 - tmp2;
 8021ef2:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 8021ef6:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8021efa:	1ad3      	subs	r3, r2, r3
 8021efc:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    tmp23 = tmp11 + tmp3;
 8021f00:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 8021f04:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 8021f08:	4413      	add	r3, r2
 8021f0a:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    tmp24 = tmp11 - tmp3;
 8021f0e:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 8021f12:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 8021f16:	1ad3      	subs	r3, r2, r3
 8021f18:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8021f1c:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021f20:	3310      	adds	r3, #16
 8021f22:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f26:	461a      	mov	r2, r3
 8021f28:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021f2c:	3320      	adds	r3, #32
 8021f2e:	681b      	ldr	r3, [r3, #0]
 8021f30:	fb03 f302 	mul.w	r3, r3, r2
 8021f34:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8021f38:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021f3c:	3330      	adds	r3, #48	; 0x30
 8021f3e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f42:	461a      	mov	r2, r3
 8021f44:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021f48:	3360      	adds	r3, #96	; 0x60
 8021f4a:	681b      	ldr	r3, [r3, #0]
 8021f4c:	fb03 f302 	mul.w	r3, r3, r2
 8021f50:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8021f54:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021f58:	3350      	adds	r3, #80	; 0x50
 8021f5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f5e:	461a      	mov	r2, r3
 8021f60:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021f64:	33a0      	adds	r3, #160	; 0xa0
 8021f66:	681b      	ldr	r3, [r3, #0]
 8021f68:	fb03 f302 	mul.w	r3, r3, r2
 8021f6c:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8021f70:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 8021f74:	3370      	adds	r3, #112	; 0x70
 8021f76:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021f7a:	461a      	mov	r2, r3
 8021f7c:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8021f80:	33e0      	adds	r3, #224	; 0xe0
 8021f82:	681b      	ldr	r3, [r3, #0]
 8021f84:	fb03 f302 	mul.w	r3, r3, r2
 8021f88:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230

    tmp11 = z1 + z3;
 8021f8c:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8021f90:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8021f94:	4413      	add	r3, r2
 8021f96:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */
 8021f9a:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8021f9e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8021fa2:	4413      	add	r3, r2
 8021fa4:	f642 324e 	movw	r2, #11086	; 0x2b4e
 8021fa8:	fb02 f303 	mul.w	r3, r2, r3
 8021fac:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */
 8021fb0:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 8021fb4:	f242 72e9 	movw	r2, #10217	; 0x27e9
 8021fb8:	fb02 f303 	mul.w	r3, r2, r3
 8021fbc:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */
 8021fc0:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8021fc4:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8021fc8:	4413      	add	r3, r2
 8021fca:	f242 22fc 	movw	r2, #8956	; 0x22fc
 8021fce:	fb02 f303 	mul.w	r3, r2, r3
 8021fd2:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */
 8021fd6:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8021fda:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8021fde:	1ad3      	subs	r3, r2, r3
 8021fe0:	f641 42b6 	movw	r2, #7350	; 0x1cb6
 8021fe4:	fb02 f303 	mul.w	r3, r2, r3
 8021fe8:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */
 8021fec:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 8021ff0:	f241 5255 	movw	r2, #5461	; 0x1555
 8021ff4:	fb02 f303 	mul.w	r3, r2, r3
 8021ff8:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */
 8021ffc:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8022000:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022004:	1ad3      	subs	r3, r2, r3
 8022006:	f640 5223 	movw	r2, #3363	; 0xd23
 802200a:	fb02 f303 	mul.w	r3, r2, r3
 802200e:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    tmp0  = tmp1 + tmp2 + tmp3 -
 8022012:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 8022016:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 802201a:	441a      	add	r2, r3
 802201c:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 8022020:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */
 8022022:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8022026:	498f      	ldr	r1, [pc, #572]	; (8022264 <jpeg_idct_8x16+0x564>)
 8022028:	fb01 f303 	mul.w	r3, r1, r3
    tmp0  = tmp1 + tmp2 + tmp3 -
 802202c:	4413      	add	r3, r2
 802202e:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp13 = tmp10 + tmp11 + tmp12 -
 8022032:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 8022036:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 802203a:	441a      	add	r2, r3
 802203c:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 8022040:	441a      	add	r2, r3
	    MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */
 8022042:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8022046:	4988      	ldr	r1, [pc, #544]	; (8022268 <jpeg_idct_8x16+0x568>)
 8022048:	fb01 f303 	mul.w	r3, r1, r3
    tmp13 = tmp10 + tmp11 + tmp12 -
 802204c:	4413      	add	r3, r2
 802204e:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */
 8022052:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 8022056:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 802205a:	4413      	add	r3, r2
 802205c:	f44f 628e 	mov.w	r2, #1136	; 0x470
 8022060:	fb02 f303 	mul.w	r3, r2, r3
 8022064:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */
 8022068:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 802206c:	f240 224d 	movw	r2, #589	; 0x24d
 8022070:	fb02 f203 	mul.w	r2, r2, r3
 8022074:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8022078:	4413      	add	r3, r2
 802207a:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 802207e:	4413      	add	r3, r2
 8022080:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */
 8022084:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8022088:	4a78      	ldr	r2, [pc, #480]	; (802226c <jpeg_idct_8x16+0x56c>)
 802208a:	fb02 f203 	mul.w	r2, r2, r3
 802208e:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8022092:	4413      	add	r3, r2
 8022094:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 8022098:	4413      	add	r3, r2
 802209a:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */
 802209e:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 80220a2:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80220a6:	1ad3      	subs	r3, r2, r3
 80220a8:	f642 5209 	movw	r2, #11529	; 0x2d09
 80220ac:	fb02 f303 	mul.w	r3, r2, r3
 80220b0:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */
 80220b4:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80220b8:	4a6d      	ldr	r2, [pc, #436]	; (8022270 <jpeg_idct_8x16+0x570>)
 80220ba:	fb02 f203 	mul.w	r2, r2, r3
 80220be:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 80220c2:	4413      	add	r3, r2
 80220c4:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 80220c8:	4413      	add	r3, r2
 80220ca:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */
 80220ce:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80220d2:	f643 721a 	movw	r2, #16154	; 0x3f1a
 80220d6:	fb02 f203 	mul.w	r2, r2, r3
 80220da:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 80220de:	4413      	add	r3, r2
 80220e0:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 80220e4:	4413      	add	r3, r2
 80220e6:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z2    += z4;
 80220ea:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 80220ee:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 80220f2:	4413      	add	r3, r2
 80220f4:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z1    = MULTIPLY(z2, - FIX(0.666655658));      /* -c11 */
 80220f8:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80220fc:	4a5d      	ldr	r2, [pc, #372]	; (8022274 <jpeg_idct_8x16+0x574>)
 80220fe:	fb02 f303 	mul.w	r3, r2, r3
 8022102:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp1  += z1;
 8022106:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 802210a:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 802210e:	4413      	add	r3, r2
 8022110:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */
 8022114:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8022118:	f242 2218 	movw	r2, #8728	; 0x2218
 802211c:	fb02 f203 	mul.w	r2, r2, r3
 8022120:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 8022124:	4413      	add	r3, r2
 8022126:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 802212a:	4413      	add	r3, r2
 802212c:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    z2    = MULTIPLY(z2, - FIX(1.247225013));      /* -c5 */
 8022130:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022134:	4a50      	ldr	r2, [pc, #320]	; (8022278 <jpeg_idct_8x16+0x578>)
 8022136:	fb02 f303 	mul.w	r3, r2, r3
 802213a:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */
 802213e:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8022142:	f246 4285 	movw	r2, #25733	; 0x6485
 8022146:	fb02 f203 	mul.w	r2, r2, r3
 802214a:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 802214e:	4413      	add	r3, r2
 8022150:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 8022154:	4413      	add	r3, r2
 8022156:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    tmp12 += z2;
 802215a:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 802215e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022162:	4413      	add	r3, r2
 8022164:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    z2    = MULTIPLY(z3 + z4, - FIX(1.353318001)); /* -c3 */
 8022168:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 802216c:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8022170:	4413      	add	r3, r2
 8022172:	4a42      	ldr	r2, [pc, #264]	; (802227c <jpeg_idct_8x16+0x57c>)
 8022174:	fb02 f303 	mul.w	r3, r2, r3
 8022178:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp2  += z2;
 802217c:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 8022180:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022184:	4413      	add	r3, r2
 8022186:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3  += z2;
 802218a:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 802218e:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022192:	4413      	add	r3, r2
 8022194:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */
 8022198:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 802219c:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80221a0:	1ad3      	subs	r3, r2, r3
 80221a2:	f640 5223 	movw	r2, #3363	; 0xd23
 80221a6:	fb02 f303 	mul.w	r3, r2, r3
 80221aa:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    tmp10 += z2;
 80221ae:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 80221b2:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80221b6:	4413      	add	r3, r2
 80221b8:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    tmp11 += z2;
 80221bc:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 80221c0:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80221c4:	4413      	add	r3, r2
 80221c6:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238

    /* Final output stage */

    wsptr[8*0]  = (int) RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS-PASS1_BITS);
 80221ca:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 80221ce:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 80221d2:	4413      	add	r3, r2
 80221d4:	12da      	asrs	r2, r3, #11
 80221d6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80221da:	601a      	str	r2, [r3, #0]
    wsptr[8*15] = (int) RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS-PASS1_BITS);
 80221dc:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 80221e0:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 80221e4:	1ad2      	subs	r2, r2, r3
 80221e6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80221ea:	f503 73f0 	add.w	r3, r3, #480	; 0x1e0
 80221ee:	12d2      	asrs	r2, r2, #11
 80221f0:	601a      	str	r2, [r3, #0]
    wsptr[8*1]  = (int) RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS-PASS1_BITS);
 80221f2:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 80221f6:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80221fa:	441a      	add	r2, r3
 80221fc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022200:	3320      	adds	r3, #32
 8022202:	12d2      	asrs	r2, r2, #11
 8022204:	601a      	str	r2, [r3, #0]
    wsptr[8*14] = (int) RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS-PASS1_BITS);
 8022206:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 802220a:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 802220e:	1ad2      	subs	r2, r2, r3
 8022210:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022214:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 8022218:	12d2      	asrs	r2, r2, #11
 802221a:	601a      	str	r2, [r3, #0]
    wsptr[8*2]  = (int) RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS-PASS1_BITS);
 802221c:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 8022220:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022224:	441a      	add	r2, r3
 8022226:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802222a:	3340      	adds	r3, #64	; 0x40
 802222c:	12d2      	asrs	r2, r2, #11
 802222e:	601a      	str	r2, [r3, #0]
    wsptr[8*13] = (int) RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS-PASS1_BITS);
 8022230:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 8022234:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022238:	1ad2      	subs	r2, r2, r3
 802223a:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802223e:	f503 73d0 	add.w	r3, r3, #416	; 0x1a0
 8022242:	12d2      	asrs	r2, r2, #11
 8022244:	601a      	str	r2, [r3, #0]
    wsptr[8*3]  = (int) RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS-PASS1_BITS);
 8022246:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 802224a:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 802224e:	441a      	add	r2, r3
 8022250:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022254:	3360      	adds	r3, #96	; 0x60
 8022256:	12d2      	asrs	r2, r2, #11
 8022258:	e012      	b.n	8022280 <jpeg_idct_8x16+0x580>
 802225a:	bf00      	nop
 802225c:	ffffecc2 	.word	0xffffecc2
 8022260:	ffffefb0 	.word	0xffffefb0
 8022264:	ffffb6d6 	.word	0xffffb6d6
 8022268:	ffffc542 	.word	0xffffc542
 802226c:	ffffdbfa 	.word	0xffffdbfa
 8022270:	ffffe77a 	.word	0xffffe77a
 8022274:	ffffeaab 	.word	0xffffeaab
 8022278:	ffffd817 	.word	0xffffd817
 802227c:	ffffd4b2 	.word	0xffffd4b2
 8022280:	601a      	str	r2, [r3, #0]
    wsptr[8*12] = (int) RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS-PASS1_BITS);
 8022282:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 8022286:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 802228a:	1ad2      	subs	r2, r2, r3
 802228c:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022290:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 8022294:	12d2      	asrs	r2, r2, #11
 8022296:	601a      	str	r2, [r3, #0]
    wsptr[8*4]  = (int) RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS-PASS1_BITS);
 8022298:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 802229c:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 80222a0:	441a      	add	r2, r3
 80222a2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80222a6:	3380      	adds	r3, #128	; 0x80
 80222a8:	12d2      	asrs	r2, r2, #11
 80222aa:	601a      	str	r2, [r3, #0]
    wsptr[8*11] = (int) RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS-PASS1_BITS);
 80222ac:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 80222b0:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 80222b4:	1ad2      	subs	r2, r2, r3
 80222b6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80222ba:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 80222be:	12d2      	asrs	r2, r2, #11
 80222c0:	601a      	str	r2, [r3, #0]
    wsptr[8*5]  = (int) RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS-PASS1_BITS);
 80222c2:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 80222c6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 80222ca:	441a      	add	r2, r3
 80222cc:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80222d0:	33a0      	adds	r3, #160	; 0xa0
 80222d2:	12d2      	asrs	r2, r2, #11
 80222d4:	601a      	str	r2, [r3, #0]
    wsptr[8*10] = (int) RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS-PASS1_BITS);
 80222d6:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 80222da:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 80222de:	1ad2      	subs	r2, r2, r3
 80222e0:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80222e4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80222e8:	12d2      	asrs	r2, r2, #11
 80222ea:	601a      	str	r2, [r3, #0]
    wsptr[8*6]  = (int) RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS-PASS1_BITS);
 80222ec:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 80222f0:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 80222f4:	441a      	add	r2, r3
 80222f6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80222fa:	33c0      	adds	r3, #192	; 0xc0
 80222fc:	12d2      	asrs	r2, r2, #11
 80222fe:	601a      	str	r2, [r3, #0]
    wsptr[8*9]  = (int) RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS-PASS1_BITS);
 8022300:	f8d7 2220 	ldr.w	r2, [r7, #544]	; 0x220
 8022304:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 8022308:	1ad2      	subs	r2, r2, r3
 802230a:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802230e:	f503 7390 	add.w	r3, r3, #288	; 0x120
 8022312:	12d2      	asrs	r2, r2, #11
 8022314:	601a      	str	r2, [r3, #0]
    wsptr[8*7]  = (int) RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS-PASS1_BITS);
 8022316:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 802231a:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 802231e:	441a      	add	r2, r3
 8022320:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022324:	33e0      	adds	r3, #224	; 0xe0
 8022326:	12d2      	asrs	r2, r2, #11
 8022328:	601a      	str	r2, [r3, #0]
    wsptr[8*8]  = (int) RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS-PASS1_BITS);
 802232a:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 802232e:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 8022332:	1ad2      	subs	r2, r2, r3
 8022334:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022338:	f503 7380 	add.w	r3, r3, #256	; 0x100
 802233c:	12d2      	asrs	r2, r2, #11
 802233e:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {
 8022340:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 8022344:	3301      	adds	r3, #1
 8022346:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 802234a:	f8d7 3274 	ldr.w	r3, [r7, #628]	; 0x274
 802234e:	3302      	adds	r3, #2
 8022350:	f8c7 3274 	str.w	r3, [r7, #628]	; 0x274
 8022354:	f8d7 3270 	ldr.w	r3, [r7, #624]	; 0x270
 8022358:	3304      	adds	r3, #4
 802235a:	f8c7 3270 	str.w	r3, [r7, #624]	; 0x270
 802235e:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022362:	3304      	adds	r3, #4
 8022364:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
 8022368:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 802236c:	2b07      	cmp	r3, #7
 802236e:	f77f acef 	ble.w	8021d50 <jpeg_idct_8x16+0x50>
  
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
 8022372:	f107 0310 	add.w	r3, r7, #16
 8022376:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 802237a:	2300      	movs	r3, #0
 802237c:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 8022380:	e1a1      	b.n	80226c6 <jpeg_idct_8x16+0x9c6>
    outptr = output_buf[ctr] + output_col;
 8022382:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 8022386:	009b      	lsls	r3, r3, #2
 8022388:	463a      	mov	r2, r7
 802238a:	6812      	ldr	r2, [r2, #0]
 802238c:	4413      	add	r3, r2
 802238e:	681a      	ldr	r2, [r3, #0]
 8022390:	f8d7 3280 	ldr.w	r3, [r7, #640]	; 0x280
 8022394:	4413      	add	r3, r2
 8022396:	f8c7 3260 	str.w	r3, [r7, #608]	; 0x260
    
    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */
    
    z2 = (INT32) wsptr[2];
 802239a:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802239e:	3308      	adds	r3, #8
 80223a0:	681b      	ldr	r3, [r3, #0]
 80223a2:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = (INT32) wsptr[6];
 80223a6:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80223aa:	3318      	adds	r3, #24
 80223ac:	681b      	ldr	r3, [r3, #0]
 80223ae:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 80223b2:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 80223b6:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80223ba:	4413      	add	r3, r2
 80223bc:	f241 1251 	movw	r2, #4433	; 0x1151
 80223c0:	fb02 f303 	mul.w	r3, r2, r3
 80223c4:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 80223c8:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80223cc:	f641 027e 	movw	r2, #6270	; 0x187e
 80223d0:	fb02 f303 	mul.w	r3, r2, r3
 80223d4:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 80223d8:	4413      	add	r3, r2
 80223da:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 80223de:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80223e2:	4abf      	ldr	r2, [pc, #764]	; (80226e0 <jpeg_idct_8x16+0x9e0>)
 80223e4:	fb02 f303 	mul.w	r3, r2, r3
 80223e8:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 80223ec:	4413      	add	r3, r2
 80223ee:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    
    /* Add fudge factor here for final descale. */
    z2 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80223f2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80223f6:	681b      	ldr	r3, [r3, #0]
 80223f8:	3310      	adds	r3, #16
 80223fa:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = (INT32) wsptr[4];
 80223fe:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022402:	3310      	adds	r3, #16
 8022404:	681b      	ldr	r3, [r3, #0]
 8022406:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    
    tmp0 = (z2 + z3) << CONST_BITS;
 802240a:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 802240e:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8022412:	4413      	add	r3, r2
 8022414:	035b      	lsls	r3, r3, #13
 8022416:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp1 = (z2 - z3) << CONST_BITS;
 802241a:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 802241e:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8022422:	1ad3      	subs	r3, r2, r3
 8022424:	035b      	lsls	r3, r3, #13
 8022426:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    
    tmp10 = tmp0 + tmp2;
 802242a:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 802242e:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022432:	4413      	add	r3, r2
 8022434:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
    tmp13 = tmp0 - tmp2;
 8022438:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 802243c:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022440:	1ad3      	subs	r3, r2, r3
 8022442:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
    tmp11 = tmp1 + tmp3;
 8022446:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 802244a:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 802244e:	4413      	add	r3, r2
 8022450:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
    tmp12 = tmp1 - tmp3;
 8022454:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 8022458:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 802245c:	1ad3      	subs	r3, r2, r3
 802245e:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    
    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */
    
    tmp0 = (INT32) wsptr[7];
 8022462:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022466:	331c      	adds	r3, #28
 8022468:	681b      	ldr	r3, [r3, #0]
 802246a:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp1 = (INT32) wsptr[5];
 802246e:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 8022472:	3314      	adds	r3, #20
 8022474:	681b      	ldr	r3, [r3, #0]
 8022476:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2 = (INT32) wsptr[3];
 802247a:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802247e:	330c      	adds	r3, #12
 8022480:	681b      	ldr	r3, [r3, #0]
 8022482:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp3 = (INT32) wsptr[1];
 8022486:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 802248a:	3304      	adds	r3, #4
 802248c:	681b      	ldr	r3, [r3, #0]
 802248e:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    
    z2 = tmp0 + tmp2;
 8022492:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8022496:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 802249a:	4413      	add	r3, r2
 802249c:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = tmp1 + tmp3;
 80224a0:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 80224a4:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 80224a8:	4413      	add	r3, r2
 80224aa:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 80224ae:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 80224b2:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80224b6:	4413      	add	r3, r2
 80224b8:	f242 52a1 	movw	r2, #9633	; 0x25a1
 80224bc:	fb02 f303 	mul.w	r3, r2, r3
 80224c0:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 80224c4:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80224c8:	4a86      	ldr	r2, [pc, #536]	; (80226e4 <jpeg_idct_8x16+0x9e4>)
 80224ca:	fb02 f303 	mul.w	r3, r2, r3
 80224ce:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 80224d2:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 80224d6:	4a84      	ldr	r2, [pc, #528]	; (80226e8 <jpeg_idct_8x16+0x9e8>)
 80224d8:	fb02 f303 	mul.w	r3, r2, r3
 80224dc:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258
    z2 += z1;
 80224e0:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 80224e4:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 80224e8:	4413      	add	r3, r2
 80224ea:	f8c7 325c 	str.w	r3, [r7, #604]	; 0x25c
    z3 += z1;
 80224ee:	f8d7 2258 	ldr.w	r2, [r7, #600]	; 0x258
 80224f2:	f8d7 3254 	ldr.w	r3, [r7, #596]	; 0x254
 80224f6:	4413      	add	r3, r2
 80224f8:	f8c7 3258 	str.w	r3, [r7, #600]	; 0x258

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 80224fc:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 8022500:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 8022504:	4413      	add	r3, r2
 8022506:	4a79      	ldr	r2, [pc, #484]	; (80226ec <jpeg_idct_8x16+0x9ec>)
 8022508:	fb02 f303 	mul.w	r3, r2, r3
 802250c:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8022510:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 8022514:	f640 128e 	movw	r2, #2446	; 0x98e
 8022518:	fb02 f303 	mul.w	r3, r2, r3
 802251c:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8022520:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 8022524:	f243 020b 	movw	r2, #12299	; 0x300b
 8022528:	fb02 f303 	mul.w	r3, r2, r3
 802252c:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
    tmp0 += z1 + z2;
 8022530:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8022534:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 8022538:	4413      	add	r3, r2
 802253a:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 802253e:	4413      	add	r3, r2
 8022540:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
    tmp3 += z1 + z3;
 8022544:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8022548:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 802254c:	4413      	add	r3, r2
 802254e:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 8022552:	4413      	add	r3, r2
 8022554:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8022558:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 802255c:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022560:	4413      	add	r3, r2
 8022562:	4a63      	ldr	r2, [pc, #396]	; (80226f0 <jpeg_idct_8x16+0x9f0>)
 8022564:	fb02 f303 	mul.w	r3, r2, r3
 8022568:	f8c7 3254 	str.w	r3, [r7, #596]	; 0x254
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 802256c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 8022570:	f244 12b3 	movw	r2, #16819	; 0x41b3
 8022574:	fb02 f303 	mul.w	r3, r2, r3
 8022578:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 802257c:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 8022580:	f246 2254 	movw	r2, #25172	; 0x6254
 8022584:	fb02 f303 	mul.w	r3, r2, r3
 8022588:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    tmp1 += z1 + z3;
 802258c:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 8022590:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8022594:	4413      	add	r3, r2
 8022596:	f8d7 2244 	ldr.w	r2, [r7, #580]	; 0x244
 802259a:	4413      	add	r3, r2
 802259c:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
    tmp2 += z1 + z2;
 80225a0:	f8d7 2254 	ldr.w	r2, [r7, #596]	; 0x254
 80225a4:	f8d7 325c 	ldr.w	r3, [r7, #604]	; 0x25c
 80225a8:	4413      	add	r3, r2
 80225aa:	f8d7 2250 	ldr.w	r2, [r7, #592]	; 0x250
 80225ae:	4413      	add	r3, r2
 80225b0:	f8c7 3250 	str.w	r3, [r7, #592]	; 0x250
    
    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
    
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80225b4:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 80225b8:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 80225bc:	4413      	add	r3, r2
 80225be:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80225c0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp3,
 80225c4:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 80225c8:	4413      	add	r3, r2
 80225ca:	781a      	ldrb	r2, [r3, #0]
 80225cc:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 80225d0:	701a      	strb	r2, [r3, #0]
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80225d2:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 80225d6:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 80225da:	1ad3      	subs	r3, r2, r3
 80225dc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80225de:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[7] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp3,
 80225e2:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 80225e6:	441a      	add	r2, r3
 80225e8:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 80225ec:	3307      	adds	r3, #7
 80225ee:	7812      	ldrb	r2, [r2, #0]
 80225f0:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 80225f2:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 80225f6:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 80225fa:	4413      	add	r3, r2
 80225fc:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80225fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp2,
 8022602:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8022606:	441a      	add	r2, r3
 8022608:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802260c:	3301      	adds	r3, #1
 802260e:	7812      	ldrb	r2, [r2, #0]
 8022610:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8022612:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 8022616:	f8d7 3250 	ldr.w	r3, [r7, #592]	; 0x250
 802261a:	1ad3      	subs	r3, r2, r3
 802261c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802261e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp2,
 8022622:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8022626:	441a      	add	r2, r3
 8022628:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802262c:	3306      	adds	r3, #6
 802262e:	7812      	ldrb	r2, [r2, #0]
 8022630:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8022632:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 8022636:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 802263a:	4413      	add	r3, r2
 802263c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802263e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp1,
 8022642:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8022646:	441a      	add	r2, r3
 8022648:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802264c:	3302      	adds	r3, #2
 802264e:	7812      	ldrb	r2, [r2, #0]
 8022650:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8022652:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 8022656:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 802265a:	1ad3      	subs	r3, r2, r3
 802265c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802265e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp1,
 8022662:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8022666:	441a      	add	r2, r3
 8022668:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802266c:	3305      	adds	r3, #5
 802266e:	7812      	ldrb	r2, [r2, #0]
 8022670:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8022672:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 8022676:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 802267a:	4413      	add	r3, r2
 802267c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802267e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp13 + tmp0,
 8022682:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 8022686:	441a      	add	r2, r3
 8022688:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802268c:	3303      	adds	r3, #3
 802268e:	7812      	ldrb	r2, [r2, #0]
 8022690:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 8022692:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 8022696:	f8d7 3248 	ldr.w	r3, [r7, #584]	; 0x248
 802269a:	1ad3      	subs	r3, r2, r3
 802269c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802269e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp13 - tmp0,
 80226a2:	f8d7 2264 	ldr.w	r2, [r7, #612]	; 0x264
 80226a6:	441a      	add	r2, r3
 80226a8:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 80226ac:	3304      	adds	r3, #4
 80226ae:	7812      	ldrb	r2, [r2, #0]
 80226b0:	701a      	strb	r2, [r3, #0]
    
    wsptr += DCTSIZE;		/* advance pointer to next row */
 80226b2:	f8d7 326c 	ldr.w	r3, [r7, #620]	; 0x26c
 80226b6:	3320      	adds	r3, #32
 80226b8:	f8c7 326c 	str.w	r3, [r7, #620]	; 0x26c
  for (ctr = 0; ctr < 16; ctr++) {
 80226bc:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 80226c0:	3301      	adds	r3, #1
 80226c2:	f8c7 3268 	str.w	r3, [r7, #616]	; 0x268
 80226c6:	f8d7 3268 	ldr.w	r3, [r7, #616]	; 0x268
 80226ca:	2b0f      	cmp	r3, #15
 80226cc:	f77f ae59 	ble.w	8022382 <jpeg_idct_8x16+0x682>
  }
}
 80226d0:	bf00      	nop
 80226d2:	bf00      	nop
 80226d4:	f507 771e 	add.w	r7, r7, #632	; 0x278
 80226d8:	46bd      	mov	sp, r7
 80226da:	bc90      	pop	{r4, r7}
 80226dc:	4770      	bx	lr
 80226de:	bf00      	nop
 80226e0:	ffffc4df 	.word	0xffffc4df
 80226e4:	ffffc13b 	.word	0xffffc13b
 80226e8:	fffff384 	.word	0xfffff384
 80226ec:	ffffe333 	.word	0xffffe333
 80226f0:	ffffadfd 	.word	0xffffadfd

080226f4 <jpeg_idct_7x14>:

GLOBAL(void)
jpeg_idct_7x14 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80226f4:	b490      	push	{r4, r7}
 80226f6:	b0fe      	sub	sp, #504	; 0x1f8
 80226f8:	af00      	add	r7, sp, #0
 80226fa:	f107 040c 	add.w	r4, r7, #12
 80226fe:	6020      	str	r0, [r4, #0]
 8022700:	f107 0008 	add.w	r0, r7, #8
 8022704:	6001      	str	r1, [r0, #0]
 8022706:	1d39      	adds	r1, r7, #4
 8022708:	600a      	str	r2, [r1, #0]
 802270a:	463a      	mov	r2, r7
 802270c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 802270e:	f107 030c 	add.w	r3, r7, #12
 8022712:	681b      	ldr	r3, [r3, #0]
 8022714:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8022718:	3380      	adds	r3, #128	; 0x80
 802271a:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 14-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/28).
   */
  inptr = coef_block;
 802271e:	1d3b      	adds	r3, r7, #4
 8022720:	681b      	ldr	r3, [r3, #0]
 8022722:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8022726:	f107 0308 	add.w	r3, r7, #8
 802272a:	681b      	ldr	r3, [r3, #0]
 802272c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802272e:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
  wsptr = workspace;
 8022732:	f107 0310 	add.w	r3, r7, #16
 8022736:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 802273a:	2300      	movs	r3, #0
 802273c:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 8022740:	e267      	b.n	8022c12 <jpeg_idct_7x14+0x51e>
    /* Even part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8022742:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022746:	f9b3 3000 	ldrsh.w	r3, [r3]
 802274a:	461a      	mov	r2, r3
 802274c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022750:	681b      	ldr	r3, [r3, #0]
 8022752:	fb03 f302 	mul.w	r3, r3, r2
 8022756:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z1 <<= CONST_BITS;
 802275a:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 802275e:	035b      	lsls	r3, r3, #13
 8022760:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    /* Add fudge factor here for final descale. */
    z1 += ONE << (CONST_BITS-PASS1_BITS-1);
 8022764:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 8022768:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 802276c:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8022770:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022774:	3340      	adds	r3, #64	; 0x40
 8022776:	f9b3 3000 	ldrsh.w	r3, [r3]
 802277a:	461a      	mov	r2, r3
 802277c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022780:	3380      	adds	r3, #128	; 0x80
 8022782:	681b      	ldr	r3, [r3, #0]
 8022784:	fb03 f302 	mul.w	r3, r3, r2
 8022788:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */
 802278c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022790:	f642 02c6 	movw	r2, #10438	; 0x28c6
 8022794:	fb02 f303 	mul.w	r3, r2, r3
 8022798:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */
 802279c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 80227a0:	f640 2212 	movw	r2, #2578	; 0xa12
 80227a4:	fb02 f303 	mul.w	r3, r2, r3
 80227a8:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */
 80227ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 80227b0:	f641 4237 	movw	r2, #7223	; 0x1c37
 80227b4:	fb02 f303 	mul.w	r3, r2, r3
 80227b8:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4

    tmp10 = z1 + z2;
 80227bc:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 80227c0:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 80227c4:	4413      	add	r3, r2
 80227c6:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp11 = z1 + z3;
 80227ca:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 80227ce:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 80227d2:	4413      	add	r3, r2
 80227d4:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    tmp12 = z1 - z4;
 80227d8:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 80227dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 80227e0:	1ad3      	subs	r3, r2, r3
 80227e2:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    tmp23 = RIGHT_SHIFT(z1 - ((z2 + z3 - z4) << 1), /* c0 = (c4+c12-c8)*2 */
 80227e6:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 80227ea:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 80227ee:	441a      	add	r2, r3
 80227f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 80227f4:	1ad3      	subs	r3, r2, r3
 80227f6:	005b      	lsls	r3, r3, #1
 80227f8:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 80227fc:	1ad3      	subs	r3, r2, r3
 80227fe:	12db      	asrs	r3, r3, #11
 8022800:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
			CONST_BITS-PASS1_BITS);

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8022804:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022808:	3320      	adds	r3, #32
 802280a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802280e:	461a      	mov	r2, r3
 8022810:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022814:	3340      	adds	r3, #64	; 0x40
 8022816:	681b      	ldr	r3, [r3, #0]
 8022818:	fb03 f302 	mul.w	r3, r3, r2
 802281c:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8022820:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022824:	3360      	adds	r3, #96	; 0x60
 8022826:	f9b3 3000 	ldrsh.w	r3, [r3]
 802282a:	461a      	mov	r2, r3
 802282c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022830:	33c0      	adds	r3, #192	; 0xc0
 8022832:	681b      	ldr	r3, [r3, #0]
 8022834:	fb03 f302 	mul.w	r3, r3, r2
 8022838:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4

    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */
 802283c:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022840:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022844:	4413      	add	r3, r2
 8022846:	f242 3262 	movw	r2, #9058	; 0x2362
 802284a:	fb02 f303 	mul.w	r3, r2, r3
 802284e:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */
 8022852:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 8022856:	f640 02bd 	movw	r2, #2237	; 0x8bd
 802285a:	fb02 f303 	mul.w	r3, r2, r3
 802285e:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 8022862:	4413      	add	r3, r2
 8022864:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */
 8022868:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 802286c:	4aef      	ldr	r2, [pc, #956]	; (8022c2c <jpeg_idct_7x14+0x538>)
 802286e:	fb02 f303 	mul.w	r3, r2, r3
 8022872:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 8022876:	4413      	add	r3, r2
 8022878:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 802287c:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 8022880:	f241 32a3 	movw	r2, #5027	; 0x13a3
 8022884:	fb02 f203 	mul.w	r2, r2, r3
	    MULTIPLY(z2, FIX(1.378756276));      /* c2 */
 8022888:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 802288c:	49e8      	ldr	r1, [pc, #928]	; (8022c30 <jpeg_idct_7x14+0x53c>)
 802288e:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */
 8022892:	4413      	add	r3, r2
 8022894:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8

    tmp20 = tmp10 + tmp13;
 8022898:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 802289c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 80228a0:	4413      	add	r3, r2
 80228a2:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp26 = tmp10 - tmp13;
 80228a6:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 80228aa:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 80228ae:	1ad3      	subs	r3, r2, r3
 80228b0:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
    tmp21 = tmp11 + tmp14;
 80228b4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 80228b8:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 80228bc:	4413      	add	r3, r2
 80228be:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp25 = tmp11 - tmp14;
 80228c2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 80228c6:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 80228ca:	1ad3      	subs	r3, r2, r3
 80228cc:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
    tmp22 = tmp12 + tmp15;
 80228d0:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 80228d4:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 80228d8:	4413      	add	r3, r2
 80228da:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    tmp24 = tmp12 - tmp15;
 80228de:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 80228e2:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 80228e6:	1ad3      	subs	r3, r2, r3
 80228e8:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80228ec:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 80228f0:	3310      	adds	r3, #16
 80228f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80228f6:	461a      	mov	r2, r3
 80228f8:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 80228fc:	3320      	adds	r3, #32
 80228fe:	681b      	ldr	r3, [r3, #0]
 8022900:	fb03 f302 	mul.w	r3, r3, r2
 8022904:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8022908:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 802290c:	3330      	adds	r3, #48	; 0x30
 802290e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022912:	461a      	mov	r2, r3
 8022914:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022918:	3360      	adds	r3, #96	; 0x60
 802291a:	681b      	ldr	r3, [r3, #0]
 802291c:	fb03 f302 	mul.w	r3, r3, r2
 8022920:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8022924:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022928:	3350      	adds	r3, #80	; 0x50
 802292a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802292e:	461a      	mov	r2, r3
 8022930:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022934:	33a0      	adds	r3, #160	; 0xa0
 8022936:	681b      	ldr	r3, [r3, #0]
 8022938:	fb03 f302 	mul.w	r3, r3, r2
 802293c:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8022940:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022944:	3370      	adds	r3, #112	; 0x70
 8022946:	f9b3 3000 	ldrsh.w	r3, [r3]
 802294a:	461a      	mov	r2, r3
 802294c:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022950:	33e0      	adds	r3, #224	; 0xe0
 8022952:	681b      	ldr	r3, [r3, #0]
 8022954:	fb03 f302 	mul.w	r3, r3, r2
 8022958:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp13 = z4 << CONST_BITS;
 802295c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022960:	035b      	lsls	r3, r3, #13
 8022962:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0

    tmp14 = z1 + z3;
 8022966:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 802296a:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 802296e:	4413      	add	r3, r2
 8022970:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */
 8022974:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022978:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 802297c:	4413      	add	r3, r2
 802297e:	f642 22b7 	movw	r2, #10935	; 0x2ab7
 8022982:	fb02 f303 	mul.w	r3, r2, r3
 8022986:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */
 802298a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 802298e:	f242 6252 	movw	r2, #9810	; 0x2652
 8022992:	fb02 f303 	mul.w	r3, r2, r3
 8022996:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */
 802299a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 802299e:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 80229a2:	441a      	add	r2, r3
 80229a4:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 80229a8:	441a      	add	r2, r3
 80229aa:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 80229ae:	49a1      	ldr	r1, [pc, #644]	; (8022c34 <jpeg_idct_7x14+0x540>)
 80229b0:	fb01 f303 	mul.w	r3, r1, r3
 80229b4:	4413      	add	r3, r2
 80229b6:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */
 80229ba:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 80229be:	f641 0214 	movw	r2, #6164	; 0x1814
 80229c2:	fb02 f303 	mul.w	r3, r2, r3
 80229c6:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */
 80229ca:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 80229ce:	4a9a      	ldr	r2, [pc, #616]	; (8022c38 <jpeg_idct_7x14+0x544>)
 80229d0:	fb02 f303 	mul.w	r3, r2, r3
 80229d4:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 80229d8:	4413      	add	r3, r2
 80229da:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    z1    -= z2;
 80229de:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 80229e2:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 80229e6:	1ad3      	subs	r3, r2, r3
 80229e8:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */
 80229ec:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 80229f0:	f640 62f2 	movw	r2, #3826	; 0xef2
 80229f4:	fb02 f203 	mul.w	r2, r2, r3
 80229f8:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 80229fc:	1ad3      	subs	r3, r2, r3
 80229fe:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
    tmp16 += tmp15;
 8022a02:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 8022a06:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8022a0a:	4413      	add	r3, r2
 8022a0c:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
    z1    += z4;
 8022a10:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022a14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022a18:	4413      	add	r3, r2
 8022a1a:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z4    = MULTIPLY(z2 + z3, - FIX(0.158341681)) - tmp13; /* -c13 */
 8022a1e:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 8022a22:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022a26:	4413      	add	r3, r2
 8022a28:	f46f 62a2 	mvn.w	r2, #1296	; 0x510
 8022a2c:	fb02 f203 	mul.w	r2, r2, r3
 8022a30:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 8022a34:	1ad3      	subs	r3, r2, r3
 8022a36:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */
 8022a3a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022a3e:	4a7f      	ldr	r2, [pc, #508]	; (8022c3c <jpeg_idct_7x14+0x548>)
 8022a40:	fb02 f203 	mul.w	r2, r2, r3
 8022a44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022a48:	4413      	add	r3, r2
 8022a4a:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 8022a4e:	4413      	add	r3, r2
 8022a50:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */
 8022a54:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022a58:	4a79      	ldr	r2, [pc, #484]	; (8022c40 <jpeg_idct_7x14+0x54c>)
 8022a5a:	fb02 f203 	mul.w	r2, r2, r3
 8022a5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022a62:	4413      	add	r3, r2
 8022a64:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 8022a68:	4413      	add	r3, r2
 8022a6a:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */
 8022a6e:	f8d7 21d0 	ldr.w	r2, [r7, #464]	; 0x1d0
 8022a72:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022a76:	1ad3      	subs	r3, r2, r3
 8022a78:	f642 42f8 	movw	r2, #11512	; 0x2cf8
 8022a7c:	fb02 f303 	mul.w	r3, r2, r3
 8022a80:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */
 8022a84:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
 8022a88:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 8022a8c:	441a      	add	r2, r3
 8022a8e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022a92:	496c      	ldr	r1, [pc, #432]	; (8022c44 <jpeg_idct_7x14+0x550>)
 8022a94:	fb01 f303 	mul.w	r3, r1, r3
 8022a98:	4413      	add	r3, r2
 8022a9a:	f8d7 21ac 	ldr.w	r2, [r7, #428]	; 0x1ac
 8022a9e:	4413      	add	r3, r2
 8022aa0:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */
 8022aa4:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022aa8:	f241 5299 	movw	r2, #5529	; 0x1599
 8022aac:	fb02 f203 	mul.w	r2, r2, r3
 8022ab0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8022ab4:	4413      	add	r3, r2
 8022ab6:	f8d7 21a8 	ldr.w	r2, [r7, #424]	; 0x1a8
 8022aba:	4413      	add	r3, r2
 8022abc:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8

    tmp13 = (z1 - z3) << PASS1_BITS;
 8022ac0:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022ac4:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022ac8:	1ad3      	subs	r3, r2, r3
 8022aca:	009b      	lsls	r3, r3, #2
 8022acc:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0

    /* Final output stage */

    wsptr[7*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8022ad0:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022ad4:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022ad8:	4413      	add	r3, r2
 8022ada:	12da      	asrs	r2, r3, #11
 8022adc:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022ae0:	601a      	str	r2, [r3, #0]
    wsptr[7*13] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 8022ae2:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022ae6:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022aea:	1ad2      	subs	r2, r2, r3
 8022aec:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022af0:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8022af4:	12d2      	asrs	r2, r2, #11
 8022af6:	601a      	str	r2, [r3, #0]
    wsptr[7*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 8022af8:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 8022afc:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 8022b00:	441a      	add	r2, r3
 8022b02:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b06:	331c      	adds	r3, #28
 8022b08:	12d2      	asrs	r2, r2, #11
 8022b0a:	601a      	str	r2, [r3, #0]
    wsptr[7*12] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8022b0c:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 8022b10:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 8022b14:	1ad2      	subs	r2, r2, r3
 8022b16:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b1a:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8022b1e:	12d2      	asrs	r2, r2, #11
 8022b20:	601a      	str	r2, [r3, #0]
    wsptr[7*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 8022b22:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 8022b26:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022b2a:	441a      	add	r2, r3
 8022b2c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b30:	3338      	adds	r3, #56	; 0x38
 8022b32:	12d2      	asrs	r2, r2, #11
 8022b34:	601a      	str	r2, [r3, #0]
    wsptr[7*11] = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 8022b36:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 8022b3a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022b3e:	1ad2      	subs	r2, r2, r3
 8022b40:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b44:	f503 739a 	add.w	r3, r3, #308	; 0x134
 8022b48:	12d2      	asrs	r2, r2, #11
 8022b4a:	601a      	str	r2, [r3, #0]
    wsptr[7*3]  = (int) (tmp23 + tmp13);
 8022b4c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b50:	3354      	adds	r3, #84	; 0x54
 8022b52:	f8d7 11dc 	ldr.w	r1, [r7, #476]	; 0x1dc
 8022b56:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 8022b5a:	440a      	add	r2, r1
 8022b5c:	601a      	str	r2, [r3, #0]
    wsptr[7*10] = (int) (tmp23 - tmp13);
 8022b5e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b62:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8022b66:	f8d7 11dc 	ldr.w	r1, [r7, #476]	; 0x1dc
 8022b6a:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
 8022b6e:	1a8a      	subs	r2, r1, r2
 8022b70:	601a      	str	r2, [r3, #0]
    wsptr[7*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8022b72:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 8022b76:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 8022b7a:	441a      	add	r2, r3
 8022b7c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b80:	3370      	adds	r3, #112	; 0x70
 8022b82:	12d2      	asrs	r2, r2, #11
 8022b84:	601a      	str	r2, [r3, #0]
    wsptr[7*9]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 8022b86:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 8022b8a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 8022b8e:	1ad2      	subs	r2, r2, r3
 8022b90:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022b94:	33fc      	adds	r3, #252	; 0xfc
 8022b96:	12d2      	asrs	r2, r2, #11
 8022b98:	601a      	str	r2, [r3, #0]
    wsptr[7*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 8022b9a:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 8022b9e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8022ba2:	441a      	add	r2, r3
 8022ba4:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022ba8:	338c      	adds	r3, #140	; 0x8c
 8022baa:	12d2      	asrs	r2, r2, #11
 8022bac:	601a      	str	r2, [r3, #0]
    wsptr[7*8]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8022bae:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 8022bb2:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8022bb6:	1ad2      	subs	r2, r2, r3
 8022bb8:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022bbc:	33e0      	adds	r3, #224	; 0xe0
 8022bbe:	12d2      	asrs	r2, r2, #11
 8022bc0:	601a      	str	r2, [r3, #0]
    wsptr[7*6]  = (int) RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS-PASS1_BITS);
 8022bc2:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8022bc6:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 8022bca:	441a      	add	r2, r3
 8022bcc:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022bd0:	33a8      	adds	r3, #168	; 0xa8
 8022bd2:	12d2      	asrs	r2, r2, #11
 8022bd4:	601a      	str	r2, [r3, #0]
    wsptr[7*7]  = (int) RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS-PASS1_BITS);
 8022bd6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8022bda:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 8022bde:	1ad2      	subs	r2, r2, r3
 8022be0:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022be4:	33c4      	adds	r3, #196	; 0xc4
 8022be6:	12d2      	asrs	r2, r2, #11
 8022be8:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {
 8022bea:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8022bee:	3301      	adds	r3, #1
 8022bf0:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 8022bf4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 8022bf8:	3302      	adds	r3, #2
 8022bfa:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
 8022bfe:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 8022c02:	3304      	adds	r3, #4
 8022c04:	f8c7 31f0 	str.w	r3, [r7, #496]	; 0x1f0
 8022c08:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022c0c:	3304      	adds	r3, #4
 8022c0e:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
 8022c12:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8022c16:	2b06      	cmp	r3, #6
 8022c18:	f77f ad93 	ble.w	8022742 <jpeg_idct_7x14+0x4e>
  }

  /* Pass 2: process 14 rows from work array, store into output array.
   * 7-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/14).
   */
  wsptr = workspace;
 8022c1c:	f107 0310 	add.w	r3, r7, #16
 8022c20:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 8022c24:	2300      	movs	r3, #0
 8022c26:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 8022c2a:	e178      	b.n	8022f1e <jpeg_idct_7x14+0x82a>
 8022c2c:	ffffc8fc 	.word	0xffffc8fc
 8022c30:	ffffd3e1 	.word	0xffffd3e1
 8022c34:	ffffdbf0 	.word	0xffffdbf0
 8022c38:	ffffde0b 	.word	0xffffde0b
 8022c3c:	fffff26e 	.word	0xfffff26e
 8022c40:	ffffb409 	.word	0xffffb409
 8022c44:	ffffc9e6 	.word	0xffffc9e6
    outptr = output_buf[ctr] + output_col;
 8022c48:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8022c4c:	009b      	lsls	r3, r3, #2
 8022c4e:	463a      	mov	r2, r7
 8022c50:	6812      	ldr	r2, [r2, #0]
 8022c52:	4413      	add	r3, r2
 8022c54:	681a      	ldr	r2, [r3, #0]
 8022c56:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 8022c5a:	4413      	add	r3, r2
 8022c5c:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp23 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8022c60:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022c64:	681b      	ldr	r3, [r3, #0]
 8022c66:	3310      	adds	r3, #16
 8022c68:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc
    tmp23 <<= CONST_BITS;
 8022c6c:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 8022c70:	035b      	lsls	r3, r3, #13
 8022c72:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc

    z1 = (INT32) wsptr[2];
 8022c76:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022c7a:	3308      	adds	r3, #8
 8022c7c:	681b      	ldr	r3, [r3, #0]
 8022c7e:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z2 = (INT32) wsptr[4];
 8022c82:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022c86:	3310      	adds	r3, #16
 8022c88:	681b      	ldr	r3, [r3, #0]
 8022c8a:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    z3 = (INT32) wsptr[6];
 8022c8e:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022c92:	3318      	adds	r3, #24
 8022c94:	681b      	ldr	r3, [r3, #0]
 8022c96:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    tmp20 = MULTIPLY(z2 - z3, FIX(0.881747734));       /* c4 */
 8022c9a:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 8022c9e:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022ca2:	1ad3      	subs	r3, r2, r3
 8022ca4:	f641 4237 	movw	r2, #7223	; 0x1c37
 8022ca8:	fb02 f303 	mul.w	r3, r2, r3
 8022cac:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp22 = MULTIPLY(z1 - z2, FIX(0.314692123));       /* c6 */
 8022cb0:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022cb4:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022cb8:	1ad3      	subs	r3, r2, r3
 8022cba:	f640 2212 	movw	r2, #2578	; 0xa12
 8022cbe:	fb02 f303 	mul.w	r3, r2, r3
 8022cc2:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    tmp21 = tmp20 + tmp22 + tmp23 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */
 8022cc6:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022cca:	f8d7 31c8 	ldr.w	r3, [r7, #456]	; 0x1c8
 8022cce:	441a      	add	r2, r3
 8022cd0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 8022cd4:	441a      	add	r2, r3
 8022cd6:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022cda:	4997      	ldr	r1, [pc, #604]	; (8022f38 <jpeg_idct_7x14+0x844>)
 8022cdc:	fb01 f303 	mul.w	r3, r1, r3
 8022ce0:	4413      	add	r3, r2
 8022ce2:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
    tmp10 = z1 + z3;
 8022ce6:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022cea:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022cee:	4413      	add	r3, r2
 8022cf0:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    z2 -= tmp10;
 8022cf4:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 8022cf8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022cfc:	1ad3      	subs	r3, r2, r3
 8022cfe:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    tmp10 = MULTIPLY(tmp10, FIX(1.274162392)) + tmp23; /* c2 */
 8022d02:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022d06:	f642 02c6 	movw	r2, #10438	; 0x28c6
 8022d0a:	fb02 f303 	mul.w	r3, r2, r3
 8022d0e:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 8022d12:	4413      	add	r3, r2
 8022d14:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp20 += tmp10 - MULTIPLY(z3, FIX(0.077722536));   /* c2-c4-c6 */
 8022d18:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022d1c:	f46f 721f 	mvn.w	r2, #636	; 0x27c
 8022d20:	fb02 f203 	mul.w	r2, r2, r3
 8022d24:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022d28:	4413      	add	r3, r2
 8022d2a:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022d2e:	4413      	add	r3, r2
 8022d30:	f8c7 31cc 	str.w	r3, [r7, #460]	; 0x1cc
    tmp22 += tmp10 - MULTIPLY(z1, FIX(2.470602249));   /* c2+c4+c6 */
 8022d34:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
 8022d38:	4a80      	ldr	r2, [pc, #512]	; (8022f3c <jpeg_idct_7x14+0x848>)
 8022d3a:	fb02 f203 	mul.w	r2, r2, r3
 8022d3e:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022d42:	4413      	add	r3, r2
 8022d44:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 8022d48:	4413      	add	r3, r2
 8022d4a:	f8c7 31c8 	str.w	r3, [r7, #456]	; 0x1c8
    tmp23 += MULTIPLY(z2, FIX(1.414213562));           /* c0 */
 8022d4e:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022d52:	f642 5241 	movw	r2, #11585	; 0x2d41
 8022d56:	fb02 f303 	mul.w	r3, r2, r3
 8022d5a:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
 8022d5e:	4413      	add	r3, r2
 8022d60:	f8c7 31dc 	str.w	r3, [r7, #476]	; 0x1dc

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8022d64:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022d68:	3304      	adds	r3, #4
 8022d6a:	681b      	ldr	r3, [r3, #0]
 8022d6c:	f8c7 31d8 	str.w	r3, [r7, #472]	; 0x1d8
    z2 = (INT32) wsptr[3];
 8022d70:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022d74:	330c      	adds	r3, #12
 8022d76:	681b      	ldr	r3, [r3, #0]
 8022d78:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    z3 = (INT32) wsptr[5];
 8022d7c:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022d80:	3314      	adds	r3, #20
 8022d82:	681b      	ldr	r3, [r3, #0]
 8022d84:	f8c7 31d0 	str.w	r3, [r7, #464]	; 0x1d0

    tmp11 = MULTIPLY(z1 + z2, FIX(0.935414347));       /* (c3+c1-c5)/2 */
 8022d88:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022d8c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022d90:	4413      	add	r3, r2
 8022d92:	f641 52ef 	movw	r2, #7663	; 0x1def
 8022d96:	fb02 f303 	mul.w	r3, r2, r3
 8022d9a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    tmp12 = MULTIPLY(z1 - z2, FIX(0.170262339));       /* (c3+c5-c1)/2 */
 8022d9e:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022da2:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022da6:	1ad3      	subs	r3, r2, r3
 8022da8:	f240 5273 	movw	r2, #1395	; 0x573
 8022dac:	fb02 f303 	mul.w	r3, r2, r3
 8022db0:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp10 = tmp11 - tmp12;
 8022db4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 8022db8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022dbc:	1ad3      	subs	r3, r2, r3
 8022dbe:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp11 += tmp12;
 8022dc2:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 8022dc6:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022dca:	4413      	add	r3, r2
 8022dcc:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    tmp12 = MULTIPLY(z2 + z3, - FIX(1.378756276));     /* -c1 */
 8022dd0:	f8d7 21d4 	ldr.w	r2, [r7, #468]	; 0x1d4
 8022dd4:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022dd8:	4413      	add	r3, r2
 8022dda:	4a59      	ldr	r2, [pc, #356]	; (8022f40 <jpeg_idct_7x14+0x84c>)
 8022ddc:	fb02 f303 	mul.w	r3, r2, r3
 8022de0:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
    tmp11 += tmp12;
 8022de4:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
 8022de8:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022dec:	4413      	add	r3, r2
 8022dee:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));          /* c5 */
 8022df2:	f8d7 21d8 	ldr.w	r2, [r7, #472]	; 0x1d8
 8022df6:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022dfa:	4413      	add	r3, r2
 8022dfc:	f241 32a3 	movw	r2, #5027	; 0x13a3
 8022e00:	fb02 f303 	mul.w	r3, r2, r3
 8022e04:	f8c7 31d4 	str.w	r3, [r7, #468]	; 0x1d4
    tmp10 += z2;
 8022e08:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
 8022e0c:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022e10:	4413      	add	r3, r2
 8022e12:	f8c7 31c0 	str.w	r3, [r7, #448]	; 0x1c0
    tmp12 += z2 + MULTIPLY(z3, FIX(1.870828693));      /* c3+c1-c5 */
 8022e16:	f8d7 31d0 	ldr.w	r3, [r7, #464]	; 0x1d0
 8022e1a:	f643 32de 	movw	r2, #15326	; 0x3bde
 8022e1e:	fb02 f203 	mul.w	r2, r2, r3
 8022e22:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
 8022e26:	4413      	add	r3, r2
 8022e28:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
 8022e2c:	4413      	add	r3, r2
 8022e2e:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8022e32:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022e36:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022e3a:	4413      	add	r3, r2
 8022e3c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022e3e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8022e42:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022e46:	4413      	add	r3, r2
 8022e48:	781a      	ldrb	r2, [r3, #0]
 8022e4a:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022e4e:	701a      	strb	r2, [r3, #0]
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8022e50:	f8d7 21cc 	ldr.w	r2, [r7, #460]	; 0x1cc
 8022e54:	f8d7 31c0 	ldr.w	r3, [r7, #448]	; 0x1c0
 8022e58:	1ad3      	subs	r3, r2, r3
 8022e5a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022e5c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[6] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 8022e60:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022e64:	441a      	add	r2, r3
 8022e66:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022e6a:	3306      	adds	r3, #6
 8022e6c:	7812      	ldrb	r2, [r2, #0]
 8022e6e:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8022e70:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 8022e74:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 8022e78:	4413      	add	r3, r2
 8022e7a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022e7c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 8022e80:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022e84:	441a      	add	r2, r3
 8022e86:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022e8a:	3301      	adds	r3, #1
 8022e8c:	7812      	ldrb	r2, [r2, #0]
 8022e8e:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8022e90:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
 8022e94:	f8d7 31bc 	ldr.w	r3, [r7, #444]	; 0x1bc
 8022e98:	1ad3      	subs	r3, r2, r3
 8022e9a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022e9c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 8022ea0:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022ea4:	441a      	add	r2, r3
 8022ea6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022eaa:	3305      	adds	r3, #5
 8022eac:	7812      	ldrb	r2, [r2, #0]
 8022eae:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8022eb0:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 8022eb4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022eb8:	4413      	add	r3, r2
 8022eba:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022ebc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 8022ec0:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022ec4:	441a      	add	r2, r3
 8022ec6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022eca:	3302      	adds	r3, #2
 8022ecc:	7812      	ldrb	r2, [r2, #0]
 8022ece:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8022ed0:	f8d7 21c8 	ldr.w	r2, [r7, #456]	; 0x1c8
 8022ed4:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8022ed8:	1ad3      	subs	r3, r2, r3
 8022eda:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022edc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 8022ee0:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022ee4:	441a      	add	r2, r3
 8022ee6:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022eea:	3304      	adds	r3, #4
 8022eec:	7812      	ldrb	r2, [r2, #0]
 8022eee:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 8022ef0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 8022ef4:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8022ef6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp23,
 8022efa:	f8d7 21e4 	ldr.w	r2, [r7, #484]	; 0x1e4
 8022efe:	441a      	add	r2, r3
 8022f00:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 8022f04:	3303      	adds	r3, #3
 8022f06:	7812      	ldrb	r2, [r2, #0]
 8022f08:	701a      	strb	r2, [r3, #0]

    wsptr += 7;		/* advance pointer to next row */
 8022f0a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8022f0e:	331c      	adds	r3, #28
 8022f10:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
  for (ctr = 0; ctr < 14; ctr++) {
 8022f14:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8022f18:	3301      	adds	r3, #1
 8022f1a:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 8022f1e:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8022f22:	2b0d      	cmp	r3, #13
 8022f24:	f77f ae90 	ble.w	8022c48 <jpeg_idct_7x14+0x554>
  }
}
 8022f28:	bf00      	nop
 8022f2a:	bf00      	nop
 8022f2c:	f507 77fc 	add.w	r7, r7, #504	; 0x1f8
 8022f30:	46bd      	mov	sp, r7
 8022f32:	bc90      	pop	{r4, r7}
 8022f34:	4770      	bx	lr
 8022f36:	bf00      	nop
 8022f38:	ffffc515 	.word	0xffffc515
 8022f3c:	ffffb0f1 	.word	0xffffb0f1
 8022f40:	ffffd3e1 	.word	0xffffd3e1

08022f44 <jpeg_idct_6x12>:

GLOBAL(void)
jpeg_idct_6x12 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8022f44:	b490      	push	{r4, r7}
 8022f46:	b0e2      	sub	sp, #392	; 0x188
 8022f48:	af00      	add	r7, sp, #0
 8022f4a:	f107 040c 	add.w	r4, r7, #12
 8022f4e:	6020      	str	r0, [r4, #0]
 8022f50:	f107 0008 	add.w	r0, r7, #8
 8022f54:	6001      	str	r1, [r0, #0]
 8022f56:	1d39      	adds	r1, r7, #4
 8022f58:	600a      	str	r2, [r1, #0]
 8022f5a:	463a      	mov	r2, r7
 8022f5c:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8022f5e:	f107 030c 	add.w	r3, r7, #12
 8022f62:	681b      	ldr	r3, [r3, #0]
 8022f64:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8022f68:	3380      	adds	r3, #128	; 0x80
 8022f6a:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 12-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/24).
   */
  inptr = coef_block;
 8022f6e:	1d3b      	adds	r3, r7, #4
 8022f70:	681b      	ldr	r3, [r3, #0]
 8022f72:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8022f76:	f107 0308 	add.w	r3, r7, #8
 8022f7a:	681b      	ldr	r3, [r3, #0]
 8022f7c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8022f7e:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
  wsptr = workspace;
 8022f82:	f107 0310 	add.w	r3, r7, #16
 8022f86:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8022f8a:	2300      	movs	r3, #0
 8022f8c:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8022f90:	e215      	b.n	80233be <jpeg_idct_6x12+0x47a>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8022f92:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8022f96:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022f9a:	461a      	mov	r2, r3
 8022f9c:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8022fa0:	681b      	ldr	r3, [r3, #0]
 8022fa2:	fb03 f302 	mul.w	r3, r3, r2
 8022fa6:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    z3 <<= CONST_BITS;
 8022faa:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8022fae:	035b      	lsls	r3, r3, #13
 8022fb0:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 8022fb4:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8022fb8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8022fbc:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c

    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8022fc0:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8022fc4:	3340      	adds	r3, #64	; 0x40
 8022fc6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022fca:	461a      	mov	r2, r3
 8022fcc:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8022fd0:	3380      	adds	r3, #128	; 0x80
 8022fd2:	681b      	ldr	r3, [r3, #0]
 8022fd4:	fb03 f302 	mul.w	r3, r3, r2
 8022fd8:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */
 8022fdc:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8022fe0:	f242 7231 	movw	r2, #10033	; 0x2731
 8022fe4:	fb02 f303 	mul.w	r3, r2, r3
 8022fe8:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148

    tmp10 = z3 + z4;
 8022fec:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8022ff0:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8022ff4:	4413      	add	r3, r2
 8022ff6:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp11 = z3 - z4;
 8022ffa:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8022ffe:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8023002:	1ad3      	subs	r3, r2, r3
 8023004:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

    z1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8023008:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 802300c:	3320      	adds	r3, #32
 802300e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023012:	461a      	mov	r2, r3
 8023014:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8023018:	3340      	adds	r3, #64	; 0x40
 802301a:	681b      	ldr	r3, [r3, #0]
 802301c:	fb03 f302 	mul.w	r3, r3, r2
 8023020:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */
 8023024:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8023028:	f642 32b6 	movw	r2, #11190	; 0x2bb6
 802302c:	fb02 f303 	mul.w	r3, r2, r3
 8023030:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
    z1 <<= CONST_BITS;
 8023034:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8023038:	035b      	lsls	r3, r3, #13
 802303a:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 802303e:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8023042:	3360      	adds	r3, #96	; 0x60
 8023044:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023048:	461a      	mov	r2, r3
 802304a:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 802304e:	33c0      	adds	r3, #192	; 0xc0
 8023050:	681b      	ldr	r3, [r3, #0]
 8023052:	fb03 f302 	mul.w	r3, r3, r2
 8023056:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    z2 <<= CONST_BITS;
 802305a:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 802305e:	035b      	lsls	r3, r3, #13
 8023060:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    tmp12 = z1 - z2;
 8023064:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 8023068:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 802306c:	1ad3      	subs	r3, r2, r3
 802306e:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

    tmp21 = z3 + tmp12;
 8023072:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8023076:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 802307a:	4413      	add	r3, r2
 802307c:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp24 = z3 - tmp12;
 8023080:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8023084:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8023088:	1ad3      	subs	r3, r2, r3
 802308a:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

    tmp12 = z4 + z2;
 802308e:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 8023092:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8023096:	4413      	add	r3, r2
 8023098:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

    tmp20 = tmp10 + tmp12;
 802309c:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 80230a0:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80230a4:	4413      	add	r3, r2
 80230a6:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp25 = tmp10 - tmp12;
 80230aa:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 80230ae:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80230b2:	1ad3      	subs	r3, r2, r3
 80230b4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

    tmp12 = z4 - z1 - z2;
 80230b8:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
 80230bc:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80230c0:	1ad2      	subs	r2, r2, r3
 80230c2:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 80230c6:	1ad3      	subs	r3, r2, r3
 80230c8:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

    tmp22 = tmp11 + tmp12;
 80230cc:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 80230d0:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80230d4:	4413      	add	r3, r2
 80230d6:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    tmp23 = tmp11 - tmp12;
 80230da:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 80230de:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80230e2:	1ad3      	subs	r3, r2, r3
 80230e4:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80230e8:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 80230ec:	3310      	adds	r3, #16
 80230ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80230f2:	461a      	mov	r2, r3
 80230f4:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 80230f8:	3320      	adds	r3, #32
 80230fa:	681b      	ldr	r3, [r3, #0]
 80230fc:	fb03 f302 	mul.w	r3, r3, r2
 8023100:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8023104:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8023108:	3330      	adds	r3, #48	; 0x30
 802310a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802310e:	461a      	mov	r2, r3
 8023110:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8023114:	3360      	adds	r3, #96	; 0x60
 8023116:	681b      	ldr	r3, [r3, #0]
 8023118:	fb03 f302 	mul.w	r3, r3, r2
 802311c:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8023120:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8023124:	3350      	adds	r3, #80	; 0x50
 8023126:	f9b3 3000 	ldrsh.w	r3, [r3]
 802312a:	461a      	mov	r2, r3
 802312c:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8023130:	33a0      	adds	r3, #160	; 0xa0
 8023132:	681b      	ldr	r3, [r3, #0]
 8023134:	fb03 f302 	mul.w	r3, r3, r2
 8023138:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 802313c:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 8023140:	3370      	adds	r3, #112	; 0x70
 8023142:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023146:	461a      	mov	r2, r3
 8023148:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 802314c:	33e0      	adds	r3, #224	; 0xe0
 802314e:	681b      	ldr	r3, [r3, #0]
 8023150:	fb03 f302 	mul.w	r3, r3, r2
 8023154:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148

    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */
 8023158:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 802315c:	f642 12cf 	movw	r2, #10703	; 0x29cf
 8023160:	fb02 f303 	mul.w	r3, r2, r3
 8023164:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp14 = MULTIPLY(z2, - FIX_0_541196100);                 /* -c9 */
 8023168:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 802316c:	4a9a      	ldr	r2, [pc, #616]	; (80233d8 <jpeg_idct_6x12+0x494>)
 802316e:	fb02 f303 	mul.w	r3, r2, r3
 8023172:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    tmp10 = z1 + z3;
 8023176:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 802317a:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 802317e:	4413      	add	r3, r2
 8023180:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */
 8023184:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 8023188:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 802318c:	4413      	add	r3, r2
 802318e:	f641 328d 	movw	r2, #7053	; 0x1b8d
 8023192:	fb02 f303 	mul.w	r3, r2, r3
 8023196:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */
 802319a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 802319e:	f640 025b 	movw	r2, #2139	; 0x85b
 80231a2:	fb02 f303 	mul.w	r3, r2, r3
 80231a6:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 80231aa:	4413      	add	r3, r2
 80231ac:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */
 80231b0:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 80231b4:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80231b8:	18d1      	adds	r1, r2, r3
 80231ba:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80231be:	4613      	mov	r3, r2
 80231c0:	00db      	lsls	r3, r3, #3
 80231c2:	4413      	add	r3, r2
 80231c4:	021a      	lsls	r2, r3, #8
 80231c6:	1ad3      	subs	r3, r2, r3
 80231c8:	440b      	add	r3, r1
 80231ca:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp13 = MULTIPLY(z3 + z4, - FIX(1.045510580));           /* -(c7+c11) */
 80231ce:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 80231d2:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 80231d6:	4413      	add	r3, r2
 80231d8:	4a80      	ldr	r2, [pc, #512]	; (80233dc <jpeg_idct_6x12+0x498>)
 80231da:	fb02 f303 	mul.w	r3, r2, r3
 80231de:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */
 80231e2:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 80231e6:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80231ea:	441a      	add	r2, r3
 80231ec:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 80231f0:	497b      	ldr	r1, [pc, #492]	; (80233e0 <jpeg_idct_6x12+0x49c>)
 80231f2:	fb01 f303 	mul.w	r3, r1, r3
 80231f6:	4413      	add	r3, r2
 80231f8:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 80231fc:	4413      	add	r3, r2
 80231fe:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */
 8023202:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8023206:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 802320a:	1ad2      	subs	r2, r2, r3
 802320c:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8023210:	f243 21c6 	movw	r1, #12998	; 0x32c6
 8023214:	fb01 f303 	mul.w	r3, r1, r3
 8023218:	4413      	add	r3, r2
 802321a:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 802321e:	4413      	add	r3, r2
 8023220:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 8023224:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8023228:	4a6e      	ldr	r2, [pc, #440]	; (80233e4 <jpeg_idct_6x12+0x4a0>)
 802322a:	fb02 f203 	mul.w	r2, r2, r3
 802322e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8023232:	441a      	add	r2, r3
	     MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */
 8023234:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8023238:	496b      	ldr	r1, [pc, #428]	; (80233e8 <jpeg_idct_6x12+0x4a4>)
 802323a:	fb01 f303 	mul.w	r3, r1, r3
    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */
 802323e:	4413      	add	r3, r2
 8023240:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8023244:	4413      	add	r3, r2
 8023246:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134

    z1 -= z4;
 802324a:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 802324e:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8023252:	1ad3      	subs	r3, r2, r3
 8023254:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    z2 -= z3;
 8023258:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
 802325c:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8023260:	1ad3      	subs	r3, r2, r3
 8023262:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */
 8023266:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 802326a:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 802326e:	4413      	add	r3, r2
 8023270:	f241 1251 	movw	r2, #4433	; 0x1151
 8023274:	fb02 f303 	mul.w	r3, r2, r3
 8023278:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */
 802327c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8023280:	f641 027e 	movw	r2, #6270	; 0x187e
 8023284:	fb02 f303 	mul.w	r3, r2, r3
 8023288:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 802328c:	4413      	add	r3, r2
 802328e:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */
 8023292:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8023296:	4a55      	ldr	r2, [pc, #340]	; (80233ec <jpeg_idct_6x12+0x4a8>)
 8023298:	fb02 f303 	mul.w	r3, r2, r3
 802329c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 80232a0:	4413      	add	r3, r2
 80232a2:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138

    /* Final output stage */

    wsptr[6*0]  = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 80232a6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80232aa:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80232ae:	4413      	add	r3, r2
 80232b0:	12da      	asrs	r2, r3, #11
 80232b2:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80232b6:	601a      	str	r2, [r3, #0]
    wsptr[6*11] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 80232b8:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 80232bc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80232c0:	1ad2      	subs	r2, r2, r3
 80232c2:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80232c6:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80232ca:	12d2      	asrs	r2, r2, #11
 80232cc:	601a      	str	r2, [r3, #0]
    wsptr[6*1]  = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 80232ce:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 80232d2:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80232d6:	441a      	add	r2, r3
 80232d8:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80232dc:	3318      	adds	r3, #24
 80232de:	12d2      	asrs	r2, r2, #11
 80232e0:	601a      	str	r2, [r3, #0]
    wsptr[6*10] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 80232e2:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 80232e6:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80232ea:	1ad2      	subs	r2, r2, r3
 80232ec:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80232f0:	33f0      	adds	r3, #240	; 0xf0
 80232f2:	12d2      	asrs	r2, r2, #11
 80232f4:	601a      	str	r2, [r3, #0]
    wsptr[6*2]  = (int) RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS-PASS1_BITS);
 80232f6:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 80232fa:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80232fe:	441a      	add	r2, r3
 8023300:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023304:	3330      	adds	r3, #48	; 0x30
 8023306:	12d2      	asrs	r2, r2, #11
 8023308:	601a      	str	r2, [r3, #0]
    wsptr[6*9]  = (int) RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS-PASS1_BITS);
 802330a:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 802330e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8023312:	1ad2      	subs	r2, r2, r3
 8023314:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023318:	33d8      	adds	r3, #216	; 0xd8
 802331a:	12d2      	asrs	r2, r2, #11
 802331c:	601a      	str	r2, [r3, #0]
    wsptr[6*3]  = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802331e:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8023322:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8023326:	441a      	add	r2, r3
 8023328:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 802332c:	3348      	adds	r3, #72	; 0x48
 802332e:	12d2      	asrs	r2, r2, #11
 8023330:	601a      	str	r2, [r3, #0]
    wsptr[6*8]  = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 8023332:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
 8023336:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 802333a:	1ad2      	subs	r2, r2, r3
 802333c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023340:	33c0      	adds	r3, #192	; 0xc0
 8023342:	12d2      	asrs	r2, r2, #11
 8023344:	601a      	str	r2, [r3, #0]
    wsptr[6*4]  = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 8023346:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 802334a:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 802334e:	441a      	add	r2, r3
 8023350:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023354:	3360      	adds	r3, #96	; 0x60
 8023356:	12d2      	asrs	r2, r2, #11
 8023358:	601a      	str	r2, [r3, #0]
    wsptr[6*7]  = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 802335a:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
 802335e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8023362:	1ad2      	subs	r2, r2, r3
 8023364:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023368:	33a8      	adds	r3, #168	; 0xa8
 802336a:	12d2      	asrs	r2, r2, #11
 802336c:	601a      	str	r2, [r3, #0]
    wsptr[6*5]  = (int) RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS-PASS1_BITS);
 802336e:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8023372:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8023376:	441a      	add	r2, r3
 8023378:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 802337c:	3378      	adds	r3, #120	; 0x78
 802337e:	12d2      	asrs	r2, r2, #11
 8023380:	601a      	str	r2, [r3, #0]
    wsptr[6*6]  = (int) RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS-PASS1_BITS);
 8023382:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
 8023386:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 802338a:	1ad2      	subs	r2, r2, r3
 802338c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023390:	3390      	adds	r3, #144	; 0x90
 8023392:	12d2      	asrs	r2, r2, #11
 8023394:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {
 8023396:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 802339a:	3301      	adds	r3, #1
 802339c:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 80233a0:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 80233a4:	3302      	adds	r3, #2
 80233a6:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
 80233aa:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 80233ae:	3304      	adds	r3, #4
 80233b0:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 80233b4:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80233b8:	3304      	adds	r3, #4
 80233ba:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 80233be:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 80233c2:	2b05      	cmp	r3, #5
 80233c4:	f77f ade5 	ble.w	8022f92 <jpeg_idct_6x12+0x4e>
  }

  /* Pass 2: process 12 rows from work array, store into output array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  wsptr = workspace;
 80233c8:	f107 0310 	add.w	r3, r7, #16
 80233cc:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 80233d0:	2300      	movs	r3, #0
 80233d2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 80233d6:	e104      	b.n	80235e2 <jpeg_idct_6x12+0x69e>
 80233d8:	ffffeeaf 	.word	0xffffeeaf
 80233dc:	ffffde8b 	.word	0xffffde8b
 80233e0:	ffffd0b0 	.word	0xffffd0b0
 80233e4:	ffffea5c 	.word	0xffffea5c
 80233e8:	ffffc08c 	.word	0xffffc08c
 80233ec:	ffffc4df 	.word	0xffffc4df
    outptr = output_buf[ctr] + output_col;
 80233f0:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 80233f4:	009b      	lsls	r3, r3, #2
 80233f6:	463a      	mov	r2, r7
 80233f8:	6812      	ldr	r2, [r2, #0]
 80233fa:	4413      	add	r3, r2
 80233fc:	681a      	ldr	r2, [r3, #0]
 80233fe:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 8023402:	4413      	add	r3, r2
 8023404:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8023408:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 802340c:	681b      	ldr	r3, [r3, #0]
 802340e:	3310      	adds	r3, #16
 8023410:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp10 <<= CONST_BITS;
 8023414:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8023418:	035b      	lsls	r3, r3, #13
 802341a:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp12 = (INT32) wsptr[4];
 802341e:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023422:	3310      	adds	r3, #16
 8023424:	681b      	ldr	r3, [r3, #0]
 8023426:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp20 = MULTIPLY(tmp12, FIX(0.707106781));   /* c4 */
 802342a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 802342e:	f241 62a1 	movw	r2, #5793	; 0x16a1
 8023432:	fb02 f303 	mul.w	r3, r2, r3
 8023436:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp11 = tmp10 + tmp20;
 802343a:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 802343e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8023442:	4413      	add	r3, r2
 8023444:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp21 = tmp10 - tmp20 - tmp20;
 8023448:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 802344c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8023450:	1ad2      	subs	r2, r2, r3
 8023452:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8023456:	1ad3      	subs	r3, r2, r3
 8023458:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    tmp20 = (INT32) wsptr[2];
 802345c:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023460:	3308      	adds	r3, #8
 8023462:	681b      	ldr	r3, [r3, #0]
 8023464:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp10 = MULTIPLY(tmp20, FIX(1.224744871));   /* c2 */
 8023468:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 802346c:	f242 7231 	movw	r2, #10033	; 0x2731
 8023470:	fb02 f303 	mul.w	r3, r2, r3
 8023474:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp20 = tmp11 + tmp10;
 8023478:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 802347c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8023480:	4413      	add	r3, r2
 8023482:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
    tmp22 = tmp11 - tmp10;
 8023486:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 802348a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 802348e:	1ad3      	subs	r3, r2, r3
 8023490:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

    /* Odd part */

    z1 = (INT32) wsptr[1];
 8023494:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8023498:	3304      	adds	r3, #4
 802349a:	681b      	ldr	r3, [r3, #0]
 802349c:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
    z2 = (INT32) wsptr[3];
 80234a0:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80234a4:	330c      	adds	r3, #12
 80234a6:	681b      	ldr	r3, [r3, #0]
 80234a8:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
    z3 = (INT32) wsptr[5];
 80234ac:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80234b0:	3314      	adds	r3, #20
 80234b2:	681b      	ldr	r3, [r3, #0]
 80234b4:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
    tmp11 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 80234b8:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80234bc:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 80234c0:	4413      	add	r3, r2
 80234c2:	f640 32b6 	movw	r2, #2998	; 0xbb6
 80234c6:	fb02 f303 	mul.w	r3, r2, r3
 80234ca:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
    tmp10 = tmp11 + ((z1 + z2) << CONST_BITS);
 80234ce:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80234d2:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 80234d6:	4413      	add	r3, r2
 80234d8:	035b      	lsls	r3, r3, #13
 80234da:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 80234de:	4413      	add	r3, r2
 80234e0:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
    tmp12 = tmp11 + ((z3 - z2) << CONST_BITS);
 80234e4:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 80234e8:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 80234ec:	1ad3      	subs	r3, r2, r3
 80234ee:	035b      	lsls	r3, r3, #13
 80234f0:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 80234f4:	4413      	add	r3, r2
 80234f6:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
    tmp11 = (z1 - z2 - z3) << CONST_BITS;
 80234fa:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 80234fe:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8023502:	1ad2      	subs	r2, r2, r3
 8023504:	f8d7 314c 	ldr.w	r3, [r7, #332]	; 0x14c
 8023508:	1ad3      	subs	r3, r2, r3
 802350a:	035b      	lsls	r3, r3, #13
 802350c:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8023510:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 8023514:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8023518:	4413      	add	r3, r2
 802351a:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802351c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp20 + tmp10,
 8023520:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 8023524:	4413      	add	r3, r2
 8023526:	781a      	ldrb	r2, [r3, #0]
 8023528:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 802352c:	701a      	strb	r2, [r3, #0]
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802352e:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 8023532:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8023536:	1ad3      	subs	r3, r2, r3
 8023538:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802353a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[5] = range_limit[(int) RIGHT_SHIFT(tmp20 - tmp10,
 802353e:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 8023542:	441a      	add	r2, r3
 8023544:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8023548:	3305      	adds	r3, #5
 802354a:	7812      	ldrb	r2, [r2, #0]
 802354c:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802354e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8023552:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8023556:	4413      	add	r3, r2
 8023558:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802355a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp21 + tmp11,
 802355e:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 8023562:	441a      	add	r2, r3
 8023564:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8023568:	3301      	adds	r3, #1
 802356a:	7812      	ldrb	r2, [r2, #0]
 802356c:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802356e:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 8023572:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8023576:	1ad3      	subs	r3, r2, r3
 8023578:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802357a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp21 - tmp11,
 802357e:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 8023582:	441a      	add	r2, r3
 8023584:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8023588:	3304      	adds	r3, #4
 802358a:	7812      	ldrb	r2, [r2, #0]
 802358c:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802358e:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 8023592:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8023596:	4413      	add	r3, r2
 8023598:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802359a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp22 + tmp12,
 802359e:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 80235a2:	441a      	add	r2, r3
 80235a4:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80235a8:	3302      	adds	r3, #2
 80235aa:	7812      	ldrb	r2, [r2, #0]
 80235ac:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80235ae:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 80235b2:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80235b6:	1ad3      	subs	r3, r2, r3
 80235b8:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80235ba:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp22 - tmp12,
 80235be:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 80235c2:	441a      	add	r2, r3
 80235c4:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80235c8:	3303      	adds	r3, #3
 80235ca:	7812      	ldrb	r2, [r2, #0]
 80235cc:	701a      	strb	r2, [r3, #0]

    wsptr += 6;		/* advance pointer to next row */
 80235ce:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 80235d2:	3318      	adds	r3, #24
 80235d4:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
  for (ctr = 0; ctr < 12; ctr++) {
 80235d8:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 80235dc:	3301      	adds	r3, #1
 80235de:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 80235e2:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 80235e6:	2b0b      	cmp	r3, #11
 80235e8:	f77f af02 	ble.w	80233f0 <jpeg_idct_6x12+0x4ac>
  }
}
 80235ec:	bf00      	nop
 80235ee:	bf00      	nop
 80235f0:	f507 77c4 	add.w	r7, r7, #392	; 0x188
 80235f4:	46bd      	mov	sp, r7
 80235f6:	bc90      	pop	{r4, r7}
 80235f8:	4770      	bx	lr
 80235fa:	bf00      	nop

080235fc <jpeg_idct_5x10>:

GLOBAL(void)
jpeg_idct_5x10 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		JCOEFPTR coef_block,
		JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80235fc:	b490      	push	{r4, r7}
 80235fe:	b0cc      	sub	sp, #304	; 0x130
 8023600:	af00      	add	r7, sp, #0
 8023602:	f107 040c 	add.w	r4, r7, #12
 8023606:	6020      	str	r0, [r4, #0]
 8023608:	f107 0008 	add.w	r0, r7, #8
 802360c:	6001      	str	r1, [r0, #0]
 802360e:	1d39      	adds	r1, r7, #4
 8023610:	600a      	str	r2, [r1, #0]
 8023612:	463a      	mov	r2, r7
 8023614:	6013      	str	r3, [r2, #0]
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8023616:	f107 030c 	add.w	r3, r7, #12
 802361a:	681b      	ldr	r3, [r3, #0]
 802361c:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8023620:	3380      	adds	r3, #128	; 0x80
 8023622:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 10-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/20).
   */
  inptr = coef_block;
 8023626:	1d3b      	adds	r3, r7, #4
 8023628:	681b      	ldr	r3, [r3, #0]
 802362a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 802362e:	f107 0308 	add.w	r3, r7, #8
 8023632:	681b      	ldr	r3, [r3, #0]
 8023634:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8023636:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  wsptr = workspace;
 802363a:	f107 0314 	add.w	r3, r7, #20
 802363e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 8023642:	2300      	movs	r3, #0
 8023644:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 8023648:	e1d3      	b.n	80239f2 <jpeg_idct_5x10+0x3f6>
    /* Even part */

    z3 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 802364a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 802364e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023652:	461a      	mov	r2, r3
 8023654:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8023658:	681b      	ldr	r3, [r3, #0]
 802365a:	fb03 f302 	mul.w	r3, r3, r2
 802365e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    z3 <<= CONST_BITS;
 8023662:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023666:	035b      	lsls	r3, r3, #13
 8023668:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    /* Add fudge factor here for final descale. */
    z3 += ONE << (CONST_BITS-PASS1_BITS-1);
 802366c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023670:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8023674:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8023678:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 802367c:	3340      	adds	r3, #64	; 0x40
 802367e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023682:	461a      	mov	r2, r3
 8023684:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8023688:	3380      	adds	r3, #128	; 0x80
 802368a:	681b      	ldr	r3, [r3, #0]
 802368c:	fb03 f302 	mul.w	r3, r3, r2
 8023690:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */
 8023694:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8023698:	f242 429d 	movw	r2, #9373	; 0x249d
 802369c:	fb02 f303 	mul.w	r3, r2, r3
 80236a0:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */
 80236a4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80236a8:	f640 52fc 	movw	r2, #3580	; 0xdfc
 80236ac:	fb02 f303 	mul.w	r3, r2, r3
 80236b0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    tmp10 = z3 + z1;
 80236b4:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80236b8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80236bc:	4413      	add	r3, r2
 80236be:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp11 = z3 - z2;
 80236c2:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80236c6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80236ca:	1ad3      	subs	r3, r2, r3
 80236cc:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8

    tmp22 = RIGHT_SHIFT(z3 - ((z1 - z2) << 1),   /* c0 = (c4-c8)*2 */
 80236d0:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 80236d4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80236d8:	1ad3      	subs	r3, r2, r3
 80236da:	005b      	lsls	r3, r3, #1
 80236dc:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80236e0:	1ad3      	subs	r3, r2, r3
 80236e2:	12db      	asrs	r3, r3, #11
 80236e4:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
			CONST_BITS-PASS1_BITS);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80236e8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80236ec:	3320      	adds	r3, #32
 80236ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80236f2:	461a      	mov	r2, r3
 80236f4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80236f8:	3340      	adds	r3, #64	; 0x40
 80236fa:	681b      	ldr	r3, [r3, #0]
 80236fc:	fb03 f302 	mul.w	r3, r3, r2
 8023700:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8023704:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8023708:	3360      	adds	r3, #96	; 0x60
 802370a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802370e:	461a      	mov	r2, r3
 8023710:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8023714:	33c0      	adds	r3, #192	; 0xc0
 8023716:	681b      	ldr	r3, [r3, #0]
 8023718:	fb03 f302 	mul.w	r3, r3, r2
 802371c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */
 8023720:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8023724:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023728:	4413      	add	r3, r2
 802372a:	f641 229a 	movw	r2, #6810	; 0x1a9a
 802372e:	fb02 f303 	mul.w	r3, r2, r3
 8023732:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */
 8023736:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 802373a:	f241 0271 	movw	r2, #4209	; 0x1071
 802373e:	fb02 f303 	mul.w	r3, r2, r3
 8023742:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8023746:	4413      	add	r3, r2
 8023748:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */
 802374c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023750:	4aae      	ldr	r2, [pc, #696]	; (8023a0c <jpeg_idct_5x10+0x410>)
 8023752:	fb02 f303 	mul.w	r3, r2, r3
 8023756:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 802375a:	4413      	add	r3, r2
 802375c:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    tmp20 = tmp10 + tmp12;
 8023760:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8023764:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8023768:	4413      	add	r3, r2
 802376a:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    tmp24 = tmp10 - tmp12;
 802376e:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8023772:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8023776:	1ad3      	subs	r3, r2, r3
 8023778:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    tmp21 = tmp11 + tmp13;
 802377c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8023780:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023784:	4413      	add	r3, r2
 8023786:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    tmp23 = tmp11 - tmp13;
 802378a:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 802378e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023792:	1ad3      	subs	r3, r2, r3
 8023794:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8023798:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 802379c:	3310      	adds	r3, #16
 802379e:	f9b3 3000 	ldrsh.w	r3, [r3]
 80237a2:	461a      	mov	r2, r3
 80237a4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80237a8:	3320      	adds	r3, #32
 80237aa:	681b      	ldr	r3, [r3, #0]
 80237ac:	fb03 f302 	mul.w	r3, r3, r2
 80237b0:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80237b4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80237b8:	3330      	adds	r3, #48	; 0x30
 80237ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 80237be:	461a      	mov	r2, r3
 80237c0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80237c4:	3360      	adds	r3, #96	; 0x60
 80237c6:	681b      	ldr	r3, [r3, #0]
 80237c8:	fb03 f302 	mul.w	r3, r3, r2
 80237cc:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 80237d0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80237d4:	3350      	adds	r3, #80	; 0x50
 80237d6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80237da:	461a      	mov	r2, r3
 80237dc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80237e0:	33a0      	adds	r3, #160	; 0xa0
 80237e2:	681b      	ldr	r3, [r3, #0]
 80237e4:	fb03 f302 	mul.w	r3, r3, r2
 80237e8:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    z4 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 80237ec:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80237f0:	3370      	adds	r3, #112	; 0x70
 80237f2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80237f6:	461a      	mov	r2, r3
 80237f8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80237fc:	33e0      	adds	r3, #224	; 0xe0
 80237fe:	681b      	ldr	r3, [r3, #0]
 8023800:	fb03 f302 	mul.w	r3, r3, r2
 8023804:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp11 = z2 + z4;
 8023808:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 802380c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8023810:	4413      	add	r3, r2
 8023812:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp13 = z2 - z4;
 8023816:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 802381a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802381e:	1ad3      	subs	r3, r2, r3
 8023820:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */
 8023824:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023828:	f640 12e3 	movw	r2, #2531	; 0x9e3
 802382c:	fb02 f303 	mul.w	r3, r2, r3
 8023830:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    z5 = z3 << CONST_BITS;
 8023834:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023838:	035b      	lsls	r3, r3, #13
 802383a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */
 802383e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8023842:	f641 626f 	movw	r2, #7791	; 0x1e6f
 8023846:	fb02 f303 	mul.w	r3, r2, r3
 802384a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z4 = z5 + tmp12;
 802384e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8023852:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8023856:	4413      	add	r3, r2
 8023858:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */
 802385c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8023860:	f642 42b3 	movw	r2, #11443	; 0x2cb3
 8023864:	fb02 f203 	mul.w	r2, r2, r3
 8023868:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 802386c:	4413      	add	r3, r2
 802386e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8023872:	4413      	add	r3, r2
 8023874:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */
 8023878:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 802387c:	f240 7214 	movw	r2, #1812	; 0x714
 8023880:	fb02 f203 	mul.w	r2, r2, r3
 8023884:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8023888:	1ad3      	subs	r3, r2, r3
 802388a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 802388e:	4413      	add	r3, r2
 8023890:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */
 8023894:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8023898:	f241 22cf 	movw	r2, #4815	; 0x12cf
 802389c:	fb02 f303 	mul.w	r3, r2, r3
 80238a0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z4 = z5 - tmp12 - (tmp13 << (CONST_BITS - 1));
 80238a4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80238a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80238ac:	1ad2      	subs	r2, r2, r3
 80238ae:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80238b2:	031b      	lsls	r3, r3, #12
 80238b4:	1ad3      	subs	r3, r2, r3
 80238b6:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    tmp12 = (z1 - tmp13 - z3) << PASS1_BITS;
 80238ba:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 80238be:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80238c2:	1ad2      	subs	r2, r2, r3
 80238c4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80238c8:	1ad3      	subs	r3, r2, r3
 80238ca:	009b      	lsls	r3, r3, #2
 80238cc:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */
 80238d0:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80238d4:	f642 0253 	movw	r2, #10323	; 0x2853
 80238d8:	fb02 f203 	mul.w	r2, r2, r3
 80238dc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80238e0:	1ad2      	subs	r2, r2, r3
 80238e2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80238e6:	1ad3      	subs	r3, r2, r3
 80238e8:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */
 80238ec:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80238f0:	f241 428c 	movw	r2, #5260	; 0x148c
 80238f4:	fb02 f203 	mul.w	r2, r2, r3
 80238f8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80238fc:	1ad3      	subs	r3, r2, r3
 80238fe:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8023902:	4413      	add	r3, r2
 8023904:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    /* Final output stage */

    wsptr[5*0] = (int) RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS-PASS1_BITS);
 8023908:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 802390c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8023910:	4413      	add	r3, r2
 8023912:	12da      	asrs	r2, r3, #11
 8023914:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023918:	601a      	str	r2, [r3, #0]
    wsptr[5*9] = (int) RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS-PASS1_BITS);
 802391a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 802391e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8023922:	1ad2      	subs	r2, r2, r3
 8023924:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023928:	33b4      	adds	r3, #180	; 0xb4
 802392a:	12d2      	asrs	r2, r2, #11
 802392c:	601a      	str	r2, [r3, #0]
    wsptr[5*1] = (int) RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS-PASS1_BITS);
 802392e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8023932:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8023936:	441a      	add	r2, r3
 8023938:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802393c:	3314      	adds	r3, #20
 802393e:	12d2      	asrs	r2, r2, #11
 8023940:	601a      	str	r2, [r3, #0]
    wsptr[5*8] = (int) RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS-PASS1_BITS);
 8023942:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8023946:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 802394a:	1ad2      	subs	r2, r2, r3
 802394c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023950:	33a0      	adds	r3, #160	; 0xa0
 8023952:	12d2      	asrs	r2, r2, #11
 8023954:	601a      	str	r2, [r3, #0]
    wsptr[5*2] = (int) (tmp22 + tmp12);
 8023956:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802395a:	3328      	adds	r3, #40	; 0x28
 802395c:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 8023960:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8023964:	440a      	add	r2, r1
 8023966:	601a      	str	r2, [r3, #0]
    wsptr[5*7] = (int) (tmp22 - tmp12);
 8023968:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802396c:	338c      	adds	r3, #140	; 0x8c
 802396e:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 8023972:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8023976:	1a8a      	subs	r2, r1, r2
 8023978:	601a      	str	r2, [r3, #0]
    wsptr[5*3] = (int) RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS-PASS1_BITS);
 802397a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 802397e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023982:	441a      	add	r2, r3
 8023984:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023988:	333c      	adds	r3, #60	; 0x3c
 802398a:	12d2      	asrs	r2, r2, #11
 802398c:	601a      	str	r2, [r3, #0]
    wsptr[5*6] = (int) RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS-PASS1_BITS);
 802398e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8023992:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023996:	1ad2      	subs	r2, r2, r3
 8023998:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 802399c:	3378      	adds	r3, #120	; 0x78
 802399e:	12d2      	asrs	r2, r2, #11
 80239a0:	601a      	str	r2, [r3, #0]
    wsptr[5*4] = (int) RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS-PASS1_BITS);
 80239a2:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 80239a6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80239aa:	441a      	add	r2, r3
 80239ac:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80239b0:	3350      	adds	r3, #80	; 0x50
 80239b2:	12d2      	asrs	r2, r2, #11
 80239b4:	601a      	str	r2, [r3, #0]
    wsptr[5*5] = (int) RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS-PASS1_BITS);
 80239b6:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 80239ba:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80239be:	1ad2      	subs	r2, r2, r3
 80239c0:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80239c4:	3364      	adds	r3, #100	; 0x64
 80239c6:	12d2      	asrs	r2, r2, #11
 80239c8:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {
 80239ca:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80239ce:	3301      	adds	r3, #1
 80239d0:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 80239d4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80239d8:	3302      	adds	r3, #2
 80239da:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 80239de:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80239e2:	3304      	adds	r3, #4
 80239e4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 80239e8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80239ec:	3304      	adds	r3, #4
 80239ee:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80239f2:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 80239f6:	2b04      	cmp	r3, #4
 80239f8:	f77f ae27 	ble.w	802364a <jpeg_idct_5x10+0x4e>
  }

  /* Pass 2: process 10 rows from work array, store into output array.
   * 5-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/10).
   */
  wsptr = workspace;
 80239fc:	f107 0314 	add.w	r3, r7, #20
 8023a00:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 8023a04:	2300      	movs	r3, #0
 8023a06:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 8023a0a:	e0d9      	b.n	8023bc0 <jpeg_idct_5x10+0x5c4>
 8023a0c:	ffffba5c 	.word	0xffffba5c
    outptr = output_buf[ctr] + output_col;
 8023a10:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8023a14:	009b      	lsls	r3, r3, #2
 8023a16:	463a      	mov	r2, r7
 8023a18:	6812      	ldr	r2, [r2, #0]
 8023a1a:	4413      	add	r3, r2
 8023a1c:	681a      	ldr	r2, [r3, #0]
 8023a1e:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8023a22:	4413      	add	r3, r2
 8023a24:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp12 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8023a28:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023a2c:	681b      	ldr	r3, [r3, #0]
 8023a2e:	3310      	adds	r3, #16
 8023a30:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp12 <<= CONST_BITS;
 8023a34:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8023a38:	035b      	lsls	r3, r3, #13
 8023a3a:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    tmp13 = (INT32) wsptr[2];
 8023a3e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023a42:	3308      	adds	r3, #8
 8023a44:	681b      	ldr	r3, [r3, #0]
 8023a46:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp14 = (INT32) wsptr[4];
 8023a4a:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023a4e:	3310      	adds	r3, #16
 8023a50:	681b      	ldr	r3, [r3, #0]
 8023a52:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    z1 = MULTIPLY(tmp13 + tmp14, FIX(0.790569415)); /* (c2+c4)/2 */
 8023a56:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8023a5a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8023a5e:	4413      	add	r3, r2
 8023a60:	f641 124c 	movw	r2, #6476	; 0x194c
 8023a64:	fb02 f303 	mul.w	r3, r2, r3
 8023a68:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    z2 = MULTIPLY(tmp13 - tmp14, FIX(0.353553391)); /* (c2-c4)/2 */
 8023a6c:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8023a70:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8023a74:	1ad3      	subs	r3, r2, r3
 8023a76:	f44f 6235 	mov.w	r2, #2896	; 0xb50
 8023a7a:	fb02 f303 	mul.w	r3, r2, r3
 8023a7e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z3 = tmp12 + z2;
 8023a82:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8023a86:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8023a8a:	4413      	add	r3, r2
 8023a8c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    tmp10 = z3 + z1;
 8023a90:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8023a94:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8023a98:	4413      	add	r3, r2
 8023a9a:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    tmp11 = z3 - z1;
 8023a9e:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8023aa2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8023aa6:	1ad3      	subs	r3, r2, r3
 8023aa8:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    tmp12 -= z2 << 2;
 8023aac:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8023ab0:	009b      	lsls	r3, r3, #2
 8023ab2:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8023ab6:	1ad3      	subs	r3, r2, r3
 8023ab8:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114

    /* Odd part */

    z2 = (INT32) wsptr[1];
 8023abc:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023ac0:	3304      	adds	r3, #4
 8023ac2:	681b      	ldr	r3, [r3, #0]
 8023ac4:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    z3 = (INT32) wsptr[3];
 8023ac8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023acc:	330c      	adds	r3, #12
 8023ace:	681b      	ldr	r3, [r3, #0]
 8023ad0:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));       /* c3 */
 8023ad4:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8023ad8:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023adc:	4413      	add	r3, r2
 8023ade:	f641 229a 	movw	r2, #6810	; 0x1a9a
 8023ae2:	fb02 f303 	mul.w	r3, r2, r3
 8023ae6:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    tmp13 = z1 + MULTIPLY(z2, FIX(0.513743148));    /* c1-c3 */
 8023aea:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8023aee:	f241 0271 	movw	r2, #4209	; 0x1071
 8023af2:	fb02 f303 	mul.w	r3, r2, r3
 8023af6:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8023afa:	4413      	add	r3, r2
 8023afc:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    tmp14 = z1 - MULTIPLY(z3, FIX(2.176250899));    /* c1+c3 */
 8023b00:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8023b04:	4a34      	ldr	r2, [pc, #208]	; (8023bd8 <jpeg_idct_5x10+0x5dc>)
 8023b06:	fb02 f303 	mul.w	r3, r2, r3
 8023b0a:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8023b0e:	4413      	add	r3, r2
 8023b10:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 8023b14:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8023b18:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023b1c:	4413      	add	r3, r2
 8023b1e:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8023b20:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp13,
 8023b24:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8023b28:	4413      	add	r3, r2
 8023b2a:	781a      	ldrb	r2, [r3, #0]
 8023b2c:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8023b30:	701a      	strb	r2, [r3, #0]
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 8023b32:	f8d7 20fc 	ldr.w	r2, [r7, #252]	; 0xfc
 8023b36:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8023b3a:	1ad3      	subs	r3, r2, r3
 8023b3c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8023b3e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[4] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp13,
 8023b42:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8023b46:	441a      	add	r2, r3
 8023b48:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8023b4c:	3304      	adds	r3, #4
 8023b4e:	7812      	ldrb	r2, [r2, #0]
 8023b50:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 8023b52:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8023b56:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8023b5a:	4413      	add	r3, r2
 8023b5c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8023b5e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp11 + tmp14,
 8023b62:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8023b66:	441a      	add	r2, r3
 8023b68:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8023b6c:	3301      	adds	r3, #1
 8023b6e:	7812      	ldrb	r2, [r2, #0]
 8023b70:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 8023b72:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 8023b76:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8023b7a:	1ad3      	subs	r3, r2, r3
 8023b7c:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8023b7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp11 - tmp14,
 8023b82:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8023b86:	441a      	add	r2, r3
 8023b88:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8023b8c:	3303      	adds	r3, #3
 8023b8e:	7812      	ldrb	r2, [r2, #0]
 8023b90:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8023b92:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8023b96:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8023b98:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12,
 8023b9c:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8023ba0:	441a      	add	r2, r3
 8023ba2:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8023ba6:	3302      	adds	r3, #2
 8023ba8:	7812      	ldrb	r2, [r2, #0]
 8023baa:	701a      	strb	r2, [r3, #0]

    wsptr += 5;		/* advance pointer to next row */
 8023bac:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8023bb0:	3314      	adds	r3, #20
 8023bb2:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  for (ctr = 0; ctr < 10; ctr++) {
 8023bb6:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8023bba:	3301      	adds	r3, #1
 8023bbc:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 8023bc0:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8023bc4:	2b09      	cmp	r3, #9
 8023bc6:	f77f af23 	ble.w	8023a10 <jpeg_idct_5x10+0x414>
  }
}
 8023bca:	bf00      	nop
 8023bcc:	bf00      	nop
 8023bce:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8023bd2:	46bd      	mov	sp, r7
 8023bd4:	bc90      	pop	{r4, r7}
 8023bd6:	4770      	bx	lr
 8023bd8:	ffffba5c 	.word	0xffffba5c

08023bdc <jpeg_idct_4x8>:

GLOBAL(void)
jpeg_idct_4x8 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8023bdc:	b480      	push	{r7}
 8023bde:	b0b7      	sub	sp, #220	; 0xdc
 8023be0:	af00      	add	r7, sp, #0
 8023be2:	60f8      	str	r0, [r7, #12]
 8023be4:	60b9      	str	r1, [r7, #8]
 8023be6:	607a      	str	r2, [r7, #4]
 8023be8:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8023bea:	68fb      	ldr	r3, [r7, #12]
 8023bec:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8023bf0:	3380      	adds	r3, #128	; 0x80
 8023bf2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

  /* Pass 1: process columns from input, store into work array. */
  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
 8023bf6:	687b      	ldr	r3, [r7, #4]
 8023bf8:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8023bfc:	68bb      	ldr	r3, [r7, #8]
 8023bfe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8023c00:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  wsptr = workspace;
 8023c04:	f107 0310 	add.w	r3, r7, #16
 8023c08:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 8023c0c:	2304      	movs	r3, #4
 8023c0e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8023c12:	e238      	b.n	8024086 <jpeg_idct_4x8+0x4aa>
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8023c14:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c18:	3310      	adds	r3, #16
 8023c1a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023c1e:	2b00      	cmp	r3, #0
 8023c20:	d175      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
 8023c22:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c26:	3320      	adds	r3, #32
 8023c28:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023c2c:	2b00      	cmp	r3, #0
 8023c2e:	d16e      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8023c30:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c34:	3330      	adds	r3, #48	; 0x30
 8023c36:	f9b3 3000 	ldrsh.w	r3, [r3]
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
 8023c3a:	2b00      	cmp	r3, #0
 8023c3c:	d167      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8023c3e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c42:	3340      	adds	r3, #64	; 0x40
 8023c44:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023c48:	2b00      	cmp	r3, #0
 8023c4a:	d160      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8023c4c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c50:	3350      	adds	r3, #80	; 0x50
 8023c52:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
 8023c56:	2b00      	cmp	r3, #0
 8023c58:	d159      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8023c5a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c5e:	3360      	adds	r3, #96	; 0x60
 8023c60:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023c64:	2b00      	cmp	r3, #0
 8023c66:	d152      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
	inptr[DCTSIZE*7] == 0) {
 8023c68:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c6c:	3370      	adds	r3, #112	; 0x70
 8023c6e:	f9b3 3000 	ldrsh.w	r3, [r3]
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
 8023c72:	2b00      	cmp	r3, #0
 8023c74:	d14b      	bne.n	8023d0e <jpeg_idct_4x8+0x132>
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
 8023c76:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023c7a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023c7e:	461a      	mov	r2, r3
 8023c80:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023c84:	681b      	ldr	r3, [r3, #0]
 8023c86:	fb03 f302 	mul.w	r3, r3, r2
 8023c8a:	009b      	lsls	r3, r3, #2
 8023c8c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

      wsptr[4*0] = dcval;
 8023c90:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023c94:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023c98:	601a      	str	r2, [r3, #0]
      wsptr[4*1] = dcval;
 8023c9a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023c9e:	3310      	adds	r3, #16
 8023ca0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023ca4:	601a      	str	r2, [r3, #0]
      wsptr[4*2] = dcval;
 8023ca6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023caa:	3320      	adds	r3, #32
 8023cac:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023cb0:	601a      	str	r2, [r3, #0]
      wsptr[4*3] = dcval;
 8023cb2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023cb6:	3330      	adds	r3, #48	; 0x30
 8023cb8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023cbc:	601a      	str	r2, [r3, #0]
      wsptr[4*4] = dcval;
 8023cbe:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023cc2:	3340      	adds	r3, #64	; 0x40
 8023cc4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023cc8:	601a      	str	r2, [r3, #0]
      wsptr[4*5] = dcval;
 8023cca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023cce:	3350      	adds	r3, #80	; 0x50
 8023cd0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023cd4:	601a      	str	r2, [r3, #0]
      wsptr[4*6] = dcval;
 8023cd6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023cda:	3360      	adds	r3, #96	; 0x60
 8023cdc:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023ce0:	601a      	str	r2, [r3, #0]
      wsptr[4*7] = dcval;
 8023ce2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023ce6:	3370      	adds	r3, #112	; 0x70
 8023ce8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8023cec:	601a      	str	r2, [r3, #0]

      inptr++;			/* advance pointers to next column */
 8023cee:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023cf2:	3302      	adds	r3, #2
 8023cf4:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      quantptr++;
 8023cf8:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023cfc:	3304      	adds	r3, #4
 8023cfe:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
      wsptr++;
 8023d02:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023d06:	3304      	adds	r3, #4
 8023d08:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
      continue;
 8023d0c:	e1b6      	b.n	802407c <jpeg_idct_4x8+0x4a0>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8023d0e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023d12:	3320      	adds	r3, #32
 8023d14:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023d18:	461a      	mov	r2, r3
 8023d1a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023d1e:	3340      	adds	r3, #64	; 0x40
 8023d20:	681b      	ldr	r3, [r3, #0]
 8023d22:	fb03 f302 	mul.w	r3, r3, r2
 8023d26:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
 8023d2a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023d2e:	3360      	adds	r3, #96	; 0x60
 8023d30:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023d34:	461a      	mov	r2, r3
 8023d36:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023d3a:	33c0      	adds	r3, #192	; 0xc0
 8023d3c:	681b      	ldr	r3, [r3, #0]
 8023d3e:	fb03 f302 	mul.w	r3, r3, r2
 8023d42:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    
    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
 8023d46:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8023d4a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023d4e:	4413      	add	r3, r2
 8023d50:	f241 1251 	movw	r2, #4433	; 0x1151
 8023d54:	fb02 f303 	mul.w	r3, r2, r3
 8023d58:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp2 = z1 + MULTIPLY(z2, FIX_0_765366865);
 8023d5c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023d60:	f641 027e 	movw	r2, #6270	; 0x187e
 8023d64:	fb02 f303 	mul.w	r3, r2, r3
 8023d68:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023d6c:	4413      	add	r3, r2
 8023d6e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065);
 8023d72:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023d76:	4aca      	ldr	r2, [pc, #808]	; (80240a0 <jpeg_idct_4x8+0x4c4>)
 8023d78:	fb02 f303 	mul.w	r3, r2, r3
 8023d7c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023d80:	4413      	add	r3, r2
 8023d82:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    
    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8023d86:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023d8a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023d8e:	461a      	mov	r2, r3
 8023d90:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023d94:	681b      	ldr	r3, [r3, #0]
 8023d96:	fb03 f302 	mul.w	r3, r3, r2
 8023d9a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8023d9e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023da2:	3340      	adds	r3, #64	; 0x40
 8023da4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023da8:	461a      	mov	r2, r3
 8023daa:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023dae:	3380      	adds	r3, #128	; 0x80
 8023db0:	681b      	ldr	r3, [r3, #0]
 8023db2:	fb03 f302 	mul.w	r3, r3, r2
 8023db6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    z2 <<= CONST_BITS;
 8023dba:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023dbe:	035b      	lsls	r3, r3, #13
 8023dc0:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 <<= CONST_BITS;
 8023dc4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023dc8:	035b      	lsls	r3, r3, #13
 8023dca:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    /* Add fudge factor here for final descale. */
    z2 += ONE << (CONST_BITS-PASS1_BITS-1);
 8023dce:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023dd2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8023dd6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    tmp0 = z2 + z3;
 8023dda:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8023dde:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023de2:	4413      	add	r3, r2
 8023de4:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp1 = z2 - z3;
 8023de8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8023dec:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023df0:	1ad3      	subs	r3, r2, r3
 8023df2:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    
    tmp10 = tmp0 + tmp2;
 8023df6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8023dfa:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023dfe:	4413      	add	r3, r2
 8023e00:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp13 = tmp0 - tmp2;
 8023e04:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8023e08:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023e0c:	1ad3      	subs	r3, r2, r3
 8023e0e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    tmp11 = tmp1 + tmp3;
 8023e12:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8023e16:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023e1a:	4413      	add	r3, r2
 8023e1c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    tmp12 = tmp1 - tmp3;
 8023e20:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8023e24:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023e28:	1ad3      	subs	r3, r2, r3
 8023e2a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
 8023e2e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023e32:	3370      	adds	r3, #112	; 0x70
 8023e34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023e38:	461a      	mov	r2, r3
 8023e3a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023e3e:	33e0      	adds	r3, #224	; 0xe0
 8023e40:	681b      	ldr	r3, [r3, #0]
 8023e42:	fb03 f302 	mul.w	r3, r3, r2
 8023e46:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 8023e4a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023e4e:	3350      	adds	r3, #80	; 0x50
 8023e50:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023e54:	461a      	mov	r2, r3
 8023e56:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023e5a:	33a0      	adds	r3, #160	; 0xa0
 8023e5c:	681b      	ldr	r3, [r3, #0]
 8023e5e:	fb03 f302 	mul.w	r3, r3, r2
 8023e62:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8023e66:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023e6a:	3330      	adds	r3, #48	; 0x30
 8023e6c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023e70:	461a      	mov	r2, r3
 8023e72:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023e76:	3360      	adds	r3, #96	; 0x60
 8023e78:	681b      	ldr	r3, [r3, #0]
 8023e7a:	fb03 f302 	mul.w	r3, r3, r2
 8023e7e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8023e82:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8023e86:	3310      	adds	r3, #16
 8023e88:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023e8c:	461a      	mov	r2, r3
 8023e8e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8023e92:	3320      	adds	r3, #32
 8023e94:	681b      	ldr	r3, [r3, #0]
 8023e96:	fb03 f302 	mul.w	r3, r3, r2
 8023e9a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

    z2 = tmp0 + tmp2;
 8023e9e:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8023ea2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023ea6:	4413      	add	r3, r2
 8023ea8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 = tmp1 + tmp3;
 8023eac:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8023eb0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023eb4:	4413      	add	r3, r2
 8023eb6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_1_175875602); /* sqrt(2) * c3 */
 8023eba:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8023ebe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023ec2:	4413      	add	r3, r2
 8023ec4:	f242 52a1 	movw	r2, #9633	; 0x25a1
 8023ec8:	fb02 f303 	mul.w	r3, r2, r3
 8023ecc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    z2 = MULTIPLY(z2, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
 8023ed0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023ed4:	4a73      	ldr	r2, [pc, #460]	; (80240a4 <jpeg_idct_4x8+0x4c8>)
 8023ed6:	fb02 f303 	mul.w	r3, r2, r3
 8023eda:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 = MULTIPLY(z3, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
 8023ede:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023ee2:	4a71      	ldr	r2, [pc, #452]	; (80240a8 <jpeg_idct_4x8+0x4cc>)
 8023ee4:	fb02 f303 	mul.w	r3, r2, r3
 8023ee8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    z2 += z1;
 8023eec:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8023ef0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8023ef4:	4413      	add	r3, r2
 8023ef6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 += z1;
 8023efa:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8023efe:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8023f02:	4413      	add	r3, r2
 8023f04:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

    z1 = MULTIPLY(tmp0 + tmp3, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
 8023f08:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8023f0c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023f10:	4413      	add	r3, r2
 8023f12:	4a66      	ldr	r2, [pc, #408]	; (80240ac <jpeg_idct_4x8+0x4d0>)
 8023f14:	fb02 f303 	mul.w	r3, r2, r3
 8023f18:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
 8023f1c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8023f20:	f640 128e 	movw	r2, #2446	; 0x98e
 8023f24:	fb02 f303 	mul.w	r3, r2, r3
 8023f28:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
 8023f2c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023f30:	f243 020b 	movw	r2, #12299	; 0x300b
 8023f34:	fb02 f303 	mul.w	r3, r2, r3
 8023f38:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    tmp0 += z1 + z2;
 8023f3c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023f40:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023f44:	4413      	add	r3, r2
 8023f46:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8023f4a:	4413      	add	r3, r2
 8023f4c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp3 += z1 + z3;
 8023f50:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023f54:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023f58:	4413      	add	r3, r2
 8023f5a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8023f5e:	4413      	add	r3, r2
 8023f60:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

    z1 = MULTIPLY(tmp1 + tmp2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
 8023f64:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8023f68:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023f6c:	4413      	add	r3, r2
 8023f6e:	4a50      	ldr	r2, [pc, #320]	; (80240b0 <jpeg_idct_4x8+0x4d4>)
 8023f70:	fb02 f303 	mul.w	r3, r2, r3
 8023f74:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
 8023f78:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8023f7c:	f244 12b3 	movw	r2, #16819	; 0x41b3
 8023f80:	fb02 f303 	mul.w	r3, r2, r3
 8023f84:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
 8023f88:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023f8c:	f246 2254 	movw	r2, #25172	; 0x6254
 8023f90:	fb02 f303 	mul.w	r3, r2, r3
 8023f94:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    tmp1 += z1 + z3;
 8023f98:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023f9c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8023fa0:	4413      	add	r3, r2
 8023fa2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8023fa6:	4413      	add	r3, r2
 8023fa8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    tmp2 += z1 + z2;
 8023fac:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8023fb0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8023fb4:	4413      	add	r3, r2
 8023fb6:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8023fba:	4413      	add	r3, r2
 8023fbc:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[4*0] = (int) RIGHT_SHIFT(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
 8023fc0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8023fc4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023fc8:	4413      	add	r3, r2
 8023fca:	12da      	asrs	r2, r3, #11
 8023fcc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023fd0:	601a      	str	r2, [r3, #0]
    wsptr[4*7] = (int) RIGHT_SHIFT(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
 8023fd2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8023fd6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8023fda:	1ad2      	subs	r2, r2, r3
 8023fdc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023fe0:	3370      	adds	r3, #112	; 0x70
 8023fe2:	12d2      	asrs	r2, r2, #11
 8023fe4:	601a      	str	r2, [r3, #0]
    wsptr[4*1] = (int) RIGHT_SHIFT(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
 8023fe6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8023fea:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8023fee:	441a      	add	r2, r3
 8023ff0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8023ff4:	3310      	adds	r3, #16
 8023ff6:	12d2      	asrs	r2, r2, #11
 8023ff8:	601a      	str	r2, [r3, #0]
    wsptr[4*6] = (int) RIGHT_SHIFT(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
 8023ffa:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8023ffe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8024002:	1ad2      	subs	r2, r2, r3
 8024004:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024008:	3360      	adds	r3, #96	; 0x60
 802400a:	12d2      	asrs	r2, r2, #11
 802400c:	601a      	str	r2, [r3, #0]
    wsptr[4*2] = (int) RIGHT_SHIFT(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
 802400e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8024012:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8024016:	441a      	add	r2, r3
 8024018:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 802401c:	3320      	adds	r3, #32
 802401e:	12d2      	asrs	r2, r2, #11
 8024020:	601a      	str	r2, [r3, #0]
    wsptr[4*5] = (int) RIGHT_SHIFT(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
 8024022:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8024026:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 802402a:	1ad2      	subs	r2, r2, r3
 802402c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024030:	3350      	adds	r3, #80	; 0x50
 8024032:	12d2      	asrs	r2, r2, #11
 8024034:	601a      	str	r2, [r3, #0]
    wsptr[4*3] = (int) RIGHT_SHIFT(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
 8024036:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802403a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 802403e:	441a      	add	r2, r3
 8024040:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024044:	3330      	adds	r3, #48	; 0x30
 8024046:	12d2      	asrs	r2, r2, #11
 8024048:	601a      	str	r2, [r3, #0]
    wsptr[4*4] = (int) RIGHT_SHIFT(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
 802404a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802404e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8024052:	1ad2      	subs	r2, r2, r3
 8024054:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024058:	3340      	adds	r3, #64	; 0x40
 802405a:	12d2      	asrs	r2, r2, #11
 802405c:	601a      	str	r2, [r3, #0]

    inptr++;			/* advance pointers to next column */
 802405e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8024062:	3302      	adds	r3, #2
 8024064:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    quantptr++;
 8024068:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 802406c:	3304      	adds	r3, #4
 802406e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    wsptr++;
 8024072:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024076:	3304      	adds	r3, #4
 8024078:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 4; ctr > 0; ctr--) {
 802407c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8024080:	3b01      	subs	r3, #1
 8024082:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8024086:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802408a:	2b00      	cmp	r3, #0
 802408c:	f73f adc2 	bgt.w	8023c14 <jpeg_idct_4x8+0x38>
  }

  /* Pass 2: process 8 rows from work array, store into output array.
   * 4-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/16).
   */
  wsptr = workspace;
 8024090:	f107 0310 	add.w	r3, r7, #16
 8024094:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 8024098:	2300      	movs	r3, #0
 802409a:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 802409e:	e0a5      	b.n	80241ec <jpeg_idct_4x8+0x610>
 80240a0:	ffffc4df 	.word	0xffffc4df
 80240a4:	ffffc13b 	.word	0xffffc13b
 80240a8:	fffff384 	.word	0xfffff384
 80240ac:	ffffe333 	.word	0xffffe333
 80240b0:	ffffadfd 	.word	0xffffadfd
    outptr = output_buf[ctr] + output_col;
 80240b4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80240b8:	009b      	lsls	r3, r3, #2
 80240ba:	683a      	ldr	r2, [r7, #0]
 80240bc:	4413      	add	r3, r2
 80240be:	681a      	ldr	r2, [r3, #0]
 80240c0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80240c4:	4413      	add	r3, r2
 80240c6:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 80240ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80240ce:	681b      	ldr	r3, [r3, #0]
 80240d0:	3310      	adds	r3, #16
 80240d2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp2 = (INT32) wsptr[2];
 80240d6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80240da:	3308      	adds	r3, #8
 80240dc:	681b      	ldr	r3, [r3, #0]
 80240de:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 80240e2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80240e6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80240ea:	4413      	add	r3, r2
 80240ec:	035b      	lsls	r3, r3, #13
 80240ee:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 80240f2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80240f6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80240fa:	1ad3      	subs	r3, r2, r3
 80240fc:	035b      	lsls	r3, r3, #13
 80240fe:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = (INT32) wsptr[1];
 8024102:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024106:	3304      	adds	r3, #4
 8024108:	681b      	ldr	r3, [r3, #0]
 802410a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    z3 = (INT32) wsptr[3];
 802410e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8024112:	330c      	adds	r3, #12
 8024114:	681b      	ldr	r3, [r3, #0]
 8024116:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 802411a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 802411e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8024122:	4413      	add	r3, r2
 8024124:	f241 1251 	movw	r2, #4433	; 0x1151
 8024128:	fb02 f303 	mul.w	r3, r2, r3
 802412c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 8024130:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8024134:	f641 027e 	movw	r2, #6270	; 0x187e
 8024138:	fb02 f303 	mul.w	r3, r2, r3
 802413c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8024140:	4413      	add	r3, r2
 8024142:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 8024146:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 802414a:	4a2e      	ldr	r2, [pc, #184]	; (8024204 <jpeg_idct_4x8+0x628>)
 802414c:	fb02 f303 	mul.w	r3, r2, r3
 8024150:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8024154:	4413      	add	r3, r2
 8024156:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802415a:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 802415e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8024162:	4413      	add	r3, r2
 8024164:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8024166:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802416a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 802416e:	4413      	add	r3, r2
 8024170:	781a      	ldrb	r2, [r3, #0]
 8024172:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8024176:	701a      	strb	r2, [r3, #0]
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8024178:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 802417c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8024180:	1ad3      	subs	r3, r2, r3
 8024182:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8024184:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[3] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8024188:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 802418c:	441a      	add	r2, r3
 802418e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8024192:	3303      	adds	r3, #3
 8024194:	7812      	ldrb	r2, [r2, #0]
 8024196:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 8024198:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 802419c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80241a0:	4413      	add	r3, r2
 80241a2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80241a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp12 + tmp2,
 80241a8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80241ac:	441a      	add	r2, r3
 80241ae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80241b2:	3301      	adds	r3, #1
 80241b4:	7812      	ldrb	r2, [r2, #0]
 80241b6:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 80241b8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80241bc:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80241c0:	1ad3      	subs	r3, r2, r3
 80241c2:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 80241c4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp12 - tmp2,
 80241c8:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80241cc:	441a      	add	r2, r3
 80241ce:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80241d2:	3302      	adds	r3, #2
 80241d4:	7812      	ldrb	r2, [r2, #0]
 80241d6:	701a      	strb	r2, [r3, #0]
    
    wsptr += 4;		/* advance pointer to next row */
 80241d8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 80241dc:	3310      	adds	r3, #16
 80241de:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  for (ctr = 0; ctr < 8; ctr++) {
 80241e2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80241e6:	3301      	adds	r3, #1
 80241e8:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 80241ec:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80241f0:	2b07      	cmp	r3, #7
 80241f2:	f77f af5f 	ble.w	80240b4 <jpeg_idct_4x8+0x4d8>
  }
}
 80241f6:	bf00      	nop
 80241f8:	bf00      	nop
 80241fa:	37dc      	adds	r7, #220	; 0xdc
 80241fc:	46bd      	mov	sp, r7
 80241fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024202:	4770      	bx	lr
 8024204:	ffffc4df 	.word	0xffffc4df

08024208 <jpeg_idct_3x6>:

GLOBAL(void)
jpeg_idct_3x6 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8024208:	b480      	push	{r7}
 802420a:	b0a7      	sub	sp, #156	; 0x9c
 802420c:	af00      	add	r7, sp, #0
 802420e:	60f8      	str	r0, [r7, #12]
 8024210:	60b9      	str	r1, [r7, #8]
 8024212:	607a      	str	r2, [r7, #4]
 8024214:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8024216:	68fb      	ldr	r3, [r7, #12]
 8024218:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 802421c:	3380      	adds	r3, #128	; 0x80
 802421e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  SHIFT_TEMPS

  /* Pass 1: process columns from input, store into work array.
   * 6-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/12).
   */
  inptr = coef_block;
 8024222:	687b      	ldr	r3, [r7, #4]
 8024224:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024228:	68bb      	ldr	r3, [r7, #8]
 802422a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802422c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  wsptr = workspace;
 8024230:	f107 0314 	add.w	r3, r7, #20
 8024234:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 8024238:	2300      	movs	r3, #0
 802423a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 802423e:	e0cf      	b.n	80243e0 <jpeg_idct_3x6+0x1d8>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024240:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024244:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024248:	461a      	mov	r2, r3
 802424a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 802424e:	681b      	ldr	r3, [r3, #0]
 8024250:	fb03 f302 	mul.w	r3, r3, r2
 8024254:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp0 <<= CONST_BITS;
 8024256:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8024258:	035b      	lsls	r3, r3, #13
 802425a:	67fb      	str	r3, [r7, #124]	; 0x7c
    /* Add fudge factor here for final descale. */
    tmp0 += ONE << (CONST_BITS-PASS1_BITS-1);
 802425c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802425e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8024262:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
 8024264:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024268:	3340      	adds	r3, #64	; 0x40
 802426a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802426e:	461a      	mov	r2, r3
 8024270:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8024274:	3380      	adds	r3, #128	; 0x80
 8024276:	681b      	ldr	r3, [r3, #0]
 8024278:	fb03 f302 	mul.w	r3, r3, r2
 802427c:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */
 802427e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8024280:	f241 62a1 	movw	r2, #5793	; 0x16a1
 8024284:	fb02 f303 	mul.w	r3, r2, r3
 8024288:	673b      	str	r3, [r7, #112]	; 0x70
    tmp1 = tmp0 + tmp10;
 802428a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 802428c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 802428e:	4413      	add	r3, r2
 8024290:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS-PASS1_BITS);
 8024292:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8024294:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8024296:	1ad2      	subs	r2, r2, r3
 8024298:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 802429a:	1ad3      	subs	r3, r2, r3
 802429c:	12db      	asrs	r3, r3, #11
 802429e:	66bb      	str	r3, [r7, #104]	; 0x68
    tmp10 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 80242a0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80242a4:	3320      	adds	r3, #32
 80242a6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80242aa:	461a      	mov	r2, r3
 80242ac:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80242b0:	3340      	adds	r3, #64	; 0x40
 80242b2:	681b      	ldr	r3, [r3, #0]
 80242b4:	fb03 f302 	mul.w	r3, r3, r2
 80242b8:	673b      	str	r3, [r7, #112]	; 0x70
    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */
 80242ba:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80242bc:	f242 7231 	movw	r2, #10033	; 0x2731
 80242c0:	fb02 f303 	mul.w	r3, r2, r3
 80242c4:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp10 = tmp1 + tmp0;
 80242c6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80242c8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80242ca:	4413      	add	r3, r2
 80242cc:	673b      	str	r3, [r7, #112]	; 0x70
    tmp12 = tmp1 - tmp0;
 80242ce:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80242d0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80242d2:	1ad3      	subs	r3, r2, r3
 80242d4:	677b      	str	r3, [r7, #116]	; 0x74

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 80242d6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80242da:	3310      	adds	r3, #16
 80242dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80242e0:	461a      	mov	r2, r3
 80242e2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80242e6:	3320      	adds	r3, #32
 80242e8:	681b      	ldr	r3, [r3, #0]
 80242ea:	fb03 f302 	mul.w	r3, r3, r2
 80242ee:	667b      	str	r3, [r7, #100]	; 0x64
    z2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 80242f0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80242f4:	3330      	adds	r3, #48	; 0x30
 80242f6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80242fa:	461a      	mov	r2, r3
 80242fc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8024300:	3360      	adds	r3, #96	; 0x60
 8024302:	681b      	ldr	r3, [r3, #0]
 8024304:	fb03 f302 	mul.w	r3, r3, r2
 8024308:	663b      	str	r3, [r7, #96]	; 0x60
    z3 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
 802430a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802430e:	3350      	adds	r3, #80	; 0x50
 8024310:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024314:	461a      	mov	r2, r3
 8024316:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 802431a:	33a0      	adds	r3, #160	; 0xa0
 802431c:	681b      	ldr	r3, [r3, #0]
 802431e:	fb03 f302 	mul.w	r3, r3, r2
 8024322:	65fb      	str	r3, [r7, #92]	; 0x5c
    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */
 8024324:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8024326:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8024328:	4413      	add	r3, r2
 802432a:	f640 32b6 	movw	r2, #2998	; 0xbb6
 802432e:	fb02 f303 	mul.w	r3, r2, r3
 8024332:	66fb      	str	r3, [r7, #108]	; 0x6c
    tmp0 = tmp1 + ((z1 + z2) << CONST_BITS);
 8024334:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8024336:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024338:	4413      	add	r3, r2
 802433a:	035b      	lsls	r3, r3, #13
 802433c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 802433e:	4413      	add	r3, r2
 8024340:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = tmp1 + ((z3 - z2) << CONST_BITS);
 8024342:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8024344:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024346:	1ad3      	subs	r3, r2, r3
 8024348:	035b      	lsls	r3, r3, #13
 802434a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 802434c:	4413      	add	r3, r2
 802434e:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp1 = (z1 - z2 - z3) << PASS1_BITS;
 8024350:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8024352:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024354:	1ad2      	subs	r2, r2, r3
 8024356:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8024358:	1ad3      	subs	r3, r2, r3
 802435a:	009b      	lsls	r3, r3, #2
 802435c:	66fb      	str	r3, [r7, #108]	; 0x6c

    /* Final output stage */

    wsptr[3*0] = (int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS-PASS1_BITS);
 802435e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8024360:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8024362:	4413      	add	r3, r2
 8024364:	12da      	asrs	r2, r3, #11
 8024366:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 802436a:	601a      	str	r2, [r3, #0]
    wsptr[3*5] = (int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS-PASS1_BITS);
 802436c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 802436e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8024370:	1ad2      	subs	r2, r2, r3
 8024372:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024376:	333c      	adds	r3, #60	; 0x3c
 8024378:	12d2      	asrs	r2, r2, #11
 802437a:	601a      	str	r2, [r3, #0]
    wsptr[3*1] = (int) (tmp11 + tmp1);
 802437c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024380:	330c      	adds	r3, #12
 8024382:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8024384:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8024386:	440a      	add	r2, r1
 8024388:	601a      	str	r2, [r3, #0]
    wsptr[3*4] = (int) (tmp11 - tmp1);
 802438a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 802438e:	3330      	adds	r3, #48	; 0x30
 8024390:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8024392:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8024394:	1a8a      	subs	r2, r1, r2
 8024396:	601a      	str	r2, [r3, #0]
    wsptr[3*2] = (int) RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS-PASS1_BITS);
 8024398:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 802439a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 802439c:	441a      	add	r2, r3
 802439e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80243a2:	3318      	adds	r3, #24
 80243a4:	12d2      	asrs	r2, r2, #11
 80243a6:	601a      	str	r2, [r3, #0]
    wsptr[3*3] = (int) RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS-PASS1_BITS);
 80243a8:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80243aa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80243ac:	1ad2      	subs	r2, r2, r3
 80243ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80243b2:	3324      	adds	r3, #36	; 0x24
 80243b4:	12d2      	asrs	r2, r2, #11
 80243b6:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {
 80243b8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80243bc:	3301      	adds	r3, #1
 80243be:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 80243c2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80243c6:	3302      	adds	r3, #2
 80243c8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 80243cc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80243d0:	3304      	adds	r3, #4
 80243d2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80243d6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80243da:	3304      	adds	r3, #4
 80243dc:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 80243e0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80243e4:	2b02      	cmp	r3, #2
 80243e6:	f77f af2b 	ble.w	8024240 <jpeg_idct_3x6+0x38>
  }

  /* Pass 2: process 6 rows from work array, store into output array.
   * 3-point IDCT kernel, cK represents sqrt(2) * cos(K*pi/6).
   */
  wsptr = workspace;
 80243ea:	f107 0314 	add.w	r3, r7, #20
 80243ee:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 80243f2:	2300      	movs	r3, #0
 80243f4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 80243f8:	e063      	b.n	80244c2 <jpeg_idct_3x6+0x2ba>
    outptr = output_buf[ctr] + output_col;
 80243fa:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80243fe:	009b      	lsls	r3, r3, #2
 8024400:	683a      	ldr	r2, [r7, #0]
 8024402:	4413      	add	r3, r2
 8024404:	681a      	ldr	r2, [r3, #0]
 8024406:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802440a:	4413      	add	r3, r2
 802440c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp0 = (INT32) wsptr[0] + (ONE << (PASS1_BITS+2));
 8024410:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024414:	681b      	ldr	r3, [r3, #0]
 8024416:	3310      	adds	r3, #16
 8024418:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp0 <<= CONST_BITS;
 802441a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802441c:	035b      	lsls	r3, r3, #13
 802441e:	67fb      	str	r3, [r7, #124]	; 0x7c
    tmp2 = (INT32) wsptr[2];
 8024420:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024424:	3308      	adds	r3, #8
 8024426:	681b      	ldr	r3, [r3, #0]
 8024428:	67bb      	str	r3, [r7, #120]	; 0x78
    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */
 802442a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 802442c:	f241 62a1 	movw	r2, #5793	; 0x16a1
 8024430:	fb02 f303 	mul.w	r3, r2, r3
 8024434:	677b      	str	r3, [r7, #116]	; 0x74
    tmp10 = tmp0 + tmp12;
 8024436:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8024438:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 802443a:	4413      	add	r3, r2
 802443c:	673b      	str	r3, [r7, #112]	; 0x70
    tmp2 = tmp0 - tmp12 - tmp12;
 802443e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8024440:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8024442:	1ad2      	subs	r2, r2, r3
 8024444:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8024446:	1ad3      	subs	r3, r2, r3
 8024448:	67bb      	str	r3, [r7, #120]	; 0x78

    /* Odd part */

    tmp12 = (INT32) wsptr[1];
 802444a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 802444e:	3304      	adds	r3, #4
 8024450:	681b      	ldr	r3, [r3, #0]
 8024452:	677b      	str	r3, [r7, #116]	; 0x74
    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */
 8024454:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8024456:	f242 7231 	movw	r2, #10033	; 0x2731
 802445a:	fb02 f303 	mul.w	r3, r2, r3
 802445e:	67fb      	str	r3, [r7, #124]	; 0x7c

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 8024460:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8024462:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8024464:	4413      	add	r3, r2
 8024466:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8024468:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0,
 802446c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8024470:	4413      	add	r3, r2
 8024472:	781a      	ldrb	r2, [r3, #0]
 8024474:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8024478:	701a      	strb	r2, [r3, #0]
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 802447a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 802447c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802447e:	1ad3      	subs	r3, r2, r3
 8024480:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 8024482:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[2] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0,
 8024486:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 802448a:	441a      	add	r2, r3
 802448c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8024490:	3302      	adds	r3, #2
 8024492:	7812      	ldrb	r2, [r2, #0]
 8024494:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 8024496:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8024498:	149b      	asrs	r3, r3, #18
					      CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
 802449a:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp2,
 802449e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 80244a2:	441a      	add	r2, r3
 80244a4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80244a8:	3301      	adds	r3, #1
 80244aa:	7812      	ldrb	r2, [r2, #0]
 80244ac:	701a      	strb	r2, [r3, #0]

    wsptr += 3;		/* advance pointer to next row */
 80244ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80244b2:	330c      	adds	r3, #12
 80244b4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  for (ctr = 0; ctr < 6; ctr++) {
 80244b8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80244bc:	3301      	adds	r3, #1
 80244be:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 80244c2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80244c6:	2b05      	cmp	r3, #5
 80244c8:	dd97      	ble.n	80243fa <jpeg_idct_3x6+0x1f2>
  }
}
 80244ca:	bf00      	nop
 80244cc:	bf00      	nop
 80244ce:	379c      	adds	r7, #156	; 0x9c
 80244d0:	46bd      	mov	sp, r7
 80244d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244d6:	4770      	bx	lr

080244d8 <jpeg_idct_2x4>:

GLOBAL(void)
jpeg_idct_2x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 80244d8:	b480      	push	{r7}
 80244da:	b09b      	sub	sp, #108	; 0x6c
 80244dc:	af00      	add	r7, sp, #0
 80244de:	60f8      	str	r0, [r7, #12]
 80244e0:	60b9      	str	r1, [r7, #8]
 80244e2:	607a      	str	r2, [r7, #4]
 80244e4:	603b      	str	r3, [r7, #0]
  INT32 z1, z2, z3;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  INT32 * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 80244e6:	68fb      	ldr	r3, [r7, #12]
 80244e8:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 80244ec:	3380      	adds	r3, #128	; 0x80
 80244ee:	657b      	str	r3, [r7, #84]	; 0x54

  /* Pass 1: process columns from input, store into work array.
   * 4-point IDCT kernel,
   * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point IDCT].
   */
  inptr = coef_block;
 80244f0:	687b      	ldr	r3, [r7, #4]
 80244f2:	667b      	str	r3, [r7, #100]	; 0x64
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 80244f4:	68bb      	ldr	r3, [r7, #8]
 80244f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80244f8:	663b      	str	r3, [r7, #96]	; 0x60
  wsptr = workspace;
 80244fa:	f107 0314 	add.w	r3, r7, #20
 80244fe:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 8024500:	2300      	movs	r3, #0
 8024502:	65bb      	str	r3, [r7, #88]	; 0x58
 8024504:	e06d      	b.n	80245e2 <jpeg_idct_2x4+0x10a>
    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024506:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8024508:	f9b3 3000 	ldrsh.w	r3, [r3]
 802450c:	461a      	mov	r2, r3
 802450e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024510:	681b      	ldr	r3, [r3, #0]
 8024512:	fb03 f302 	mul.w	r3, r3, r2
 8024516:	64bb      	str	r3, [r7, #72]	; 0x48
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
 8024518:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802451a:	3320      	adds	r3, #32
 802451c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024520:	461a      	mov	r2, r3
 8024522:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024524:	3340      	adds	r3, #64	; 0x40
 8024526:	681b      	ldr	r3, [r3, #0]
 8024528:	fb03 f302 	mul.w	r3, r3, r2
 802452c:	647b      	str	r3, [r7, #68]	; 0x44

    tmp10 = (tmp0 + tmp2) << CONST_BITS;
 802452e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8024530:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8024532:	4413      	add	r3, r2
 8024534:	035b      	lsls	r3, r3, #13
 8024536:	64fb      	str	r3, [r7, #76]	; 0x4c
    tmp12 = (tmp0 - tmp2) << CONST_BITS;
 8024538:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802453a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802453c:	1ad3      	subs	r3, r2, r3
 802453e:	035b      	lsls	r3, r3, #13
 8024540:	643b      	str	r3, [r7, #64]	; 0x40

    /* Odd part */
    /* Same rotation as in the even part of the 8x8 LL&M IDCT */

    z2 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
 8024542:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8024544:	3310      	adds	r3, #16
 8024546:	f9b3 3000 	ldrsh.w	r3, [r3]
 802454a:	461a      	mov	r2, r3
 802454c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802454e:	3320      	adds	r3, #32
 8024550:	681b      	ldr	r3, [r3, #0]
 8024552:	fb03 f302 	mul.w	r3, r3, r2
 8024556:	63fb      	str	r3, [r7, #60]	; 0x3c
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
 8024558:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802455a:	3330      	adds	r3, #48	; 0x30
 802455c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8024560:	461a      	mov	r2, r3
 8024562:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8024564:	3360      	adds	r3, #96	; 0x60
 8024566:	681b      	ldr	r3, [r3, #0]
 8024568:	fb03 f302 	mul.w	r3, r3, r2
 802456c:	63bb      	str	r3, [r7, #56]	; 0x38

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);   /* c6 */
 802456e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8024570:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8024572:	4413      	add	r3, r2
 8024574:	f241 1251 	movw	r2, #4433	; 0x1151
 8024578:	fb02 f303 	mul.w	r3, r2, r3
 802457c:	637b      	str	r3, [r7, #52]	; 0x34
    tmp0 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
 802457e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8024580:	f641 027e 	movw	r2, #6270	; 0x187e
 8024584:	fb02 f303 	mul.w	r3, r2, r3
 8024588:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802458a:	4413      	add	r3, r2
 802458c:	64bb      	str	r3, [r7, #72]	; 0x48
    tmp2 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 802458e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8024590:	4a34      	ldr	r2, [pc, #208]	; (8024664 <jpeg_idct_2x4+0x18c>)
 8024592:	fb02 f303 	mul.w	r3, r2, r3
 8024596:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8024598:	4413      	add	r3, r2
 802459a:	647b      	str	r3, [r7, #68]	; 0x44

    /* Final output stage */

    wsptr[2*0] = tmp10 + tmp0;
 802459c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 802459e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80245a0:	441a      	add	r2, r3
 80245a2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80245a4:	601a      	str	r2, [r3, #0]
    wsptr[2*3] = tmp10 - tmp0;
 80245a6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80245a8:	3318      	adds	r3, #24
 80245aa:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80245ac:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80245ae:	1a8a      	subs	r2, r1, r2
 80245b0:	601a      	str	r2, [r3, #0]
    wsptr[2*1] = tmp12 + tmp2;
 80245b2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80245b4:	3308      	adds	r3, #8
 80245b6:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80245b8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80245ba:	440a      	add	r2, r1
 80245bc:	601a      	str	r2, [r3, #0]
    wsptr[2*2] = tmp12 - tmp2;
 80245be:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80245c0:	3310      	adds	r3, #16
 80245c2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80245c4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80245c6:	1a8a      	subs	r2, r1, r2
 80245c8:	601a      	str	r2, [r3, #0]
  for (ctr = 0; ctr < 2; ctr++, inptr++, quantptr++, wsptr++) {
 80245ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80245cc:	3301      	adds	r3, #1
 80245ce:	65bb      	str	r3, [r7, #88]	; 0x58
 80245d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80245d2:	3302      	adds	r3, #2
 80245d4:	667b      	str	r3, [r7, #100]	; 0x64
 80245d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80245d8:	3304      	adds	r3, #4
 80245da:	663b      	str	r3, [r7, #96]	; 0x60
 80245dc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80245de:	3304      	adds	r3, #4
 80245e0:	65fb      	str	r3, [r7, #92]	; 0x5c
 80245e2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80245e4:	2b01      	cmp	r3, #1
 80245e6:	dd8e      	ble.n	8024506 <jpeg_idct_2x4+0x2e>
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
 80245e8:	f107 0314 	add.w	r3, r7, #20
 80245ec:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 80245ee:	2300      	movs	r3, #0
 80245f0:	65bb      	str	r3, [r7, #88]	; 0x58
 80245f2:	e02c      	b.n	802464e <jpeg_idct_2x4+0x176>
    outptr = output_buf[ctr] + output_col;
 80245f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80245f6:	009b      	lsls	r3, r3, #2
 80245f8:	683a      	ldr	r2, [r7, #0]
 80245fa:	4413      	add	r3, r2
 80245fc:	681a      	ldr	r2, [r3, #0]
 80245fe:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8024600:	4413      	add	r3, r2
 8024602:	653b      	str	r3, [r7, #80]	; 0x50

    /* Even part */

    /* Add fudge factor here for final descale. */
    tmp10 = wsptr[0] + (ONE << (CONST_BITS+2));
 8024604:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8024606:	681b      	ldr	r3, [r3, #0]
 8024608:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 802460c:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Odd part */

    tmp0 = wsptr[1];
 802460e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8024610:	685b      	ldr	r3, [r3, #4]
 8024612:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Final output stage */

    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 8024614:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8024616:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8024618:	4413      	add	r3, r2
 802461a:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 802461c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[0] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS+3)
 8024620:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8024622:	4413      	add	r3, r2
 8024624:	781a      	ldrb	r2, [r3, #0]
 8024626:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8024628:	701a      	strb	r2, [r3, #0]
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 802462a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 802462c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802462e:	1ad3      	subs	r3, r2, r3
 8024630:	141b      	asrs	r3, r3, #16
			    & RANGE_MASK];
 8024632:	f3c3 0309 	ubfx	r3, r3, #0, #10
    outptr[1] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS+3)
 8024636:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8024638:	441a      	add	r2, r3
 802463a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 802463c:	3301      	adds	r3, #1
 802463e:	7812      	ldrb	r2, [r2, #0]
 8024640:	701a      	strb	r2, [r3, #0]

    wsptr += 2;		/* advance pointer to next row */
 8024642:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8024644:	3308      	adds	r3, #8
 8024646:	65fb      	str	r3, [r7, #92]	; 0x5c
  for (ctr = 0; ctr < 4; ctr++) {
 8024648:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 802464a:	3301      	adds	r3, #1
 802464c:	65bb      	str	r3, [r7, #88]	; 0x58
 802464e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8024650:	2b03      	cmp	r3, #3
 8024652:	ddcf      	ble.n	80245f4 <jpeg_idct_2x4+0x11c>
  }
}
 8024654:	bf00      	nop
 8024656:	bf00      	nop
 8024658:	376c      	adds	r7, #108	; 0x6c
 802465a:	46bd      	mov	sp, r7
 802465c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024660:	4770      	bx	lr
 8024662:	bf00      	nop
 8024664:	ffffc4df 	.word	0xffffc4df

08024668 <jpeg_idct_1x2>:

GLOBAL(void)
jpeg_idct_1x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
 8024668:	b480      	push	{r7}
 802466a:	b089      	sub	sp, #36	; 0x24
 802466c:	af00      	add	r7, sp, #0
 802466e:	60f8      	str	r0, [r7, #12]
 8024670:	60b9      	str	r1, [r7, #8]
 8024672:	607a      	str	r2, [r7, #4]
 8024674:	603b      	str	r3, [r7, #0]
  INT32 tmp0, tmp10;
  ISLOW_MULT_TYPE * quantptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
 8024676:	68fb      	ldr	r3, [r7, #12]
 8024678:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 802467c:	3380      	adds	r3, #128	; 0x80
 802467e:	61fb      	str	r3, [r7, #28]
  SHIFT_TEMPS

  /* Process 1 column from input, store into output array. */

  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
 8024680:	68bb      	ldr	r3, [r7, #8]
 8024682:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8024684:	61bb      	str	r3, [r7, #24]

  /* Even part */
    
  tmp10 = DEQUANTIZE(coef_block[DCTSIZE*0], quantptr[DCTSIZE*0]);
 8024686:	687b      	ldr	r3, [r7, #4]
 8024688:	f9b3 3000 	ldrsh.w	r3, [r3]
 802468c:	461a      	mov	r2, r3
 802468e:	69bb      	ldr	r3, [r7, #24]
 8024690:	681b      	ldr	r3, [r3, #0]
 8024692:	fb03 f302 	mul.w	r3, r3, r2
 8024696:	617b      	str	r3, [r7, #20]
  /* Add fudge factor here for final descale. */
  tmp10 += ONE << 2;
 8024698:	697b      	ldr	r3, [r7, #20]
 802469a:	3304      	adds	r3, #4
 802469c:	617b      	str	r3, [r7, #20]

  /* Odd part */

  tmp0 = DEQUANTIZE(coef_block[DCTSIZE*1], quantptr[DCTSIZE*1]);
 802469e:	687b      	ldr	r3, [r7, #4]
 80246a0:	3310      	adds	r3, #16
 80246a2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80246a6:	461a      	mov	r2, r3
 80246a8:	69bb      	ldr	r3, [r7, #24]
 80246aa:	3320      	adds	r3, #32
 80246ac:	681b      	ldr	r3, [r3, #0]
 80246ae:	fb03 f302 	mul.w	r3, r3, r2
 80246b2:	613b      	str	r3, [r7, #16]

  /* Final output stage */

  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 80246b4:	697a      	ldr	r2, [r7, #20]
 80246b6:	693b      	ldr	r3, [r7, #16]
 80246b8:	4413      	add	r3, r2
 80246ba:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 80246bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[0][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 + tmp0, 3)
 80246c0:	69fa      	ldr	r2, [r7, #28]
 80246c2:	441a      	add	r2, r3
 80246c4:	683b      	ldr	r3, [r7, #0]
 80246c6:	6819      	ldr	r1, [r3, #0]
 80246c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80246ca:	440b      	add	r3, r1
 80246cc:	7812      	ldrb	r2, [r2, #0]
 80246ce:	701a      	strb	r2, [r3, #0]
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 80246d0:	697a      	ldr	r2, [r7, #20]
 80246d2:	693b      	ldr	r3, [r7, #16]
 80246d4:	1ad3      	subs	r3, r2, r3
 80246d6:	10db      	asrs	r3, r3, #3
					  & RANGE_MASK];
 80246d8:	f3c3 0309 	ubfx	r3, r3, #0, #10
  output_buf[1][output_col] = range_limit[(int) RIGHT_SHIFT(tmp10 - tmp0, 3)
 80246dc:	69fa      	ldr	r2, [r7, #28]
 80246de:	441a      	add	r2, r3
 80246e0:	683b      	ldr	r3, [r7, #0]
 80246e2:	3304      	adds	r3, #4
 80246e4:	6819      	ldr	r1, [r3, #0]
 80246e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80246e8:	440b      	add	r3, r1
 80246ea:	7812      	ldrb	r2, [r2, #0]
 80246ec:	701a      	strb	r2, [r3, #0]
}
 80246ee:	bf00      	nop
 80246f0:	3724      	adds	r7, #36	; 0x24
 80246f2:	46bd      	mov	sp, r7
 80246f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80246f8:	4770      	bx	lr

080246fa <out_of_memory>:

LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
 80246fa:	b580      	push	{r7, lr}
 80246fc:	b082      	sub	sp, #8
 80246fe:	af00      	add	r7, sp, #0
 8024700:	6078      	str	r0, [r7, #4]
 8024702:	6039      	str	r1, [r7, #0]
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 8024704:	687b      	ldr	r3, [r7, #4]
 8024706:	681b      	ldr	r3, [r3, #0]
 8024708:	2238      	movs	r2, #56	; 0x38
 802470a:	615a      	str	r2, [r3, #20]
 802470c:	687b      	ldr	r3, [r7, #4]
 802470e:	681b      	ldr	r3, [r3, #0]
 8024710:	683a      	ldr	r2, [r7, #0]
 8024712:	619a      	str	r2, [r3, #24]
 8024714:	687b      	ldr	r3, [r7, #4]
 8024716:	681b      	ldr	r3, [r3, #0]
 8024718:	681b      	ldr	r3, [r3, #0]
 802471a:	6878      	ldr	r0, [r7, #4]
 802471c:	4798      	blx	r3
}
 802471e:	bf00      	nop
 8024720:	3708      	adds	r7, #8
 8024722:	46bd      	mov	sp, r7
 8024724:	bd80      	pop	{r7, pc}
	...

08024728 <alloc_small>:


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
 8024728:	b580      	push	{r7, lr}
 802472a:	b08c      	sub	sp, #48	; 0x30
 802472c:	af00      	add	r7, sp, #0
 802472e:	60f8      	str	r0, [r7, #12]
 8024730:	60b9      	str	r1, [r7, #8]
 8024732:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8024734:	68fb      	ldr	r3, [r7, #12]
 8024736:	685b      	ldr	r3, [r3, #4]
 8024738:	623b      	str	r3, [r7, #32]
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
 802473a:	687b      	ldr	r3, [r7, #4]
 802473c:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8024740:	4293      	cmp	r3, r2
 8024742:	d903      	bls.n	802474c <alloc_small+0x24>
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
 8024744:	2101      	movs	r1, #1
 8024746:	68f8      	ldr	r0, [r7, #12]
 8024748:	f7ff ffd7 	bl	80246fa <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 802474c:	687b      	ldr	r3, [r7, #4]
 802474e:	f003 0307 	and.w	r3, r3, #7
 8024752:	61fb      	str	r3, [r7, #28]
  if (odd_bytes > 0)
 8024754:	69fb      	ldr	r3, [r7, #28]
 8024756:	2b00      	cmp	r3, #0
 8024758:	d004      	beq.n	8024764 <alloc_small+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 802475a:	687a      	ldr	r2, [r7, #4]
 802475c:	69fb      	ldr	r3, [r7, #28]
 802475e:	1ad3      	subs	r3, r2, r3
 8024760:	3308      	adds	r3, #8
 8024762:	607b      	str	r3, [r7, #4]

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 8024764:	68bb      	ldr	r3, [r7, #8]
 8024766:	2b00      	cmp	r3, #0
 8024768:	db02      	blt.n	8024770 <alloc_small+0x48>
 802476a:	68bb      	ldr	r3, [r7, #8]
 802476c:	2b01      	cmp	r3, #1
 802476e:	dd0c      	ble.n	802478a <alloc_small+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8024770:	68fb      	ldr	r3, [r7, #12]
 8024772:	681b      	ldr	r3, [r3, #0]
 8024774:	220f      	movs	r2, #15
 8024776:	615a      	str	r2, [r3, #20]
 8024778:	68fb      	ldr	r3, [r7, #12]
 802477a:	681b      	ldr	r3, [r3, #0]
 802477c:	68ba      	ldr	r2, [r7, #8]
 802477e:	619a      	str	r2, [r3, #24]
 8024780:	68fb      	ldr	r3, [r7, #12]
 8024782:	681b      	ldr	r3, [r3, #0]
 8024784:	681b      	ldr	r3, [r3, #0]
 8024786:	68f8      	ldr	r0, [r7, #12]
 8024788:	4798      	blx	r3
  prev_hdr_ptr = NULL;
 802478a:	2300      	movs	r3, #0
 802478c:	62bb      	str	r3, [r7, #40]	; 0x28
  hdr_ptr = mem->small_list[pool_id];
 802478e:	6a3a      	ldr	r2, [r7, #32]
 8024790:	68bb      	ldr	r3, [r7, #8]
 8024792:	330c      	adds	r3, #12
 8024794:	009b      	lsls	r3, r3, #2
 8024796:	4413      	add	r3, r2
 8024798:	685b      	ldr	r3, [r3, #4]
 802479a:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (hdr_ptr != NULL) {
 802479c:	e009      	b.n	80247b2 <alloc_small+0x8a>
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
 802479e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80247a0:	689b      	ldr	r3, [r3, #8]
 80247a2:	687a      	ldr	r2, [r7, #4]
 80247a4:	429a      	cmp	r2, r3
 80247a6:	d908      	bls.n	80247ba <alloc_small+0x92>
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
 80247a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80247aa:	62bb      	str	r3, [r7, #40]	; 0x28
    hdr_ptr = hdr_ptr->hdr.next;
 80247ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80247ae:	681b      	ldr	r3, [r3, #0]
 80247b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (hdr_ptr != NULL) {
 80247b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80247b4:	2b00      	cmp	r3, #0
 80247b6:	d1f2      	bne.n	802479e <alloc_small+0x76>
 80247b8:	e000      	b.n	80247bc <alloc_small+0x94>
      break;			/* found pool with enough space */
 80247ba:	bf00      	nop
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
 80247bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80247be:	2b00      	cmp	r3, #0
 80247c0:	d154      	bne.n	802486c <alloc_small+0x144>
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
 80247c2:	687b      	ldr	r3, [r7, #4]
 80247c4:	3310      	adds	r3, #16
 80247c6:	61bb      	str	r3, [r7, #24]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 80247c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80247ca:	2b00      	cmp	r3, #0
 80247cc:	d105      	bne.n	80247da <alloc_small+0xb2>
      slop = first_pool_slop[pool_id];
 80247ce:	4a34      	ldr	r2, [pc, #208]	; (80248a0 <alloc_small+0x178>)
 80247d0:	68bb      	ldr	r3, [r7, #8]
 80247d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80247d6:	627b      	str	r3, [r7, #36]	; 0x24
 80247d8:	e004      	b.n	80247e4 <alloc_small+0xbc>
    else
      slop = extra_pool_slop[pool_id];
 80247da:	4a32      	ldr	r2, [pc, #200]	; (80248a4 <alloc_small+0x17c>)
 80247dc:	68bb      	ldr	r3, [r7, #8]
 80247de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80247e2:	627b      	str	r3, [r7, #36]	; 0x24
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
 80247e4:	69bb      	ldr	r3, [r7, #24]
 80247e6:	f5c3 3380 	rsb	r3, r3, #65536	; 0x10000
 80247ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80247ec:	429a      	cmp	r2, r3
 80247ee:	d903      	bls.n	80247f8 <alloc_small+0xd0>
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 80247f0:	69bb      	ldr	r3, [r7, #24]
 80247f2:	f5c3 3380 	rsb	r3, r3, #65536	; 0x10000
 80247f6:	627b      	str	r3, [r7, #36]	; 0x24
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 80247f8:	69ba      	ldr	r2, [r7, #24]
 80247fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80247fc:	4413      	add	r3, r2
 80247fe:	4619      	mov	r1, r3
 8024800:	68f8      	ldr	r0, [r7, #12]
 8024802:	f000 feff 	bl	8025604 <jpeg_get_small>
 8024806:	62f8      	str	r0, [r7, #44]	; 0x2c
      if (hdr_ptr != NULL)
 8024808:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802480a:	2b00      	cmp	r3, #0
 802480c:	d10a      	bne.n	8024824 <alloc_small+0xfc>
	break;
      slop /= 2;
 802480e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024810:	085b      	lsrs	r3, r3, #1
 8024812:	627b      	str	r3, [r7, #36]	; 0x24
      if (slop < MIN_SLOP)	/* give up when it gets real small */
 8024814:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024816:	2b31      	cmp	r3, #49	; 0x31
 8024818:	d8ee      	bhi.n	80247f8 <alloc_small+0xd0>
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 802481a:	2102      	movs	r1, #2
 802481c:	68f8      	ldr	r0, [r7, #12]
 802481e:	f7ff ff6c 	bl	80246fa <out_of_memory>
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 8024822:	e7e9      	b.n	80247f8 <alloc_small+0xd0>
	break;
 8024824:	bf00      	nop
    }
    mem->total_space_allocated += min_request + slop;
 8024826:	6a3b      	ldr	r3, [r7, #32]
 8024828:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802482a:	4619      	mov	r1, r3
 802482c:	69ba      	ldr	r2, [r7, #24]
 802482e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024830:	4413      	add	r3, r2
 8024832:	440b      	add	r3, r1
 8024834:	461a      	mov	r2, r3
 8024836:	6a3b      	ldr	r3, [r7, #32]
 8024838:	64da      	str	r2, [r3, #76]	; 0x4c
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
 802483a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802483c:	2200      	movs	r2, #0
 802483e:	601a      	str	r2, [r3, #0]
    hdr_ptr->hdr.bytes_used = 0;
 8024840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024842:	2200      	movs	r2, #0
 8024844:	605a      	str	r2, [r3, #4]
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
 8024846:	687a      	ldr	r2, [r7, #4]
 8024848:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802484a:	441a      	add	r2, r3
 802484c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802484e:	609a      	str	r2, [r3, #8]
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
 8024850:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024852:	2b00      	cmp	r3, #0
 8024854:	d107      	bne.n	8024866 <alloc_small+0x13e>
      mem->small_list[pool_id] = hdr_ptr;
 8024856:	6a3a      	ldr	r2, [r7, #32]
 8024858:	68bb      	ldr	r3, [r7, #8]
 802485a:	330c      	adds	r3, #12
 802485c:	009b      	lsls	r3, r3, #2
 802485e:	4413      	add	r3, r2
 8024860:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024862:	605a      	str	r2, [r3, #4]
 8024864:	e002      	b.n	802486c <alloc_small+0x144>
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
 8024866:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024868:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802486a:	601a      	str	r2, [r3, #0]
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 802486c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802486e:	3310      	adds	r3, #16
 8024870:	617b      	str	r3, [r7, #20]
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
 8024872:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024874:	685b      	ldr	r3, [r3, #4]
 8024876:	697a      	ldr	r2, [r7, #20]
 8024878:	4413      	add	r3, r2
 802487a:	617b      	str	r3, [r7, #20]
  hdr_ptr->hdr.bytes_used += sizeofobject;
 802487c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802487e:	685a      	ldr	r2, [r3, #4]
 8024880:	687b      	ldr	r3, [r7, #4]
 8024882:	441a      	add	r2, r3
 8024884:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024886:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left -= sizeofobject;
 8024888:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802488a:	689a      	ldr	r2, [r3, #8]
 802488c:	687b      	ldr	r3, [r7, #4]
 802488e:	1ad2      	subs	r2, r2, r3
 8024890:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024892:	609a      	str	r2, [r3, #8]

  return (void *) data_ptr;
 8024894:	697b      	ldr	r3, [r7, #20]
}
 8024896:	4618      	mov	r0, r3
 8024898:	3730      	adds	r7, #48	; 0x30
 802489a:	46bd      	mov	sp, r7
 802489c:	bd80      	pop	{r7, pc}
 802489e:	bf00      	nop
 80248a0:	0802ab4c 	.word	0x0802ab4c
 80248a4:	0802ab54 	.word	0x0802ab54

080248a8 <alloc_large>:
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
 80248a8:	b580      	push	{r7, lr}
 80248aa:	b088      	sub	sp, #32
 80248ac:	af00      	add	r7, sp, #0
 80248ae:	60f8      	str	r0, [r7, #12]
 80248b0:	60b9      	str	r1, [r7, #8]
 80248b2:	607a      	str	r2, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 80248b4:	68fb      	ldr	r3, [r7, #12]
 80248b6:	685b      	ldr	r3, [r3, #4]
 80248b8:	61fb      	str	r3, [r7, #28]
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
 80248ba:	687b      	ldr	r3, [r7, #4]
 80248bc:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 80248c0:	4293      	cmp	r3, r2
 80248c2:	d903      	bls.n	80248cc <alloc_large+0x24>
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
 80248c4:	2103      	movs	r1, #3
 80248c6:	68f8      	ldr	r0, [r7, #12]
 80248c8:	f7ff ff17 	bl	80246fa <out_of_memory>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 80248cc:	687b      	ldr	r3, [r7, #4]
 80248ce:	f003 0307 	and.w	r3, r3, #7
 80248d2:	61bb      	str	r3, [r7, #24]
  if (odd_bytes > 0)
 80248d4:	69bb      	ldr	r3, [r7, #24]
 80248d6:	2b00      	cmp	r3, #0
 80248d8:	d004      	beq.n	80248e4 <alloc_large+0x3c>
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 80248da:	687a      	ldr	r2, [r7, #4]
 80248dc:	69bb      	ldr	r3, [r7, #24]
 80248de:	1ad3      	subs	r3, r2, r3
 80248e0:	3308      	adds	r3, #8
 80248e2:	607b      	str	r3, [r7, #4]

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 80248e4:	68bb      	ldr	r3, [r7, #8]
 80248e6:	2b00      	cmp	r3, #0
 80248e8:	db02      	blt.n	80248f0 <alloc_large+0x48>
 80248ea:	68bb      	ldr	r3, [r7, #8]
 80248ec:	2b01      	cmp	r3, #1
 80248ee:	dd0c      	ble.n	802490a <alloc_large+0x62>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 80248f0:	68fb      	ldr	r3, [r7, #12]
 80248f2:	681b      	ldr	r3, [r3, #0]
 80248f4:	220f      	movs	r2, #15
 80248f6:	615a      	str	r2, [r3, #20]
 80248f8:	68fb      	ldr	r3, [r7, #12]
 80248fa:	681b      	ldr	r3, [r3, #0]
 80248fc:	68ba      	ldr	r2, [r7, #8]
 80248fe:	619a      	str	r2, [r3, #24]
 8024900:	68fb      	ldr	r3, [r7, #12]
 8024902:	681b      	ldr	r3, [r3, #0]
 8024904:	681b      	ldr	r3, [r3, #0]
 8024906:	68f8      	ldr	r0, [r7, #12]
 8024908:	4798      	blx	r3

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 802490a:	687b      	ldr	r3, [r7, #4]
 802490c:	3310      	adds	r3, #16
 802490e:	4619      	mov	r1, r3
 8024910:	68f8      	ldr	r0, [r7, #12]
 8024912:	f000 fe91 	bl	8025638 <jpeg_get_large>
 8024916:	6178      	str	r0, [r7, #20]
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
 8024918:	697b      	ldr	r3, [r7, #20]
 802491a:	2b00      	cmp	r3, #0
 802491c:	d103      	bne.n	8024926 <alloc_large+0x7e>
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
 802491e:	2104      	movs	r1, #4
 8024920:	68f8      	ldr	r0, [r7, #12]
 8024922:	f7ff feea 	bl	80246fa <out_of_memory>
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 8024926:	69fb      	ldr	r3, [r7, #28]
 8024928:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802492a:	461a      	mov	r2, r3
 802492c:	687b      	ldr	r3, [r7, #4]
 802492e:	4413      	add	r3, r2
 8024930:	3310      	adds	r3, #16
 8024932:	461a      	mov	r2, r3
 8024934:	69fb      	ldr	r3, [r7, #28]
 8024936:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
 8024938:	69fa      	ldr	r2, [r7, #28]
 802493a:	68bb      	ldr	r3, [r7, #8]
 802493c:	330e      	adds	r3, #14
 802493e:	009b      	lsls	r3, r3, #2
 8024940:	4413      	add	r3, r2
 8024942:	685a      	ldr	r2, [r3, #4]
 8024944:	697b      	ldr	r3, [r7, #20]
 8024946:	601a      	str	r2, [r3, #0]
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
 8024948:	697b      	ldr	r3, [r7, #20]
 802494a:	687a      	ldr	r2, [r7, #4]
 802494c:	605a      	str	r2, [r3, #4]
  hdr_ptr->hdr.bytes_left = 0;
 802494e:	697b      	ldr	r3, [r7, #20]
 8024950:	2200      	movs	r2, #0
 8024952:	609a      	str	r2, [r3, #8]
  mem->large_list[pool_id] = hdr_ptr;
 8024954:	69fa      	ldr	r2, [r7, #28]
 8024956:	68bb      	ldr	r3, [r7, #8]
 8024958:	330e      	adds	r3, #14
 802495a:	009b      	lsls	r3, r3, #2
 802495c:	4413      	add	r3, r2
 802495e:	697a      	ldr	r2, [r7, #20]
 8024960:	605a      	str	r2, [r3, #4]

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 8024962:	697b      	ldr	r3, [r7, #20]
 8024964:	3310      	adds	r3, #16
}
 8024966:	4618      	mov	r0, r3
 8024968:	3720      	adds	r7, #32
 802496a:	46bd      	mov	sp, r7
 802496c:	bd80      	pop	{r7, pc}

0802496e <alloc_sarray>:

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
 802496e:	b580      	push	{r7, lr}
 8024970:	b08c      	sub	sp, #48	; 0x30
 8024972:	af00      	add	r7, sp, #0
 8024974:	60f8      	str	r0, [r7, #12]
 8024976:	60b9      	str	r1, [r7, #8]
 8024978:	607a      	str	r2, [r7, #4]
 802497a:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802497c:	68fb      	ldr	r3, [r7, #12]
 802497e:	685b      	ldr	r3, [r3, #4]
 8024980:	61fb      	str	r3, [r7, #28]
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 8024982:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8024986:	687b      	ldr	r3, [r7, #4]
 8024988:	fbb2 f3f3 	udiv	r3, r2, r3
 802498c:	61bb      	str	r3, [r7, #24]
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
 802498e:	69bb      	ldr	r3, [r7, #24]
 8024990:	2b00      	cmp	r3, #0
 8024992:	dc08      	bgt.n	80249a6 <alloc_sarray+0x38>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 8024994:	68fb      	ldr	r3, [r7, #12]
 8024996:	681b      	ldr	r3, [r3, #0]
 8024998:	2248      	movs	r2, #72	; 0x48
 802499a:	615a      	str	r2, [r3, #20]
 802499c:	68fb      	ldr	r3, [r7, #12]
 802499e:	681b      	ldr	r3, [r3, #0]
 80249a0:	681b      	ldr	r3, [r3, #0]
 80249a2:	68f8      	ldr	r0, [r7, #12]
 80249a4:	4798      	blx	r3
  if (ltemp < (long) numrows)
 80249a6:	683b      	ldr	r3, [r7, #0]
 80249a8:	69ba      	ldr	r2, [r7, #24]
 80249aa:	429a      	cmp	r2, r3
 80249ac:	da02      	bge.n	80249b4 <alloc_sarray+0x46>
    rowsperchunk = (JDIMENSION) ltemp;
 80249ae:	69bb      	ldr	r3, [r7, #24]
 80249b0:	62bb      	str	r3, [r7, #40]	; 0x28
 80249b2:	e001      	b.n	80249b8 <alloc_sarray+0x4a>
  else
    rowsperchunk = numrows;
 80249b4:	683b      	ldr	r3, [r7, #0]
 80249b6:	62bb      	str	r3, [r7, #40]	; 0x28
  mem->last_rowsperchunk = rowsperchunk;
 80249b8:	69fb      	ldr	r3, [r7, #28]
 80249ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80249bc:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));
 80249be:	683b      	ldr	r3, [r7, #0]
 80249c0:	009b      	lsls	r3, r3, #2
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
 80249c2:	461a      	mov	r2, r3
 80249c4:	68b9      	ldr	r1, [r7, #8]
 80249c6:	68f8      	ldr	r0, [r7, #12]
 80249c8:	f7ff feae 	bl	8024728 <alloc_small>
 80249cc:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 80249ce:	2300      	movs	r3, #0
 80249d0:	627b      	str	r3, [r7, #36]	; 0x24
  while (currow < numrows) {
 80249d2:	e026      	b.n	8024a22 <alloc_sarray+0xb4>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 80249d4:	683a      	ldr	r2, [r7, #0]
 80249d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80249d8:	1ad3      	subs	r3, r2, r3
 80249da:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80249dc:	4293      	cmp	r3, r2
 80249de:	bf28      	it	cs
 80249e0:	4613      	movcs	r3, r2
 80249e2:	62bb      	str	r3, [r7, #40]	; 0x28
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 80249e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80249e6:	687a      	ldr	r2, [r7, #4]
 80249e8:	fb02 f303 	mul.w	r3, r2, r3
 80249ec:	461a      	mov	r2, r3
 80249ee:	68b9      	ldr	r1, [r7, #8]
 80249f0:	68f8      	ldr	r0, [r7, #12]
 80249f2:	f7ff ff59 	bl	80248a8 <alloc_large>
 80249f6:	62f8      	str	r0, [r7, #44]	; 0x2c
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
 80249f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80249fa:	623b      	str	r3, [r7, #32]
 80249fc:	e00e      	b.n	8024a1c <alloc_sarray+0xae>
      result[currow++] = workspace;
 80249fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024a00:	1c5a      	adds	r2, r3, #1
 8024a02:	627a      	str	r2, [r7, #36]	; 0x24
 8024a04:	009b      	lsls	r3, r3, #2
 8024a06:	697a      	ldr	r2, [r7, #20]
 8024a08:	4413      	add	r3, r2
 8024a0a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024a0c:	601a      	str	r2, [r3, #0]
      workspace += samplesperrow;
 8024a0e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024a10:	687b      	ldr	r3, [r7, #4]
 8024a12:	4413      	add	r3, r2
 8024a14:	62fb      	str	r3, [r7, #44]	; 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 8024a16:	6a3b      	ldr	r3, [r7, #32]
 8024a18:	3b01      	subs	r3, #1
 8024a1a:	623b      	str	r3, [r7, #32]
 8024a1c:	6a3b      	ldr	r3, [r7, #32]
 8024a1e:	2b00      	cmp	r3, #0
 8024a20:	d1ed      	bne.n	80249fe <alloc_sarray+0x90>
  while (currow < numrows) {
 8024a22:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024a24:	683b      	ldr	r3, [r7, #0]
 8024a26:	429a      	cmp	r2, r3
 8024a28:	d3d4      	bcc.n	80249d4 <alloc_sarray+0x66>
    }
  }

  return result;
 8024a2a:	697b      	ldr	r3, [r7, #20]
}
 8024a2c:	4618      	mov	r0, r3
 8024a2e:	3730      	adds	r7, #48	; 0x30
 8024a30:	46bd      	mov	sp, r7
 8024a32:	bd80      	pop	{r7, pc}

08024a34 <alloc_barray>:

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
 8024a34:	b580      	push	{r7, lr}
 8024a36:	b08c      	sub	sp, #48	; 0x30
 8024a38:	af00      	add	r7, sp, #0
 8024a3a:	60f8      	str	r0, [r7, #12]
 8024a3c:	60b9      	str	r1, [r7, #8]
 8024a3e:	607a      	str	r2, [r7, #4]
 8024a40:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8024a42:	68fb      	ldr	r3, [r7, #12]
 8024a44:	685b      	ldr	r3, [r3, #4]
 8024a46:	61fb      	str	r3, [r7, #28]
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
 8024a48:	687b      	ldr	r3, [r7, #4]
 8024a4a:	01db      	lsls	r3, r3, #7
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 8024a4c:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8024a50:	fbb2 f3f3 	udiv	r3, r2, r3
 8024a54:	61bb      	str	r3, [r7, #24]
  if (ltemp <= 0)
 8024a56:	69bb      	ldr	r3, [r7, #24]
 8024a58:	2b00      	cmp	r3, #0
 8024a5a:	dc08      	bgt.n	8024a6e <alloc_barray+0x3a>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 8024a5c:	68fb      	ldr	r3, [r7, #12]
 8024a5e:	681b      	ldr	r3, [r3, #0]
 8024a60:	2248      	movs	r2, #72	; 0x48
 8024a62:	615a      	str	r2, [r3, #20]
 8024a64:	68fb      	ldr	r3, [r7, #12]
 8024a66:	681b      	ldr	r3, [r3, #0]
 8024a68:	681b      	ldr	r3, [r3, #0]
 8024a6a:	68f8      	ldr	r0, [r7, #12]
 8024a6c:	4798      	blx	r3
  if (ltemp < (long) numrows)
 8024a6e:	683b      	ldr	r3, [r7, #0]
 8024a70:	69ba      	ldr	r2, [r7, #24]
 8024a72:	429a      	cmp	r2, r3
 8024a74:	da02      	bge.n	8024a7c <alloc_barray+0x48>
    rowsperchunk = (JDIMENSION) ltemp;
 8024a76:	69bb      	ldr	r3, [r7, #24]
 8024a78:	62bb      	str	r3, [r7, #40]	; 0x28
 8024a7a:	e001      	b.n	8024a80 <alloc_barray+0x4c>
  else
    rowsperchunk = numrows;
 8024a7c:	683b      	ldr	r3, [r7, #0]
 8024a7e:	62bb      	str	r3, [r7, #40]	; 0x28
  mem->last_rowsperchunk = rowsperchunk;
 8024a80:	69fb      	ldr	r3, [r7, #28]
 8024a82:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024a84:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
 8024a86:	683b      	ldr	r3, [r7, #0]
 8024a88:	009b      	lsls	r3, r3, #2
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
 8024a8a:	461a      	mov	r2, r3
 8024a8c:	68b9      	ldr	r1, [r7, #8]
 8024a8e:	68f8      	ldr	r0, [r7, #12]
 8024a90:	f7ff fe4a 	bl	8024728 <alloc_small>
 8024a94:	6178      	str	r0, [r7, #20]

  /* Get the rows themselves (large objects) */
  currow = 0;
 8024a96:	2300      	movs	r3, #0
 8024a98:	627b      	str	r3, [r7, #36]	; 0x24
  while (currow < numrows) {
 8024a9a:	e028      	b.n	8024aee <alloc_barray+0xba>
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
 8024a9c:	683a      	ldr	r2, [r7, #0]
 8024a9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024aa0:	1ad3      	subs	r3, r2, r3
 8024aa2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024aa4:	4293      	cmp	r3, r2
 8024aa6:	bf28      	it	cs
 8024aa8:	4613      	movcs	r3, r2
 8024aaa:	62bb      	str	r3, [r7, #40]	; 0x28
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 8024aac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024aae:	687a      	ldr	r2, [r7, #4]
 8024ab0:	fb02 f303 	mul.w	r3, r2, r3
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 8024ab4:	01db      	lsls	r3, r3, #7
 8024ab6:	461a      	mov	r2, r3
 8024ab8:	68b9      	ldr	r1, [r7, #8]
 8024aba:	68f8      	ldr	r0, [r7, #12]
 8024abc:	f7ff fef4 	bl	80248a8 <alloc_large>
 8024ac0:	62f8      	str	r0, [r7, #44]	; 0x2c
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
 8024ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024ac4:	623b      	str	r3, [r7, #32]
 8024ac6:	e00f      	b.n	8024ae8 <alloc_barray+0xb4>
      result[currow++] = workspace;
 8024ac8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024aca:	1c5a      	adds	r2, r3, #1
 8024acc:	627a      	str	r2, [r7, #36]	; 0x24
 8024ace:	009b      	lsls	r3, r3, #2
 8024ad0:	697a      	ldr	r2, [r7, #20]
 8024ad2:	4413      	add	r3, r2
 8024ad4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024ad6:	601a      	str	r2, [r3, #0]
      workspace += blocksperrow;
 8024ad8:	687b      	ldr	r3, [r7, #4]
 8024ada:	01db      	lsls	r3, r3, #7
 8024adc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8024ade:	4413      	add	r3, r2
 8024ae0:	62fb      	str	r3, [r7, #44]	; 0x2c
    for (i = rowsperchunk; i > 0; i--) {
 8024ae2:	6a3b      	ldr	r3, [r7, #32]
 8024ae4:	3b01      	subs	r3, #1
 8024ae6:	623b      	str	r3, [r7, #32]
 8024ae8:	6a3b      	ldr	r3, [r7, #32]
 8024aea:	2b00      	cmp	r3, #0
 8024aec:	d1ec      	bne.n	8024ac8 <alloc_barray+0x94>
  while (currow < numrows) {
 8024aee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024af0:	683b      	ldr	r3, [r7, #0]
 8024af2:	429a      	cmp	r2, r3
 8024af4:	d3d2      	bcc.n	8024a9c <alloc_barray+0x68>
    }
  }

  return result;
 8024af6:	697b      	ldr	r3, [r7, #20]
}
 8024af8:	4618      	mov	r0, r3
 8024afa:	3730      	adds	r7, #48	; 0x30
 8024afc:	46bd      	mov	sp, r7
 8024afe:	bd80      	pop	{r7, pc}

08024b00 <request_virt_sarray>:
METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
 8024b00:	b580      	push	{r7, lr}
 8024b02:	b086      	sub	sp, #24
 8024b04:	af00      	add	r7, sp, #0
 8024b06:	60f8      	str	r0, [r7, #12]
 8024b08:	60b9      	str	r1, [r7, #8]
 8024b0a:	607a      	str	r2, [r7, #4]
 8024b0c:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8024b0e:	68fb      	ldr	r3, [r7, #12]
 8024b10:	685b      	ldr	r3, [r3, #4]
 8024b12:	617b      	str	r3, [r7, #20]
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 8024b14:	68bb      	ldr	r3, [r7, #8]
 8024b16:	2b01      	cmp	r3, #1
 8024b18:	d00c      	beq.n	8024b34 <request_virt_sarray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8024b1a:	68fb      	ldr	r3, [r7, #12]
 8024b1c:	681b      	ldr	r3, [r3, #0]
 8024b1e:	220f      	movs	r2, #15
 8024b20:	615a      	str	r2, [r3, #20]
 8024b22:	68fb      	ldr	r3, [r7, #12]
 8024b24:	681b      	ldr	r3, [r3, #0]
 8024b26:	68ba      	ldr	r2, [r7, #8]
 8024b28:	619a      	str	r2, [r3, #24]
 8024b2a:	68fb      	ldr	r3, [r7, #12]
 8024b2c:	681b      	ldr	r3, [r3, #0]
 8024b2e:	681b      	ldr	r3, [r3, #0]
 8024b30:	68f8      	ldr	r0, [r7, #12]
 8024b32:	4798      	blx	r3

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 8024b34:	223c      	movs	r2, #60	; 0x3c
 8024b36:	68b9      	ldr	r1, [r7, #8]
 8024b38:	68f8      	ldr	r0, [r7, #12]
 8024b3a:	f7ff fdf5 	bl	8024728 <alloc_small>
 8024b3e:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 8024b40:	693b      	ldr	r3, [r7, #16]
 8024b42:	2200      	movs	r2, #0
 8024b44:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 8024b46:	693b      	ldr	r3, [r7, #16]
 8024b48:	6a3a      	ldr	r2, [r7, #32]
 8024b4a:	605a      	str	r2, [r3, #4]
  result->samplesperrow = samplesperrow;
 8024b4c:	693b      	ldr	r3, [r7, #16]
 8024b4e:	683a      	ldr	r2, [r7, #0]
 8024b50:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 8024b52:	693b      	ldr	r3, [r7, #16]
 8024b54:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024b56:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 8024b58:	693b      	ldr	r3, [r7, #16]
 8024b5a:	687a      	ldr	r2, [r7, #4]
 8024b5c:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 8024b5e:	693b      	ldr	r3, [r7, #16]
 8024b60:	2200      	movs	r2, #0
 8024b62:	629a      	str	r2, [r3, #40]	; 0x28
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
 8024b64:	697b      	ldr	r3, [r7, #20]
 8024b66:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8024b68:	693b      	ldr	r3, [r7, #16]
 8024b6a:	62da      	str	r2, [r3, #44]	; 0x2c
  mem->virt_sarray_list = result;
 8024b6c:	697b      	ldr	r3, [r7, #20]
 8024b6e:	693a      	ldr	r2, [r7, #16]
 8024b70:	645a      	str	r2, [r3, #68]	; 0x44

  return result;
 8024b72:	693b      	ldr	r3, [r7, #16]
}
 8024b74:	4618      	mov	r0, r3
 8024b76:	3718      	adds	r7, #24
 8024b78:	46bd      	mov	sp, r7
 8024b7a:	bd80      	pop	{r7, pc}

08024b7c <request_virt_barray>:
METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
 8024b7c:	b580      	push	{r7, lr}
 8024b7e:	b086      	sub	sp, #24
 8024b80:	af00      	add	r7, sp, #0
 8024b82:	60f8      	str	r0, [r7, #12]
 8024b84:	60b9      	str	r1, [r7, #8]
 8024b86:	607a      	str	r2, [r7, #4]
 8024b88:	603b      	str	r3, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8024b8a:	68fb      	ldr	r3, [r7, #12]
 8024b8c:	685b      	ldr	r3, [r3, #4]
 8024b8e:	617b      	str	r3, [r7, #20]
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
 8024b90:	68bb      	ldr	r3, [r7, #8]
 8024b92:	2b01      	cmp	r3, #1
 8024b94:	d00c      	beq.n	8024bb0 <request_virt_barray+0x34>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 8024b96:	68fb      	ldr	r3, [r7, #12]
 8024b98:	681b      	ldr	r3, [r3, #0]
 8024b9a:	220f      	movs	r2, #15
 8024b9c:	615a      	str	r2, [r3, #20]
 8024b9e:	68fb      	ldr	r3, [r7, #12]
 8024ba0:	681b      	ldr	r3, [r3, #0]
 8024ba2:	68ba      	ldr	r2, [r7, #8]
 8024ba4:	619a      	str	r2, [r3, #24]
 8024ba6:	68fb      	ldr	r3, [r7, #12]
 8024ba8:	681b      	ldr	r3, [r3, #0]
 8024baa:	681b      	ldr	r3, [r3, #0]
 8024bac:	68f8      	ldr	r0, [r7, #12]
 8024bae:	4798      	blx	r3

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 8024bb0:	223c      	movs	r2, #60	; 0x3c
 8024bb2:	68b9      	ldr	r1, [r7, #8]
 8024bb4:	68f8      	ldr	r0, [r7, #12]
 8024bb6:	f7ff fdb7 	bl	8024728 <alloc_small>
 8024bba:	6138      	str	r0, [r7, #16]
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
 8024bbc:	693b      	ldr	r3, [r7, #16]
 8024bbe:	2200      	movs	r2, #0
 8024bc0:	601a      	str	r2, [r3, #0]
  result->rows_in_array = numrows;
 8024bc2:	693b      	ldr	r3, [r7, #16]
 8024bc4:	6a3a      	ldr	r2, [r7, #32]
 8024bc6:	605a      	str	r2, [r3, #4]
  result->blocksperrow = blocksperrow;
 8024bc8:	693b      	ldr	r3, [r7, #16]
 8024bca:	683a      	ldr	r2, [r7, #0]
 8024bcc:	609a      	str	r2, [r3, #8]
  result->maxaccess = maxaccess;
 8024bce:	693b      	ldr	r3, [r7, #16]
 8024bd0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024bd2:	60da      	str	r2, [r3, #12]
  result->pre_zero = pre_zero;
 8024bd4:	693b      	ldr	r3, [r7, #16]
 8024bd6:	687a      	ldr	r2, [r7, #4]
 8024bd8:	621a      	str	r2, [r3, #32]
  result->b_s_open = FALSE;	/* no associated backing-store object */
 8024bda:	693b      	ldr	r3, [r7, #16]
 8024bdc:	2200      	movs	r2, #0
 8024bde:	629a      	str	r2, [r3, #40]	; 0x28
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
 8024be0:	697b      	ldr	r3, [r7, #20]
 8024be2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8024be4:	693b      	ldr	r3, [r7, #16]
 8024be6:	62da      	str	r2, [r3, #44]	; 0x2c
  mem->virt_barray_list = result;
 8024be8:	697b      	ldr	r3, [r7, #20]
 8024bea:	693a      	ldr	r2, [r7, #16]
 8024bec:	649a      	str	r2, [r3, #72]	; 0x48

  return result;
 8024bee:	693b      	ldr	r3, [r7, #16]
}
 8024bf0:	4618      	mov	r0, r3
 8024bf2:	3718      	adds	r7, #24
 8024bf4:	46bd      	mov	sp, r7
 8024bf6:	bd80      	pop	{r7, pc}

08024bf8 <realize_virt_arrays>:


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
 8024bf8:	b580      	push	{r7, lr}
 8024bfa:	b08a      	sub	sp, #40	; 0x28
 8024bfc:	af00      	add	r7, sp, #0
 8024bfe:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 8024c00:	687b      	ldr	r3, [r7, #4]
 8024c02:	685b      	ldr	r3, [r3, #4]
 8024c04:	613b      	str	r3, [r7, #16]

  /* Compute the minimum space needed (maxaccess rows in each buffer)
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
 8024c06:	2300      	movs	r3, #0
 8024c08:	627b      	str	r3, [r7, #36]	; 0x24
  maximum_space = 0;
 8024c0a:	2300      	movs	r3, #0
 8024c0c:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8024c0e:	693b      	ldr	r3, [r7, #16]
 8024c10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8024c12:	61bb      	str	r3, [r7, #24]
 8024c14:	e01c      	b.n	8024c50 <realize_virt_arrays+0x58>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 8024c16:	69bb      	ldr	r3, [r7, #24]
 8024c18:	681b      	ldr	r3, [r3, #0]
 8024c1a:	2b00      	cmp	r3, #0
 8024c1c:	d115      	bne.n	8024c4a <realize_virt_arrays+0x52>
      space_per_minheight += (long) sptr->maxaccess *
 8024c1e:	69bb      	ldr	r3, [r7, #24]
 8024c20:	68db      	ldr	r3, [r3, #12]
 8024c22:	461a      	mov	r2, r3
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8024c24:	69bb      	ldr	r3, [r7, #24]
 8024c26:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) sptr->maxaccess *
 8024c28:	fb03 f302 	mul.w	r3, r3, r2
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8024c2c:	461a      	mov	r2, r3
      space_per_minheight += (long) sptr->maxaccess *
 8024c2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024c30:	4413      	add	r3, r2
 8024c32:	627b      	str	r3, [r7, #36]	; 0x24
      maximum_space += (long) sptr->rows_in_array *
 8024c34:	69bb      	ldr	r3, [r7, #24]
 8024c36:	685b      	ldr	r3, [r3, #4]
 8024c38:	461a      	mov	r2, r3
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8024c3a:	69bb      	ldr	r3, [r7, #24]
 8024c3c:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) sptr->rows_in_array *
 8024c3e:	fb03 f302 	mul.w	r3, r3, r2
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
 8024c42:	461a      	mov	r2, r3
      maximum_space += (long) sptr->rows_in_array *
 8024c44:	6a3b      	ldr	r3, [r7, #32]
 8024c46:	4413      	add	r3, r2
 8024c48:	623b      	str	r3, [r7, #32]
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8024c4a:	69bb      	ldr	r3, [r7, #24]
 8024c4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024c4e:	61bb      	str	r3, [r7, #24]
 8024c50:	69bb      	ldr	r3, [r7, #24]
 8024c52:	2b00      	cmp	r3, #0
 8024c54:	d1df      	bne.n	8024c16 <realize_virt_arrays+0x1e>
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8024c56:	693b      	ldr	r3, [r7, #16]
 8024c58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8024c5a:	617b      	str	r3, [r7, #20]
 8024c5c:	e01c      	b.n	8024c98 <realize_virt_arrays+0xa0>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 8024c5e:	697b      	ldr	r3, [r7, #20]
 8024c60:	681b      	ldr	r3, [r3, #0]
 8024c62:	2b00      	cmp	r3, #0
 8024c64:	d115      	bne.n	8024c92 <realize_virt_arrays+0x9a>
      space_per_minheight += (long) bptr->maxaccess *
 8024c66:	697b      	ldr	r3, [r7, #20]
 8024c68:	68db      	ldr	r3, [r3, #12]
 8024c6a:	461a      	mov	r2, r3
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8024c6c:	697b      	ldr	r3, [r7, #20]
 8024c6e:	689b      	ldr	r3, [r3, #8]
      space_per_minheight += (long) bptr->maxaccess *
 8024c70:	fb03 f302 	mul.w	r3, r3, r2
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8024c74:	01da      	lsls	r2, r3, #7
      space_per_minheight += (long) bptr->maxaccess *
 8024c76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024c78:	4413      	add	r3, r2
 8024c7a:	627b      	str	r3, [r7, #36]	; 0x24
      maximum_space += (long) bptr->rows_in_array *
 8024c7c:	697b      	ldr	r3, [r7, #20]
 8024c7e:	685b      	ldr	r3, [r3, #4]
 8024c80:	461a      	mov	r2, r3
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8024c82:	697b      	ldr	r3, [r7, #20]
 8024c84:	689b      	ldr	r3, [r3, #8]
      maximum_space += (long) bptr->rows_in_array *
 8024c86:	fb03 f302 	mul.w	r3, r3, r2
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
 8024c8a:	01da      	lsls	r2, r3, #7
      maximum_space += (long) bptr->rows_in_array *
 8024c8c:	6a3b      	ldr	r3, [r7, #32]
 8024c8e:	4413      	add	r3, r2
 8024c90:	623b      	str	r3, [r7, #32]
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8024c92:	697b      	ldr	r3, [r7, #20]
 8024c94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024c96:	617b      	str	r3, [r7, #20]
 8024c98:	697b      	ldr	r3, [r7, #20]
 8024c9a:	2b00      	cmp	r3, #0
 8024c9c:	d1df      	bne.n	8024c5e <realize_virt_arrays+0x66>
    }
  }

  if (space_per_minheight <= 0)
 8024c9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024ca0:	2b00      	cmp	r3, #0
 8024ca2:	f340 80bd 	ble.w	8024e20 <realize_virt_arrays+0x228>
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
 8024ca6:	693b      	ldr	r3, [r7, #16]
 8024ca8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8024caa:	6a3a      	ldr	r2, [r7, #32]
 8024cac:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024cae:	6878      	ldr	r0, [r7, #4]
 8024cb0:	f000 fcdc 	bl	802566c <jpeg_mem_available>
 8024cb4:	60f8      	str	r0, [r7, #12]

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
 8024cb6:	68fa      	ldr	r2, [r7, #12]
 8024cb8:	6a3b      	ldr	r3, [r7, #32]
 8024cba:	429a      	cmp	r2, r3
 8024cbc:	db02      	blt.n	8024cc4 <realize_virt_arrays+0xcc>
    max_minheights = 1000000000L;
 8024cbe:	4b5a      	ldr	r3, [pc, #360]	; (8024e28 <realize_virt_arrays+0x230>)
 8024cc0:	61fb      	str	r3, [r7, #28]
 8024cc2:	e009      	b.n	8024cd8 <realize_virt_arrays+0xe0>
  else {
    max_minheights = avail_mem / space_per_minheight;
 8024cc4:	68fa      	ldr	r2, [r7, #12]
 8024cc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024cc8:	fb92 f3f3 	sdiv	r3, r2, r3
 8024ccc:	61fb      	str	r3, [r7, #28]
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
 8024cce:	69fb      	ldr	r3, [r7, #28]
 8024cd0:	2b00      	cmp	r3, #0
 8024cd2:	dc01      	bgt.n	8024cd8 <realize_virt_arrays+0xe0>
      max_minheights = 1;
 8024cd4:	2301      	movs	r3, #1
 8024cd6:	61fb      	str	r3, [r7, #28]
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8024cd8:	693b      	ldr	r3, [r7, #16]
 8024cda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8024cdc:	61bb      	str	r3, [r7, #24]
 8024cde:	e049      	b.n	8024d74 <realize_virt_arrays+0x17c>
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
 8024ce0:	69bb      	ldr	r3, [r7, #24]
 8024ce2:	681b      	ldr	r3, [r3, #0]
 8024ce4:	2b00      	cmp	r3, #0
 8024ce6:	d142      	bne.n	8024d6e <realize_virt_arrays+0x176>
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
 8024ce8:	69bb      	ldr	r3, [r7, #24]
 8024cea:	685b      	ldr	r3, [r3, #4]
 8024cec:	3b01      	subs	r3, #1
 8024cee:	461a      	mov	r2, r3
 8024cf0:	69bb      	ldr	r3, [r7, #24]
 8024cf2:	68db      	ldr	r3, [r3, #12]
 8024cf4:	fbb2 f3f3 	udiv	r3, r2, r3
 8024cf8:	3301      	adds	r3, #1
 8024cfa:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 8024cfc:	68ba      	ldr	r2, [r7, #8]
 8024cfe:	69fb      	ldr	r3, [r7, #28]
 8024d00:	429a      	cmp	r2, r3
 8024d02:	dc04      	bgt.n	8024d0e <realize_virt_arrays+0x116>
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
 8024d04:	69bb      	ldr	r3, [r7, #24]
 8024d06:	685a      	ldr	r2, [r3, #4]
 8024d08:	69bb      	ldr	r3, [r7, #24]
 8024d0a:	611a      	str	r2, [r3, #16]
 8024d0c:	e017      	b.n	8024d3e <realize_virt_arrays+0x146>
      } else {
	/* It doesn't fit in memory, create backing store. */
	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
 8024d0e:	69bb      	ldr	r3, [r7, #24]
 8024d10:	68db      	ldr	r3, [r3, #12]
 8024d12:	69fa      	ldr	r2, [r7, #28]
 8024d14:	fb02 f203 	mul.w	r2, r2, r3
 8024d18:	69bb      	ldr	r3, [r7, #24]
 8024d1a:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 8024d1c:	69bb      	ldr	r3, [r7, #24]
 8024d1e:	f103 0130 	add.w	r1, r3, #48	; 0x30
				(long) sptr->rows_in_array *
 8024d22:	69bb      	ldr	r3, [r7, #24]
 8024d24:	685b      	ldr	r3, [r3, #4]
 8024d26:	461a      	mov	r2, r3
				(long) sptr->samplesperrow *
 8024d28:	69bb      	ldr	r3, [r7, #24]
 8024d2a:	689b      	ldr	r3, [r3, #8]
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 8024d2c:	fb03 f302 	mul.w	r3, r3, r2
 8024d30:	461a      	mov	r2, r3
 8024d32:	6878      	ldr	r0, [r7, #4]
 8024d34:	f000 fca8 	bl	8025688 <jpeg_open_backing_store>
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
 8024d38:	69bb      	ldr	r3, [r7, #24]
 8024d3a:	2201      	movs	r2, #1
 8024d3c:	629a      	str	r2, [r3, #40]	; 0x28
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 8024d3e:	69bb      	ldr	r3, [r7, #24]
 8024d40:	689a      	ldr	r2, [r3, #8]
 8024d42:	69bb      	ldr	r3, [r7, #24]
 8024d44:	691b      	ldr	r3, [r3, #16]
 8024d46:	2101      	movs	r1, #1
 8024d48:	6878      	ldr	r0, [r7, #4]
 8024d4a:	f7ff fe10 	bl	802496e <alloc_sarray>
 8024d4e:	4602      	mov	r2, r0
 8024d50:	69bb      	ldr	r3, [r7, #24]
 8024d52:	601a      	str	r2, [r3, #0]
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
 8024d54:	693b      	ldr	r3, [r7, #16]
 8024d56:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8024d58:	69bb      	ldr	r3, [r7, #24]
 8024d5a:	615a      	str	r2, [r3, #20]
      sptr->cur_start_row = 0;
 8024d5c:	69bb      	ldr	r3, [r7, #24]
 8024d5e:	2200      	movs	r2, #0
 8024d60:	619a      	str	r2, [r3, #24]
      sptr->first_undef_row = 0;
 8024d62:	69bb      	ldr	r3, [r7, #24]
 8024d64:	2200      	movs	r2, #0
 8024d66:	61da      	str	r2, [r3, #28]
      sptr->dirty = FALSE;
 8024d68:	69bb      	ldr	r3, [r7, #24]
 8024d6a:	2200      	movs	r2, #0
 8024d6c:	625a      	str	r2, [r3, #36]	; 0x24
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8024d6e:	69bb      	ldr	r3, [r7, #24]
 8024d70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024d72:	61bb      	str	r3, [r7, #24]
 8024d74:	69bb      	ldr	r3, [r7, #24]
 8024d76:	2b00      	cmp	r3, #0
 8024d78:	d1b2      	bne.n	8024ce0 <realize_virt_arrays+0xe8>
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8024d7a:	693b      	ldr	r3, [r7, #16]
 8024d7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8024d7e:	617b      	str	r3, [r7, #20]
 8024d80:	e04a      	b.n	8024e18 <realize_virt_arrays+0x220>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
 8024d82:	697b      	ldr	r3, [r7, #20]
 8024d84:	681b      	ldr	r3, [r3, #0]
 8024d86:	2b00      	cmp	r3, #0
 8024d88:	d143      	bne.n	8024e12 <realize_virt_arrays+0x21a>
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
 8024d8a:	697b      	ldr	r3, [r7, #20]
 8024d8c:	685b      	ldr	r3, [r3, #4]
 8024d8e:	3b01      	subs	r3, #1
 8024d90:	461a      	mov	r2, r3
 8024d92:	697b      	ldr	r3, [r7, #20]
 8024d94:	68db      	ldr	r3, [r3, #12]
 8024d96:	fbb2 f3f3 	udiv	r3, r2, r3
 8024d9a:	3301      	adds	r3, #1
 8024d9c:	60bb      	str	r3, [r7, #8]
      if (minheights <= max_minheights) {
 8024d9e:	68ba      	ldr	r2, [r7, #8]
 8024da0:	69fb      	ldr	r3, [r7, #28]
 8024da2:	429a      	cmp	r2, r3
 8024da4:	dc04      	bgt.n	8024db0 <realize_virt_arrays+0x1b8>
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
 8024da6:	697b      	ldr	r3, [r7, #20]
 8024da8:	685a      	ldr	r2, [r3, #4]
 8024daa:	697b      	ldr	r3, [r7, #20]
 8024dac:	611a      	str	r2, [r3, #16]
 8024dae:	e018      	b.n	8024de2 <realize_virt_arrays+0x1ea>
      } else {
	/* It doesn't fit in memory, create backing store. */
	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
 8024db0:	697b      	ldr	r3, [r7, #20]
 8024db2:	68db      	ldr	r3, [r3, #12]
 8024db4:	69fa      	ldr	r2, [r7, #28]
 8024db6:	fb02 f203 	mul.w	r2, r2, r3
 8024dba:	697b      	ldr	r3, [r7, #20]
 8024dbc:	611a      	str	r2, [r3, #16]
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 8024dbe:	697b      	ldr	r3, [r7, #20]
 8024dc0:	f103 0130 	add.w	r1, r3, #48	; 0x30
				(long) bptr->rows_in_array *
 8024dc4:	697b      	ldr	r3, [r7, #20]
 8024dc6:	685b      	ldr	r3, [r3, #4]
 8024dc8:	461a      	mov	r2, r3
				(long) bptr->blocksperrow *
 8024dca:	697b      	ldr	r3, [r7, #20]
 8024dcc:	689b      	ldr	r3, [r3, #8]
				(long) bptr->rows_in_array *
 8024dce:	fb03 f302 	mul.w	r3, r3, r2
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
 8024dd2:	01db      	lsls	r3, r3, #7
 8024dd4:	461a      	mov	r2, r3
 8024dd6:	6878      	ldr	r0, [r7, #4]
 8024dd8:	f000 fc56 	bl	8025688 <jpeg_open_backing_store>
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
 8024ddc:	697b      	ldr	r3, [r7, #20]
 8024dde:	2201      	movs	r2, #1
 8024de0:	629a      	str	r2, [r3, #40]	; 0x28
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 8024de2:	697b      	ldr	r3, [r7, #20]
 8024de4:	689a      	ldr	r2, [r3, #8]
 8024de6:	697b      	ldr	r3, [r7, #20]
 8024de8:	691b      	ldr	r3, [r3, #16]
 8024dea:	2101      	movs	r1, #1
 8024dec:	6878      	ldr	r0, [r7, #4]
 8024dee:	f7ff fe21 	bl	8024a34 <alloc_barray>
 8024df2:	4602      	mov	r2, r0
 8024df4:	697b      	ldr	r3, [r7, #20]
 8024df6:	601a      	str	r2, [r3, #0]
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
 8024df8:	693b      	ldr	r3, [r7, #16]
 8024dfa:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8024dfc:	697b      	ldr	r3, [r7, #20]
 8024dfe:	615a      	str	r2, [r3, #20]
      bptr->cur_start_row = 0;
 8024e00:	697b      	ldr	r3, [r7, #20]
 8024e02:	2200      	movs	r2, #0
 8024e04:	619a      	str	r2, [r3, #24]
      bptr->first_undef_row = 0;
 8024e06:	697b      	ldr	r3, [r7, #20]
 8024e08:	2200      	movs	r2, #0
 8024e0a:	61da      	str	r2, [r3, #28]
      bptr->dirty = FALSE;
 8024e0c:	697b      	ldr	r3, [r7, #20]
 8024e0e:	2200      	movs	r2, #0
 8024e10:	625a      	str	r2, [r3, #36]	; 0x24
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 8024e12:	697b      	ldr	r3, [r7, #20]
 8024e14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024e16:	617b      	str	r3, [r7, #20]
 8024e18:	697b      	ldr	r3, [r7, #20]
 8024e1a:	2b00      	cmp	r3, #0
 8024e1c:	d1b1      	bne.n	8024d82 <realize_virt_arrays+0x18a>
 8024e1e:	e000      	b.n	8024e22 <realize_virt_arrays+0x22a>
    return;			/* no unrealized arrays, no work */
 8024e20:	bf00      	nop
    }
  }
}
 8024e22:	3728      	adds	r7, #40	; 0x28
 8024e24:	46bd      	mov	sp, r7
 8024e26:	bd80      	pop	{r7, pc}
 8024e28:	3b9aca00 	.word	0x3b9aca00

08024e2c <do_sarray_io>:


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
 8024e2c:	b590      	push	{r4, r7, lr}
 8024e2e:	b08d      	sub	sp, #52	; 0x34
 8024e30:	af02      	add	r7, sp, #8
 8024e32:	60f8      	str	r0, [r7, #12]
 8024e34:	60b9      	str	r1, [r7, #8]
 8024e36:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
 8024e38:	68bb      	ldr	r3, [r7, #8]
 8024e3a:	689b      	ldr	r3, [r3, #8]
 8024e3c:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 8024e3e:	68bb      	ldr	r3, [r7, #8]
 8024e40:	699b      	ldr	r3, [r3, #24]
 8024e42:	69fa      	ldr	r2, [r7, #28]
 8024e44:	fb02 f303 	mul.w	r3, r2, r3
 8024e48:	627b      	str	r3, [r7, #36]	; 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8024e4a:	2300      	movs	r3, #0
 8024e4c:	623b      	str	r3, [r7, #32]
 8024e4e:	e059      	b.n	8024f04 <do_sarray_io+0xd8>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 8024e50:	68bb      	ldr	r3, [r7, #8]
 8024e52:	691b      	ldr	r3, [r3, #16]
 8024e54:	461a      	mov	r2, r3
 8024e56:	6a3b      	ldr	r3, [r7, #32]
 8024e58:	1ad3      	subs	r3, r2, r3
 8024e5a:	68ba      	ldr	r2, [r7, #8]
 8024e5c:	6952      	ldr	r2, [r2, #20]
 8024e5e:	4293      	cmp	r3, r2
 8024e60:	bfa8      	it	ge
 8024e62:	4613      	movge	r3, r2
 8024e64:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 8024e66:	68bb      	ldr	r3, [r7, #8]
 8024e68:	699b      	ldr	r3, [r3, #24]
 8024e6a:	461a      	mov	r2, r3
 8024e6c:	6a3b      	ldr	r3, [r7, #32]
 8024e6e:	4413      	add	r3, r2
 8024e70:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 8024e72:	68bb      	ldr	r3, [r7, #8]
 8024e74:	69db      	ldr	r3, [r3, #28]
 8024e76:	461a      	mov	r2, r3
 8024e78:	697b      	ldr	r3, [r7, #20]
 8024e7a:	1ad3      	subs	r3, r2, r3
 8024e7c:	69ba      	ldr	r2, [r7, #24]
 8024e7e:	4293      	cmp	r3, r2
 8024e80:	bfa8      	it	ge
 8024e82:	4613      	movge	r3, r2
 8024e84:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 8024e86:	68bb      	ldr	r3, [r7, #8]
 8024e88:	685b      	ldr	r3, [r3, #4]
 8024e8a:	461a      	mov	r2, r3
 8024e8c:	697b      	ldr	r3, [r7, #20]
 8024e8e:	1ad3      	subs	r3, r2, r3
 8024e90:	69ba      	ldr	r2, [r7, #24]
 8024e92:	4293      	cmp	r3, r2
 8024e94:	bfa8      	it	ge
 8024e96:	4613      	movge	r3, r2
 8024e98:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 8024e9a:	69bb      	ldr	r3, [r7, #24]
 8024e9c:	2b00      	cmp	r3, #0
 8024e9e:	dd38      	ble.n	8024f12 <do_sarray_io+0xe6>
      break;
    byte_count = rows * bytesperrow;
 8024ea0:	69bb      	ldr	r3, [r7, #24]
 8024ea2:	69fa      	ldr	r2, [r7, #28]
 8024ea4:	fb02 f303 	mul.w	r3, r2, r3
 8024ea8:	613b      	str	r3, [r7, #16]
    if (writing)
 8024eaa:	687b      	ldr	r3, [r7, #4]
 8024eac:	2b00      	cmp	r3, #0
 8024eae:	d010      	beq.n	8024ed2 <do_sarray_io+0xa6>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8024eb0:	68bb      	ldr	r3, [r7, #8]
 8024eb2:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8024eb4:	68bb      	ldr	r3, [r7, #8]
 8024eb6:	f103 0130 	add.w	r1, r3, #48	; 0x30
					    (void FAR *) ptr->mem_buffer[i],
 8024eba:	68bb      	ldr	r3, [r7, #8]
 8024ebc:	681a      	ldr	r2, [r3, #0]
 8024ebe:	6a3b      	ldr	r3, [r7, #32]
 8024ec0:	009b      	lsls	r3, r3, #2
 8024ec2:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8024ec4:	681a      	ldr	r2, [r3, #0]
 8024ec6:	693b      	ldr	r3, [r7, #16]
 8024ec8:	9300      	str	r3, [sp, #0]
 8024eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024ecc:	68f8      	ldr	r0, [r7, #12]
 8024ece:	47a0      	blx	r4
 8024ed0:	e00f      	b.n	8024ef2 <do_sarray_io+0xc6>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8024ed2:	68bb      	ldr	r3, [r7, #8]
 8024ed4:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8024ed6:	68bb      	ldr	r3, [r7, #8]
 8024ed8:	f103 0130 	add.w	r1, r3, #48	; 0x30
					   (void FAR *) ptr->mem_buffer[i],
 8024edc:	68bb      	ldr	r3, [r7, #8]
 8024ede:	681a      	ldr	r2, [r3, #0]
 8024ee0:	6a3b      	ldr	r3, [r7, #32]
 8024ee2:	009b      	lsls	r3, r3, #2
 8024ee4:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8024ee6:	681a      	ldr	r2, [r3, #0]
 8024ee8:	693b      	ldr	r3, [r7, #16]
 8024eea:	9300      	str	r3, [sp, #0]
 8024eec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024eee:	68f8      	ldr	r0, [r7, #12]
 8024ef0:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 8024ef2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024ef4:	693b      	ldr	r3, [r7, #16]
 8024ef6:	4413      	add	r3, r2
 8024ef8:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8024efa:	68bb      	ldr	r3, [r7, #8]
 8024efc:	695a      	ldr	r2, [r3, #20]
 8024efe:	6a3b      	ldr	r3, [r7, #32]
 8024f00:	4413      	add	r3, r2
 8024f02:	623b      	str	r3, [r7, #32]
 8024f04:	68bb      	ldr	r3, [r7, #8]
 8024f06:	691b      	ldr	r3, [r3, #16]
 8024f08:	461a      	mov	r2, r3
 8024f0a:	6a3b      	ldr	r3, [r7, #32]
 8024f0c:	4293      	cmp	r3, r2
 8024f0e:	db9f      	blt.n	8024e50 <do_sarray_io+0x24>
  }
}
 8024f10:	e000      	b.n	8024f14 <do_sarray_io+0xe8>
      break;
 8024f12:	bf00      	nop
}
 8024f14:	bf00      	nop
 8024f16:	372c      	adds	r7, #44	; 0x2c
 8024f18:	46bd      	mov	sp, r7
 8024f1a:	bd90      	pop	{r4, r7, pc}

08024f1c <do_barray_io>:


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
 8024f1c:	b590      	push	{r4, r7, lr}
 8024f1e:	b08d      	sub	sp, #52	; 0x34
 8024f20:	af02      	add	r7, sp, #8
 8024f22:	60f8      	str	r0, [r7, #12]
 8024f24:	60b9      	str	r1, [r7, #8]
 8024f26:	607a      	str	r2, [r7, #4]
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
 8024f28:	68bb      	ldr	r3, [r7, #8]
 8024f2a:	689b      	ldr	r3, [r3, #8]
 8024f2c:	01db      	lsls	r3, r3, #7
 8024f2e:	61fb      	str	r3, [r7, #28]
  file_offset = ptr->cur_start_row * bytesperrow;
 8024f30:	68bb      	ldr	r3, [r7, #8]
 8024f32:	699b      	ldr	r3, [r3, #24]
 8024f34:	69fa      	ldr	r2, [r7, #28]
 8024f36:	fb02 f303 	mul.w	r3, r2, r3
 8024f3a:	627b      	str	r3, [r7, #36]	; 0x24
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8024f3c:	2300      	movs	r3, #0
 8024f3e:	623b      	str	r3, [r7, #32]
 8024f40:	e059      	b.n	8024ff6 <do_barray_io+0xda>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
 8024f42:	68bb      	ldr	r3, [r7, #8]
 8024f44:	691b      	ldr	r3, [r3, #16]
 8024f46:	461a      	mov	r2, r3
 8024f48:	6a3b      	ldr	r3, [r7, #32]
 8024f4a:	1ad3      	subs	r3, r2, r3
 8024f4c:	68ba      	ldr	r2, [r7, #8]
 8024f4e:	6952      	ldr	r2, [r2, #20]
 8024f50:	4293      	cmp	r3, r2
 8024f52:	bfa8      	it	ge
 8024f54:	4613      	movge	r3, r2
 8024f56:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
 8024f58:	68bb      	ldr	r3, [r7, #8]
 8024f5a:	699b      	ldr	r3, [r3, #24]
 8024f5c:	461a      	mov	r2, r3
 8024f5e:	6a3b      	ldr	r3, [r7, #32]
 8024f60:	4413      	add	r3, r2
 8024f62:	617b      	str	r3, [r7, #20]
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
 8024f64:	68bb      	ldr	r3, [r7, #8]
 8024f66:	69db      	ldr	r3, [r3, #28]
 8024f68:	461a      	mov	r2, r3
 8024f6a:	697b      	ldr	r3, [r7, #20]
 8024f6c:	1ad3      	subs	r3, r2, r3
 8024f6e:	69ba      	ldr	r2, [r7, #24]
 8024f70:	4293      	cmp	r3, r2
 8024f72:	bfa8      	it	ge
 8024f74:	4613      	movge	r3, r2
 8024f76:	61bb      	str	r3, [r7, #24]
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
 8024f78:	68bb      	ldr	r3, [r7, #8]
 8024f7a:	685b      	ldr	r3, [r3, #4]
 8024f7c:	461a      	mov	r2, r3
 8024f7e:	697b      	ldr	r3, [r7, #20]
 8024f80:	1ad3      	subs	r3, r2, r3
 8024f82:	69ba      	ldr	r2, [r7, #24]
 8024f84:	4293      	cmp	r3, r2
 8024f86:	bfa8      	it	ge
 8024f88:	4613      	movge	r3, r2
 8024f8a:	61bb      	str	r3, [r7, #24]
    if (rows <= 0)		/* this chunk might be past end of file! */
 8024f8c:	69bb      	ldr	r3, [r7, #24]
 8024f8e:	2b00      	cmp	r3, #0
 8024f90:	dd38      	ble.n	8025004 <do_barray_io+0xe8>
      break;
    byte_count = rows * bytesperrow;
 8024f92:	69bb      	ldr	r3, [r7, #24]
 8024f94:	69fa      	ldr	r2, [r7, #28]
 8024f96:	fb02 f303 	mul.w	r3, r2, r3
 8024f9a:	613b      	str	r3, [r7, #16]
    if (writing)
 8024f9c:	687b      	ldr	r3, [r7, #4]
 8024f9e:	2b00      	cmp	r3, #0
 8024fa0:	d010      	beq.n	8024fc4 <do_barray_io+0xa8>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8024fa2:	68bb      	ldr	r3, [r7, #8]
 8024fa4:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8024fa6:	68bb      	ldr	r3, [r7, #8]
 8024fa8:	f103 0130 	add.w	r1, r3, #48	; 0x30
					    (void FAR *) ptr->mem_buffer[i],
 8024fac:	68bb      	ldr	r3, [r7, #8]
 8024fae:	681a      	ldr	r2, [r3, #0]
 8024fb0:	6a3b      	ldr	r3, [r7, #32]
 8024fb2:	009b      	lsls	r3, r3, #2
 8024fb4:	4413      	add	r3, r2
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
 8024fb6:	681a      	ldr	r2, [r3, #0]
 8024fb8:	693b      	ldr	r3, [r7, #16]
 8024fba:	9300      	str	r3, [sp, #0]
 8024fbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024fbe:	68f8      	ldr	r0, [r7, #12]
 8024fc0:	47a0      	blx	r4
 8024fc2:	e00f      	b.n	8024fe4 <do_barray_io+0xc8>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8024fc4:	68bb      	ldr	r3, [r7, #8]
 8024fc6:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8024fc8:	68bb      	ldr	r3, [r7, #8]
 8024fca:	f103 0130 	add.w	r1, r3, #48	; 0x30
					   (void FAR *) ptr->mem_buffer[i],
 8024fce:	68bb      	ldr	r3, [r7, #8]
 8024fd0:	681a      	ldr	r2, [r3, #0]
 8024fd2:	6a3b      	ldr	r3, [r7, #32]
 8024fd4:	009b      	lsls	r3, r3, #2
 8024fd6:	4413      	add	r3, r2
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
 8024fd8:	681a      	ldr	r2, [r3, #0]
 8024fda:	693b      	ldr	r3, [r7, #16]
 8024fdc:	9300      	str	r3, [sp, #0]
 8024fde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024fe0:	68f8      	ldr	r0, [r7, #12]
 8024fe2:	47a0      	blx	r4
					   file_offset, byte_count);
    file_offset += byte_count;
 8024fe4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8024fe6:	693b      	ldr	r3, [r7, #16]
 8024fe8:	4413      	add	r3, r2
 8024fea:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
 8024fec:	68bb      	ldr	r3, [r7, #8]
 8024fee:	695a      	ldr	r2, [r3, #20]
 8024ff0:	6a3b      	ldr	r3, [r7, #32]
 8024ff2:	4413      	add	r3, r2
 8024ff4:	623b      	str	r3, [r7, #32]
 8024ff6:	68bb      	ldr	r3, [r7, #8]
 8024ff8:	691b      	ldr	r3, [r3, #16]
 8024ffa:	461a      	mov	r2, r3
 8024ffc:	6a3b      	ldr	r3, [r7, #32]
 8024ffe:	4293      	cmp	r3, r2
 8025000:	db9f      	blt.n	8024f42 <do_barray_io+0x26>
  }
}
 8025002:	e000      	b.n	8025006 <do_barray_io+0xea>
      break;
 8025004:	bf00      	nop
}
 8025006:	bf00      	nop
 8025008:	372c      	adds	r7, #44	; 0x2c
 802500a:	46bd      	mov	sp, r7
 802500c:	bd90      	pop	{r4, r7, pc}

0802500e <access_virt_sarray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802500e:	b580      	push	{r7, lr}
 8025010:	b088      	sub	sp, #32
 8025012:	af00      	add	r7, sp, #0
 8025014:	60f8      	str	r0, [r7, #12]
 8025016:	60b9      	str	r1, [r7, #8]
 8025018:	607a      	str	r2, [r7, #4]
 802501a:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 802501c:	687a      	ldr	r2, [r7, #4]
 802501e:	683b      	ldr	r3, [r7, #0]
 8025020:	4413      	add	r3, r2
 8025022:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 8025024:	68bb      	ldr	r3, [r7, #8]
 8025026:	685b      	ldr	r3, [r3, #4]
 8025028:	697a      	ldr	r2, [r7, #20]
 802502a:	429a      	cmp	r2, r3
 802502c:	d808      	bhi.n	8025040 <access_virt_sarray+0x32>
 802502e:	68bb      	ldr	r3, [r7, #8]
 8025030:	68db      	ldr	r3, [r3, #12]
 8025032:	683a      	ldr	r2, [r7, #0]
 8025034:	429a      	cmp	r2, r3
 8025036:	d803      	bhi.n	8025040 <access_virt_sarray+0x32>
      ptr->mem_buffer == NULL)
 8025038:	68bb      	ldr	r3, [r7, #8]
 802503a:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 802503c:	2b00      	cmp	r3, #0
 802503e:	d108      	bne.n	8025052 <access_virt_sarray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 8025040:	68fb      	ldr	r3, [r7, #12]
 8025042:	681b      	ldr	r3, [r3, #0]
 8025044:	2217      	movs	r2, #23
 8025046:	615a      	str	r2, [r3, #20]
 8025048:	68fb      	ldr	r3, [r7, #12]
 802504a:	681b      	ldr	r3, [r3, #0]
 802504c:	681b      	ldr	r3, [r3, #0]
 802504e:	68f8      	ldr	r0, [r7, #12]
 8025050:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 8025052:	68bb      	ldr	r3, [r7, #8]
 8025054:	699b      	ldr	r3, [r3, #24]
 8025056:	687a      	ldr	r2, [r7, #4]
 8025058:	429a      	cmp	r2, r3
 802505a:	d307      	bcc.n	802506c <access_virt_sarray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 802505c:	68bb      	ldr	r3, [r7, #8]
 802505e:	699a      	ldr	r2, [r3, #24]
 8025060:	68bb      	ldr	r3, [r7, #8]
 8025062:	691b      	ldr	r3, [r3, #16]
 8025064:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 8025066:	697a      	ldr	r2, [r7, #20]
 8025068:	429a      	cmp	r2, r3
 802506a:	d933      	bls.n	80250d4 <access_virt_sarray+0xc6>
    if (! ptr->b_s_open)
 802506c:	68bb      	ldr	r3, [r7, #8]
 802506e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025070:	2b00      	cmp	r3, #0
 8025072:	d108      	bne.n	8025086 <access_virt_sarray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 8025074:	68fb      	ldr	r3, [r7, #12]
 8025076:	681b      	ldr	r3, [r3, #0]
 8025078:	2247      	movs	r2, #71	; 0x47
 802507a:	615a      	str	r2, [r3, #20]
 802507c:	68fb      	ldr	r3, [r7, #12]
 802507e:	681b      	ldr	r3, [r3, #0]
 8025080:	681b      	ldr	r3, [r3, #0]
 8025082:	68f8      	ldr	r0, [r7, #12]
 8025084:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 8025086:	68bb      	ldr	r3, [r7, #8]
 8025088:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802508a:	2b00      	cmp	r3, #0
 802508c:	d007      	beq.n	802509e <access_virt_sarray+0x90>
      do_sarray_io(cinfo, ptr, TRUE);
 802508e:	2201      	movs	r2, #1
 8025090:	68b9      	ldr	r1, [r7, #8]
 8025092:	68f8      	ldr	r0, [r7, #12]
 8025094:	f7ff feca 	bl	8024e2c <do_sarray_io>
      ptr->dirty = FALSE;
 8025098:	68bb      	ldr	r3, [r7, #8]
 802509a:	2200      	movs	r2, #0
 802509c:	625a      	str	r2, [r3, #36]	; 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802509e:	68bb      	ldr	r3, [r7, #8]
 80250a0:	699b      	ldr	r3, [r3, #24]
 80250a2:	687a      	ldr	r2, [r7, #4]
 80250a4:	429a      	cmp	r2, r3
 80250a6:	d903      	bls.n	80250b0 <access_virt_sarray+0xa2>
      ptr->cur_start_row = start_row;
 80250a8:	68bb      	ldr	r3, [r7, #8]
 80250aa:	687a      	ldr	r2, [r7, #4]
 80250ac:	619a      	str	r2, [r3, #24]
 80250ae:	e00c      	b.n	80250ca <access_virt_sarray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 80250b0:	697b      	ldr	r3, [r7, #20]
 80250b2:	68ba      	ldr	r2, [r7, #8]
 80250b4:	6912      	ldr	r2, [r2, #16]
 80250b6:	1a9b      	subs	r3, r3, r2
 80250b8:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 80250ba:	69bb      	ldr	r3, [r7, #24]
 80250bc:	2b00      	cmp	r3, #0
 80250be:	da01      	bge.n	80250c4 <access_virt_sarray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 80250c0:	2300      	movs	r3, #0
 80250c2:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 80250c4:	69ba      	ldr	r2, [r7, #24]
 80250c6:	68bb      	ldr	r3, [r7, #8]
 80250c8:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_sarray_io(cinfo, ptr, FALSE);
 80250ca:	2200      	movs	r2, #0
 80250cc:	68b9      	ldr	r1, [r7, #8]
 80250ce:	68f8      	ldr	r0, [r7, #12]
 80250d0:	f7ff feac 	bl	8024e2c <do_sarray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 80250d4:	68bb      	ldr	r3, [r7, #8]
 80250d6:	69db      	ldr	r3, [r3, #28]
 80250d8:	697a      	ldr	r2, [r7, #20]
 80250da:	429a      	cmp	r2, r3
 80250dc:	d94d      	bls.n	802517a <access_virt_sarray+0x16c>
    if (ptr->first_undef_row < start_row) {
 80250de:	68bb      	ldr	r3, [r7, #8]
 80250e0:	69db      	ldr	r3, [r3, #28]
 80250e2:	687a      	ldr	r2, [r7, #4]
 80250e4:	429a      	cmp	r2, r3
 80250e6:	d90e      	bls.n	8025106 <access_virt_sarray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 80250e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80250ea:	2b00      	cmp	r3, #0
 80250ec:	d008      	beq.n	8025100 <access_virt_sarray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 80250ee:	68fb      	ldr	r3, [r7, #12]
 80250f0:	681b      	ldr	r3, [r3, #0]
 80250f2:	2217      	movs	r2, #23
 80250f4:	615a      	str	r2, [r3, #20]
 80250f6:	68fb      	ldr	r3, [r7, #12]
 80250f8:	681b      	ldr	r3, [r3, #0]
 80250fa:	681b      	ldr	r3, [r3, #0]
 80250fc:	68f8      	ldr	r0, [r7, #12]
 80250fe:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 8025100:	687b      	ldr	r3, [r7, #4]
 8025102:	61fb      	str	r3, [r7, #28]
 8025104:	e002      	b.n	802510c <access_virt_sarray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 8025106:	68bb      	ldr	r3, [r7, #8]
 8025108:	69db      	ldr	r3, [r3, #28]
 802510a:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802510c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802510e:	2b00      	cmp	r3, #0
 8025110:	d002      	beq.n	8025118 <access_virt_sarray+0x10a>
      ptr->first_undef_row = end_row;
 8025112:	68bb      	ldr	r3, [r7, #8]
 8025114:	697a      	ldr	r2, [r7, #20]
 8025116:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 8025118:	68bb      	ldr	r3, [r7, #8]
 802511a:	6a1b      	ldr	r3, [r3, #32]
 802511c:	2b00      	cmp	r3, #0
 802511e:	d020      	beq.n	8025162 <access_virt_sarray+0x154>
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
 8025120:	68bb      	ldr	r3, [r7, #8]
 8025122:	689b      	ldr	r3, [r3, #8]
 8025124:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 8025126:	68bb      	ldr	r3, [r7, #8]
 8025128:	699b      	ldr	r3, [r3, #24]
 802512a:	69fa      	ldr	r2, [r7, #28]
 802512c:	1ad3      	subs	r3, r2, r3
 802512e:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 8025130:	68bb      	ldr	r3, [r7, #8]
 8025132:	699b      	ldr	r3, [r3, #24]
 8025134:	697a      	ldr	r2, [r7, #20]
 8025136:	1ad3      	subs	r3, r2, r3
 8025138:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 802513a:	e00d      	b.n	8025158 <access_virt_sarray+0x14a>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 802513c:	68bb      	ldr	r3, [r7, #8]
 802513e:	681a      	ldr	r2, [r3, #0]
 8025140:	69fb      	ldr	r3, [r7, #28]
 8025142:	009b      	lsls	r3, r3, #2
 8025144:	4413      	add	r3, r2
 8025146:	681b      	ldr	r3, [r3, #0]
 8025148:	693a      	ldr	r2, [r7, #16]
 802514a:	2100      	movs	r1, #0
 802514c:	4618      	mov	r0, r3
 802514e:	f003 f897 	bl	8028280 <memset>
	undef_row++;
 8025152:	69fb      	ldr	r3, [r7, #28]
 8025154:	3301      	adds	r3, #1
 8025156:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 8025158:	69fa      	ldr	r2, [r7, #28]
 802515a:	697b      	ldr	r3, [r7, #20]
 802515c:	429a      	cmp	r2, r3
 802515e:	d3ed      	bcc.n	802513c <access_virt_sarray+0x12e>
 8025160:	e00b      	b.n	802517a <access_virt_sarray+0x16c>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 8025162:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025164:	2b00      	cmp	r3, #0
 8025166:	d108      	bne.n	802517a <access_virt_sarray+0x16c>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 8025168:	68fb      	ldr	r3, [r7, #12]
 802516a:	681b      	ldr	r3, [r3, #0]
 802516c:	2217      	movs	r2, #23
 802516e:	615a      	str	r2, [r3, #20]
 8025170:	68fb      	ldr	r3, [r7, #12]
 8025172:	681b      	ldr	r3, [r3, #0]
 8025174:	681b      	ldr	r3, [r3, #0]
 8025176:	68f8      	ldr	r0, [r7, #12]
 8025178:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802517a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802517c:	2b00      	cmp	r3, #0
 802517e:	d002      	beq.n	8025186 <access_virt_sarray+0x178>
    ptr->dirty = TRUE;
 8025180:	68bb      	ldr	r3, [r7, #8]
 8025182:	2201      	movs	r2, #1
 8025184:	625a      	str	r2, [r3, #36]	; 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 8025186:	68bb      	ldr	r3, [r7, #8]
 8025188:	681a      	ldr	r2, [r3, #0]
 802518a:	68bb      	ldr	r3, [r7, #8]
 802518c:	699b      	ldr	r3, [r3, #24]
 802518e:	6879      	ldr	r1, [r7, #4]
 8025190:	1acb      	subs	r3, r1, r3
 8025192:	009b      	lsls	r3, r3, #2
 8025194:	4413      	add	r3, r2
}
 8025196:	4618      	mov	r0, r3
 8025198:	3720      	adds	r7, #32
 802519a:	46bd      	mov	sp, r7
 802519c:	bd80      	pop	{r7, pc}

0802519e <access_virt_barray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
 802519e:	b580      	push	{r7, lr}
 80251a0:	b088      	sub	sp, #32
 80251a2:	af00      	add	r7, sp, #0
 80251a4:	60f8      	str	r0, [r7, #12]
 80251a6:	60b9      	str	r1, [r7, #8]
 80251a8:	607a      	str	r2, [r7, #4]
 80251aa:	603b      	str	r3, [r7, #0]
  JDIMENSION end_row = start_row + num_rows;
 80251ac:	687a      	ldr	r2, [r7, #4]
 80251ae:	683b      	ldr	r3, [r7, #0]
 80251b0:	4413      	add	r3, r2
 80251b2:	617b      	str	r3, [r7, #20]
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 80251b4:	68bb      	ldr	r3, [r7, #8]
 80251b6:	685b      	ldr	r3, [r3, #4]
 80251b8:	697a      	ldr	r2, [r7, #20]
 80251ba:	429a      	cmp	r2, r3
 80251bc:	d808      	bhi.n	80251d0 <access_virt_barray+0x32>
 80251be:	68bb      	ldr	r3, [r7, #8]
 80251c0:	68db      	ldr	r3, [r3, #12]
 80251c2:	683a      	ldr	r2, [r7, #0]
 80251c4:	429a      	cmp	r2, r3
 80251c6:	d803      	bhi.n	80251d0 <access_virt_barray+0x32>
      ptr->mem_buffer == NULL)
 80251c8:	68bb      	ldr	r3, [r7, #8]
 80251ca:	681b      	ldr	r3, [r3, #0]
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
 80251cc:	2b00      	cmp	r3, #0
 80251ce:	d108      	bne.n	80251e2 <access_virt_barray+0x44>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 80251d0:	68fb      	ldr	r3, [r7, #12]
 80251d2:	681b      	ldr	r3, [r3, #0]
 80251d4:	2217      	movs	r2, #23
 80251d6:	615a      	str	r2, [r3, #20]
 80251d8:	68fb      	ldr	r3, [r7, #12]
 80251da:	681b      	ldr	r3, [r3, #0]
 80251dc:	681b      	ldr	r3, [r3, #0]
 80251de:	68f8      	ldr	r0, [r7, #12]
 80251e0:	4798      	blx	r3

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
 80251e2:	68bb      	ldr	r3, [r7, #8]
 80251e4:	699b      	ldr	r3, [r3, #24]
 80251e6:	687a      	ldr	r2, [r7, #4]
 80251e8:	429a      	cmp	r2, r3
 80251ea:	d307      	bcc.n	80251fc <access_virt_barray+0x5e>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
 80251ec:	68bb      	ldr	r3, [r7, #8]
 80251ee:	699a      	ldr	r2, [r3, #24]
 80251f0:	68bb      	ldr	r3, [r7, #8]
 80251f2:	691b      	ldr	r3, [r3, #16]
 80251f4:	4413      	add	r3, r2
  if (start_row < ptr->cur_start_row ||
 80251f6:	697a      	ldr	r2, [r7, #20]
 80251f8:	429a      	cmp	r2, r3
 80251fa:	d933      	bls.n	8025264 <access_virt_barray+0xc6>
    if (! ptr->b_s_open)
 80251fc:	68bb      	ldr	r3, [r7, #8]
 80251fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025200:	2b00      	cmp	r3, #0
 8025202:	d108      	bne.n	8025216 <access_virt_barray+0x78>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 8025204:	68fb      	ldr	r3, [r7, #12]
 8025206:	681b      	ldr	r3, [r3, #0]
 8025208:	2247      	movs	r2, #71	; 0x47
 802520a:	615a      	str	r2, [r3, #20]
 802520c:	68fb      	ldr	r3, [r7, #12]
 802520e:	681b      	ldr	r3, [r3, #0]
 8025210:	681b      	ldr	r3, [r3, #0]
 8025212:	68f8      	ldr	r0, [r7, #12]
 8025214:	4798      	blx	r3
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
 8025216:	68bb      	ldr	r3, [r7, #8]
 8025218:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802521a:	2b00      	cmp	r3, #0
 802521c:	d007      	beq.n	802522e <access_virt_barray+0x90>
      do_barray_io(cinfo, ptr, TRUE);
 802521e:	2201      	movs	r2, #1
 8025220:	68b9      	ldr	r1, [r7, #8]
 8025222:	68f8      	ldr	r0, [r7, #12]
 8025224:	f7ff fe7a 	bl	8024f1c <do_barray_io>
      ptr->dirty = FALSE;
 8025228:	68bb      	ldr	r3, [r7, #8]
 802522a:	2200      	movs	r2, #0
 802522c:	625a      	str	r2, [r3, #36]	; 0x24
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
 802522e:	68bb      	ldr	r3, [r7, #8]
 8025230:	699b      	ldr	r3, [r3, #24]
 8025232:	687a      	ldr	r2, [r7, #4]
 8025234:	429a      	cmp	r2, r3
 8025236:	d903      	bls.n	8025240 <access_virt_barray+0xa2>
      ptr->cur_start_row = start_row;
 8025238:	68bb      	ldr	r3, [r7, #8]
 802523a:	687a      	ldr	r2, [r7, #4]
 802523c:	619a      	str	r2, [r3, #24]
 802523e:	e00c      	b.n	802525a <access_virt_barray+0xbc>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
 8025240:	697b      	ldr	r3, [r7, #20]
 8025242:	68ba      	ldr	r2, [r7, #8]
 8025244:	6912      	ldr	r2, [r2, #16]
 8025246:	1a9b      	subs	r3, r3, r2
 8025248:	61bb      	str	r3, [r7, #24]
      if (ltemp < 0)
 802524a:	69bb      	ldr	r3, [r7, #24]
 802524c:	2b00      	cmp	r3, #0
 802524e:	da01      	bge.n	8025254 <access_virt_barray+0xb6>
	ltemp = 0;		/* don't fall off front end of file */
 8025250:	2300      	movs	r3, #0
 8025252:	61bb      	str	r3, [r7, #24]
      ptr->cur_start_row = (JDIMENSION) ltemp;
 8025254:	69ba      	ldr	r2, [r7, #24]
 8025256:	68bb      	ldr	r3, [r7, #8]
 8025258:	619a      	str	r2, [r3, #24]
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_barray_io(cinfo, ptr, FALSE);
 802525a:	2200      	movs	r2, #0
 802525c:	68b9      	ldr	r1, [r7, #8]
 802525e:	68f8      	ldr	r0, [r7, #12]
 8025260:	f7ff fe5c 	bl	8024f1c <do_barray_io>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
 8025264:	68bb      	ldr	r3, [r7, #8]
 8025266:	69db      	ldr	r3, [r3, #28]
 8025268:	697a      	ldr	r2, [r7, #20]
 802526a:	429a      	cmp	r2, r3
 802526c:	d94e      	bls.n	802530c <access_virt_barray+0x16e>
    if (ptr->first_undef_row < start_row) {
 802526e:	68bb      	ldr	r3, [r7, #8]
 8025270:	69db      	ldr	r3, [r3, #28]
 8025272:	687a      	ldr	r2, [r7, #4]
 8025274:	429a      	cmp	r2, r3
 8025276:	d90e      	bls.n	8025296 <access_virt_barray+0xf8>
      if (writable)		/* writer skipped over a section of array */
 8025278:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802527a:	2b00      	cmp	r3, #0
 802527c:	d008      	beq.n	8025290 <access_virt_barray+0xf2>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 802527e:	68fb      	ldr	r3, [r7, #12]
 8025280:	681b      	ldr	r3, [r3, #0]
 8025282:	2217      	movs	r2, #23
 8025284:	615a      	str	r2, [r3, #20]
 8025286:	68fb      	ldr	r3, [r7, #12]
 8025288:	681b      	ldr	r3, [r3, #0]
 802528a:	681b      	ldr	r3, [r3, #0]
 802528c:	68f8      	ldr	r0, [r7, #12]
 802528e:	4798      	blx	r3
      undef_row = start_row;	/* but reader is allowed to read ahead */
 8025290:	687b      	ldr	r3, [r7, #4]
 8025292:	61fb      	str	r3, [r7, #28]
 8025294:	e002      	b.n	802529c <access_virt_barray+0xfe>
    } else {
      undef_row = ptr->first_undef_row;
 8025296:	68bb      	ldr	r3, [r7, #8]
 8025298:	69db      	ldr	r3, [r3, #28]
 802529a:	61fb      	str	r3, [r7, #28]
    }
    if (writable)
 802529c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802529e:	2b00      	cmp	r3, #0
 80252a0:	d002      	beq.n	80252a8 <access_virt_barray+0x10a>
      ptr->first_undef_row = end_row;
 80252a2:	68bb      	ldr	r3, [r7, #8]
 80252a4:	697a      	ldr	r2, [r7, #20]
 80252a6:	61da      	str	r2, [r3, #28]
    if (ptr->pre_zero) {
 80252a8:	68bb      	ldr	r3, [r7, #8]
 80252aa:	6a1b      	ldr	r3, [r3, #32]
 80252ac:	2b00      	cmp	r3, #0
 80252ae:	d021      	beq.n	80252f4 <access_virt_barray+0x156>
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
 80252b0:	68bb      	ldr	r3, [r7, #8]
 80252b2:	689b      	ldr	r3, [r3, #8]
 80252b4:	01db      	lsls	r3, r3, #7
 80252b6:	613b      	str	r3, [r7, #16]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
 80252b8:	68bb      	ldr	r3, [r7, #8]
 80252ba:	699b      	ldr	r3, [r3, #24]
 80252bc:	69fa      	ldr	r2, [r7, #28]
 80252be:	1ad3      	subs	r3, r2, r3
 80252c0:	61fb      	str	r3, [r7, #28]
      end_row -= ptr->cur_start_row;
 80252c2:	68bb      	ldr	r3, [r7, #8]
 80252c4:	699b      	ldr	r3, [r3, #24]
 80252c6:	697a      	ldr	r2, [r7, #20]
 80252c8:	1ad3      	subs	r3, r2, r3
 80252ca:	617b      	str	r3, [r7, #20]
      while (undef_row < end_row) {
 80252cc:	e00d      	b.n	80252ea <access_virt_barray+0x14c>
	FMEMZERO((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
 80252ce:	68bb      	ldr	r3, [r7, #8]
 80252d0:	681a      	ldr	r2, [r3, #0]
 80252d2:	69fb      	ldr	r3, [r7, #28]
 80252d4:	009b      	lsls	r3, r3, #2
 80252d6:	4413      	add	r3, r2
 80252d8:	681b      	ldr	r3, [r3, #0]
 80252da:	693a      	ldr	r2, [r7, #16]
 80252dc:	2100      	movs	r1, #0
 80252de:	4618      	mov	r0, r3
 80252e0:	f002 ffce 	bl	8028280 <memset>
	undef_row++;
 80252e4:	69fb      	ldr	r3, [r7, #28]
 80252e6:	3301      	adds	r3, #1
 80252e8:	61fb      	str	r3, [r7, #28]
      while (undef_row < end_row) {
 80252ea:	69fa      	ldr	r2, [r7, #28]
 80252ec:	697b      	ldr	r3, [r7, #20]
 80252ee:	429a      	cmp	r2, r3
 80252f0:	d3ed      	bcc.n	80252ce <access_virt_barray+0x130>
 80252f2:	e00b      	b.n	802530c <access_virt_barray+0x16e>
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
 80252f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80252f6:	2b00      	cmp	r3, #0
 80252f8:	d108      	bne.n	802530c <access_virt_barray+0x16e>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 80252fa:	68fb      	ldr	r3, [r7, #12]
 80252fc:	681b      	ldr	r3, [r3, #0]
 80252fe:	2217      	movs	r2, #23
 8025300:	615a      	str	r2, [r3, #20]
 8025302:	68fb      	ldr	r3, [r7, #12]
 8025304:	681b      	ldr	r3, [r3, #0]
 8025306:	681b      	ldr	r3, [r3, #0]
 8025308:	68f8      	ldr	r0, [r7, #12]
 802530a:	4798      	blx	r3
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
 802530c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802530e:	2b00      	cmp	r3, #0
 8025310:	d002      	beq.n	8025318 <access_virt_barray+0x17a>
    ptr->dirty = TRUE;
 8025312:	68bb      	ldr	r3, [r7, #8]
 8025314:	2201      	movs	r2, #1
 8025316:	625a      	str	r2, [r3, #36]	; 0x24
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
 8025318:	68bb      	ldr	r3, [r7, #8]
 802531a:	681a      	ldr	r2, [r3, #0]
 802531c:	68bb      	ldr	r3, [r7, #8]
 802531e:	699b      	ldr	r3, [r3, #24]
 8025320:	6879      	ldr	r1, [r7, #4]
 8025322:	1acb      	subs	r3, r1, r3
 8025324:	009b      	lsls	r3, r3, #2
 8025326:	4413      	add	r3, r2
}
 8025328:	4618      	mov	r0, r3
 802532a:	3720      	adds	r7, #32
 802532c:	46bd      	mov	sp, r7
 802532e:	bd80      	pop	{r7, pc}

08025330 <free_pool>:
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
 8025330:	b580      	push	{r7, lr}
 8025332:	b08a      	sub	sp, #40	; 0x28
 8025334:	af00      	add	r7, sp, #0
 8025336:	6078      	str	r0, [r7, #4]
 8025338:	6039      	str	r1, [r7, #0]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
 802533a:	687b      	ldr	r3, [r7, #4]
 802533c:	685b      	ldr	r3, [r3, #4]
 802533e:	617b      	str	r3, [r7, #20]
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
 8025340:	683b      	ldr	r3, [r7, #0]
 8025342:	2b00      	cmp	r3, #0
 8025344:	db02      	blt.n	802534c <free_pool+0x1c>
 8025346:	683b      	ldr	r3, [r7, #0]
 8025348:	2b01      	cmp	r3, #1
 802534a:	dd0c      	ble.n	8025366 <free_pool+0x36>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
 802534c:	687b      	ldr	r3, [r7, #4]
 802534e:	681b      	ldr	r3, [r3, #0]
 8025350:	220f      	movs	r2, #15
 8025352:	615a      	str	r2, [r3, #20]
 8025354:	687b      	ldr	r3, [r7, #4]
 8025356:	681b      	ldr	r3, [r3, #0]
 8025358:	683a      	ldr	r2, [r7, #0]
 802535a:	619a      	str	r2, [r3, #24]
 802535c:	687b      	ldr	r3, [r7, #4]
 802535e:	681b      	ldr	r3, [r3, #0]
 8025360:	681b      	ldr	r3, [r3, #0]
 8025362:	6878      	ldr	r0, [r7, #4]
 8025364:	4798      	blx	r3
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
 8025366:	683b      	ldr	r3, [r7, #0]
 8025368:	2b01      	cmp	r3, #1
 802536a:	d135      	bne.n	80253d8 <free_pool+0xa8>
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 802536c:	697b      	ldr	r3, [r7, #20]
 802536e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8025370:	61fb      	str	r3, [r7, #28]
 8025372:	e010      	b.n	8025396 <free_pool+0x66>
      if (sptr->b_s_open) {	/* there may be no backing store */
 8025374:	69fb      	ldr	r3, [r7, #28]
 8025376:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025378:	2b00      	cmp	r3, #0
 802537a:	d009      	beq.n	8025390 <free_pool+0x60>
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
 802537c:	69fb      	ldr	r3, [r7, #28]
 802537e:	2200      	movs	r2, #0
 8025380:	629a      	str	r2, [r3, #40]	; 0x28
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
 8025382:	69fb      	ldr	r3, [r7, #28]
 8025384:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8025386:	69fa      	ldr	r2, [r7, #28]
 8025388:	3230      	adds	r2, #48	; 0x30
 802538a:	4611      	mov	r1, r2
 802538c:	6878      	ldr	r0, [r7, #4]
 802538e:	4798      	blx	r3
    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
 8025390:	69fb      	ldr	r3, [r7, #28]
 8025392:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025394:	61fb      	str	r3, [r7, #28]
 8025396:	69fb      	ldr	r3, [r7, #28]
 8025398:	2b00      	cmp	r3, #0
 802539a:	d1eb      	bne.n	8025374 <free_pool+0x44>
      }
    }
    mem->virt_sarray_list = NULL;
 802539c:	697b      	ldr	r3, [r7, #20]
 802539e:	2200      	movs	r2, #0
 80253a0:	645a      	str	r2, [r3, #68]	; 0x44
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 80253a2:	697b      	ldr	r3, [r7, #20]
 80253a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80253a6:	61bb      	str	r3, [r7, #24]
 80253a8:	e010      	b.n	80253cc <free_pool+0x9c>
      if (bptr->b_s_open) {	/* there may be no backing store */
 80253aa:	69bb      	ldr	r3, [r7, #24]
 80253ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80253ae:	2b00      	cmp	r3, #0
 80253b0:	d009      	beq.n	80253c6 <free_pool+0x96>
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
 80253b2:	69bb      	ldr	r3, [r7, #24]
 80253b4:	2200      	movs	r2, #0
 80253b6:	629a      	str	r2, [r3, #40]	; 0x28
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
 80253b8:	69bb      	ldr	r3, [r7, #24]
 80253ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80253bc:	69ba      	ldr	r2, [r7, #24]
 80253be:	3230      	adds	r2, #48	; 0x30
 80253c0:	4611      	mov	r1, r2
 80253c2:	6878      	ldr	r0, [r7, #4]
 80253c4:	4798      	blx	r3
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
 80253c6:	69bb      	ldr	r3, [r7, #24]
 80253c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80253ca:	61bb      	str	r3, [r7, #24]
 80253cc:	69bb      	ldr	r3, [r7, #24]
 80253ce:	2b00      	cmp	r3, #0
 80253d0:	d1eb      	bne.n	80253aa <free_pool+0x7a>
      }
    }
    mem->virt_barray_list = NULL;
 80253d2:	697b      	ldr	r3, [r7, #20]
 80253d4:	2200      	movs	r2, #0
 80253d6:	649a      	str	r2, [r3, #72]	; 0x48
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
 80253d8:	697a      	ldr	r2, [r7, #20]
 80253da:	683b      	ldr	r3, [r7, #0]
 80253dc:	330e      	adds	r3, #14
 80253de:	009b      	lsls	r3, r3, #2
 80253e0:	4413      	add	r3, r2
 80253e2:	685b      	ldr	r3, [r3, #4]
 80253e4:	623b      	str	r3, [r7, #32]
  mem->large_list[pool_id] = NULL;
 80253e6:	697a      	ldr	r2, [r7, #20]
 80253e8:	683b      	ldr	r3, [r7, #0]
 80253ea:	330e      	adds	r3, #14
 80253ec:	009b      	lsls	r3, r3, #2
 80253ee:	4413      	add	r3, r2
 80253f0:	2200      	movs	r2, #0
 80253f2:	605a      	str	r2, [r3, #4]

  while (lhdr_ptr != NULL) {
 80253f4:	e018      	b.n	8025428 <free_pool+0xf8>
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
 80253f6:	6a3b      	ldr	r3, [r7, #32]
 80253f8:	681b      	ldr	r3, [r3, #0]
 80253fa:	60bb      	str	r3, [r7, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 80253fc:	6a3b      	ldr	r3, [r7, #32]
 80253fe:	685a      	ldr	r2, [r3, #4]
		  lhdr_ptr->hdr.bytes_left +
 8025400:	6a3b      	ldr	r3, [r7, #32]
 8025402:	689b      	ldr	r3, [r3, #8]
    space_freed = lhdr_ptr->hdr.bytes_used +
 8025404:	4413      	add	r3, r2
 8025406:	3310      	adds	r3, #16
 8025408:	60fb      	str	r3, [r7, #12]
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 802540a:	68fa      	ldr	r2, [r7, #12]
 802540c:	6a39      	ldr	r1, [r7, #32]
 802540e:	6878      	ldr	r0, [r7, #4]
 8025410:	f000 f91f 	bl	8025652 <jpeg_free_large>
    mem->total_space_allocated -= space_freed;
 8025414:	697b      	ldr	r3, [r7, #20]
 8025416:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8025418:	461a      	mov	r2, r3
 802541a:	68fb      	ldr	r3, [r7, #12]
 802541c:	1ad3      	subs	r3, r2, r3
 802541e:	461a      	mov	r2, r3
 8025420:	697b      	ldr	r3, [r7, #20]
 8025422:	64da      	str	r2, [r3, #76]	; 0x4c
    lhdr_ptr = next_lhdr_ptr;
 8025424:	68bb      	ldr	r3, [r7, #8]
 8025426:	623b      	str	r3, [r7, #32]
  while (lhdr_ptr != NULL) {
 8025428:	6a3b      	ldr	r3, [r7, #32]
 802542a:	2b00      	cmp	r3, #0
 802542c:	d1e3      	bne.n	80253f6 <free_pool+0xc6>
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
 802542e:	697a      	ldr	r2, [r7, #20]
 8025430:	683b      	ldr	r3, [r7, #0]
 8025432:	330c      	adds	r3, #12
 8025434:	009b      	lsls	r3, r3, #2
 8025436:	4413      	add	r3, r2
 8025438:	685b      	ldr	r3, [r3, #4]
 802543a:	627b      	str	r3, [r7, #36]	; 0x24
  mem->small_list[pool_id] = NULL;
 802543c:	697a      	ldr	r2, [r7, #20]
 802543e:	683b      	ldr	r3, [r7, #0]
 8025440:	330c      	adds	r3, #12
 8025442:	009b      	lsls	r3, r3, #2
 8025444:	4413      	add	r3, r2
 8025446:	2200      	movs	r2, #0
 8025448:	605a      	str	r2, [r3, #4]

  while (shdr_ptr != NULL) {
 802544a:	e018      	b.n	802547e <free_pool+0x14e>
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
 802544c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802544e:	681b      	ldr	r3, [r3, #0]
 8025450:	613b      	str	r3, [r7, #16]
    space_freed = shdr_ptr->hdr.bytes_used +
 8025452:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025454:	685a      	ldr	r2, [r3, #4]
		  shdr_ptr->hdr.bytes_left +
 8025456:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025458:	689b      	ldr	r3, [r3, #8]
    space_freed = shdr_ptr->hdr.bytes_used +
 802545a:	4413      	add	r3, r2
 802545c:	3310      	adds	r3, #16
 802545e:	60fb      	str	r3, [r7, #12]
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 8025460:	68fa      	ldr	r2, [r7, #12]
 8025462:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8025464:	6878      	ldr	r0, [r7, #4]
 8025466:	f000 f8da 	bl	802561e <jpeg_free_small>
    mem->total_space_allocated -= space_freed;
 802546a:	697b      	ldr	r3, [r7, #20]
 802546c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802546e:	461a      	mov	r2, r3
 8025470:	68fb      	ldr	r3, [r7, #12]
 8025472:	1ad3      	subs	r3, r2, r3
 8025474:	461a      	mov	r2, r3
 8025476:	697b      	ldr	r3, [r7, #20]
 8025478:	64da      	str	r2, [r3, #76]	; 0x4c
    shdr_ptr = next_shdr_ptr;
 802547a:	693b      	ldr	r3, [r7, #16]
 802547c:	627b      	str	r3, [r7, #36]	; 0x24
  while (shdr_ptr != NULL) {
 802547e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025480:	2b00      	cmp	r3, #0
 8025482:	d1e3      	bne.n	802544c <free_pool+0x11c>
  }
}
 8025484:	bf00      	nop
 8025486:	bf00      	nop
 8025488:	3728      	adds	r7, #40	; 0x28
 802548a:	46bd      	mov	sp, r7
 802548c:	bd80      	pop	{r7, pc}

0802548e <self_destruct>:
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
 802548e:	b580      	push	{r7, lr}
 8025490:	b084      	sub	sp, #16
 8025492:	af00      	add	r7, sp, #0
 8025494:	6078      	str	r0, [r7, #4]

  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 8025496:	2301      	movs	r3, #1
 8025498:	60fb      	str	r3, [r7, #12]
 802549a:	e006      	b.n	80254aa <self_destruct+0x1c>
    free_pool(cinfo, pool);
 802549c:	68f9      	ldr	r1, [r7, #12]
 802549e:	6878      	ldr	r0, [r7, #4]
 80254a0:	f7ff ff46 	bl	8025330 <free_pool>
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 80254a4:	68fb      	ldr	r3, [r7, #12]
 80254a6:	3b01      	subs	r3, #1
 80254a8:	60fb      	str	r3, [r7, #12]
 80254aa:	68fb      	ldr	r3, [r7, #12]
 80254ac:	2b00      	cmp	r3, #0
 80254ae:	daf5      	bge.n	802549c <self_destruct+0xe>
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
 80254b0:	687b      	ldr	r3, [r7, #4]
 80254b2:	685b      	ldr	r3, [r3, #4]
 80254b4:	2254      	movs	r2, #84	; 0x54
 80254b6:	4619      	mov	r1, r3
 80254b8:	6878      	ldr	r0, [r7, #4]
 80254ba:	f000 f8b0 	bl	802561e <jpeg_free_small>
  cinfo->mem = NULL;		/* ensures I will be called only once */
 80254be:	687b      	ldr	r3, [r7, #4]
 80254c0:	2200      	movs	r2, #0
 80254c2:	605a      	str	r2, [r3, #4]

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
 80254c4:	6878      	ldr	r0, [r7, #4]
 80254c6:	f000 f8fd 	bl	80256c4 <jpeg_mem_term>
}
 80254ca:	bf00      	nop
 80254cc:	3710      	adds	r7, #16
 80254ce:	46bd      	mov	sp, r7
 80254d0:	bd80      	pop	{r7, pc}
	...

080254d4 <jinit_memory_mgr>:
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
 80254d4:	b580      	push	{r7, lr}
 80254d6:	b086      	sub	sp, #24
 80254d8:	af00      	add	r7, sp, #0
 80254da:	6078      	str	r0, [r7, #4]
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */
 80254dc:	687b      	ldr	r3, [r7, #4]
 80254de:	2200      	movs	r2, #0
 80254e0:	605a      	str	r2, [r3, #4]
  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
   * a multiple of SIZEOF(ALIGN_TYPE).
   * Again, an "unreachable code" warning may be ignored here.
   * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
   */
  test_mac = (size_t) MAX_ALLOC_CHUNK;
 80254e2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80254e6:	613b      	str	r3, [r7, #16]
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
 80254e8:	693b      	ldr	r3, [r7, #16]
 80254ea:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80254ee:	d008      	beq.n	8025502 <jinit_memory_mgr+0x2e>
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
 80254f0:	687b      	ldr	r3, [r7, #4]
 80254f2:	681b      	ldr	r3, [r3, #0]
 80254f4:	2202      	movs	r2, #2
 80254f6:	615a      	str	r2, [r3, #20]
 80254f8:	687b      	ldr	r3, [r7, #4]
 80254fa:	681b      	ldr	r3, [r3, #0]
 80254fc:	681b      	ldr	r3, [r3, #0]
 80254fe:	6878      	ldr	r0, [r7, #4]
 8025500:	4798      	blx	r3

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
 8025502:	6878      	ldr	r0, [r7, #4]
 8025504:	f000 f8d3 	bl	80256ae <jpeg_mem_init>
 8025508:	60f8      	str	r0, [r7, #12]

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
 802550a:	2154      	movs	r1, #84	; 0x54
 802550c:	6878      	ldr	r0, [r7, #4]
 802550e:	f000 f879 	bl	8025604 <jpeg_get_small>
 8025512:	60b8      	str	r0, [r7, #8]

  if (mem == NULL) {
 8025514:	68bb      	ldr	r3, [r7, #8]
 8025516:	2b00      	cmp	r3, #0
 8025518:	d10f      	bne.n	802553a <jinit_memory_mgr+0x66>
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
 802551a:	6878      	ldr	r0, [r7, #4]
 802551c:	f000 f8d2 	bl	80256c4 <jpeg_mem_term>
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
 8025520:	687b      	ldr	r3, [r7, #4]
 8025522:	681b      	ldr	r3, [r3, #0]
 8025524:	2238      	movs	r2, #56	; 0x38
 8025526:	615a      	str	r2, [r3, #20]
 8025528:	687b      	ldr	r3, [r7, #4]
 802552a:	681b      	ldr	r3, [r3, #0]
 802552c:	2200      	movs	r2, #0
 802552e:	619a      	str	r2, [r3, #24]
 8025530:	687b      	ldr	r3, [r7, #4]
 8025532:	681b      	ldr	r3, [r3, #0]
 8025534:	681b      	ldr	r3, [r3, #0]
 8025536:	6878      	ldr	r0, [r7, #4]
 8025538:	4798      	blx	r3
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
 802553a:	68bb      	ldr	r3, [r7, #8]
 802553c:	4a26      	ldr	r2, [pc, #152]	; (80255d8 <jinit_memory_mgr+0x104>)
 802553e:	601a      	str	r2, [r3, #0]
  mem->pub.alloc_large = alloc_large;
 8025540:	68bb      	ldr	r3, [r7, #8]
 8025542:	4a26      	ldr	r2, [pc, #152]	; (80255dc <jinit_memory_mgr+0x108>)
 8025544:	605a      	str	r2, [r3, #4]
  mem->pub.alloc_sarray = alloc_sarray;
 8025546:	68bb      	ldr	r3, [r7, #8]
 8025548:	4a25      	ldr	r2, [pc, #148]	; (80255e0 <jinit_memory_mgr+0x10c>)
 802554a:	609a      	str	r2, [r3, #8]
  mem->pub.alloc_barray = alloc_barray;
 802554c:	68bb      	ldr	r3, [r7, #8]
 802554e:	4a25      	ldr	r2, [pc, #148]	; (80255e4 <jinit_memory_mgr+0x110>)
 8025550:	60da      	str	r2, [r3, #12]
  mem->pub.request_virt_sarray = request_virt_sarray;
 8025552:	68bb      	ldr	r3, [r7, #8]
 8025554:	4a24      	ldr	r2, [pc, #144]	; (80255e8 <jinit_memory_mgr+0x114>)
 8025556:	611a      	str	r2, [r3, #16]
  mem->pub.request_virt_barray = request_virt_barray;
 8025558:	68bb      	ldr	r3, [r7, #8]
 802555a:	4a24      	ldr	r2, [pc, #144]	; (80255ec <jinit_memory_mgr+0x118>)
 802555c:	615a      	str	r2, [r3, #20]
  mem->pub.realize_virt_arrays = realize_virt_arrays;
 802555e:	68bb      	ldr	r3, [r7, #8]
 8025560:	4a23      	ldr	r2, [pc, #140]	; (80255f0 <jinit_memory_mgr+0x11c>)
 8025562:	619a      	str	r2, [r3, #24]
  mem->pub.access_virt_sarray = access_virt_sarray;
 8025564:	68bb      	ldr	r3, [r7, #8]
 8025566:	4a23      	ldr	r2, [pc, #140]	; (80255f4 <jinit_memory_mgr+0x120>)
 8025568:	61da      	str	r2, [r3, #28]
  mem->pub.access_virt_barray = access_virt_barray;
 802556a:	68bb      	ldr	r3, [r7, #8]
 802556c:	4a22      	ldr	r2, [pc, #136]	; (80255f8 <jinit_memory_mgr+0x124>)
 802556e:	621a      	str	r2, [r3, #32]
  mem->pub.free_pool = free_pool;
 8025570:	68bb      	ldr	r3, [r7, #8]
 8025572:	4a22      	ldr	r2, [pc, #136]	; (80255fc <jinit_memory_mgr+0x128>)
 8025574:	625a      	str	r2, [r3, #36]	; 0x24
  mem->pub.self_destruct = self_destruct;
 8025576:	68bb      	ldr	r3, [r7, #8]
 8025578:	4a21      	ldr	r2, [pc, #132]	; (8025600 <jinit_memory_mgr+0x12c>)
 802557a:	629a      	str	r2, [r3, #40]	; 0x28

  /* Make MAX_ALLOC_CHUNK accessible to other modules */
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
 802557c:	68bb      	ldr	r3, [r7, #8]
 802557e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8025582:	631a      	str	r2, [r3, #48]	; 0x30

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;
 8025584:	68bb      	ldr	r3, [r7, #8]
 8025586:	68fa      	ldr	r2, [r7, #12]
 8025588:	62da      	str	r2, [r3, #44]	; 0x2c

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 802558a:	2301      	movs	r3, #1
 802558c:	617b      	str	r3, [r7, #20]
 802558e:	e010      	b.n	80255b2 <jinit_memory_mgr+0xde>
    mem->small_list[pool] = NULL;
 8025590:	68ba      	ldr	r2, [r7, #8]
 8025592:	697b      	ldr	r3, [r7, #20]
 8025594:	330c      	adds	r3, #12
 8025596:	009b      	lsls	r3, r3, #2
 8025598:	4413      	add	r3, r2
 802559a:	2200      	movs	r2, #0
 802559c:	605a      	str	r2, [r3, #4]
    mem->large_list[pool] = NULL;
 802559e:	68ba      	ldr	r2, [r7, #8]
 80255a0:	697b      	ldr	r3, [r7, #20]
 80255a2:	330e      	adds	r3, #14
 80255a4:	009b      	lsls	r3, r3, #2
 80255a6:	4413      	add	r3, r2
 80255a8:	2200      	movs	r2, #0
 80255aa:	605a      	str	r2, [r3, #4]
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
 80255ac:	697b      	ldr	r3, [r7, #20]
 80255ae:	3b01      	subs	r3, #1
 80255b0:	617b      	str	r3, [r7, #20]
 80255b2:	697b      	ldr	r3, [r7, #20]
 80255b4:	2b00      	cmp	r3, #0
 80255b6:	daeb      	bge.n	8025590 <jinit_memory_mgr+0xbc>
  }
  mem->virt_sarray_list = NULL;
 80255b8:	68bb      	ldr	r3, [r7, #8]
 80255ba:	2200      	movs	r2, #0
 80255bc:	645a      	str	r2, [r3, #68]	; 0x44
  mem->virt_barray_list = NULL;
 80255be:	68bb      	ldr	r3, [r7, #8]
 80255c0:	2200      	movs	r2, #0
 80255c2:	649a      	str	r2, [r3, #72]	; 0x48

  mem->total_space_allocated = SIZEOF(my_memory_mgr);
 80255c4:	68bb      	ldr	r3, [r7, #8]
 80255c6:	2254      	movs	r2, #84	; 0x54
 80255c8:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;
 80255ca:	68ba      	ldr	r2, [r7, #8]
 80255cc:	687b      	ldr	r3, [r7, #4]
 80255ce:	605a      	str	r2, [r3, #4]
      }
    }
  }
#endif

}
 80255d0:	bf00      	nop
 80255d2:	3718      	adds	r7, #24
 80255d4:	46bd      	mov	sp, r7
 80255d6:	bd80      	pop	{r7, pc}
 80255d8:	08024729 	.word	0x08024729
 80255dc:	080248a9 	.word	0x080248a9
 80255e0:	0802496f 	.word	0x0802496f
 80255e4:	08024a35 	.word	0x08024a35
 80255e8:	08024b01 	.word	0x08024b01
 80255ec:	08024b7d 	.word	0x08024b7d
 80255f0:	08024bf9 	.word	0x08024bf9
 80255f4:	0802500f 	.word	0x0802500f
 80255f8:	0802519f 	.word	0x0802519f
 80255fc:	08025331 	.word	0x08025331
 8025600:	0802548f 	.word	0x0802548f

08025604 <jpeg_get_small>:
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
 8025604:	b580      	push	{r7, lr}
 8025606:	b082      	sub	sp, #8
 8025608:	af00      	add	r7, sp, #0
 802560a:	6078      	str	r0, [r7, #4]
 802560c:	6039      	str	r1, [r7, #0]
  return (void *) JMALLOC(sizeofobject);
 802560e:	6838      	ldr	r0, [r7, #0]
 8025610:	f002 fe18 	bl	8028244 <malloc>
 8025614:	4603      	mov	r3, r0
}
 8025616:	4618      	mov	r0, r3
 8025618:	3708      	adds	r7, #8
 802561a:	46bd      	mov	sp, r7
 802561c:	bd80      	pop	{r7, pc}

0802561e <jpeg_free_small>:

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
 802561e:	b580      	push	{r7, lr}
 8025620:	b084      	sub	sp, #16
 8025622:	af00      	add	r7, sp, #0
 8025624:	60f8      	str	r0, [r7, #12]
 8025626:	60b9      	str	r1, [r7, #8]
 8025628:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802562a:	68b8      	ldr	r0, [r7, #8]
 802562c:	f002 fe12 	bl	8028254 <free>
}
 8025630:	bf00      	nop
 8025632:	3710      	adds	r7, #16
 8025634:	46bd      	mov	sp, r7
 8025636:	bd80      	pop	{r7, pc}

08025638 <jpeg_get_large>:
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
 8025638:	b580      	push	{r7, lr}
 802563a:	b082      	sub	sp, #8
 802563c:	af00      	add	r7, sp, #0
 802563e:	6078      	str	r0, [r7, #4]
 8025640:	6039      	str	r1, [r7, #0]
  return (void FAR *) JMALLOC(sizeofobject);
 8025642:	6838      	ldr	r0, [r7, #0]
 8025644:	f002 fdfe 	bl	8028244 <malloc>
 8025648:	4603      	mov	r3, r0
}
 802564a:	4618      	mov	r0, r3
 802564c:	3708      	adds	r7, #8
 802564e:	46bd      	mov	sp, r7
 8025650:	bd80      	pop	{r7, pc}

08025652 <jpeg_free_large>:

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
 8025652:	b580      	push	{r7, lr}
 8025654:	b084      	sub	sp, #16
 8025656:	af00      	add	r7, sp, #0
 8025658:	60f8      	str	r0, [r7, #12]
 802565a:	60b9      	str	r1, [r7, #8]
 802565c:	607a      	str	r2, [r7, #4]
  JFREE(object);
 802565e:	68b8      	ldr	r0, [r7, #8]
 8025660:	f002 fdf8 	bl	8028254 <free>
}
 8025664:	bf00      	nop
 8025666:	3710      	adds	r7, #16
 8025668:	46bd      	mov	sp, r7
 802566a:	bd80      	pop	{r7, pc}

0802566c <jpeg_mem_available>:
 */

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
 802566c:	b480      	push	{r7}
 802566e:	b085      	sub	sp, #20
 8025670:	af00      	add	r7, sp, #0
 8025672:	60f8      	str	r0, [r7, #12]
 8025674:	60b9      	str	r1, [r7, #8]
 8025676:	607a      	str	r2, [r7, #4]
 8025678:	603b      	str	r3, [r7, #0]
  return max_bytes_needed;
 802567a:	687b      	ldr	r3, [r7, #4]
}
 802567c:	4618      	mov	r0, r3
 802567e:	3714      	adds	r7, #20
 8025680:	46bd      	mov	sp, r7
 8025682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025686:	4770      	bx	lr

08025688 <jpeg_open_backing_store>:
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
 8025688:	b580      	push	{r7, lr}
 802568a:	b084      	sub	sp, #16
 802568c:	af00      	add	r7, sp, #0
 802568e:	60f8      	str	r0, [r7, #12]
 8025690:	60b9      	str	r1, [r7, #8]
 8025692:	607a      	str	r2, [r7, #4]
  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
 8025694:	68fb      	ldr	r3, [r7, #12]
 8025696:	681b      	ldr	r3, [r3, #0]
 8025698:	2233      	movs	r2, #51	; 0x33
 802569a:	615a      	str	r2, [r3, #20]
 802569c:	68fb      	ldr	r3, [r7, #12]
 802569e:	681b      	ldr	r3, [r3, #0]
 80256a0:	681b      	ldr	r3, [r3, #0]
 80256a2:	68f8      	ldr	r0, [r7, #12]
 80256a4:	4798      	blx	r3
}
 80256a6:	bf00      	nop
 80256a8:	3710      	adds	r7, #16
 80256aa:	46bd      	mov	sp, r7
 80256ac:	bd80      	pop	{r7, pc}

080256ae <jpeg_mem_init>:
 * cleanup required.  Here, there isn't any.
 */

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
 80256ae:	b480      	push	{r7}
 80256b0:	b083      	sub	sp, #12
 80256b2:	af00      	add	r7, sp, #0
 80256b4:	6078      	str	r0, [r7, #4]
  return 0;			/* just set max_memory_to_use to 0 */
 80256b6:	2300      	movs	r3, #0
}
 80256b8:	4618      	mov	r0, r3
 80256ba:	370c      	adds	r7, #12
 80256bc:	46bd      	mov	sp, r7
 80256be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80256c2:	4770      	bx	lr

080256c4 <jpeg_mem_term>:

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
 80256c4:	b480      	push	{r7}
 80256c6:	b083      	sub	sp, #12
 80256c8:	af00      	add	r7, sp, #0
 80256ca:	6078      	str	r0, [r7, #4]
}
 80256cc:	bf00      	nop
 80256ce:	370c      	adds	r7, #12
 80256d0:	46bd      	mov	sp, r7
 80256d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80256d6:	4770      	bx	lr

080256d8 <select_ncolors>:
LOCAL(int)
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
 80256d8:	b580      	push	{r7, lr}
 80256da:	b08a      	sub	sp, #40	; 0x28
 80256dc:	af00      	add	r7, sp, #0
 80256de:	6078      	str	r0, [r7, #4]
 80256e0:	6039      	str	r1, [r7, #0]
  int nc = cinfo->out_color_components; /* number of color components */
 80256e2:	687b      	ldr	r3, [r7, #4]
 80256e4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80256e6:	613b      	str	r3, [r7, #16]
  int max_colors = cinfo->desired_number_of_colors;
 80256e8:	687b      	ldr	r3, [r7, #4]
 80256ea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80256ec:	60fb      	str	r3, [r7, #12]
  long temp;
  static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
 80256ee:	2301      	movs	r3, #1
 80256f0:	623b      	str	r3, [r7, #32]
  do {
    iroot++;
 80256f2:	6a3b      	ldr	r3, [r7, #32]
 80256f4:	3301      	adds	r3, #1
 80256f6:	623b      	str	r3, [r7, #32]
    temp = iroot;		/* set temp = iroot ** nc */
 80256f8:	6a3b      	ldr	r3, [r7, #32]
 80256fa:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 80256fc:	2301      	movs	r3, #1
 80256fe:	61fb      	str	r3, [r7, #28]
 8025700:	e007      	b.n	8025712 <select_ncolors+0x3a>
      temp *= iroot;
 8025702:	697b      	ldr	r3, [r7, #20]
 8025704:	6a3a      	ldr	r2, [r7, #32]
 8025706:	fb02 f303 	mul.w	r3, r2, r3
 802570a:	617b      	str	r3, [r7, #20]
    for (i = 1; i < nc; i++)
 802570c:	69fb      	ldr	r3, [r7, #28]
 802570e:	3301      	adds	r3, #1
 8025710:	61fb      	str	r3, [r7, #28]
 8025712:	69fa      	ldr	r2, [r7, #28]
 8025714:	693b      	ldr	r3, [r7, #16]
 8025716:	429a      	cmp	r2, r3
 8025718:	dbf3      	blt.n	8025702 <select_ncolors+0x2a>
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
 802571a:	697a      	ldr	r2, [r7, #20]
 802571c:	68fb      	ldr	r3, [r7, #12]
 802571e:	429a      	cmp	r2, r3
 8025720:	dde7      	ble.n	80256f2 <select_ncolors+0x1a>
  iroot--;			/* now iroot = floor(root) */
 8025722:	6a3b      	ldr	r3, [r7, #32]
 8025724:	3b01      	subs	r3, #1
 8025726:	623b      	str	r3, [r7, #32]

  /* Must have at least 2 color values per component */
  if (iroot < 2)
 8025728:	6a3b      	ldr	r3, [r7, #32]
 802572a:	2b01      	cmp	r3, #1
 802572c:	dc0c      	bgt.n	8025748 <select_ncolors+0x70>
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
 802572e:	687b      	ldr	r3, [r7, #4]
 8025730:	681b      	ldr	r3, [r3, #0]
 8025732:	223a      	movs	r2, #58	; 0x3a
 8025734:	615a      	str	r2, [r3, #20]
 8025736:	687b      	ldr	r3, [r7, #4]
 8025738:	681b      	ldr	r3, [r3, #0]
 802573a:	697a      	ldr	r2, [r7, #20]
 802573c:	619a      	str	r2, [r3, #24]
 802573e:	687b      	ldr	r3, [r7, #4]
 8025740:	681b      	ldr	r3, [r3, #0]
 8025742:	681b      	ldr	r3, [r3, #0]
 8025744:	6878      	ldr	r0, [r7, #4]
 8025746:	4798      	blx	r3

  /* Initialize to iroot color values for each component */
  total_colors = 1;
 8025748:	2301      	movs	r3, #1
 802574a:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0; i < nc; i++) {
 802574c:	2300      	movs	r3, #0
 802574e:	61fb      	str	r3, [r7, #28]
 8025750:	e00d      	b.n	802576e <select_ncolors+0x96>
    Ncolors[i] = iroot;
 8025752:	69fb      	ldr	r3, [r7, #28]
 8025754:	009b      	lsls	r3, r3, #2
 8025756:	683a      	ldr	r2, [r7, #0]
 8025758:	4413      	add	r3, r2
 802575a:	6a3a      	ldr	r2, [r7, #32]
 802575c:	601a      	str	r2, [r3, #0]
    total_colors *= iroot;
 802575e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025760:	6a3a      	ldr	r2, [r7, #32]
 8025762:	fb02 f303 	mul.w	r3, r2, r3
 8025766:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = 0; i < nc; i++) {
 8025768:	69fb      	ldr	r3, [r7, #28]
 802576a:	3301      	adds	r3, #1
 802576c:	61fb      	str	r3, [r7, #28]
 802576e:	69fa      	ldr	r2, [r7, #28]
 8025770:	693b      	ldr	r3, [r7, #16]
 8025772:	429a      	cmp	r2, r3
 8025774:	dbed      	blt.n	8025752 <select_ncolors+0x7a>
   * Sometimes, the first component can be incremented more than once!
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
 8025776:	2300      	movs	r3, #0
 8025778:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 802577a:	2300      	movs	r3, #0
 802577c:	61fb      	str	r3, [r7, #28]
 802577e:	e030      	b.n	80257e2 <select_ncolors+0x10a>
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
 8025780:	687b      	ldr	r3, [r7, #4]
 8025782:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8025786:	2b02      	cmp	r3, #2
 8025788:	d104      	bne.n	8025794 <select_ncolors+0xbc>
 802578a:	4a1d      	ldr	r2, [pc, #116]	; (8025800 <select_ncolors+0x128>)
 802578c:	69fb      	ldr	r3, [r7, #28]
 802578e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025792:	e000      	b.n	8025796 <select_ncolors+0xbe>
 8025794:	69fb      	ldr	r3, [r7, #28]
 8025796:	60bb      	str	r3, [r7, #8]
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
 8025798:	68bb      	ldr	r3, [r7, #8]
 802579a:	009b      	lsls	r3, r3, #2
 802579c:	683a      	ldr	r2, [r7, #0]
 802579e:	4413      	add	r3, r2
 80257a0:	681b      	ldr	r3, [r3, #0]
 80257a2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80257a4:	fb92 f3f3 	sdiv	r3, r2, r3
 80257a8:	617b      	str	r3, [r7, #20]
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
 80257aa:	68bb      	ldr	r3, [r7, #8]
 80257ac:	009b      	lsls	r3, r3, #2
 80257ae:	683a      	ldr	r2, [r7, #0]
 80257b0:	4413      	add	r3, r2
 80257b2:	681b      	ldr	r3, [r3, #0]
 80257b4:	1c5a      	adds	r2, r3, #1
 80257b6:	697b      	ldr	r3, [r7, #20]
 80257b8:	fb02 f303 	mul.w	r3, r2, r3
 80257bc:	617b      	str	r3, [r7, #20]
      if (temp > (long) max_colors)
 80257be:	697a      	ldr	r2, [r7, #20]
 80257c0:	68fb      	ldr	r3, [r7, #12]
 80257c2:	429a      	cmp	r2, r3
 80257c4:	dc12      	bgt.n	80257ec <select_ncolors+0x114>
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
 80257c6:	68bb      	ldr	r3, [r7, #8]
 80257c8:	009b      	lsls	r3, r3, #2
 80257ca:	683a      	ldr	r2, [r7, #0]
 80257cc:	4413      	add	r3, r2
 80257ce:	681a      	ldr	r2, [r3, #0]
 80257d0:	3201      	adds	r2, #1
 80257d2:	601a      	str	r2, [r3, #0]
      total_colors = (int) temp;
 80257d4:	697b      	ldr	r3, [r7, #20]
 80257d6:	627b      	str	r3, [r7, #36]	; 0x24
      changed = TRUE;
 80257d8:	2301      	movs	r3, #1
 80257da:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < nc; i++) {
 80257dc:	69fb      	ldr	r3, [r7, #28]
 80257de:	3301      	adds	r3, #1
 80257e0:	61fb      	str	r3, [r7, #28]
 80257e2:	69fa      	ldr	r2, [r7, #28]
 80257e4:	693b      	ldr	r3, [r7, #16]
 80257e6:	429a      	cmp	r2, r3
 80257e8:	dbca      	blt.n	8025780 <select_ncolors+0xa8>
 80257ea:	e000      	b.n	80257ee <select_ncolors+0x116>
	break;			/* won't fit, done with this pass */
 80257ec:	bf00      	nop
    }
  } while (changed);
 80257ee:	69bb      	ldr	r3, [r7, #24]
 80257f0:	2b00      	cmp	r3, #0
 80257f2:	d1c0      	bne.n	8025776 <select_ncolors+0x9e>

  return total_colors;
 80257f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80257f6:	4618      	mov	r0, r3
 80257f8:	3728      	adds	r7, #40	; 0x28
 80257fa:	46bd      	mov	sp, r7
 80257fc:	bd80      	pop	{r7, pc}
 80257fe:	bf00      	nop
 8025800:	0802ac5c 	.word	0x0802ac5c

08025804 <output_value>:

LOCAL(int)
output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
{
 8025804:	b480      	push	{r7}
 8025806:	b085      	sub	sp, #20
 8025808:	af00      	add	r7, sp, #0
 802580a:	60f8      	str	r0, [r7, #12]
 802580c:	60b9      	str	r1, [r7, #8]
 802580e:	607a      	str	r2, [r7, #4]
 8025810:	603b      	str	r3, [r7, #0]
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
 8025812:	687a      	ldr	r2, [r7, #4]
 8025814:	4613      	mov	r3, r2
 8025816:	021b      	lsls	r3, r3, #8
 8025818:	1a9a      	subs	r2, r3, r2
 802581a:	683b      	ldr	r3, [r7, #0]
 802581c:	0fd9      	lsrs	r1, r3, #31
 802581e:	440b      	add	r3, r1
 8025820:	105b      	asrs	r3, r3, #1
 8025822:	441a      	add	r2, r3
 8025824:	683b      	ldr	r3, [r7, #0]
 8025826:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802582a:	4618      	mov	r0, r3
 802582c:	3714      	adds	r7, #20
 802582e:	46bd      	mov	sp, r7
 8025830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025834:	4770      	bx	lr

08025836 <largest_input_value>:

LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
 8025836:	b480      	push	{r7}
 8025838:	b085      	sub	sp, #20
 802583a:	af00      	add	r7, sp, #0
 802583c:	60f8      	str	r0, [r7, #12]
 802583e:	60b9      	str	r1, [r7, #8]
 8025840:	607a      	str	r2, [r7, #4]
 8025842:	603b      	str	r3, [r7, #0]
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
 8025844:	687b      	ldr	r3, [r7, #4]
 8025846:	005b      	lsls	r3, r3, #1
 8025848:	1c5a      	adds	r2, r3, #1
 802584a:	4613      	mov	r3, r2
 802584c:	021b      	lsls	r3, r3, #8
 802584e:	1a9a      	subs	r2, r3, r2
 8025850:	683b      	ldr	r3, [r7, #0]
 8025852:	441a      	add	r2, r3
 8025854:	683b      	ldr	r3, [r7, #0]
 8025856:	005b      	lsls	r3, r3, #1
 8025858:	fb92 f3f3 	sdiv	r3, r2, r3
}
 802585c:	4618      	mov	r0, r3
 802585e:	3714      	adds	r7, #20
 8025860:	46bd      	mov	sp, r7
 8025862:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025866:	4770      	bx	lr

08025868 <create_colormap>:
 * Create the colormap.
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
 8025868:	b590      	push	{r4, r7, lr}
 802586a:	b08f      	sub	sp, #60	; 0x3c
 802586c:	af00      	add	r7, sp, #0
 802586e:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025870:	687b      	ldr	r3, [r7, #4]
 8025872:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025876:	623b      	str	r3, [r7, #32]
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
 8025878:	6a3b      	ldr	r3, [r7, #32]
 802587a:	3320      	adds	r3, #32
 802587c:	4619      	mov	r1, r3
 802587e:	6878      	ldr	r0, [r7, #4]
 8025880:	f7ff ff2a 	bl	80256d8 <select_ncolors>
 8025884:	61f8      	str	r0, [r7, #28]

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
 8025886:	687b      	ldr	r3, [r7, #4]
 8025888:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802588a:	2b03      	cmp	r3, #3
 802588c:	d120      	bne.n	80258d0 <create_colormap+0x68>
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
 802588e:	687b      	ldr	r3, [r7, #4]
 8025890:	681b      	ldr	r3, [r3, #0]
 8025892:	3318      	adds	r3, #24
 8025894:	61bb      	str	r3, [r7, #24]
 8025896:	69bb      	ldr	r3, [r7, #24]
 8025898:	69fa      	ldr	r2, [r7, #28]
 802589a:	601a      	str	r2, [r3, #0]
 802589c:	69bb      	ldr	r3, [r7, #24]
 802589e:	3304      	adds	r3, #4
 80258a0:	6a3a      	ldr	r2, [r7, #32]
 80258a2:	6a12      	ldr	r2, [r2, #32]
 80258a4:	601a      	str	r2, [r3, #0]
 80258a6:	69bb      	ldr	r3, [r7, #24]
 80258a8:	3308      	adds	r3, #8
 80258aa:	6a3a      	ldr	r2, [r7, #32]
 80258ac:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80258ae:	601a      	str	r2, [r3, #0]
 80258b0:	69bb      	ldr	r3, [r7, #24]
 80258b2:	330c      	adds	r3, #12
 80258b4:	6a3a      	ldr	r2, [r7, #32]
 80258b6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80258b8:	601a      	str	r2, [r3, #0]
 80258ba:	687b      	ldr	r3, [r7, #4]
 80258bc:	681b      	ldr	r3, [r3, #0]
 80258be:	2260      	movs	r2, #96	; 0x60
 80258c0:	615a      	str	r2, [r3, #20]
 80258c2:	687b      	ldr	r3, [r7, #4]
 80258c4:	681b      	ldr	r3, [r3, #0]
 80258c6:	685b      	ldr	r3, [r3, #4]
 80258c8:	2101      	movs	r1, #1
 80258ca:	6878      	ldr	r0, [r7, #4]
 80258cc:	4798      	blx	r3
 80258ce:	e00d      	b.n	80258ec <create_colormap+0x84>
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
 80258d0:	687b      	ldr	r3, [r7, #4]
 80258d2:	681b      	ldr	r3, [r3, #0]
 80258d4:	2261      	movs	r2, #97	; 0x61
 80258d6:	615a      	str	r2, [r3, #20]
 80258d8:	687b      	ldr	r3, [r7, #4]
 80258da:	681b      	ldr	r3, [r3, #0]
 80258dc:	69fa      	ldr	r2, [r7, #28]
 80258de:	619a      	str	r2, [r3, #24]
 80258e0:	687b      	ldr	r3, [r7, #4]
 80258e2:	681b      	ldr	r3, [r3, #0]
 80258e4:	685b      	ldr	r3, [r3, #4]
 80258e6:	2101      	movs	r1, #1
 80258e8:	6878      	ldr	r0, [r7, #4]
 80258ea:	4798      	blx	r3

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
 80258ec:	687b      	ldr	r3, [r7, #4]
 80258ee:	685b      	ldr	r3, [r3, #4]
 80258f0:	689c      	ldr	r4, [r3, #8]
 80258f2:	69fa      	ldr	r2, [r7, #28]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
 80258f4:	687b      	ldr	r3, [r7, #4]
 80258f6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  colormap = (*cinfo->mem->alloc_sarray)
 80258f8:	2101      	movs	r1, #1
 80258fa:	6878      	ldr	r0, [r7, #4]
 80258fc:	47a0      	blx	r4
 80258fe:	6178      	str	r0, [r7, #20]

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;
 8025900:	69fb      	ldr	r3, [r7, #28]
 8025902:	62bb      	str	r3, [r7, #40]	; 0x28

  for (i = 0; i < cinfo->out_color_components; i++) {
 8025904:	2300      	movs	r3, #0
 8025906:	637b      	str	r3, [r7, #52]	; 0x34
 8025908:	e045      	b.n	8025996 <create_colormap+0x12e>
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 802590a:	6a3b      	ldr	r3, [r7, #32]
 802590c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802590e:	3208      	adds	r2, #8
 8025910:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025914:	613b      	str	r3, [r7, #16]
    blksize = blkdist / nci;
 8025916:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8025918:	693b      	ldr	r3, [r7, #16]
 802591a:	fb92 f3f3 	sdiv	r3, r2, r3
 802591e:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < nci; j++) {
 8025920:	2300      	movs	r3, #0
 8025922:	633b      	str	r3, [r7, #48]	; 0x30
 8025924:	e02e      	b.n	8025984 <create_colormap+0x11c>
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
 8025926:	693b      	ldr	r3, [r7, #16]
 8025928:	3b01      	subs	r3, #1
 802592a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802592c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 802592e:	6878      	ldr	r0, [r7, #4]
 8025930:	f7ff ff68 	bl	8025804 <output_value>
 8025934:	60b8      	str	r0, [r7, #8]
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 8025936:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025938:	68fa      	ldr	r2, [r7, #12]
 802593a:	fb02 f303 	mul.w	r3, r2, r3
 802593e:	627b      	str	r3, [r7, #36]	; 0x24
 8025940:	e019      	b.n	8025976 <create_colormap+0x10e>
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
 8025942:	2300      	movs	r3, #0
 8025944:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025946:	e00e      	b.n	8025966 <create_colormap+0xfe>
	  colormap[i][ptr+k] = (JSAMPLE) val;
 8025948:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802594a:	009b      	lsls	r3, r3, #2
 802594c:	697a      	ldr	r2, [r7, #20]
 802594e:	4413      	add	r3, r2
 8025950:	681b      	ldr	r3, [r3, #0]
 8025952:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8025954:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025956:	440a      	add	r2, r1
 8025958:	4413      	add	r3, r2
 802595a:	68ba      	ldr	r2, [r7, #8]
 802595c:	b2d2      	uxtb	r2, r2
 802595e:	701a      	strb	r2, [r3, #0]
	for (k = 0; k < blksize; k++)
 8025960:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025962:	3301      	adds	r3, #1
 8025964:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025966:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025968:	68fb      	ldr	r3, [r7, #12]
 802596a:	429a      	cmp	r2, r3
 802596c:	dbec      	blt.n	8025948 <create_colormap+0xe0>
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 802596e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025970:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025972:	4413      	add	r3, r2
 8025974:	627b      	str	r3, [r7, #36]	; 0x24
 8025976:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025978:	69fb      	ldr	r3, [r7, #28]
 802597a:	429a      	cmp	r2, r3
 802597c:	dbe1      	blt.n	8025942 <create_colormap+0xda>
    for (j = 0; j < nci; j++) {
 802597e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025980:	3301      	adds	r3, #1
 8025982:	633b      	str	r3, [r7, #48]	; 0x30
 8025984:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8025986:	693b      	ldr	r3, [r7, #16]
 8025988:	429a      	cmp	r2, r3
 802598a:	dbcc      	blt.n	8025926 <create_colormap+0xbe>
      }
    }
    blkdist = blksize;		/* blksize of this color is blkdist of next */
 802598c:	68fb      	ldr	r3, [r7, #12]
 802598e:	62bb      	str	r3, [r7, #40]	; 0x28
  for (i = 0; i < cinfo->out_color_components; i++) {
 8025990:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025992:	3301      	adds	r3, #1
 8025994:	637b      	str	r3, [r7, #52]	; 0x34
 8025996:	687b      	ldr	r3, [r7, #4]
 8025998:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802599a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802599c:	429a      	cmp	r2, r3
 802599e:	dbb4      	blt.n	802590a <create_colormap+0xa2>
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
 80259a0:	6a3b      	ldr	r3, [r7, #32]
 80259a2:	697a      	ldr	r2, [r7, #20]
 80259a4:	611a      	str	r2, [r3, #16]
  cquantize->sv_actual = total_colors;
 80259a6:	6a3b      	ldr	r3, [r7, #32]
 80259a8:	69fa      	ldr	r2, [r7, #28]
 80259aa:	615a      	str	r2, [r3, #20]
}
 80259ac:	bf00      	nop
 80259ae:	373c      	adds	r7, #60	; 0x3c
 80259b0:	46bd      	mov	sp, r7
 80259b2:	bd90      	pop	{r4, r7, pc}

080259b4 <create_colorindex>:
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
 80259b4:	b590      	push	{r4, r7, lr}
 80259b6:	b08d      	sub	sp, #52	; 0x34
 80259b8:	af00      	add	r7, sp, #0
 80259ba:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80259bc:	687b      	ldr	r3, [r7, #4]
 80259be:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80259c2:	617b      	str	r3, [r7, #20]
  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
 80259c4:	687b      	ldr	r3, [r7, #4]
 80259c6:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 80259ca:	2b01      	cmp	r3, #1
 80259cc:	d106      	bne.n	80259dc <create_colorindex+0x28>
    pad = MAXJSAMPLE*2;
 80259ce:	f44f 73ff 	mov.w	r3, #510	; 0x1fe
 80259d2:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = TRUE;
 80259d4:	697b      	ldr	r3, [r7, #20]
 80259d6:	2201      	movs	r2, #1
 80259d8:	61da      	str	r2, [r3, #28]
 80259da:	e004      	b.n	80259e6 <create_colorindex+0x32>
  } else {
    pad = 0;
 80259dc:	2300      	movs	r3, #0
 80259de:	61bb      	str	r3, [r7, #24]
    cquantize->is_padded = FALSE;
 80259e0:	697b      	ldr	r3, [r7, #20]
 80259e2:	2200      	movs	r2, #0
 80259e4:	61da      	str	r2, [r3, #28]
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 80259e6:	687b      	ldr	r3, [r7, #4]
 80259e8:	685b      	ldr	r3, [r3, #4]
 80259ea:	689c      	ldr	r4, [r3, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
 80259ec:	69bb      	ldr	r3, [r7, #24]
 80259ee:	f503 7380 	add.w	r3, r3, #256	; 0x100
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 80259f2:	461a      	mov	r2, r3
     (JDIMENSION) cinfo->out_color_components);
 80259f4:	687b      	ldr	r3, [r7, #4]
 80259f6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
 80259f8:	2101      	movs	r1, #1
 80259fa:	6878      	ldr	r0, [r7, #4]
 80259fc:	47a0      	blx	r4
 80259fe:	4602      	mov	r2, r0
 8025a00:	697b      	ldr	r3, [r7, #20]
 8025a02:	619a      	str	r2, [r3, #24]

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;
 8025a04:	697b      	ldr	r3, [r7, #20]
 8025a06:	695b      	ldr	r3, [r3, #20]
 8025a08:	623b      	str	r3, [r7, #32]

  for (i = 0; i < cinfo->out_color_components; i++) {
 8025a0a:	2300      	movs	r3, #0
 8025a0c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025a0e:	e06e      	b.n	8025aee <create_colorindex+0x13a>
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 8025a10:	697b      	ldr	r3, [r7, #20]
 8025a12:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025a14:	3208      	adds	r2, #8
 8025a16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025a1a:	613b      	str	r3, [r7, #16]
    blksize = blksize / nci;
 8025a1c:	6a3a      	ldr	r2, [r7, #32]
 8025a1e:	693b      	ldr	r3, [r7, #16]
 8025a20:	fb92 f3f3 	sdiv	r3, r2, r3
 8025a24:	623b      	str	r3, [r7, #32]

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
 8025a26:	69bb      	ldr	r3, [r7, #24]
 8025a28:	2b00      	cmp	r3, #0
 8025a2a:	d00c      	beq.n	8025a46 <create_colorindex+0x92>
      cquantize->colorindex[i] += MAXJSAMPLE;
 8025a2c:	697b      	ldr	r3, [r7, #20]
 8025a2e:	699a      	ldr	r2, [r3, #24]
 8025a30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025a32:	009b      	lsls	r3, r3, #2
 8025a34:	4413      	add	r3, r2
 8025a36:	681a      	ldr	r2, [r3, #0]
 8025a38:	697b      	ldr	r3, [r7, #20]
 8025a3a:	6999      	ldr	r1, [r3, #24]
 8025a3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025a3e:	009b      	lsls	r3, r3, #2
 8025a40:	440b      	add	r3, r1
 8025a42:	32ff      	adds	r2, #255	; 0xff
 8025a44:	601a      	str	r2, [r3, #0]

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
 8025a46:	697b      	ldr	r3, [r7, #20]
 8025a48:	699a      	ldr	r2, [r3, #24]
 8025a4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025a4c:	009b      	lsls	r3, r3, #2
 8025a4e:	4413      	add	r3, r2
 8025a50:	681b      	ldr	r3, [r3, #0]
 8025a52:	60fb      	str	r3, [r7, #12]
    val = 0;
 8025a54:	2300      	movs	r3, #0
 8025a56:	61fb      	str	r3, [r7, #28]
    k = largest_input_value(cinfo, i, 0, nci-1);
 8025a58:	693b      	ldr	r3, [r7, #16]
 8025a5a:	3b01      	subs	r3, #1
 8025a5c:	2200      	movs	r2, #0
 8025a5e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8025a60:	6878      	ldr	r0, [r7, #4]
 8025a62:	f7ff fee8 	bl	8025836 <largest_input_value>
 8025a66:	6278      	str	r0, [r7, #36]	; 0x24
    for (j = 0; j <= MAXJSAMPLE; j++) {
 8025a68:	2300      	movs	r3, #0
 8025a6a:	62bb      	str	r3, [r7, #40]	; 0x28
 8025a6c:	e01c      	b.n	8025aa8 <create_colorindex+0xf4>
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
 8025a6e:	69fb      	ldr	r3, [r7, #28]
 8025a70:	3301      	adds	r3, #1
 8025a72:	61fb      	str	r3, [r7, #28]
 8025a74:	693b      	ldr	r3, [r7, #16]
 8025a76:	3b01      	subs	r3, #1
 8025a78:	69fa      	ldr	r2, [r7, #28]
 8025a7a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8025a7c:	6878      	ldr	r0, [r7, #4]
 8025a7e:	f7ff feda 	bl	8025836 <largest_input_value>
 8025a82:	6278      	str	r0, [r7, #36]	; 0x24
      while (j > k)		/* advance val if past boundary */
 8025a84:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8025a86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a88:	429a      	cmp	r2, r3
 8025a8a:	dcf0      	bgt.n	8025a6e <create_colorindex+0xba>
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
 8025a8c:	69fb      	ldr	r3, [r7, #28]
 8025a8e:	b2d9      	uxtb	r1, r3
 8025a90:	6a3b      	ldr	r3, [r7, #32]
 8025a92:	b2da      	uxtb	r2, r3
 8025a94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025a96:	68f8      	ldr	r0, [r7, #12]
 8025a98:	4403      	add	r3, r0
 8025a9a:	fb11 f202 	smulbb	r2, r1, r2
 8025a9e:	b2d2      	uxtb	r2, r2
 8025aa0:	701a      	strb	r2, [r3, #0]
    for (j = 0; j <= MAXJSAMPLE; j++) {
 8025aa2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025aa4:	3301      	adds	r3, #1
 8025aa6:	62bb      	str	r3, [r7, #40]	; 0x28
 8025aa8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025aaa:	2bff      	cmp	r3, #255	; 0xff
 8025aac:	ddea      	ble.n	8025a84 <create_colorindex+0xd0>
    }
    /* Pad at both ends if necessary */
    if (pad)
 8025aae:	69bb      	ldr	r3, [r7, #24]
 8025ab0:	2b00      	cmp	r3, #0
 8025ab2:	d019      	beq.n	8025ae8 <create_colorindex+0x134>
      for (j = 1; j <= MAXJSAMPLE; j++) {
 8025ab4:	2301      	movs	r3, #1
 8025ab6:	62bb      	str	r3, [r7, #40]	; 0x28
 8025ab8:	e013      	b.n	8025ae2 <create_colorindex+0x12e>
	indexptr[-j] = indexptr[0];
 8025aba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025abc:	425b      	negs	r3, r3
 8025abe:	461a      	mov	r2, r3
 8025ac0:	68fb      	ldr	r3, [r7, #12]
 8025ac2:	4413      	add	r3, r2
 8025ac4:	68fa      	ldr	r2, [r7, #12]
 8025ac6:	7812      	ldrb	r2, [r2, #0]
 8025ac8:	701a      	strb	r2, [r3, #0]
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
 8025aca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025acc:	33ff      	adds	r3, #255	; 0xff
 8025ace:	461a      	mov	r2, r3
 8025ad0:	68fb      	ldr	r3, [r7, #12]
 8025ad2:	4413      	add	r3, r2
 8025ad4:	68fa      	ldr	r2, [r7, #12]
 8025ad6:	f892 20ff 	ldrb.w	r2, [r2, #255]	; 0xff
 8025ada:	701a      	strb	r2, [r3, #0]
      for (j = 1; j <= MAXJSAMPLE; j++) {
 8025adc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025ade:	3301      	adds	r3, #1
 8025ae0:	62bb      	str	r3, [r7, #40]	; 0x28
 8025ae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025ae4:	2bff      	cmp	r3, #255	; 0xff
 8025ae6:	dde8      	ble.n	8025aba <create_colorindex+0x106>
  for (i = 0; i < cinfo->out_color_components; i++) {
 8025ae8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025aea:	3301      	adds	r3, #1
 8025aec:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025aee:	687b      	ldr	r3, [r7, #4]
 8025af0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8025af2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025af4:	429a      	cmp	r2, r3
 8025af6:	db8b      	blt.n	8025a10 <create_colorindex+0x5c>
      }
  }
}
 8025af8:	bf00      	nop
 8025afa:	bf00      	nop
 8025afc:	3734      	adds	r7, #52	; 0x34
 8025afe:	46bd      	mov	sp, r7
 8025b00:	bd90      	pop	{r4, r7, pc}
	...

08025b04 <make_odither_array>:
 * distinct output values.
 */

LOCAL(ODITHER_MATRIX_PTR)
make_odither_array (j_decompress_ptr cinfo, int ncolors)
{
 8025b04:	b580      	push	{r7, lr}
 8025b06:	b088      	sub	sp, #32
 8025b08:	af00      	add	r7, sp, #0
 8025b0a:	6078      	str	r0, [r7, #4]
 8025b0c:	6039      	str	r1, [r7, #0]
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 8025b0e:	687b      	ldr	r3, [r7, #4]
 8025b10:	685b      	ldr	r3, [r3, #4]
 8025b12:	681b      	ldr	r3, [r3, #0]
 8025b14:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8025b18:	2101      	movs	r1, #1
 8025b1a:	6878      	ldr	r0, [r7, #4]
 8025b1c:	4798      	blx	r3
 8025b1e:	6178      	str	r0, [r7, #20]
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
 8025b20:	683b      	ldr	r3, [r7, #0]
 8025b22:	3b01      	subs	r3, #1
 8025b24:	025b      	lsls	r3, r3, #9
 8025b26:	613b      	str	r3, [r7, #16]
  for (j = 0; j < ODITHER_SIZE; j++) {
 8025b28:	2300      	movs	r3, #0
 8025b2a:	61fb      	str	r3, [r7, #28]
 8025b2c:	e02e      	b.n	8025b8c <make_odither_array+0x88>
    for (k = 0; k < ODITHER_SIZE; k++) {
 8025b2e:	2300      	movs	r3, #0
 8025b30:	61bb      	str	r3, [r7, #24]
 8025b32:	e025      	b.n	8025b80 <make_odither_array+0x7c>
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
 8025b34:	4a19      	ldr	r2, [pc, #100]	; (8025b9c <make_odither_array+0x98>)
 8025b36:	69fb      	ldr	r3, [r7, #28]
 8025b38:	011b      	lsls	r3, r3, #4
 8025b3a:	441a      	add	r2, r3
 8025b3c:	69bb      	ldr	r3, [r7, #24]
 8025b3e:	4413      	add	r3, r2
 8025b40:	781b      	ldrb	r3, [r3, #0]
 8025b42:	005b      	lsls	r3, r3, #1
 8025b44:	f1c3 02ff 	rsb	r2, r3, #255	; 0xff
 8025b48:	4613      	mov	r3, r2
 8025b4a:	021b      	lsls	r3, r3, #8
 8025b4c:	1a9b      	subs	r3, r3, r2
 8025b4e:	60fb      	str	r3, [r7, #12]
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
 8025b50:	68fb      	ldr	r3, [r7, #12]
 8025b52:	2b00      	cmp	r3, #0
 8025b54:	da06      	bge.n	8025b64 <make_odither_array+0x60>
 8025b56:	68fb      	ldr	r3, [r7, #12]
 8025b58:	425a      	negs	r2, r3
 8025b5a:	693b      	ldr	r3, [r7, #16]
 8025b5c:	fb92 f3f3 	sdiv	r3, r2, r3
 8025b60:	425b      	negs	r3, r3
 8025b62:	e003      	b.n	8025b6c <make_odither_array+0x68>
 8025b64:	68fa      	ldr	r2, [r7, #12]
 8025b66:	693b      	ldr	r3, [r7, #16]
 8025b68:	fb92 f3f3 	sdiv	r3, r2, r3
 8025b6c:	69fa      	ldr	r2, [r7, #28]
 8025b6e:	0192      	lsls	r2, r2, #6
 8025b70:	6979      	ldr	r1, [r7, #20]
 8025b72:	440a      	add	r2, r1
 8025b74:	69b9      	ldr	r1, [r7, #24]
 8025b76:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    for (k = 0; k < ODITHER_SIZE; k++) {
 8025b7a:	69bb      	ldr	r3, [r7, #24]
 8025b7c:	3301      	adds	r3, #1
 8025b7e:	61bb      	str	r3, [r7, #24]
 8025b80:	69bb      	ldr	r3, [r7, #24]
 8025b82:	2b0f      	cmp	r3, #15
 8025b84:	ddd6      	ble.n	8025b34 <make_odither_array+0x30>
  for (j = 0; j < ODITHER_SIZE; j++) {
 8025b86:	69fb      	ldr	r3, [r7, #28]
 8025b88:	3301      	adds	r3, #1
 8025b8a:	61fb      	str	r3, [r7, #28]
 8025b8c:	69fb      	ldr	r3, [r7, #28]
 8025b8e:	2b0f      	cmp	r3, #15
 8025b90:	ddcd      	ble.n	8025b2e <make_odither_array+0x2a>
    }
  }
  return odither;
 8025b92:	697b      	ldr	r3, [r7, #20]
}
 8025b94:	4618      	mov	r0, r3
 8025b96:	3720      	adds	r7, #32
 8025b98:	46bd      	mov	sp, r7
 8025b9a:	bd80      	pop	{r7, pc}
 8025b9c:	0802ab5c 	.word	0x0802ab5c

08025ba0 <create_odither_tables>:
 * share a dither table.
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
 8025ba0:	b580      	push	{r7, lr}
 8025ba2:	b088      	sub	sp, #32
 8025ba4:	af00      	add	r7, sp, #0
 8025ba6:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025ba8:	687b      	ldr	r3, [r7, #4]
 8025baa:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025bae:	613b      	str	r3, [r7, #16]
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
 8025bb0:	2300      	movs	r3, #0
 8025bb2:	61bb      	str	r3, [r7, #24]
 8025bb4:	e033      	b.n	8025c1e <create_odither_tables+0x7e>
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
 8025bb6:	693b      	ldr	r3, [r7, #16]
 8025bb8:	69ba      	ldr	r2, [r7, #24]
 8025bba:	3208      	adds	r2, #8
 8025bbc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025bc0:	60fb      	str	r3, [r7, #12]
    odither = NULL;		/* search for matching prior component */
 8025bc2:	2300      	movs	r3, #0
 8025bc4:	61fb      	str	r3, [r7, #28]
    for (j = 0; j < i; j++) {
 8025bc6:	2300      	movs	r3, #0
 8025bc8:	617b      	str	r3, [r7, #20]
 8025bca:	e012      	b.n	8025bf2 <create_odither_tables+0x52>
      if (nci == cquantize->Ncolors[j]) {
 8025bcc:	693b      	ldr	r3, [r7, #16]
 8025bce:	697a      	ldr	r2, [r7, #20]
 8025bd0:	3208      	adds	r2, #8
 8025bd2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025bd6:	68fa      	ldr	r2, [r7, #12]
 8025bd8:	429a      	cmp	r2, r3
 8025bda:	d107      	bne.n	8025bec <create_odither_tables+0x4c>
	odither = cquantize->odither[j];
 8025bdc:	693a      	ldr	r2, [r7, #16]
 8025bde:	697b      	ldr	r3, [r7, #20]
 8025be0:	330c      	adds	r3, #12
 8025be2:	009b      	lsls	r3, r3, #2
 8025be4:	4413      	add	r3, r2
 8025be6:	685b      	ldr	r3, [r3, #4]
 8025be8:	61fb      	str	r3, [r7, #28]
	break;
 8025bea:	e006      	b.n	8025bfa <create_odither_tables+0x5a>
    for (j = 0; j < i; j++) {
 8025bec:	697b      	ldr	r3, [r7, #20]
 8025bee:	3301      	adds	r3, #1
 8025bf0:	617b      	str	r3, [r7, #20]
 8025bf2:	697a      	ldr	r2, [r7, #20]
 8025bf4:	69bb      	ldr	r3, [r7, #24]
 8025bf6:	429a      	cmp	r2, r3
 8025bf8:	dbe8      	blt.n	8025bcc <create_odither_tables+0x2c>
      }
    }
    if (odither == NULL)	/* need a new table? */
 8025bfa:	69fb      	ldr	r3, [r7, #28]
 8025bfc:	2b00      	cmp	r3, #0
 8025bfe:	d104      	bne.n	8025c0a <create_odither_tables+0x6a>
      odither = make_odither_array(cinfo, nci);
 8025c00:	68f9      	ldr	r1, [r7, #12]
 8025c02:	6878      	ldr	r0, [r7, #4]
 8025c04:	f7ff ff7e 	bl	8025b04 <make_odither_array>
 8025c08:	61f8      	str	r0, [r7, #28]
    cquantize->odither[i] = odither;
 8025c0a:	693a      	ldr	r2, [r7, #16]
 8025c0c:	69bb      	ldr	r3, [r7, #24]
 8025c0e:	330c      	adds	r3, #12
 8025c10:	009b      	lsls	r3, r3, #2
 8025c12:	4413      	add	r3, r2
 8025c14:	69fa      	ldr	r2, [r7, #28]
 8025c16:	605a      	str	r2, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 8025c18:	69bb      	ldr	r3, [r7, #24]
 8025c1a:	3301      	adds	r3, #1
 8025c1c:	61bb      	str	r3, [r7, #24]
 8025c1e:	687b      	ldr	r3, [r7, #4]
 8025c20:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8025c22:	69ba      	ldr	r2, [r7, #24]
 8025c24:	429a      	cmp	r2, r3
 8025c26:	dbc6      	blt.n	8025bb6 <create_odither_tables+0x16>
  }
}
 8025c28:	bf00      	nop
 8025c2a:	bf00      	nop
 8025c2c:	3720      	adds	r7, #32
 8025c2e:	46bd      	mov	sp, r7
 8025c30:	bd80      	pop	{r7, pc}

08025c32 <color_quantize>:

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
 8025c32:	b4f0      	push	{r4, r5, r6, r7}
 8025c34:	b08a      	sub	sp, #40	; 0x28
 8025c36:	af00      	add	r7, sp, #0
 8025c38:	60f8      	str	r0, [r7, #12]
 8025c3a:	60b9      	str	r1, [r7, #8]
 8025c3c:	607a      	str	r2, [r7, #4]
 8025c3e:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025c40:	68fb      	ldr	r3, [r7, #12]
 8025c42:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025c46:	61fb      	str	r3, [r7, #28]
  JSAMPARRAY colorindex = cquantize->colorindex;
 8025c48:	69fb      	ldr	r3, [r7, #28]
 8025c4a:	699b      	ldr	r3, [r3, #24]
 8025c4c:	61bb      	str	r3, [r7, #24]
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 8025c4e:	68fb      	ldr	r3, [r7, #12]
 8025c50:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8025c52:	617b      	str	r3, [r7, #20]
  register int nc = cinfo->out_color_components;
 8025c54:	68fb      	ldr	r3, [r7, #12]
 8025c56:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8025c58:	4618      	mov	r0, r3

  for (row = 0; row < num_rows; row++) {
 8025c5a:	2300      	movs	r3, #0
 8025c5c:	627b      	str	r3, [r7, #36]	; 0x24
 8025c5e:	e02d      	b.n	8025cbc <color_quantize+0x8a>
    ptrin = input_buf[row];
 8025c60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025c62:	009b      	lsls	r3, r3, #2
 8025c64:	68ba      	ldr	r2, [r7, #8]
 8025c66:	4413      	add	r3, r2
 8025c68:	681e      	ldr	r6, [r3, #0]
    ptrout = output_buf[row];
 8025c6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025c6c:	009b      	lsls	r3, r3, #2
 8025c6e:	687a      	ldr	r2, [r7, #4]
 8025c70:	4413      	add	r3, r2
 8025c72:	681b      	ldr	r3, [r3, #0]
 8025c74:	4619      	mov	r1, r3
    for (col = width; col > 0; col--) {
 8025c76:	697b      	ldr	r3, [r7, #20]
 8025c78:	623b      	str	r3, [r7, #32]
 8025c7a:	e019      	b.n	8025cb0 <color_quantize+0x7e>
      pixcode = 0;
 8025c7c:	2500      	movs	r5, #0
      for (ci = 0; ci < nc; ci++) {
 8025c7e:	2400      	movs	r4, #0
 8025c80:	e00b      	b.n	8025c9a <color_quantize+0x68>
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
 8025c82:	4623      	mov	r3, r4
 8025c84:	009b      	lsls	r3, r3, #2
 8025c86:	69ba      	ldr	r2, [r7, #24]
 8025c88:	4413      	add	r3, r2
 8025c8a:	681a      	ldr	r2, [r3, #0]
 8025c8c:	4633      	mov	r3, r6
 8025c8e:	1c5e      	adds	r6, r3, #1
 8025c90:	781b      	ldrb	r3, [r3, #0]
 8025c92:	4413      	add	r3, r2
 8025c94:	781b      	ldrb	r3, [r3, #0]
 8025c96:	441d      	add	r5, r3
      for (ci = 0; ci < nc; ci++) {
 8025c98:	3401      	adds	r4, #1
 8025c9a:	4603      	mov	r3, r0
 8025c9c:	429c      	cmp	r4, r3
 8025c9e:	dbf0      	blt.n	8025c82 <color_quantize+0x50>
      }
      *ptrout++ = (JSAMPLE) pixcode;
 8025ca0:	460b      	mov	r3, r1
 8025ca2:	1c5a      	adds	r2, r3, #1
 8025ca4:	4611      	mov	r1, r2
 8025ca6:	b2ea      	uxtb	r2, r5
 8025ca8:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 8025caa:	6a3b      	ldr	r3, [r7, #32]
 8025cac:	3b01      	subs	r3, #1
 8025cae:	623b      	str	r3, [r7, #32]
 8025cb0:	6a3b      	ldr	r3, [r7, #32]
 8025cb2:	2b00      	cmp	r3, #0
 8025cb4:	d1e2      	bne.n	8025c7c <color_quantize+0x4a>
  for (row = 0; row < num_rows; row++) {
 8025cb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025cb8:	3301      	adds	r3, #1
 8025cba:	627b      	str	r3, [r7, #36]	; 0x24
 8025cbc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025cbe:	683b      	ldr	r3, [r7, #0]
 8025cc0:	429a      	cmp	r2, r3
 8025cc2:	dbcd      	blt.n	8025c60 <color_quantize+0x2e>
    }
  }
}
 8025cc4:	bf00      	nop
 8025cc6:	bf00      	nop
 8025cc8:	3728      	adds	r7, #40	; 0x28
 8025cca:	46bd      	mov	sp, r7
 8025ccc:	bcf0      	pop	{r4, r5, r6, r7}
 8025cce:	4770      	bx	lr

08025cd0 <color_quantize3>:

METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
 8025cd0:	b4f0      	push	{r4, r5, r6, r7}
 8025cd2:	b08c      	sub	sp, #48	; 0x30
 8025cd4:	af00      	add	r7, sp, #0
 8025cd6:	60f8      	str	r0, [r7, #12]
 8025cd8:	60b9      	str	r1, [r7, #8]
 8025cda:	607a      	str	r2, [r7, #4]
 8025cdc:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025cde:	68fb      	ldr	r3, [r7, #12]
 8025ce0:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025ce4:	627b      	str	r3, [r7, #36]	; 0x24
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 8025ce6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025ce8:	699b      	ldr	r3, [r3, #24]
 8025cea:	681b      	ldr	r3, [r3, #0]
 8025cec:	623b      	str	r3, [r7, #32]
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 8025cee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025cf0:	699b      	ldr	r3, [r3, #24]
 8025cf2:	685b      	ldr	r3, [r3, #4]
 8025cf4:	61fb      	str	r3, [r7, #28]
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 8025cf6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025cf8:	699b      	ldr	r3, [r3, #24]
 8025cfa:	689b      	ldr	r3, [r3, #8]
 8025cfc:	61bb      	str	r3, [r7, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 8025cfe:	68fb      	ldr	r3, [r7, #12]
 8025d00:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8025d02:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 8025d04:	2300      	movs	r3, #0
 8025d06:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025d08:	e031      	b.n	8025d6e <color_quantize3+0x9e>
    ptrin = input_buf[row];
 8025d0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d0c:	009b      	lsls	r3, r3, #2
 8025d0e:	68ba      	ldr	r2, [r7, #8]
 8025d10:	4413      	add	r3, r2
 8025d12:	681c      	ldr	r4, [r3, #0]
    ptrout = output_buf[row];
 8025d14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d16:	009b      	lsls	r3, r3, #2
 8025d18:	687a      	ldr	r2, [r7, #4]
 8025d1a:	4413      	add	r3, r2
 8025d1c:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 8025d1e:	697b      	ldr	r3, [r7, #20]
 8025d20:	62bb      	str	r3, [r7, #40]	; 0x28
 8025d22:	e01e      	b.n	8025d62 <color_quantize3+0x92>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
 8025d24:	4623      	mov	r3, r4
 8025d26:	1c5c      	adds	r4, r3, #1
 8025d28:	781b      	ldrb	r3, [r3, #0]
 8025d2a:	461a      	mov	r2, r3
 8025d2c:	6a3b      	ldr	r3, [r7, #32]
 8025d2e:	4413      	add	r3, r2
 8025d30:	781b      	ldrb	r3, [r3, #0]
 8025d32:	461d      	mov	r5, r3
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
 8025d34:	4623      	mov	r3, r4
 8025d36:	1c5c      	adds	r4, r3, #1
 8025d38:	781b      	ldrb	r3, [r3, #0]
 8025d3a:	461a      	mov	r2, r3
 8025d3c:	69fb      	ldr	r3, [r7, #28]
 8025d3e:	4413      	add	r3, r2
 8025d40:	781b      	ldrb	r3, [r3, #0]
 8025d42:	441d      	add	r5, r3
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
 8025d44:	4623      	mov	r3, r4
 8025d46:	1c5c      	adds	r4, r3, #1
 8025d48:	781b      	ldrb	r3, [r3, #0]
 8025d4a:	461a      	mov	r2, r3
 8025d4c:	69bb      	ldr	r3, [r7, #24]
 8025d4e:	4413      	add	r3, r2
 8025d50:	781b      	ldrb	r3, [r3, #0]
 8025d52:	441d      	add	r5, r3
      *ptrout++ = (JSAMPLE) pixcode;
 8025d54:	4633      	mov	r3, r6
 8025d56:	1c5e      	adds	r6, r3, #1
 8025d58:	b2ea      	uxtb	r2, r5
 8025d5a:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 8025d5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025d5e:	3b01      	subs	r3, #1
 8025d60:	62bb      	str	r3, [r7, #40]	; 0x28
 8025d62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025d64:	2b00      	cmp	r3, #0
 8025d66:	d1dd      	bne.n	8025d24 <color_quantize3+0x54>
  for (row = 0; row < num_rows; row++) {
 8025d68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d6a:	3301      	adds	r3, #1
 8025d6c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025d6e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025d70:	683b      	ldr	r3, [r7, #0]
 8025d72:	429a      	cmp	r2, r3
 8025d74:	dbc9      	blt.n	8025d0a <color_quantize3+0x3a>
    }
  }
}
 8025d76:	bf00      	nop
 8025d78:	bf00      	nop
 8025d7a:	3730      	adds	r7, #48	; 0x30
 8025d7c:	46bd      	mov	sp, r7
 8025d7e:	bcf0      	pop	{r4, r5, r6, r7}
 8025d80:	4770      	bx	lr

08025d82 <quantize_ord_dither>:

METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
 8025d82:	b5b0      	push	{r4, r5, r7, lr}
 8025d84:	b08e      	sub	sp, #56	; 0x38
 8025d86:	af00      	add	r7, sp, #0
 8025d88:	60f8      	str	r0, [r7, #12]
 8025d8a:	60b9      	str	r1, [r7, #8]
 8025d8c:	607a      	str	r2, [r7, #4]
 8025d8e:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025d90:	68fb      	ldr	r3, [r7, #12]
 8025d92:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025d96:	627b      	str	r3, [r7, #36]	; 0x24
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
 8025d98:	68fb      	ldr	r3, [r7, #12]
 8025d9a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8025d9c:	623b      	str	r3, [r7, #32]
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 8025d9e:	68fb      	ldr	r3, [r7, #12]
 8025da0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8025da2:	61fb      	str	r3, [r7, #28]

  for (row = 0; row < num_rows; row++) {
 8025da4:	2300      	movs	r3, #0
 8025da6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025da8:	e061      	b.n	8025e6e <quantize_ord_dither+0xec>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 8025daa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025dac:	009b      	lsls	r3, r3, #2
 8025dae:	687a      	ldr	r2, [r7, #4]
 8025db0:	4413      	add	r3, r2
 8025db2:	681b      	ldr	r3, [r3, #0]
 8025db4:	69fa      	ldr	r2, [r7, #28]
 8025db6:	2100      	movs	r1, #0
 8025db8:	4618      	mov	r0, r3
 8025dba:	f002 fa61 	bl	8028280 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
 8025dbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025dc0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025dc2:	61bb      	str	r3, [r7, #24]
    for (ci = 0; ci < nc; ci++) {
 8025dc4:	2300      	movs	r3, #0
 8025dc6:	633b      	str	r3, [r7, #48]	; 0x30
 8025dc8:	e042      	b.n	8025e50 <quantize_ord_dither+0xce>
      input_ptr = input_buf[row] + ci;
 8025dca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025dcc:	009b      	lsls	r3, r3, #2
 8025dce:	68ba      	ldr	r2, [r7, #8]
 8025dd0:	4413      	add	r3, r2
 8025dd2:	681a      	ldr	r2, [r3, #0]
 8025dd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025dd6:	18d5      	adds	r5, r2, r3
      output_ptr = output_buf[row];
 8025dd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025dda:	009b      	lsls	r3, r3, #2
 8025ddc:	687a      	ldr	r2, [r7, #4]
 8025dde:	4413      	add	r3, r2
 8025de0:	681c      	ldr	r4, [r3, #0]
      colorindex_ci = cquantize->colorindex[ci];
 8025de2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025de4:	699a      	ldr	r2, [r3, #24]
 8025de6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025de8:	009b      	lsls	r3, r3, #2
 8025dea:	4413      	add	r3, r2
 8025dec:	681b      	ldr	r3, [r3, #0]
 8025dee:	617b      	str	r3, [r7, #20]
      dither = cquantize->odither[ci][row_index];
 8025df0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025df2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025df4:	330c      	adds	r3, #12
 8025df6:	009b      	lsls	r3, r3, #2
 8025df8:	4413      	add	r3, r2
 8025dfa:	685a      	ldr	r2, [r3, #4]
 8025dfc:	69bb      	ldr	r3, [r7, #24]
 8025dfe:	019b      	lsls	r3, r3, #6
 8025e00:	4413      	add	r3, r2
 8025e02:	613b      	str	r3, [r7, #16]
      col_index = 0;
 8025e04:	2300      	movs	r3, #0
 8025e06:	637b      	str	r3, [r7, #52]	; 0x34

      for (col = width; col > 0; col--) {
 8025e08:	69fb      	ldr	r3, [r7, #28]
 8025e0a:	62bb      	str	r3, [r7, #40]	; 0x28
 8025e0c:	e01a      	b.n	8025e44 <quantize_ord_dither+0xc2>
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
 8025e0e:	7822      	ldrb	r2, [r4, #0]
 8025e10:	782b      	ldrb	r3, [r5, #0]
 8025e12:	4618      	mov	r0, r3
 8025e14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025e16:	009b      	lsls	r3, r3, #2
 8025e18:	6939      	ldr	r1, [r7, #16]
 8025e1a:	440b      	add	r3, r1
 8025e1c:	681b      	ldr	r3, [r3, #0]
 8025e1e:	4403      	add	r3, r0
 8025e20:	4619      	mov	r1, r3
 8025e22:	697b      	ldr	r3, [r7, #20]
 8025e24:	440b      	add	r3, r1
 8025e26:	781b      	ldrb	r3, [r3, #0]
 8025e28:	4413      	add	r3, r2
 8025e2a:	b2db      	uxtb	r3, r3
 8025e2c:	7023      	strb	r3, [r4, #0]
	input_ptr += nc;
 8025e2e:	6a3b      	ldr	r3, [r7, #32]
 8025e30:	441d      	add	r5, r3
	output_ptr++;
 8025e32:	3401      	adds	r4, #1
	col_index = (col_index + 1) & ODITHER_MASK;
 8025e34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025e36:	3301      	adds	r3, #1
 8025e38:	f003 030f 	and.w	r3, r3, #15
 8025e3c:	637b      	str	r3, [r7, #52]	; 0x34
      for (col = width; col > 0; col--) {
 8025e3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e40:	3b01      	subs	r3, #1
 8025e42:	62bb      	str	r3, [r7, #40]	; 0x28
 8025e44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e46:	2b00      	cmp	r3, #0
 8025e48:	d1e1      	bne.n	8025e0e <quantize_ord_dither+0x8c>
    for (ci = 0; ci < nc; ci++) {
 8025e4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025e4c:	3301      	adds	r3, #1
 8025e4e:	633b      	str	r3, [r7, #48]	; 0x30
 8025e50:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8025e52:	6a3b      	ldr	r3, [r7, #32]
 8025e54:	429a      	cmp	r2, r3
 8025e56:	dbb8      	blt.n	8025dca <quantize_ord_dither+0x48>
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
 8025e58:	69bb      	ldr	r3, [r7, #24]
 8025e5a:	3301      	adds	r3, #1
 8025e5c:	f003 030f 	and.w	r3, r3, #15
 8025e60:	61bb      	str	r3, [r7, #24]
    cquantize->row_index = row_index;
 8025e62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025e64:	69ba      	ldr	r2, [r7, #24]
 8025e66:	631a      	str	r2, [r3, #48]	; 0x30
  for (row = 0; row < num_rows; row++) {
 8025e68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025e6a:	3301      	adds	r3, #1
 8025e6c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8025e6e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025e70:	683b      	ldr	r3, [r7, #0]
 8025e72:	429a      	cmp	r2, r3
 8025e74:	db99      	blt.n	8025daa <quantize_ord_dither+0x28>
  }
}
 8025e76:	bf00      	nop
 8025e78:	bf00      	nop
 8025e7a:	3738      	adds	r7, #56	; 0x38
 8025e7c:	46bd      	mov	sp, r7
 8025e7e:	bdb0      	pop	{r4, r5, r7, pc}

08025e80 <quantize3_ord_dither>:

METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
 8025e80:	b4f0      	push	{r4, r5, r6, r7}
 8025e82:	b090      	sub	sp, #64	; 0x40
 8025e84:	af00      	add	r7, sp, #0
 8025e86:	60f8      	str	r0, [r7, #12]
 8025e88:	60b9      	str	r1, [r7, #8]
 8025e8a:	607a      	str	r2, [r7, #4]
 8025e8c:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025e8e:	68fb      	ldr	r3, [r7, #12]
 8025e90:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025e94:	633b      	str	r3, [r7, #48]	; 0x30
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
 8025e96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025e98:	699b      	ldr	r3, [r3, #24]
 8025e9a:	681b      	ldr	r3, [r3, #0]
 8025e9c:	62fb      	str	r3, [r7, #44]	; 0x2c
  JSAMPROW colorindex1 = cquantize->colorindex[1];
 8025e9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025ea0:	699b      	ldr	r3, [r3, #24]
 8025ea2:	685b      	ldr	r3, [r3, #4]
 8025ea4:	62bb      	str	r3, [r7, #40]	; 0x28
  JSAMPROW colorindex2 = cquantize->colorindex[2];
 8025ea6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025ea8:	699b      	ldr	r3, [r3, #24]
 8025eaa:	689b      	ldr	r3, [r3, #8]
 8025eac:	627b      	str	r3, [r7, #36]	; 0x24
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 8025eae:	68fb      	ldr	r3, [r7, #12]
 8025eb0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8025eb2:	623b      	str	r3, [r7, #32]

  for (row = 0; row < num_rows; row++) {
 8025eb4:	2300      	movs	r3, #0
 8025eb6:	63bb      	str	r3, [r7, #56]	; 0x38
 8025eb8:	e06a      	b.n	8025f90 <quantize3_ord_dither+0x110>
    row_index = cquantize->row_index;
 8025eba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025ebc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025ebe:	61fb      	str	r3, [r7, #28]
    input_ptr = input_buf[row];
 8025ec0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8025ec2:	009b      	lsls	r3, r3, #2
 8025ec4:	68ba      	ldr	r2, [r7, #8]
 8025ec6:	4413      	add	r3, r2
 8025ec8:	681c      	ldr	r4, [r3, #0]
    output_ptr = output_buf[row];
 8025eca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8025ecc:	009b      	lsls	r3, r3, #2
 8025ece:	687a      	ldr	r2, [r7, #4]
 8025ed0:	4413      	add	r3, r2
 8025ed2:	681e      	ldr	r6, [r3, #0]
    dither0 = cquantize->odither[0][row_index];
 8025ed4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025ed6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8025ed8:	69fb      	ldr	r3, [r7, #28]
 8025eda:	019b      	lsls	r3, r3, #6
 8025edc:	4413      	add	r3, r2
 8025ede:	61bb      	str	r3, [r7, #24]
    dither1 = cquantize->odither[1][row_index];
 8025ee0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025ee2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8025ee4:	69fb      	ldr	r3, [r7, #28]
 8025ee6:	019b      	lsls	r3, r3, #6
 8025ee8:	4413      	add	r3, r2
 8025eea:	617b      	str	r3, [r7, #20]
    dither2 = cquantize->odither[2][row_index];
 8025eec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025eee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8025ef0:	69fb      	ldr	r3, [r7, #28]
 8025ef2:	019b      	lsls	r3, r3, #6
 8025ef4:	4413      	add	r3, r2
 8025ef6:	613b      	str	r3, [r7, #16]
    col_index = 0;
 8025ef8:	2300      	movs	r3, #0
 8025efa:	63fb      	str	r3, [r7, #60]	; 0x3c

    for (col = width; col > 0; col--) {
 8025efc:	6a3b      	ldr	r3, [r7, #32]
 8025efe:	637b      	str	r3, [r7, #52]	; 0x34
 8025f00:	e038      	b.n	8025f74 <quantize3_ord_dither+0xf4>
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
 8025f02:	4623      	mov	r3, r4
 8025f04:	1c5c      	adds	r4, r3, #1
 8025f06:	781b      	ldrb	r3, [r3, #0]
 8025f08:	4619      	mov	r1, r3
 8025f0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025f0c:	009b      	lsls	r3, r3, #2
 8025f0e:	69ba      	ldr	r2, [r7, #24]
 8025f10:	4413      	add	r3, r2
 8025f12:	681b      	ldr	r3, [r3, #0]
 8025f14:	440b      	add	r3, r1
 8025f16:	461a      	mov	r2, r3
 8025f18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025f1a:	4413      	add	r3, r2
 8025f1c:	781b      	ldrb	r3, [r3, #0]
 8025f1e:	461d      	mov	r5, r3
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
 8025f20:	4623      	mov	r3, r4
 8025f22:	1c5c      	adds	r4, r3, #1
 8025f24:	781b      	ldrb	r3, [r3, #0]
 8025f26:	4619      	mov	r1, r3
 8025f28:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025f2a:	009b      	lsls	r3, r3, #2
 8025f2c:	697a      	ldr	r2, [r7, #20]
 8025f2e:	4413      	add	r3, r2
 8025f30:	681b      	ldr	r3, [r3, #0]
 8025f32:	440b      	add	r3, r1
 8025f34:	461a      	mov	r2, r3
 8025f36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025f38:	4413      	add	r3, r2
 8025f3a:	781b      	ldrb	r3, [r3, #0]
 8025f3c:	441d      	add	r5, r3
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
 8025f3e:	4623      	mov	r3, r4
 8025f40:	1c5c      	adds	r4, r3, #1
 8025f42:	781b      	ldrb	r3, [r3, #0]
 8025f44:	4619      	mov	r1, r3
 8025f46:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025f48:	009b      	lsls	r3, r3, #2
 8025f4a:	693a      	ldr	r2, [r7, #16]
 8025f4c:	4413      	add	r3, r2
 8025f4e:	681b      	ldr	r3, [r3, #0]
 8025f50:	440b      	add	r3, r1
 8025f52:	461a      	mov	r2, r3
 8025f54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025f56:	4413      	add	r3, r2
 8025f58:	781b      	ldrb	r3, [r3, #0]
 8025f5a:	441d      	add	r5, r3
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
 8025f5c:	4633      	mov	r3, r6
 8025f5e:	1c5e      	adds	r6, r3, #1
 8025f60:	b2ea      	uxtb	r2, r5
 8025f62:	701a      	strb	r2, [r3, #0]
      col_index = (col_index + 1) & ODITHER_MASK;
 8025f64:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025f66:	3301      	adds	r3, #1
 8025f68:	f003 030f 	and.w	r3, r3, #15
 8025f6c:	63fb      	str	r3, [r7, #60]	; 0x3c
    for (col = width; col > 0; col--) {
 8025f6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025f70:	3b01      	subs	r3, #1
 8025f72:	637b      	str	r3, [r7, #52]	; 0x34
 8025f74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025f76:	2b00      	cmp	r3, #0
 8025f78:	d1c3      	bne.n	8025f02 <quantize3_ord_dither+0x82>
    }
    row_index = (row_index + 1) & ODITHER_MASK;
 8025f7a:	69fb      	ldr	r3, [r7, #28]
 8025f7c:	3301      	adds	r3, #1
 8025f7e:	f003 030f 	and.w	r3, r3, #15
 8025f82:	61fb      	str	r3, [r7, #28]
    cquantize->row_index = row_index;
 8025f84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025f86:	69fa      	ldr	r2, [r7, #28]
 8025f88:	631a      	str	r2, [r3, #48]	; 0x30
  for (row = 0; row < num_rows; row++) {
 8025f8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8025f8c:	3301      	adds	r3, #1
 8025f8e:	63bb      	str	r3, [r7, #56]	; 0x38
 8025f90:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8025f92:	683b      	ldr	r3, [r7, #0]
 8025f94:	429a      	cmp	r2, r3
 8025f96:	db90      	blt.n	8025eba <quantize3_ord_dither+0x3a>
  }
}
 8025f98:	bf00      	nop
 8025f9a:	bf00      	nop
 8025f9c:	3740      	adds	r7, #64	; 0x40
 8025f9e:	46bd      	mov	sp, r7
 8025fa0:	bcf0      	pop	{r4, r5, r6, r7}
 8025fa2:	4770      	bx	lr

08025fa4 <quantize_fs_dither>:

METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
 8025fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8025fa8:	b094      	sub	sp, #80	; 0x50
 8025faa:	af00      	add	r7, sp, #0
 8025fac:	60f8      	str	r0, [r7, #12]
 8025fae:	60b9      	str	r1, [r7, #8]
 8025fb0:	607a      	str	r2, [r7, #4]
 8025fb2:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8025fb4:	68fb      	ldr	r3, [r7, #12]
 8025fb6:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8025fba:	633b      	str	r3, [r7, #48]	; 0x30
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
 8025fbc:	68fb      	ldr	r3, [r7, #12]
 8025fbe:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8025fc0:	62fb      	str	r3, [r7, #44]	; 0x2c
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 8025fc2:	68fb      	ldr	r3, [r7, #12]
 8025fc4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8025fc6:	62bb      	str	r3, [r7, #40]	; 0x28
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 8025fc8:	68fb      	ldr	r3, [r7, #12]
 8025fca:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8025fce:	627b      	str	r3, [r7, #36]	; 0x24
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 8025fd0:	2300      	movs	r3, #0
 8025fd2:	63bb      	str	r3, [r7, #56]	; 0x38
 8025fd4:	e0b1      	b.n	802613a <quantize_fs_dither+0x196>
    /* Initialize output values to 0 so can process components separately */
    FMEMZERO((void FAR *) output_buf[row],
 8025fd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8025fd8:	009b      	lsls	r3, r3, #2
 8025fda:	687a      	ldr	r2, [r7, #4]
 8025fdc:	4413      	add	r3, r2
 8025fde:	681b      	ldr	r3, [r3, #0]
 8025fe0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8025fe2:	2100      	movs	r1, #0
 8025fe4:	4618      	mov	r0, r3
 8025fe6:	f002 f94b 	bl	8028280 <memset>
	     (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
 8025fea:	2300      	movs	r3, #0
 8025fec:	63fb      	str	r3, [r7, #60]	; 0x3c
 8025fee:	e092      	b.n	8026116 <quantize_fs_dither+0x172>
      input_ptr = input_buf[row] + ci;
 8025ff0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8025ff2:	009b      	lsls	r3, r3, #2
 8025ff4:	68ba      	ldr	r2, [r7, #8]
 8025ff6:	4413      	add	r3, r2
 8025ff8:	681a      	ldr	r2, [r3, #0]
 8025ffa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025ffc:	eb02 0803 	add.w	r8, r2, r3
      output_ptr = output_buf[row];
 8026000:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026002:	009b      	lsls	r3, r3, #2
 8026004:	687a      	ldr	r2, [r7, #4]
 8026006:	4413      	add	r3, r2
 8026008:	681e      	ldr	r6, [r3, #0]
      if (cquantize->on_odd_row) {
 802600a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802600c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802600e:	2b00      	cmp	r3, #0
 8026010:	d019      	beq.n	8026046 <quantize_fs_dither+0xa2>
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
 8026012:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026014:	3b01      	subs	r3, #1
 8026016:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8026018:	fb02 f303 	mul.w	r3, r2, r3
 802601c:	4498      	add	r8, r3
	output_ptr += width-1;
 802601e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026020:	3b01      	subs	r3, #1
 8026022:	441e      	add	r6, r3
	dir = -1;
 8026024:	f04f 33ff 	mov.w	r3, #4294967295
 8026028:	647b      	str	r3, [r7, #68]	; 0x44
	dirnc = -nc;
 802602a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802602c:	425b      	negs	r3, r3
 802602e:	643b      	str	r3, [r7, #64]	; 0x40
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
 8026030:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8026032:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026034:	3310      	adds	r3, #16
 8026036:	009b      	lsls	r3, r3, #2
 8026038:	4413      	add	r3, r2
 802603a:	685a      	ldr	r2, [r3, #4]
 802603c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802603e:	3301      	adds	r3, #1
 8026040:	005b      	lsls	r3, r3, #1
 8026042:	18d5      	adds	r5, r2, r3
 8026044:	e009      	b.n	802605a <quantize_fs_dither+0xb6>
      } else {
	/* work left to right in this row */
	dir = 1;
 8026046:	2301      	movs	r3, #1
 8026048:	647b      	str	r3, [r7, #68]	; 0x44
	dirnc = nc;
 802604a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802604c:	643b      	str	r3, [r7, #64]	; 0x40
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
 802604e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8026050:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026052:	3310      	adds	r3, #16
 8026054:	009b      	lsls	r3, r3, #2
 8026056:	4413      	add	r3, r2
 8026058:	685d      	ldr	r5, [r3, #4]
      }
      colorindex_ci = cquantize->colorindex[ci];
 802605a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802605c:	699a      	ldr	r2, [r3, #24]
 802605e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026060:	009b      	lsls	r3, r3, #2
 8026062:	4413      	add	r3, r2
 8026064:	681b      	ldr	r3, [r3, #0]
 8026066:	623b      	str	r3, [r7, #32]
      colormap_ci = cquantize->sv_colormap[ci];
 8026068:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802606a:	691a      	ldr	r2, [r3, #16]
 802606c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802606e:	009b      	lsls	r3, r3, #2
 8026070:	4413      	add	r3, r2
 8026072:	681b      	ldr	r3, [r3, #0]
 8026074:	61fb      	str	r3, [r7, #28]
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
 8026076:	2400      	movs	r4, #0
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;
 8026078:	2300      	movs	r3, #0
 802607a:	64bb      	str	r3, [r7, #72]	; 0x48
 802607c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802607e:	64fb      	str	r3, [r7, #76]	; 0x4c

      for (col = width; col > 0; col--) {
 8026080:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026082:	637b      	str	r3, [r7, #52]	; 0x34
 8026084:	e03e      	b.n	8026104 <quantize_fs_dither+0x160>
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
 8026086:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026088:	005b      	lsls	r3, r3, #1
 802608a:	442b      	add	r3, r5
 802608c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8026090:	4423      	add	r3, r4
 8026092:	3308      	adds	r3, #8
 8026094:	111c      	asrs	r4, r3, #4
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
 8026096:	f898 3000 	ldrb.w	r3, [r8]
 802609a:	441c      	add	r4, r3
	cur = GETJSAMPLE(range_limit[cur]);
 802609c:	4622      	mov	r2, r4
 802609e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80260a0:	4413      	add	r3, r2
 80260a2:	781b      	ldrb	r3, [r3, #0]
 80260a4:	461c      	mov	r4, r3
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
 80260a6:	4622      	mov	r2, r4
 80260a8:	6a3b      	ldr	r3, [r7, #32]
 80260aa:	4413      	add	r3, r2
 80260ac:	781b      	ldrb	r3, [r3, #0]
 80260ae:	61bb      	str	r3, [r7, #24]
	*output_ptr += (JSAMPLE) pixcode;
 80260b0:	7832      	ldrb	r2, [r6, #0]
 80260b2:	69bb      	ldr	r3, [r7, #24]
 80260b4:	b2db      	uxtb	r3, r3
 80260b6:	4413      	add	r3, r2
 80260b8:	b2db      	uxtb	r3, r3
 80260ba:	7033      	strb	r3, [r6, #0]
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
 80260bc:	69bb      	ldr	r3, [r7, #24]
 80260be:	69fa      	ldr	r2, [r7, #28]
 80260c0:	4413      	add	r3, r2
 80260c2:	781b      	ldrb	r3, [r3, #0]
 80260c4:	1ae4      	subs	r4, r4, r3
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
 80260c6:	617c      	str	r4, [r7, #20]
	delta = cur * 2;
 80260c8:	0063      	lsls	r3, r4, #1
 80260ca:	613b      	str	r3, [r7, #16]
	cur += delta;		/* form error * 3 */
 80260cc:	693b      	ldr	r3, [r7, #16]
 80260ce:	441c      	add	r4, r3
	errorptr[0] = (FSERROR) (bpreverr + cur);
 80260d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80260d2:	b29a      	uxth	r2, r3
 80260d4:	b2a3      	uxth	r3, r4
 80260d6:	4413      	add	r3, r2
 80260d8:	b29b      	uxth	r3, r3
 80260da:	b21b      	sxth	r3, r3
 80260dc:	802b      	strh	r3, [r5, #0]
	cur += delta;		/* form error * 5 */
 80260de:	693b      	ldr	r3, [r7, #16]
 80260e0:	441c      	add	r4, r3
	bpreverr = belowerr + cur;
 80260e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80260e4:	4423      	add	r3, r4
 80260e6:	64bb      	str	r3, [r7, #72]	; 0x48
	belowerr = bnexterr;
 80260e8:	697b      	ldr	r3, [r7, #20]
 80260ea:	64fb      	str	r3, [r7, #76]	; 0x4c
	cur += delta;		/* form error * 7 */
 80260ec:	693b      	ldr	r3, [r7, #16]
 80260ee:	441c      	add	r4, r3
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
 80260f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80260f2:	4498      	add	r8, r3
	output_ptr += dir;	/* advance output ptr to next column */
 80260f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80260f6:	441e      	add	r6, r3
	errorptr += dir;	/* advance errorptr to current column */
 80260f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80260fa:	005b      	lsls	r3, r3, #1
 80260fc:	441d      	add	r5, r3
      for (col = width; col > 0; col--) {
 80260fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026100:	3b01      	subs	r3, #1
 8026102:	637b      	str	r3, [r7, #52]	; 0x34
 8026104:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026106:	2b00      	cmp	r3, #0
 8026108:	d1bd      	bne.n	8026086 <quantize_fs_dither+0xe2>
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
 802610a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802610c:	b21b      	sxth	r3, r3
 802610e:	802b      	strh	r3, [r5, #0]
    for (ci = 0; ci < nc; ci++) {
 8026110:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026112:	3301      	adds	r3, #1
 8026114:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026116:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8026118:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802611a:	429a      	cmp	r2, r3
 802611c:	f6ff af68 	blt.w	8025ff0 <quantize_fs_dither+0x4c>
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
 8026120:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026122:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8026124:	2b00      	cmp	r3, #0
 8026126:	bf0c      	ite	eq
 8026128:	2301      	moveq	r3, #1
 802612a:	2300      	movne	r3, #0
 802612c:	b2db      	uxtb	r3, r3
 802612e:	461a      	mov	r2, r3
 8026130:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026132:	655a      	str	r2, [r3, #84]	; 0x54
  for (row = 0; row < num_rows; row++) {
 8026134:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026136:	3301      	adds	r3, #1
 8026138:	63bb      	str	r3, [r7, #56]	; 0x38
 802613a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802613c:	683b      	ldr	r3, [r7, #0]
 802613e:	429a      	cmp	r2, r3
 8026140:	f6ff af49 	blt.w	8025fd6 <quantize_fs_dither+0x32>
  }
}
 8026144:	bf00      	nop
 8026146:	bf00      	nop
 8026148:	3750      	adds	r7, #80	; 0x50
 802614a:	46bd      	mov	sp, r7
 802614c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08026150 <alloc_fs_workspace>:
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
 8026150:	b580      	push	{r7, lr}
 8026152:	b086      	sub	sp, #24
 8026154:	af00      	add	r7, sp, #0
 8026156:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8026158:	687b      	ldr	r3, [r7, #4]
 802615a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 802615e:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 8026160:	687b      	ldr	r3, [r7, #4]
 8026162:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8026164:	3302      	adds	r3, #2
 8026166:	005b      	lsls	r3, r3, #1
 8026168:	60fb      	str	r3, [r7, #12]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802616a:	2300      	movs	r3, #0
 802616c:	617b      	str	r3, [r7, #20]
 802616e:	e010      	b.n	8026192 <alloc_fs_workspace+0x42>
    cquantize->fserrors[i] = (FSERRPTR)
      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
 8026170:	687b      	ldr	r3, [r7, #4]
 8026172:	685b      	ldr	r3, [r3, #4]
 8026174:	685b      	ldr	r3, [r3, #4]
 8026176:	68fa      	ldr	r2, [r7, #12]
 8026178:	2101      	movs	r1, #1
 802617a:	6878      	ldr	r0, [r7, #4]
 802617c:	4798      	blx	r3
 802617e:	4601      	mov	r1, r0
    cquantize->fserrors[i] = (FSERRPTR)
 8026180:	693a      	ldr	r2, [r7, #16]
 8026182:	697b      	ldr	r3, [r7, #20]
 8026184:	3310      	adds	r3, #16
 8026186:	009b      	lsls	r3, r3, #2
 8026188:	4413      	add	r3, r2
 802618a:	6059      	str	r1, [r3, #4]
  for (i = 0; i < cinfo->out_color_components; i++) {
 802618c:	697b      	ldr	r3, [r7, #20]
 802618e:	3301      	adds	r3, #1
 8026190:	617b      	str	r3, [r7, #20]
 8026192:	687b      	ldr	r3, [r7, #4]
 8026194:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8026196:	697a      	ldr	r2, [r7, #20]
 8026198:	429a      	cmp	r2, r3
 802619a:	dbe9      	blt.n	8026170 <alloc_fs_workspace+0x20>
  }
}
 802619c:	bf00      	nop
 802619e:	bf00      	nop
 80261a0:	3718      	adds	r7, #24
 80261a2:	46bd      	mov	sp, r7
 80261a4:	bd80      	pop	{r7, pc}
	...

080261a8 <start_pass_1_quant>:
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 80261a8:	b580      	push	{r7, lr}
 80261aa:	b086      	sub	sp, #24
 80261ac:	af00      	add	r7, sp, #0
 80261ae:	6078      	str	r0, [r7, #4]
 80261b0:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80261b2:	687b      	ldr	r3, [r7, #4]
 80261b4:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80261b8:	613b      	str	r3, [r7, #16]
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
 80261ba:	693b      	ldr	r3, [r7, #16]
 80261bc:	691a      	ldr	r2, [r3, #16]
 80261be:	687b      	ldr	r3, [r7, #4]
 80261c0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  cinfo->actual_number_of_colors = cquantize->sv_actual;
 80261c4:	693b      	ldr	r3, [r7, #16]
 80261c6:	695a      	ldr	r2, [r3, #20]
 80261c8:	687b      	ldr	r3, [r7, #4]
 80261ca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
 80261ce:	687b      	ldr	r3, [r7, #4]
 80261d0:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 80261d4:	2b02      	cmp	r3, #2
 80261d6:	d02f      	beq.n	8026238 <start_pass_1_quant+0x90>
 80261d8:	2b02      	cmp	r3, #2
 80261da:	dc56      	bgt.n	802628a <start_pass_1_quant+0xe2>
 80261dc:	2b00      	cmp	r3, #0
 80261de:	d002      	beq.n	80261e6 <start_pass_1_quant+0x3e>
 80261e0:	2b01      	cmp	r3, #1
 80261e2:	d00c      	beq.n	80261fe <start_pass_1_quant+0x56>
 80261e4:	e051      	b.n	802628a <start_pass_1_quant+0xe2>
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
 80261e6:	687b      	ldr	r3, [r7, #4]
 80261e8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80261ea:	2b03      	cmp	r3, #3
 80261ec:	d103      	bne.n	80261f6 <start_pass_1_quant+0x4e>
      cquantize->pub.color_quantize = color_quantize3;
 80261ee:	693b      	ldr	r3, [r7, #16]
 80261f0:	4a2d      	ldr	r2, [pc, #180]	; (80262a8 <start_pass_1_quant+0x100>)
 80261f2:	605a      	str	r2, [r3, #4]
    else
      cquantize->pub.color_quantize = color_quantize;
    break;
 80261f4:	e054      	b.n	80262a0 <start_pass_1_quant+0xf8>
      cquantize->pub.color_quantize = color_quantize;
 80261f6:	693b      	ldr	r3, [r7, #16]
 80261f8:	4a2c      	ldr	r2, [pc, #176]	; (80262ac <start_pass_1_quant+0x104>)
 80261fa:	605a      	str	r2, [r3, #4]
    break;
 80261fc:	e050      	b.n	80262a0 <start_pass_1_quant+0xf8>
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
 80261fe:	687b      	ldr	r3, [r7, #4]
 8026200:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8026202:	2b03      	cmp	r3, #3
 8026204:	d103      	bne.n	802620e <start_pass_1_quant+0x66>
      cquantize->pub.color_quantize = quantize3_ord_dither;
 8026206:	693b      	ldr	r3, [r7, #16]
 8026208:	4a29      	ldr	r2, [pc, #164]	; (80262b0 <start_pass_1_quant+0x108>)
 802620a:	605a      	str	r2, [r3, #4]
 802620c:	e002      	b.n	8026214 <start_pass_1_quant+0x6c>
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
 802620e:	693b      	ldr	r3, [r7, #16]
 8026210:	4a28      	ldr	r2, [pc, #160]	; (80262b4 <start_pass_1_quant+0x10c>)
 8026212:	605a      	str	r2, [r3, #4]
    cquantize->row_index = 0;	/* initialize state for ordered dither */
 8026214:	693b      	ldr	r3, [r7, #16]
 8026216:	2200      	movs	r2, #0
 8026218:	631a      	str	r2, [r3, #48]	; 0x30
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
 802621a:	693b      	ldr	r3, [r7, #16]
 802621c:	69db      	ldr	r3, [r3, #28]
 802621e:	2b00      	cmp	r3, #0
 8026220:	d102      	bne.n	8026228 <start_pass_1_quant+0x80>
      create_colorindex(cinfo);
 8026222:	6878      	ldr	r0, [r7, #4]
 8026224:	f7ff fbc6 	bl	80259b4 <create_colorindex>
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
 8026228:	693b      	ldr	r3, [r7, #16]
 802622a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802622c:	2b00      	cmp	r3, #0
 802622e:	d136      	bne.n	802629e <start_pass_1_quant+0xf6>
      create_odither_tables(cinfo);
 8026230:	6878      	ldr	r0, [r7, #4]
 8026232:	f7ff fcb5 	bl	8025ba0 <create_odither_tables>
    break;
 8026236:	e032      	b.n	802629e <start_pass_1_quant+0xf6>
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
 8026238:	693b      	ldr	r3, [r7, #16]
 802623a:	4a1f      	ldr	r2, [pc, #124]	; (80262b8 <start_pass_1_quant+0x110>)
 802623c:	605a      	str	r2, [r3, #4]
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
 802623e:	693b      	ldr	r3, [r7, #16]
 8026240:	2200      	movs	r2, #0
 8026242:	655a      	str	r2, [r3, #84]	; 0x54
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
 8026244:	693b      	ldr	r3, [r7, #16]
 8026246:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8026248:	2b00      	cmp	r3, #0
 802624a:	d102      	bne.n	8026252 <start_pass_1_quant+0xaa>
      alloc_fs_workspace(cinfo);
 802624c:	6878      	ldr	r0, [r7, #4]
 802624e:	f7ff ff7f 	bl	8026150 <alloc_fs_workspace>
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
 8026252:	687b      	ldr	r3, [r7, #4]
 8026254:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8026256:	3302      	adds	r3, #2
 8026258:	005b      	lsls	r3, r3, #1
 802625a:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < cinfo->out_color_components; i++)
 802625c:	2300      	movs	r3, #0
 802625e:	617b      	str	r3, [r7, #20]
 8026260:	e00d      	b.n	802627e <start_pass_1_quant+0xd6>
      FMEMZERO((void FAR *) cquantize->fserrors[i], arraysize);
 8026262:	693a      	ldr	r2, [r7, #16]
 8026264:	697b      	ldr	r3, [r7, #20]
 8026266:	3310      	adds	r3, #16
 8026268:	009b      	lsls	r3, r3, #2
 802626a:	4413      	add	r3, r2
 802626c:	685b      	ldr	r3, [r3, #4]
 802626e:	68fa      	ldr	r2, [r7, #12]
 8026270:	2100      	movs	r1, #0
 8026272:	4618      	mov	r0, r3
 8026274:	f002 f804 	bl	8028280 <memset>
    for (i = 0; i < cinfo->out_color_components; i++)
 8026278:	697b      	ldr	r3, [r7, #20]
 802627a:	3301      	adds	r3, #1
 802627c:	617b      	str	r3, [r7, #20]
 802627e:	687b      	ldr	r3, [r7, #4]
 8026280:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8026282:	697a      	ldr	r2, [r7, #20]
 8026284:	429a      	cmp	r2, r3
 8026286:	dbec      	blt.n	8026262 <start_pass_1_quant+0xba>
    break;
 8026288:	e00a      	b.n	80262a0 <start_pass_1_quant+0xf8>
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
 802628a:	687b      	ldr	r3, [r7, #4]
 802628c:	681b      	ldr	r3, [r3, #0]
 802628e:	2231      	movs	r2, #49	; 0x31
 8026290:	615a      	str	r2, [r3, #20]
 8026292:	687b      	ldr	r3, [r7, #4]
 8026294:	681b      	ldr	r3, [r3, #0]
 8026296:	681b      	ldr	r3, [r3, #0]
 8026298:	6878      	ldr	r0, [r7, #4]
 802629a:	4798      	blx	r3
    break;
 802629c:	e000      	b.n	80262a0 <start_pass_1_quant+0xf8>
    break;
 802629e:	bf00      	nop
  }
}
 80262a0:	bf00      	nop
 80262a2:	3718      	adds	r7, #24
 80262a4:	46bd      	mov	sp, r7
 80262a6:	bd80      	pop	{r7, pc}
 80262a8:	08025cd1 	.word	0x08025cd1
 80262ac:	08025c33 	.word	0x08025c33
 80262b0:	08025e81 	.word	0x08025e81
 80262b4:	08025d83 	.word	0x08025d83
 80262b8:	08025fa5 	.word	0x08025fa5

080262bc <finish_pass_1_quant>:
 * Finish up at the end of the pass.
 */

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
 80262bc:	b480      	push	{r7}
 80262be:	b083      	sub	sp, #12
 80262c0:	af00      	add	r7, sp, #0
 80262c2:	6078      	str	r0, [r7, #4]
  /* no work in 1-pass case */
}
 80262c4:	bf00      	nop
 80262c6:	370c      	adds	r7, #12
 80262c8:	46bd      	mov	sp, r7
 80262ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80262ce:	4770      	bx	lr

080262d0 <new_color_map_1_quant>:
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
 80262d0:	b580      	push	{r7, lr}
 80262d2:	b082      	sub	sp, #8
 80262d4:	af00      	add	r7, sp, #0
 80262d6:	6078      	str	r0, [r7, #4]
  ERREXIT(cinfo, JERR_MODE_CHANGE);
 80262d8:	687b      	ldr	r3, [r7, #4]
 80262da:	681b      	ldr	r3, [r3, #0]
 80262dc:	222f      	movs	r2, #47	; 0x2f
 80262de:	615a      	str	r2, [r3, #20]
 80262e0:	687b      	ldr	r3, [r7, #4]
 80262e2:	681b      	ldr	r3, [r3, #0]
 80262e4:	681b      	ldr	r3, [r3, #0]
 80262e6:	6878      	ldr	r0, [r7, #4]
 80262e8:	4798      	blx	r3
}
 80262ea:	bf00      	nop
 80262ec:	3708      	adds	r7, #8
 80262ee:	46bd      	mov	sp, r7
 80262f0:	bd80      	pop	{r7, pc}
	...

080262f4 <jinit_1pass_quantizer>:
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
 80262f4:	b580      	push	{r7, lr}
 80262f6:	b084      	sub	sp, #16
 80262f8:	af00      	add	r7, sp, #0
 80262fa:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80262fc:	687b      	ldr	r3, [r7, #4]
 80262fe:	685b      	ldr	r3, [r3, #4]
 8026300:	681b      	ldr	r3, [r3, #0]
 8026302:	2258      	movs	r2, #88	; 0x58
 8026304:	2101      	movs	r1, #1
 8026306:	6878      	ldr	r0, [r7, #4]
 8026308:	4798      	blx	r3
 802630a:	60f8      	str	r0, [r7, #12]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 802630c:	687b      	ldr	r3, [r7, #4]
 802630e:	68fa      	ldr	r2, [r7, #12]
 8026310:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
  cquantize->pub.start_pass = start_pass_1_quant;
 8026314:	68fb      	ldr	r3, [r7, #12]
 8026316:	4a22      	ldr	r2, [pc, #136]	; (80263a0 <jinit_1pass_quantizer+0xac>)
 8026318:	601a      	str	r2, [r3, #0]
  cquantize->pub.finish_pass = finish_pass_1_quant;
 802631a:	68fb      	ldr	r3, [r7, #12]
 802631c:	4a21      	ldr	r2, [pc, #132]	; (80263a4 <jinit_1pass_quantizer+0xb0>)
 802631e:	609a      	str	r2, [r3, #8]
  cquantize->pub.new_color_map = new_color_map_1_quant;
 8026320:	68fb      	ldr	r3, [r7, #12]
 8026322:	4a21      	ldr	r2, [pc, #132]	; (80263a8 <jinit_1pass_quantizer+0xb4>)
 8026324:	60da      	str	r2, [r3, #12]
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
 8026326:	68fb      	ldr	r3, [r7, #12]
 8026328:	2200      	movs	r2, #0
 802632a:	645a      	str	r2, [r3, #68]	; 0x44
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
 802632c:	68fb      	ldr	r3, [r7, #12]
 802632e:	2200      	movs	r2, #0
 8026330:	635a      	str	r2, [r3, #52]	; 0x34

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
 8026332:	687b      	ldr	r3, [r7, #4]
 8026334:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8026336:	2b04      	cmp	r3, #4
 8026338:	dd0c      	ble.n	8026354 <jinit_1pass_quantizer+0x60>
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
 802633a:	687b      	ldr	r3, [r7, #4]
 802633c:	681b      	ldr	r3, [r3, #0]
 802633e:	2239      	movs	r2, #57	; 0x39
 8026340:	615a      	str	r2, [r3, #20]
 8026342:	687b      	ldr	r3, [r7, #4]
 8026344:	681b      	ldr	r3, [r3, #0]
 8026346:	2204      	movs	r2, #4
 8026348:	619a      	str	r2, [r3, #24]
 802634a:	687b      	ldr	r3, [r7, #4]
 802634c:	681b      	ldr	r3, [r3, #0]
 802634e:	681b      	ldr	r3, [r3, #0]
 8026350:	6878      	ldr	r0, [r7, #4]
 8026352:	4798      	blx	r3
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
 8026354:	687b      	ldr	r3, [r7, #4]
 8026356:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8026358:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802635c:	dd0d      	ble.n	802637a <jinit_1pass_quantizer+0x86>
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
 802635e:	687b      	ldr	r3, [r7, #4]
 8026360:	681b      	ldr	r3, [r3, #0]
 8026362:	223b      	movs	r2, #59	; 0x3b
 8026364:	615a      	str	r2, [r3, #20]
 8026366:	687b      	ldr	r3, [r7, #4]
 8026368:	681b      	ldr	r3, [r3, #0]
 802636a:	f44f 7280 	mov.w	r2, #256	; 0x100
 802636e:	619a      	str	r2, [r3, #24]
 8026370:	687b      	ldr	r3, [r7, #4]
 8026372:	681b      	ldr	r3, [r3, #0]
 8026374:	681b      	ldr	r3, [r3, #0]
 8026376:	6878      	ldr	r0, [r7, #4]
 8026378:	4798      	blx	r3

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
 802637a:	6878      	ldr	r0, [r7, #4]
 802637c:	f7ff fa74 	bl	8025868 <create_colormap>
  create_colorindex(cinfo);
 8026380:	6878      	ldr	r0, [r7, #4]
 8026382:	f7ff fb17 	bl	80259b4 <create_colorindex>
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
 8026386:	687b      	ldr	r3, [r7, #4]
 8026388:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 802638c:	2b02      	cmp	r3, #2
 802638e:	d102      	bne.n	8026396 <jinit_1pass_quantizer+0xa2>
    alloc_fs_workspace(cinfo);
 8026390:	6878      	ldr	r0, [r7, #4]
 8026392:	f7ff fedd 	bl	8026150 <alloc_fs_workspace>
}
 8026396:	bf00      	nop
 8026398:	3710      	adds	r7, #16
 802639a:	46bd      	mov	sp, r7
 802639c:	bd80      	pop	{r7, pc}
 802639e:	bf00      	nop
 80263a0:	080261a9 	.word	0x080261a9
 80263a4:	080262bd 	.word	0x080262bd
 80263a8:	080262d1 	.word	0x080262d1

080263ac <prescan_quantize>:
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
 80263ac:	b4f0      	push	{r4, r5, r6, r7}
 80263ae:	b088      	sub	sp, #32
 80263b0:	af00      	add	r7, sp, #0
 80263b2:	60f8      	str	r0, [r7, #12]
 80263b4:	60b9      	str	r1, [r7, #8]
 80263b6:	607a      	str	r2, [r7, #4]
 80263b8:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80263ba:	68fb      	ldr	r3, [r7, #12]
 80263bc:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80263c0:	617b      	str	r3, [r7, #20]
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
 80263c2:	697b      	ldr	r3, [r7, #20]
 80263c4:	699e      	ldr	r6, [r3, #24]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 80263c6:	68fb      	ldr	r3, [r7, #12]
 80263c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80263ca:	613b      	str	r3, [r7, #16]

  for (row = 0; row < num_rows; row++) {
 80263cc:	2300      	movs	r3, #0
 80263ce:	61fb      	str	r3, [r7, #28]
 80263d0:	e02e      	b.n	8026430 <prescan_quantize+0x84>
    ptr = input_buf[row];
 80263d2:	69fb      	ldr	r3, [r7, #28]
 80263d4:	009b      	lsls	r3, r3, #2
 80263d6:	68ba      	ldr	r2, [r7, #8]
 80263d8:	4413      	add	r3, r2
 80263da:	681c      	ldr	r4, [r3, #0]
    for (col = width; col > 0; col--) {
 80263dc:	693b      	ldr	r3, [r7, #16]
 80263de:	61bb      	str	r3, [r7, #24]
 80263e0:	e020      	b.n	8026424 <prescan_quantize+0x78>
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 80263e2:	7823      	ldrb	r3, [r4, #0]
 80263e4:	08db      	lsrs	r3, r3, #3
 80263e6:	b2db      	uxtb	r3, r3
 80263e8:	009b      	lsls	r3, r3, #2
 80263ea:	4433      	add	r3, r6
 80263ec:	681a      	ldr	r2, [r3, #0]
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
 80263ee:	1c63      	adds	r3, r4, #1
 80263f0:	781b      	ldrb	r3, [r3, #0]
 80263f2:	089b      	lsrs	r3, r3, #2
 80263f4:	b2db      	uxtb	r3, r3
 80263f6:	019b      	lsls	r3, r3, #6
 80263f8:	441a      	add	r2, r3
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
 80263fa:	1ca3      	adds	r3, r4, #2
 80263fc:	781b      	ldrb	r3, [r3, #0]
 80263fe:	08db      	lsrs	r3, r3, #3
 8026400:	b2db      	uxtb	r3, r3
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
 8026402:	005b      	lsls	r3, r3, #1
 8026404:	18d5      	adds	r5, r2, r3
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
 8026406:	882b      	ldrh	r3, [r5, #0]
 8026408:	3301      	adds	r3, #1
 802640a:	b29b      	uxth	r3, r3
 802640c:	802b      	strh	r3, [r5, #0]
 802640e:	882b      	ldrh	r3, [r5, #0]
 8026410:	2b00      	cmp	r3, #0
 8026412:	d103      	bne.n	802641c <prescan_quantize+0x70>
	(*histp)--;
 8026414:	882b      	ldrh	r3, [r5, #0]
 8026416:	3b01      	subs	r3, #1
 8026418:	b29b      	uxth	r3, r3
 802641a:	802b      	strh	r3, [r5, #0]
      ptr += 3;
 802641c:	3403      	adds	r4, #3
    for (col = width; col > 0; col--) {
 802641e:	69bb      	ldr	r3, [r7, #24]
 8026420:	3b01      	subs	r3, #1
 8026422:	61bb      	str	r3, [r7, #24]
 8026424:	69bb      	ldr	r3, [r7, #24]
 8026426:	2b00      	cmp	r3, #0
 8026428:	d1db      	bne.n	80263e2 <prescan_quantize+0x36>
  for (row = 0; row < num_rows; row++) {
 802642a:	69fb      	ldr	r3, [r7, #28]
 802642c:	3301      	adds	r3, #1
 802642e:	61fb      	str	r3, [r7, #28]
 8026430:	69fa      	ldr	r2, [r7, #28]
 8026432:	683b      	ldr	r3, [r7, #0]
 8026434:	429a      	cmp	r2, r3
 8026436:	dbcc      	blt.n	80263d2 <prescan_quantize+0x26>
    }
  }
}
 8026438:	bf00      	nop
 802643a:	bf00      	nop
 802643c:	3720      	adds	r7, #32
 802643e:	46bd      	mov	sp, r7
 8026440:	bcf0      	pop	{r4, r5, r6, r7}
 8026442:	4770      	bx	lr

08026444 <find_biggest_color_pop>:

LOCAL(boxptr)
find_biggest_color_pop (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
{
 8026444:	b4f0      	push	{r4, r5, r6, r7}
 8026446:	b084      	sub	sp, #16
 8026448:	af00      	add	r7, sp, #0
 802644a:	6078      	str	r0, [r7, #4]
 802644c:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register long maxc = 0;
 802644e:	2600      	movs	r6, #0
  boxptr which = NULL;
 8026450:	2300      	movs	r3, #0
 8026452:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 8026454:	2500      	movs	r5, #0
 8026456:	687c      	ldr	r4, [r7, #4]
 8026458:	e009      	b.n	802646e <find_biggest_color_pop+0x2a>
    if (boxp->colorcount > maxc && boxp->volume > 0) {
 802645a:	69e3      	ldr	r3, [r4, #28]
 802645c:	429e      	cmp	r6, r3
 802645e:	da04      	bge.n	802646a <find_biggest_color_pop+0x26>
 8026460:	69a3      	ldr	r3, [r4, #24]
 8026462:	2b00      	cmp	r3, #0
 8026464:	dd01      	ble.n	802646a <find_biggest_color_pop+0x26>
      which = boxp;
 8026466:	60fc      	str	r4, [r7, #12]
      maxc = boxp->colorcount;
 8026468:	69e6      	ldr	r6, [r4, #28]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 802646a:	3501      	adds	r5, #1
 802646c:	3420      	adds	r4, #32
 802646e:	683b      	ldr	r3, [r7, #0]
 8026470:	429d      	cmp	r5, r3
 8026472:	dbf2      	blt.n	802645a <find_biggest_color_pop+0x16>
    }
  }
  return which;
 8026474:	68fb      	ldr	r3, [r7, #12]
}
 8026476:	4618      	mov	r0, r3
 8026478:	3710      	adds	r7, #16
 802647a:	46bd      	mov	sp, r7
 802647c:	bcf0      	pop	{r4, r5, r6, r7}
 802647e:	4770      	bx	lr

08026480 <find_biggest_volume>:

LOCAL(boxptr)
find_biggest_volume (boxptr boxlist, int numboxes)
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
{
 8026480:	b4f0      	push	{r4, r5, r6, r7}
 8026482:	b084      	sub	sp, #16
 8026484:	af00      	add	r7, sp, #0
 8026486:	6078      	str	r0, [r7, #4]
 8026488:	6039      	str	r1, [r7, #0]
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
 802648a:	2600      	movs	r6, #0
  boxptr which = NULL;
 802648c:	2300      	movs	r3, #0
 802648e:	60fb      	str	r3, [r7, #12]
  
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 8026490:	2500      	movs	r5, #0
 8026492:	687c      	ldr	r4, [r7, #4]
 8026494:	e006      	b.n	80264a4 <find_biggest_volume+0x24>
    if (boxp->volume > maxv) {
 8026496:	69a3      	ldr	r3, [r4, #24]
 8026498:	429e      	cmp	r6, r3
 802649a:	da01      	bge.n	80264a0 <find_biggest_volume+0x20>
      which = boxp;
 802649c:	60fc      	str	r4, [r7, #12]
      maxv = boxp->volume;
 802649e:	69a6      	ldr	r6, [r4, #24]
  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
 80264a0:	3501      	adds	r5, #1
 80264a2:	3420      	adds	r4, #32
 80264a4:	683b      	ldr	r3, [r7, #0]
 80264a6:	429d      	cmp	r5, r3
 80264a8:	dbf5      	blt.n	8026496 <find_biggest_volume+0x16>
    }
  }
  return which;
 80264aa:	68fb      	ldr	r3, [r7, #12]
}
 80264ac:	4618      	mov	r0, r3
 80264ae:	3710      	adds	r7, #16
 80264b0:	46bd      	mov	sp, r7
 80264b2:	bcf0      	pop	{r4, r5, r6, r7}
 80264b4:	4770      	bx	lr

080264b6 <update_box>:

LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
 80264b6:	b480      	push	{r7}
 80264b8:	b093      	sub	sp, #76	; 0x4c
 80264ba:	af00      	add	r7, sp, #0
 80264bc:	6078      	str	r0, [r7, #4]
 80264be:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80264c0:	687b      	ldr	r3, [r7, #4]
 80264c2:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80264c6:	61bb      	str	r3, [r7, #24]
  hist3d histogram = cquantize->histogram;
 80264c8:	69bb      	ldr	r3, [r7, #24]
 80264ca:	699b      	ldr	r3, [r3, #24]
 80264cc:	617b      	str	r3, [r7, #20]
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 80264ce:	683b      	ldr	r3, [r7, #0]
 80264d0:	681b      	ldr	r3, [r3, #0]
 80264d2:	637b      	str	r3, [r7, #52]	; 0x34
 80264d4:	683b      	ldr	r3, [r7, #0]
 80264d6:	685b      	ldr	r3, [r3, #4]
 80264d8:	633b      	str	r3, [r7, #48]	; 0x30
  c1min = boxp->c1min;  c1max = boxp->c1max;
 80264da:	683b      	ldr	r3, [r7, #0]
 80264dc:	689b      	ldr	r3, [r3, #8]
 80264de:	62fb      	str	r3, [r7, #44]	; 0x2c
 80264e0:	683b      	ldr	r3, [r7, #0]
 80264e2:	68db      	ldr	r3, [r3, #12]
 80264e4:	62bb      	str	r3, [r7, #40]	; 0x28
  c2min = boxp->c2min;  c2max = boxp->c2max;
 80264e6:	683b      	ldr	r3, [r7, #0]
 80264e8:	691b      	ldr	r3, [r3, #16]
 80264ea:	627b      	str	r3, [r7, #36]	; 0x24
 80264ec:	683b      	ldr	r3, [r7, #0]
 80264ee:	695b      	ldr	r3, [r3, #20]
 80264f0:	623b      	str	r3, [r7, #32]
  
  if (c0max > c0min)
 80264f2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80264f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80264f6:	429a      	cmp	r2, r3
 80264f8:	dd35      	ble.n	8026566 <update_box+0xb0>
    for (c0 = c0min; c0 <= c0max; c0++)
 80264fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80264fc:	643b      	str	r3, [r7, #64]	; 0x40
 80264fe:	e02e      	b.n	802655e <update_box+0xa8>
      for (c1 = c1min; c1 <= c1max; c1++) {
 8026500:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026502:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026504:	e024      	b.n	8026550 <update_box+0x9a>
	histp = & histogram[c0][c1][c2min];
 8026506:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026508:	009b      	lsls	r3, r3, #2
 802650a:	697a      	ldr	r2, [r7, #20]
 802650c:	4413      	add	r3, r2
 802650e:	681a      	ldr	r2, [r3, #0]
 8026510:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026512:	019b      	lsls	r3, r3, #6
 8026514:	441a      	add	r2, r3
 8026516:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026518:	005b      	lsls	r3, r3, #1
 802651a:	4413      	add	r3, r2
 802651c:	647b      	str	r3, [r7, #68]	; 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802651e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026520:	63bb      	str	r3, [r7, #56]	; 0x38
 8026522:	e00e      	b.n	8026542 <update_box+0x8c>
	  if (*histp++ != 0) {
 8026524:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026526:	1c9a      	adds	r2, r3, #2
 8026528:	647a      	str	r2, [r7, #68]	; 0x44
 802652a:	881b      	ldrh	r3, [r3, #0]
 802652c:	2b00      	cmp	r3, #0
 802652e:	d005      	beq.n	802653c <update_box+0x86>
	    boxp->c0min = c0min = c0;
 8026530:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026532:	637b      	str	r3, [r7, #52]	; 0x34
 8026534:	683b      	ldr	r3, [r7, #0]
 8026536:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8026538:	601a      	str	r2, [r3, #0]
	    goto have_c0min;
 802653a:	e015      	b.n	8026568 <update_box+0xb2>
	for (c2 = c2min; c2 <= c2max; c2++)
 802653c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802653e:	3301      	adds	r3, #1
 8026540:	63bb      	str	r3, [r7, #56]	; 0x38
 8026542:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8026544:	6a3b      	ldr	r3, [r7, #32]
 8026546:	429a      	cmp	r2, r3
 8026548:	ddec      	ble.n	8026524 <update_box+0x6e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 802654a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802654c:	3301      	adds	r3, #1
 802654e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026550:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8026552:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026554:	429a      	cmp	r2, r3
 8026556:	ddd6      	ble.n	8026506 <update_box+0x50>
    for (c0 = c0min; c0 <= c0max; c0++)
 8026558:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802655a:	3301      	adds	r3, #1
 802655c:	643b      	str	r3, [r7, #64]	; 0x40
 802655e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8026560:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026562:	429a      	cmp	r2, r3
 8026564:	ddcc      	ble.n	8026500 <update_box+0x4a>
	  }
      }
 have_c0min:
 8026566:	bf00      	nop
  if (c0max > c0min)
 8026568:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802656a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802656c:	429a      	cmp	r2, r3
 802656e:	dd35      	ble.n	80265dc <update_box+0x126>
    for (c0 = c0max; c0 >= c0min; c0--)
 8026570:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026572:	643b      	str	r3, [r7, #64]	; 0x40
 8026574:	e02e      	b.n	80265d4 <update_box+0x11e>
      for (c1 = c1min; c1 <= c1max; c1++) {
 8026576:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026578:	63fb      	str	r3, [r7, #60]	; 0x3c
 802657a:	e024      	b.n	80265c6 <update_box+0x110>
	histp = & histogram[c0][c1][c2min];
 802657c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802657e:	009b      	lsls	r3, r3, #2
 8026580:	697a      	ldr	r2, [r7, #20]
 8026582:	4413      	add	r3, r2
 8026584:	681a      	ldr	r2, [r3, #0]
 8026586:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026588:	019b      	lsls	r3, r3, #6
 802658a:	441a      	add	r2, r3
 802658c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802658e:	005b      	lsls	r3, r3, #1
 8026590:	4413      	add	r3, r2
 8026592:	647b      	str	r3, [r7, #68]	; 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 8026594:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026596:	63bb      	str	r3, [r7, #56]	; 0x38
 8026598:	e00e      	b.n	80265b8 <update_box+0x102>
	  if (*histp++ != 0) {
 802659a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802659c:	1c9a      	adds	r2, r3, #2
 802659e:	647a      	str	r2, [r7, #68]	; 0x44
 80265a0:	881b      	ldrh	r3, [r3, #0]
 80265a2:	2b00      	cmp	r3, #0
 80265a4:	d005      	beq.n	80265b2 <update_box+0xfc>
	    boxp->c0max = c0max = c0;
 80265a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80265a8:	633b      	str	r3, [r7, #48]	; 0x30
 80265aa:	683b      	ldr	r3, [r7, #0]
 80265ac:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80265ae:	605a      	str	r2, [r3, #4]
	    goto have_c0max;
 80265b0:	e015      	b.n	80265de <update_box+0x128>
	for (c2 = c2min; c2 <= c2max; c2++)
 80265b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80265b4:	3301      	adds	r3, #1
 80265b6:	63bb      	str	r3, [r7, #56]	; 0x38
 80265b8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80265ba:	6a3b      	ldr	r3, [r7, #32]
 80265bc:	429a      	cmp	r2, r3
 80265be:	ddec      	ble.n	802659a <update_box+0xe4>
      for (c1 = c1min; c1 <= c1max; c1++) {
 80265c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80265c2:	3301      	adds	r3, #1
 80265c4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80265c6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80265c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80265ca:	429a      	cmp	r2, r3
 80265cc:	ddd6      	ble.n	802657c <update_box+0xc6>
    for (c0 = c0max; c0 >= c0min; c0--)
 80265ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80265d0:	3b01      	subs	r3, #1
 80265d2:	643b      	str	r3, [r7, #64]	; 0x40
 80265d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80265d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80265d8:	429a      	cmp	r2, r3
 80265da:	dacc      	bge.n	8026576 <update_box+0xc0>
	  }
      }
 have_c0max:
 80265dc:	bf00      	nop
  if (c1max > c1min)
 80265de:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80265e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80265e2:	429a      	cmp	r2, r3
 80265e4:	dd35      	ble.n	8026652 <update_box+0x19c>
    for (c1 = c1min; c1 <= c1max; c1++)
 80265e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80265e8:	63fb      	str	r3, [r7, #60]	; 0x3c
 80265ea:	e02e      	b.n	802664a <update_box+0x194>
      for (c0 = c0min; c0 <= c0max; c0++) {
 80265ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80265ee:	643b      	str	r3, [r7, #64]	; 0x40
 80265f0:	e024      	b.n	802663c <update_box+0x186>
	histp = & histogram[c0][c1][c2min];
 80265f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80265f4:	009b      	lsls	r3, r3, #2
 80265f6:	697a      	ldr	r2, [r7, #20]
 80265f8:	4413      	add	r3, r2
 80265fa:	681a      	ldr	r2, [r3, #0]
 80265fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80265fe:	019b      	lsls	r3, r3, #6
 8026600:	441a      	add	r2, r3
 8026602:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026604:	005b      	lsls	r3, r3, #1
 8026606:	4413      	add	r3, r2
 8026608:	647b      	str	r3, [r7, #68]	; 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 802660a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802660c:	63bb      	str	r3, [r7, #56]	; 0x38
 802660e:	e00e      	b.n	802662e <update_box+0x178>
	  if (*histp++ != 0) {
 8026610:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026612:	1c9a      	adds	r2, r3, #2
 8026614:	647a      	str	r2, [r7, #68]	; 0x44
 8026616:	881b      	ldrh	r3, [r3, #0]
 8026618:	2b00      	cmp	r3, #0
 802661a:	d005      	beq.n	8026628 <update_box+0x172>
	    boxp->c1min = c1min = c1;
 802661c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802661e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8026620:	683b      	ldr	r3, [r7, #0]
 8026622:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8026624:	609a      	str	r2, [r3, #8]
	    goto have_c1min;
 8026626:	e015      	b.n	8026654 <update_box+0x19e>
	for (c2 = c2min; c2 <= c2max; c2++)
 8026628:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802662a:	3301      	adds	r3, #1
 802662c:	63bb      	str	r3, [r7, #56]	; 0x38
 802662e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8026630:	6a3b      	ldr	r3, [r7, #32]
 8026632:	429a      	cmp	r2, r3
 8026634:	ddec      	ble.n	8026610 <update_box+0x15a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 8026636:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026638:	3301      	adds	r3, #1
 802663a:	643b      	str	r3, [r7, #64]	; 0x40
 802663c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 802663e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026640:	429a      	cmp	r2, r3
 8026642:	ddd6      	ble.n	80265f2 <update_box+0x13c>
    for (c1 = c1min; c1 <= c1max; c1++)
 8026644:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026646:	3301      	adds	r3, #1
 8026648:	63fb      	str	r3, [r7, #60]	; 0x3c
 802664a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 802664c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802664e:	429a      	cmp	r2, r3
 8026650:	ddcc      	ble.n	80265ec <update_box+0x136>
	  }
      }
 have_c1min:
 8026652:	bf00      	nop
  if (c1max > c1min)
 8026654:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8026656:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026658:	429a      	cmp	r2, r3
 802665a:	dd35      	ble.n	80266c8 <update_box+0x212>
    for (c1 = c1max; c1 >= c1min; c1--)
 802665c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802665e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026660:	e02e      	b.n	80266c0 <update_box+0x20a>
      for (c0 = c0min; c0 <= c0max; c0++) {
 8026662:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026664:	643b      	str	r3, [r7, #64]	; 0x40
 8026666:	e024      	b.n	80266b2 <update_box+0x1fc>
	histp = & histogram[c0][c1][c2min];
 8026668:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802666a:	009b      	lsls	r3, r3, #2
 802666c:	697a      	ldr	r2, [r7, #20]
 802666e:	4413      	add	r3, r2
 8026670:	681a      	ldr	r2, [r3, #0]
 8026672:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026674:	019b      	lsls	r3, r3, #6
 8026676:	441a      	add	r2, r3
 8026678:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802667a:	005b      	lsls	r3, r3, #1
 802667c:	4413      	add	r3, r2
 802667e:	647b      	str	r3, [r7, #68]	; 0x44
	for (c2 = c2min; c2 <= c2max; c2++)
 8026680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026682:	63bb      	str	r3, [r7, #56]	; 0x38
 8026684:	e00e      	b.n	80266a4 <update_box+0x1ee>
	  if (*histp++ != 0) {
 8026686:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026688:	1c9a      	adds	r2, r3, #2
 802668a:	647a      	str	r2, [r7, #68]	; 0x44
 802668c:	881b      	ldrh	r3, [r3, #0]
 802668e:	2b00      	cmp	r3, #0
 8026690:	d005      	beq.n	802669e <update_box+0x1e8>
	    boxp->c1max = c1max = c1;
 8026692:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026694:	62bb      	str	r3, [r7, #40]	; 0x28
 8026696:	683b      	ldr	r3, [r7, #0]
 8026698:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802669a:	60da      	str	r2, [r3, #12]
	    goto have_c1max;
 802669c:	e015      	b.n	80266ca <update_box+0x214>
	for (c2 = c2min; c2 <= c2max; c2++)
 802669e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266a0:	3301      	adds	r3, #1
 80266a2:	63bb      	str	r3, [r7, #56]	; 0x38
 80266a4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80266a6:	6a3b      	ldr	r3, [r7, #32]
 80266a8:	429a      	cmp	r2, r3
 80266aa:	ddec      	ble.n	8026686 <update_box+0x1d0>
      for (c0 = c0min; c0 <= c0max; c0++) {
 80266ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80266ae:	3301      	adds	r3, #1
 80266b0:	643b      	str	r3, [r7, #64]	; 0x40
 80266b2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80266b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80266b6:	429a      	cmp	r2, r3
 80266b8:	ddd6      	ble.n	8026668 <update_box+0x1b2>
    for (c1 = c1max; c1 >= c1min; c1--)
 80266ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80266bc:	3b01      	subs	r3, #1
 80266be:	63fb      	str	r3, [r7, #60]	; 0x3c
 80266c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80266c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80266c4:	429a      	cmp	r2, r3
 80266c6:	dacc      	bge.n	8026662 <update_box+0x1ac>
	  }
      }
 have_c1max:
 80266c8:	bf00      	nop
  if (c2max > c2min)
 80266ca:	6a3a      	ldr	r2, [r7, #32]
 80266cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80266ce:	429a      	cmp	r2, r3
 80266d0:	dd36      	ble.n	8026740 <update_box+0x28a>
    for (c2 = c2min; c2 <= c2max; c2++)
 80266d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80266d4:	63bb      	str	r3, [r7, #56]	; 0x38
 80266d6:	e02f      	b.n	8026738 <update_box+0x282>
      for (c0 = c0min; c0 <= c0max; c0++) {
 80266d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80266da:	643b      	str	r3, [r7, #64]	; 0x40
 80266dc:	e025      	b.n	802672a <update_box+0x274>
	histp = & histogram[c0][c1min][c2];
 80266de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80266e0:	009b      	lsls	r3, r3, #2
 80266e2:	697a      	ldr	r2, [r7, #20]
 80266e4:	4413      	add	r3, r2
 80266e6:	681a      	ldr	r2, [r3, #0]
 80266e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80266ea:	019b      	lsls	r3, r3, #6
 80266ec:	441a      	add	r2, r3
 80266ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80266f0:	005b      	lsls	r3, r3, #1
 80266f2:	4413      	add	r3, r2
 80266f4:	647b      	str	r3, [r7, #68]	; 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 80266f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80266f8:	63fb      	str	r3, [r7, #60]	; 0x3c
 80266fa:	e00f      	b.n	802671c <update_box+0x266>
	  if (*histp != 0) {
 80266fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80266fe:	881b      	ldrh	r3, [r3, #0]
 8026700:	2b00      	cmp	r3, #0
 8026702:	d005      	beq.n	8026710 <update_box+0x25a>
	    boxp->c2min = c2min = c2;
 8026704:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026706:	627b      	str	r3, [r7, #36]	; 0x24
 8026708:	683b      	ldr	r3, [r7, #0]
 802670a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802670c:	611a      	str	r2, [r3, #16]
	    goto have_c2min;
 802670e:	e018      	b.n	8026742 <update_box+0x28c>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 8026710:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026712:	3301      	adds	r3, #1
 8026714:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026716:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026718:	3340      	adds	r3, #64	; 0x40
 802671a:	647b      	str	r3, [r7, #68]	; 0x44
 802671c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 802671e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026720:	429a      	cmp	r2, r3
 8026722:	ddeb      	ble.n	80266fc <update_box+0x246>
      for (c0 = c0min; c0 <= c0max; c0++) {
 8026724:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026726:	3301      	adds	r3, #1
 8026728:	643b      	str	r3, [r7, #64]	; 0x40
 802672a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 802672c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802672e:	429a      	cmp	r2, r3
 8026730:	ddd5      	ble.n	80266de <update_box+0x228>
    for (c2 = c2min; c2 <= c2max; c2++)
 8026732:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026734:	3301      	adds	r3, #1
 8026736:	63bb      	str	r3, [r7, #56]	; 0x38
 8026738:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802673a:	6a3b      	ldr	r3, [r7, #32]
 802673c:	429a      	cmp	r2, r3
 802673e:	ddcb      	ble.n	80266d8 <update_box+0x222>
	  }
      }
 have_c2min:
 8026740:	bf00      	nop
  if (c2max > c2min)
 8026742:	6a3a      	ldr	r2, [r7, #32]
 8026744:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026746:	429a      	cmp	r2, r3
 8026748:	dd36      	ble.n	80267b8 <update_box+0x302>
    for (c2 = c2max; c2 >= c2min; c2--)
 802674a:	6a3b      	ldr	r3, [r7, #32]
 802674c:	63bb      	str	r3, [r7, #56]	; 0x38
 802674e:	e02f      	b.n	80267b0 <update_box+0x2fa>
      for (c0 = c0min; c0 <= c0max; c0++) {
 8026750:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026752:	643b      	str	r3, [r7, #64]	; 0x40
 8026754:	e025      	b.n	80267a2 <update_box+0x2ec>
	histp = & histogram[c0][c1min][c2];
 8026756:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026758:	009b      	lsls	r3, r3, #2
 802675a:	697a      	ldr	r2, [r7, #20]
 802675c:	4413      	add	r3, r2
 802675e:	681a      	ldr	r2, [r3, #0]
 8026760:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026762:	019b      	lsls	r3, r3, #6
 8026764:	441a      	add	r2, r3
 8026766:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026768:	005b      	lsls	r3, r3, #1
 802676a:	4413      	add	r3, r2
 802676c:	647b      	str	r3, [r7, #68]	; 0x44
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 802676e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026770:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026772:	e00f      	b.n	8026794 <update_box+0x2de>
	  if (*histp != 0) {
 8026774:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026776:	881b      	ldrh	r3, [r3, #0]
 8026778:	2b00      	cmp	r3, #0
 802677a:	d005      	beq.n	8026788 <update_box+0x2d2>
	    boxp->c2max = c2max = c2;
 802677c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802677e:	623b      	str	r3, [r7, #32]
 8026780:	683b      	ldr	r3, [r7, #0]
 8026782:	6a3a      	ldr	r2, [r7, #32]
 8026784:	615a      	str	r2, [r3, #20]
	    goto have_c2max;
 8026786:	e018      	b.n	80267ba <update_box+0x304>
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
 8026788:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802678a:	3301      	adds	r3, #1
 802678c:	63fb      	str	r3, [r7, #60]	; 0x3c
 802678e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026790:	3340      	adds	r3, #64	; 0x40
 8026792:	647b      	str	r3, [r7, #68]	; 0x44
 8026794:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8026796:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026798:	429a      	cmp	r2, r3
 802679a:	ddeb      	ble.n	8026774 <update_box+0x2be>
      for (c0 = c0min; c0 <= c0max; c0++) {
 802679c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802679e:	3301      	adds	r3, #1
 80267a0:	643b      	str	r3, [r7, #64]	; 0x40
 80267a2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80267a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80267a6:	429a      	cmp	r2, r3
 80267a8:	ddd5      	ble.n	8026756 <update_box+0x2a0>
    for (c2 = c2max; c2 >= c2min; c2--)
 80267aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80267ac:	3b01      	subs	r3, #1
 80267ae:	63bb      	str	r3, [r7, #56]	; 0x38
 80267b0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80267b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80267b4:	429a      	cmp	r2, r3
 80267b6:	dacb      	bge.n	8026750 <update_box+0x29a>
	  }
      }
 have_c2max:
 80267b8:	bf00      	nop
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
 80267ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80267bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80267be:	1ad3      	subs	r3, r2, r3
 80267c0:	00db      	lsls	r3, r3, #3
 80267c2:	005b      	lsls	r3, r3, #1
 80267c4:	613b      	str	r3, [r7, #16]
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
 80267c6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80267c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80267ca:	1ad3      	subs	r3, r2, r3
 80267cc:	009a      	lsls	r2, r3, #2
 80267ce:	4613      	mov	r3, r2
 80267d0:	005b      	lsls	r3, r3, #1
 80267d2:	4413      	add	r3, r2
 80267d4:	60fb      	str	r3, [r7, #12]
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
 80267d6:	6a3a      	ldr	r2, [r7, #32]
 80267d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80267da:	1ad3      	subs	r3, r2, r3
 80267dc:	00db      	lsls	r3, r3, #3
 80267de:	60bb      	str	r3, [r7, #8]
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
 80267e0:	693b      	ldr	r3, [r7, #16]
 80267e2:	fb03 f203 	mul.w	r2, r3, r3
 80267e6:	68fb      	ldr	r3, [r7, #12]
 80267e8:	fb03 f303 	mul.w	r3, r3, r3
 80267ec:	441a      	add	r2, r3
 80267ee:	68bb      	ldr	r3, [r7, #8]
 80267f0:	fb03 f303 	mul.w	r3, r3, r3
 80267f4:	441a      	add	r2, r3
 80267f6:	683b      	ldr	r3, [r7, #0]
 80267f8:	619a      	str	r2, [r3, #24]
  
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
 80267fa:	2300      	movs	r3, #0
 80267fc:	61fb      	str	r3, [r7, #28]
  for (c0 = c0min; c0 <= c0max; c0++)
 80267fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8026800:	643b      	str	r3, [r7, #64]	; 0x40
 8026802:	e02c      	b.n	802685e <update_box+0x3a8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 8026804:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8026806:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026808:	e022      	b.n	8026850 <update_box+0x39a>
      histp = & histogram[c0][c1][c2min];
 802680a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802680c:	009b      	lsls	r3, r3, #2
 802680e:	697a      	ldr	r2, [r7, #20]
 8026810:	4413      	add	r3, r2
 8026812:	681a      	ldr	r2, [r3, #0]
 8026814:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026816:	019b      	lsls	r3, r3, #6
 8026818:	441a      	add	r2, r3
 802681a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802681c:	005b      	lsls	r3, r3, #1
 802681e:	4413      	add	r3, r2
 8026820:	647b      	str	r3, [r7, #68]	; 0x44
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 8026822:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026824:	63bb      	str	r3, [r7, #56]	; 0x38
 8026826:	e00c      	b.n	8026842 <update_box+0x38c>
	if (*histp != 0) {
 8026828:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802682a:	881b      	ldrh	r3, [r3, #0]
 802682c:	2b00      	cmp	r3, #0
 802682e:	d002      	beq.n	8026836 <update_box+0x380>
	  ccount++;
 8026830:	69fb      	ldr	r3, [r7, #28]
 8026832:	3301      	adds	r3, #1
 8026834:	61fb      	str	r3, [r7, #28]
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
 8026836:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026838:	3301      	adds	r3, #1
 802683a:	63bb      	str	r3, [r7, #56]	; 0x38
 802683c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802683e:	3302      	adds	r3, #2
 8026840:	647b      	str	r3, [r7, #68]	; 0x44
 8026842:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8026844:	6a3b      	ldr	r3, [r7, #32]
 8026846:	429a      	cmp	r2, r3
 8026848:	ddee      	ble.n	8026828 <update_box+0x372>
    for (c1 = c1min; c1 <= c1max; c1++) {
 802684a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802684c:	3301      	adds	r3, #1
 802684e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8026850:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8026852:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026854:	429a      	cmp	r2, r3
 8026856:	ddd8      	ble.n	802680a <update_box+0x354>
  for (c0 = c0min; c0 <= c0max; c0++)
 8026858:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802685a:	3301      	adds	r3, #1
 802685c:	643b      	str	r3, [r7, #64]	; 0x40
 802685e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8026860:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8026862:	429a      	cmp	r2, r3
 8026864:	ddce      	ble.n	8026804 <update_box+0x34e>
	}
    }
  boxp->colorcount = ccount;
 8026866:	683b      	ldr	r3, [r7, #0]
 8026868:	69fa      	ldr	r2, [r7, #28]
 802686a:	61da      	str	r2, [r3, #28]
}
 802686c:	bf00      	nop
 802686e:	374c      	adds	r7, #76	; 0x4c
 8026870:	46bd      	mov	sp, r7
 8026872:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026876:	4770      	bx	lr

08026878 <median_cut>:

LOCAL(int)
median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
	    int desired_colors)
/* Repeatedly select and split the largest box until we have enough boxes */
{
 8026878:	b5b0      	push	{r4, r5, r7, lr}
 802687a:	b08a      	sub	sp, #40	; 0x28
 802687c:	af00      	add	r7, sp, #0
 802687e:	60f8      	str	r0, [r7, #12]
 8026880:	60b9      	str	r1, [r7, #8]
 8026882:	607a      	str	r2, [r7, #4]
 8026884:	603b      	str	r3, [r7, #0]
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
 8026886:	e085      	b.n	8026994 <median_cut+0x11c>
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
 8026888:	687b      	ldr	r3, [r7, #4]
 802688a:	005b      	lsls	r3, r3, #1
 802688c:	683a      	ldr	r2, [r7, #0]
 802688e:	429a      	cmp	r2, r3
 8026890:	db05      	blt.n	802689e <median_cut+0x26>
      b1 = find_biggest_color_pop(boxlist, numboxes);
 8026892:	6879      	ldr	r1, [r7, #4]
 8026894:	68b8      	ldr	r0, [r7, #8]
 8026896:	f7ff fdd5 	bl	8026444 <find_biggest_color_pop>
 802689a:	4604      	mov	r4, r0
 802689c:	e004      	b.n	80268a8 <median_cut+0x30>
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
 802689e:	6879      	ldr	r1, [r7, #4]
 80268a0:	68b8      	ldr	r0, [r7, #8]
 80268a2:	f7ff fded 	bl	8026480 <find_biggest_volume>
 80268a6:	4604      	mov	r4, r0
    }
    if (b1 == NULL)		/* no splittable boxes left! */
 80268a8:	2c00      	cmp	r4, #0
 80268aa:	d079      	beq.n	80269a0 <median_cut+0x128>
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
 80268ac:	687b      	ldr	r3, [r7, #4]
 80268ae:	015b      	lsls	r3, r3, #5
 80268b0:	68ba      	ldr	r2, [r7, #8]
 80268b2:	18d5      	adds	r5, r2, r3
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
 80268b4:	6863      	ldr	r3, [r4, #4]
 80268b6:	606b      	str	r3, [r5, #4]
 80268b8:	68e3      	ldr	r3, [r4, #12]
 80268ba:	60eb      	str	r3, [r5, #12]
 80268bc:	6963      	ldr	r3, [r4, #20]
 80268be:	616b      	str	r3, [r5, #20]
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
 80268c0:	6823      	ldr	r3, [r4, #0]
 80268c2:	602b      	str	r3, [r5, #0]
 80268c4:	68a3      	ldr	r3, [r4, #8]
 80268c6:	60ab      	str	r3, [r5, #8]
 80268c8:	6923      	ldr	r3, [r4, #16]
 80268ca:	612b      	str	r3, [r5, #16]
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
 80268cc:	6862      	ldr	r2, [r4, #4]
 80268ce:	6823      	ldr	r3, [r4, #0]
 80268d0:	1ad3      	subs	r3, r2, r3
 80268d2:	00db      	lsls	r3, r3, #3
 80268d4:	005b      	lsls	r3, r3, #1
 80268d6:	61fb      	str	r3, [r7, #28]
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
 80268d8:	68e2      	ldr	r2, [r4, #12]
 80268da:	68a3      	ldr	r3, [r4, #8]
 80268dc:	1ad3      	subs	r3, r2, r3
 80268de:	009a      	lsls	r2, r3, #2
 80268e0:	4613      	mov	r3, r2
 80268e2:	005b      	lsls	r3, r3, #1
 80268e4:	4413      	add	r3, r2
 80268e6:	61bb      	str	r3, [r7, #24]
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
 80268e8:	6962      	ldr	r2, [r4, #20]
 80268ea:	6923      	ldr	r3, [r4, #16]
 80268ec:	1ad3      	subs	r3, r2, r3
 80268ee:	00db      	lsls	r3, r3, #3
 80268f0:	617b      	str	r3, [r7, #20]
    /* We want to break any ties in favor of green, then red, blue last.
     * This code does the right thing for R,G,B or B,G,R color orders only.
     */
#if RGB_RED == 0
    cmax = c1; n = 1;
 80268f2:	69bb      	ldr	r3, [r7, #24]
 80268f4:	623b      	str	r3, [r7, #32]
 80268f6:	2301      	movs	r3, #1
 80268f8:	627b      	str	r3, [r7, #36]	; 0x24
    if (c0 > cmax) { cmax = c0; n = 0; }
 80268fa:	69fa      	ldr	r2, [r7, #28]
 80268fc:	6a3b      	ldr	r3, [r7, #32]
 80268fe:	429a      	cmp	r2, r3
 8026900:	dd03      	ble.n	802690a <median_cut+0x92>
 8026902:	69fb      	ldr	r3, [r7, #28]
 8026904:	623b      	str	r3, [r7, #32]
 8026906:	2300      	movs	r3, #0
 8026908:	627b      	str	r3, [r7, #36]	; 0x24
    if (c2 > cmax) { n = 2; }
 802690a:	697a      	ldr	r2, [r7, #20]
 802690c:	6a3b      	ldr	r3, [r7, #32]
 802690e:	429a      	cmp	r2, r3
 8026910:	dd01      	ble.n	8026916 <median_cut+0x9e>
 8026912:	2302      	movs	r3, #2
 8026914:	627b      	str	r3, [r7, #36]	; 0x24
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
 8026916:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026918:	2b02      	cmp	r3, #2
 802691a:	d023      	beq.n	8026964 <median_cut+0xec>
 802691c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802691e:	2b02      	cmp	r3, #2
 8026920:	dc2d      	bgt.n	802697e <median_cut+0x106>
 8026922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026924:	2b00      	cmp	r3, #0
 8026926:	d003      	beq.n	8026930 <median_cut+0xb8>
 8026928:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802692a:	2b01      	cmp	r3, #1
 802692c:	d00d      	beq.n	802694a <median_cut+0xd2>
 802692e:	e026      	b.n	802697e <median_cut+0x106>
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
 8026930:	6862      	ldr	r2, [r4, #4]
 8026932:	6823      	ldr	r3, [r4, #0]
 8026934:	4413      	add	r3, r2
 8026936:	0fda      	lsrs	r2, r3, #31
 8026938:	4413      	add	r3, r2
 802693a:	105b      	asrs	r3, r3, #1
 802693c:	613b      	str	r3, [r7, #16]
      b1->c0max = lb;
 802693e:	693b      	ldr	r3, [r7, #16]
 8026940:	6063      	str	r3, [r4, #4]
      b2->c0min = lb+1;
 8026942:	693b      	ldr	r3, [r7, #16]
 8026944:	3301      	adds	r3, #1
 8026946:	602b      	str	r3, [r5, #0]
      break;
 8026948:	e019      	b.n	802697e <median_cut+0x106>
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
 802694a:	68e2      	ldr	r2, [r4, #12]
 802694c:	68a3      	ldr	r3, [r4, #8]
 802694e:	4413      	add	r3, r2
 8026950:	0fda      	lsrs	r2, r3, #31
 8026952:	4413      	add	r3, r2
 8026954:	105b      	asrs	r3, r3, #1
 8026956:	613b      	str	r3, [r7, #16]
      b1->c1max = lb;
 8026958:	693b      	ldr	r3, [r7, #16]
 802695a:	60e3      	str	r3, [r4, #12]
      b2->c1min = lb+1;
 802695c:	693b      	ldr	r3, [r7, #16]
 802695e:	3301      	adds	r3, #1
 8026960:	60ab      	str	r3, [r5, #8]
      break;
 8026962:	e00c      	b.n	802697e <median_cut+0x106>
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
 8026964:	6962      	ldr	r2, [r4, #20]
 8026966:	6923      	ldr	r3, [r4, #16]
 8026968:	4413      	add	r3, r2
 802696a:	0fda      	lsrs	r2, r3, #31
 802696c:	4413      	add	r3, r2
 802696e:	105b      	asrs	r3, r3, #1
 8026970:	613b      	str	r3, [r7, #16]
      b1->c2max = lb;
 8026972:	693b      	ldr	r3, [r7, #16]
 8026974:	6163      	str	r3, [r4, #20]
      b2->c2min = lb+1;
 8026976:	693b      	ldr	r3, [r7, #16]
 8026978:	3301      	adds	r3, #1
 802697a:	612b      	str	r3, [r5, #16]
      break;
 802697c:	bf00      	nop
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
 802697e:	4621      	mov	r1, r4
 8026980:	68f8      	ldr	r0, [r7, #12]
 8026982:	f7ff fd98 	bl	80264b6 <update_box>
    update_box(cinfo, b2);
 8026986:	4629      	mov	r1, r5
 8026988:	68f8      	ldr	r0, [r7, #12]
 802698a:	f7ff fd94 	bl	80264b6 <update_box>
    numboxes++;
 802698e:	687b      	ldr	r3, [r7, #4]
 8026990:	3301      	adds	r3, #1
 8026992:	607b      	str	r3, [r7, #4]
  while (numboxes < desired_colors) {
 8026994:	687a      	ldr	r2, [r7, #4]
 8026996:	683b      	ldr	r3, [r7, #0]
 8026998:	429a      	cmp	r2, r3
 802699a:	f6ff af75 	blt.w	8026888 <median_cut+0x10>
 802699e:	e000      	b.n	80269a2 <median_cut+0x12a>
      break;
 80269a0:	bf00      	nop
  }
  return numboxes;
 80269a2:	687b      	ldr	r3, [r7, #4]
}
 80269a4:	4618      	mov	r0, r3
 80269a6:	3728      	adds	r7, #40	; 0x28
 80269a8:	46bd      	mov	sp, r7
 80269aa:	bdb0      	pop	{r4, r5, r7, pc}

080269ac <compute_color>:


LOCAL(void)
compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
/* Compute representative color for a box, put it in colormap[icolor] */
{
 80269ac:	b480      	push	{r7}
 80269ae:	b097      	sub	sp, #92	; 0x5c
 80269b0:	af00      	add	r7, sp, #0
 80269b2:	60f8      	str	r0, [r7, #12]
 80269b4:	60b9      	str	r1, [r7, #8]
 80269b6:	607a      	str	r2, [r7, #4]
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80269b8:	68fb      	ldr	r3, [r7, #12]
 80269ba:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80269be:	637b      	str	r3, [r7, #52]	; 0x34
  hist3d histogram = cquantize->histogram;
 80269c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80269c2:	699b      	ldr	r3, [r3, #24]
 80269c4:	633b      	str	r3, [r7, #48]	; 0x30
  histptr histp;
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  long count;
  long total = 0;
 80269c6:	2300      	movs	r3, #0
 80269c8:	647b      	str	r3, [r7, #68]	; 0x44
  long c0total = 0;
 80269ca:	2300      	movs	r3, #0
 80269cc:	643b      	str	r3, [r7, #64]	; 0x40
  long c1total = 0;
 80269ce:	2300      	movs	r3, #0
 80269d0:	63fb      	str	r3, [r7, #60]	; 0x3c
  long c2total = 0;
 80269d2:	2300      	movs	r3, #0
 80269d4:	63bb      	str	r3, [r7, #56]	; 0x38
  
  c0min = boxp->c0min;  c0max = boxp->c0max;
 80269d6:	68bb      	ldr	r3, [r7, #8]
 80269d8:	681b      	ldr	r3, [r3, #0]
 80269da:	62fb      	str	r3, [r7, #44]	; 0x2c
 80269dc:	68bb      	ldr	r3, [r7, #8]
 80269de:	685b      	ldr	r3, [r3, #4]
 80269e0:	62bb      	str	r3, [r7, #40]	; 0x28
  c1min = boxp->c1min;  c1max = boxp->c1max;
 80269e2:	68bb      	ldr	r3, [r7, #8]
 80269e4:	689b      	ldr	r3, [r3, #8]
 80269e6:	627b      	str	r3, [r7, #36]	; 0x24
 80269e8:	68bb      	ldr	r3, [r7, #8]
 80269ea:	68db      	ldr	r3, [r3, #12]
 80269ec:	623b      	str	r3, [r7, #32]
  c2min = boxp->c2min;  c2max = boxp->c2max;
 80269ee:	68bb      	ldr	r3, [r7, #8]
 80269f0:	691b      	ldr	r3, [r3, #16]
 80269f2:	61fb      	str	r3, [r7, #28]
 80269f4:	68bb      	ldr	r3, [r7, #8]
 80269f6:	695b      	ldr	r3, [r3, #20]
 80269f8:	61bb      	str	r3, [r7, #24]
  
  for (c0 = c0min; c0 <= c0max; c0++)
 80269fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80269fc:	653b      	str	r3, [r7, #80]	; 0x50
 80269fe:	e049      	b.n	8026a94 <compute_color+0xe8>
    for (c1 = c1min; c1 <= c1max; c1++) {
 8026a00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026a02:	64fb      	str	r3, [r7, #76]	; 0x4c
 8026a04:	e03f      	b.n	8026a86 <compute_color+0xda>
      histp = & histogram[c0][c1][c2min];
 8026a06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8026a08:	009b      	lsls	r3, r3, #2
 8026a0a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8026a0c:	4413      	add	r3, r2
 8026a0e:	681a      	ldr	r2, [r3, #0]
 8026a10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8026a12:	019b      	lsls	r3, r3, #6
 8026a14:	441a      	add	r2, r3
 8026a16:	69fb      	ldr	r3, [r7, #28]
 8026a18:	005b      	lsls	r3, r3, #1
 8026a1a:	4413      	add	r3, r2
 8026a1c:	657b      	str	r3, [r7, #84]	; 0x54
      for (c2 = c2min; c2 <= c2max; c2++) {
 8026a1e:	69fb      	ldr	r3, [r7, #28]
 8026a20:	64bb      	str	r3, [r7, #72]	; 0x48
 8026a22:	e029      	b.n	8026a78 <compute_color+0xcc>
	if ((count = *histp++) != 0) {
 8026a24:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8026a26:	1c9a      	adds	r2, r3, #2
 8026a28:	657a      	str	r2, [r7, #84]	; 0x54
 8026a2a:	881b      	ldrh	r3, [r3, #0]
 8026a2c:	617b      	str	r3, [r7, #20]
 8026a2e:	697b      	ldr	r3, [r7, #20]
 8026a30:	2b00      	cmp	r3, #0
 8026a32:	d01e      	beq.n	8026a72 <compute_color+0xc6>
	  total += count;
 8026a34:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8026a36:	697b      	ldr	r3, [r7, #20]
 8026a38:	4413      	add	r3, r2
 8026a3a:	647b      	str	r3, [r7, #68]	; 0x44
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
 8026a3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8026a3e:	00db      	lsls	r3, r3, #3
 8026a40:	3304      	adds	r3, #4
 8026a42:	697a      	ldr	r2, [r7, #20]
 8026a44:	fb02 f303 	mul.w	r3, r2, r3
 8026a48:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8026a4a:	4413      	add	r3, r2
 8026a4c:	643b      	str	r3, [r7, #64]	; 0x40
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
 8026a4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8026a50:	009b      	lsls	r3, r3, #2
 8026a52:	3302      	adds	r3, #2
 8026a54:	697a      	ldr	r2, [r7, #20]
 8026a56:	fb02 f303 	mul.w	r3, r2, r3
 8026a5a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8026a5c:	4413      	add	r3, r2
 8026a5e:	63fb      	str	r3, [r7, #60]	; 0x3c
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
 8026a60:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8026a62:	00db      	lsls	r3, r3, #3
 8026a64:	3304      	adds	r3, #4
 8026a66:	697a      	ldr	r2, [r7, #20]
 8026a68:	fb02 f303 	mul.w	r3, r2, r3
 8026a6c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8026a6e:	4413      	add	r3, r2
 8026a70:	63bb      	str	r3, [r7, #56]	; 0x38
      for (c2 = c2min; c2 <= c2max; c2++) {
 8026a72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8026a74:	3301      	adds	r3, #1
 8026a76:	64bb      	str	r3, [r7, #72]	; 0x48
 8026a78:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8026a7a:	69bb      	ldr	r3, [r7, #24]
 8026a7c:	429a      	cmp	r2, r3
 8026a7e:	ddd1      	ble.n	8026a24 <compute_color+0x78>
    for (c1 = c1min; c1 <= c1max; c1++) {
 8026a80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8026a82:	3301      	adds	r3, #1
 8026a84:	64fb      	str	r3, [r7, #76]	; 0x4c
 8026a86:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8026a88:	6a3b      	ldr	r3, [r7, #32]
 8026a8a:	429a      	cmp	r2, r3
 8026a8c:	ddbb      	ble.n	8026a06 <compute_color+0x5a>
  for (c0 = c0min; c0 <= c0max; c0++)
 8026a8e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8026a90:	3301      	adds	r3, #1
 8026a92:	653b      	str	r3, [r7, #80]	; 0x50
 8026a94:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8026a96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8026a98:	429a      	cmp	r2, r3
 8026a9a:	ddb1      	ble.n	8026a00 <compute_color+0x54>
	}
      }
    }
  
  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
 8026a9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026a9e:	105a      	asrs	r2, r3, #1
 8026aa0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8026aa2:	441a      	add	r2, r3
 8026aa4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026aa6:	fb92 f1f3 	sdiv	r1, r2, r3
 8026aaa:	68fb      	ldr	r3, [r7, #12]
 8026aac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026ab0:	681a      	ldr	r2, [r3, #0]
 8026ab2:	687b      	ldr	r3, [r7, #4]
 8026ab4:	4413      	add	r3, r2
 8026ab6:	b2ca      	uxtb	r2, r1
 8026ab8:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
 8026aba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026abc:	105a      	asrs	r2, r3, #1
 8026abe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8026ac0:	441a      	add	r2, r3
 8026ac2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026ac4:	fb92 f1f3 	sdiv	r1, r2, r3
 8026ac8:	68fb      	ldr	r3, [r7, #12]
 8026aca:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026ace:	3304      	adds	r3, #4
 8026ad0:	681a      	ldr	r2, [r3, #0]
 8026ad2:	687b      	ldr	r3, [r7, #4]
 8026ad4:	4413      	add	r3, r2
 8026ad6:	b2ca      	uxtb	r2, r1
 8026ad8:	701a      	strb	r2, [r3, #0]
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
 8026ada:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026adc:	105a      	asrs	r2, r3, #1
 8026ade:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8026ae0:	441a      	add	r2, r3
 8026ae2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8026ae4:	fb92 f1f3 	sdiv	r1, r2, r3
 8026ae8:	68fb      	ldr	r3, [r7, #12]
 8026aea:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026aee:	3308      	adds	r3, #8
 8026af0:	681a      	ldr	r2, [r3, #0]
 8026af2:	687b      	ldr	r3, [r7, #4]
 8026af4:	4413      	add	r3, r2
 8026af6:	b2ca      	uxtb	r2, r1
 8026af8:	701a      	strb	r2, [r3, #0]
}
 8026afa:	bf00      	nop
 8026afc:	375c      	adds	r7, #92	; 0x5c
 8026afe:	46bd      	mov	sp, r7
 8026b00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b04:	4770      	bx	lr

08026b06 <select_colors>:


LOCAL(void)
select_colors (j_decompress_ptr cinfo, int desired_colors)
/* Master routine for color selection */
{
 8026b06:	b580      	push	{r7, lr}
 8026b08:	b086      	sub	sp, #24
 8026b0a:	af00      	add	r7, sp, #0
 8026b0c:	6078      	str	r0, [r7, #4]
 8026b0e:	6039      	str	r1, [r7, #0]
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
 8026b10:	687b      	ldr	r3, [r7, #4]
 8026b12:	685b      	ldr	r3, [r3, #4]
 8026b14:	681b      	ldr	r3, [r3, #0]
 8026b16:	683a      	ldr	r2, [r7, #0]
 8026b18:	0152      	lsls	r2, r2, #5
 8026b1a:	2101      	movs	r1, #1
 8026b1c:	6878      	ldr	r0, [r7, #4]
 8026b1e:	4798      	blx	r3
 8026b20:	6138      	str	r0, [r7, #16]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
 8026b22:	2301      	movs	r3, #1
 8026b24:	60fb      	str	r3, [r7, #12]
  boxlist[0].c0min = 0;
 8026b26:	693b      	ldr	r3, [r7, #16]
 8026b28:	2200      	movs	r2, #0
 8026b2a:	601a      	str	r2, [r3, #0]
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
 8026b2c:	693b      	ldr	r3, [r7, #16]
 8026b2e:	221f      	movs	r2, #31
 8026b30:	605a      	str	r2, [r3, #4]
  boxlist[0].c1min = 0;
 8026b32:	693b      	ldr	r3, [r7, #16]
 8026b34:	2200      	movs	r2, #0
 8026b36:	609a      	str	r2, [r3, #8]
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
 8026b38:	693b      	ldr	r3, [r7, #16]
 8026b3a:	223f      	movs	r2, #63	; 0x3f
 8026b3c:	60da      	str	r2, [r3, #12]
  boxlist[0].c2min = 0;
 8026b3e:	693b      	ldr	r3, [r7, #16]
 8026b40:	2200      	movs	r2, #0
 8026b42:	611a      	str	r2, [r3, #16]
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
 8026b44:	693b      	ldr	r3, [r7, #16]
 8026b46:	221f      	movs	r2, #31
 8026b48:	615a      	str	r2, [r3, #20]
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
 8026b4a:	6939      	ldr	r1, [r7, #16]
 8026b4c:	6878      	ldr	r0, [r7, #4]
 8026b4e:	f7ff fcb2 	bl	80264b6 <update_box>
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
 8026b52:	683b      	ldr	r3, [r7, #0]
 8026b54:	68fa      	ldr	r2, [r7, #12]
 8026b56:	6939      	ldr	r1, [r7, #16]
 8026b58:	6878      	ldr	r0, [r7, #4]
 8026b5a:	f7ff fe8d 	bl	8026878 <median_cut>
 8026b5e:	60f8      	str	r0, [r7, #12]
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
 8026b60:	2300      	movs	r3, #0
 8026b62:	617b      	str	r3, [r7, #20]
 8026b64:	e00b      	b.n	8026b7e <select_colors+0x78>
    compute_color(cinfo, & boxlist[i], i);
 8026b66:	697b      	ldr	r3, [r7, #20]
 8026b68:	015b      	lsls	r3, r3, #5
 8026b6a:	693a      	ldr	r2, [r7, #16]
 8026b6c:	4413      	add	r3, r2
 8026b6e:	697a      	ldr	r2, [r7, #20]
 8026b70:	4619      	mov	r1, r3
 8026b72:	6878      	ldr	r0, [r7, #4]
 8026b74:	f7ff ff1a 	bl	80269ac <compute_color>
  for (i = 0; i < numboxes; i++)
 8026b78:	697b      	ldr	r3, [r7, #20]
 8026b7a:	3301      	adds	r3, #1
 8026b7c:	617b      	str	r3, [r7, #20]
 8026b7e:	697a      	ldr	r2, [r7, #20]
 8026b80:	68fb      	ldr	r3, [r7, #12]
 8026b82:	429a      	cmp	r2, r3
 8026b84:	dbef      	blt.n	8026b66 <select_colors+0x60>
  cinfo->actual_number_of_colors = numboxes;
 8026b86:	687b      	ldr	r3, [r7, #4]
 8026b88:	68fa      	ldr	r2, [r7, #12]
 8026b8a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
 8026b8e:	687b      	ldr	r3, [r7, #4]
 8026b90:	681b      	ldr	r3, [r3, #0]
 8026b92:	2262      	movs	r2, #98	; 0x62
 8026b94:	615a      	str	r2, [r3, #20]
 8026b96:	687b      	ldr	r3, [r7, #4]
 8026b98:	681b      	ldr	r3, [r3, #0]
 8026b9a:	68fa      	ldr	r2, [r7, #12]
 8026b9c:	619a      	str	r2, [r3, #24]
 8026b9e:	687b      	ldr	r3, [r7, #4]
 8026ba0:	681b      	ldr	r3, [r3, #0]
 8026ba2:	685b      	ldr	r3, [r3, #4]
 8026ba4:	2101      	movs	r1, #1
 8026ba6:	6878      	ldr	r0, [r7, #4]
 8026ba8:	4798      	blx	r3
}
 8026baa:	bf00      	nop
 8026bac:	3718      	adds	r7, #24
 8026bae:	46bd      	mov	sp, r7
 8026bb0:	bd80      	pop	{r7, pc}

08026bb2 <find_nearby_colors>:
 * candidate colormap entries is returned, and their colormap indexes are
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
 8026bb2:	b490      	push	{r4, r7}
 8026bb4:	f5ad 6d89 	sub.w	sp, sp, #1096	; 0x448
 8026bb8:	af00      	add	r7, sp, #0
 8026bba:	f107 040c 	add.w	r4, r7, #12
 8026bbe:	6020      	str	r0, [r4, #0]
 8026bc0:	f107 0008 	add.w	r0, r7, #8
 8026bc4:	6001      	str	r1, [r0, #0]
 8026bc6:	1d39      	adds	r1, r7, #4
 8026bc8:	600a      	str	r2, [r1, #0]
 8026bca:	463a      	mov	r2, r7
 8026bcc:	6013      	str	r3, [r2, #0]
  int numcolors = cinfo->actual_number_of_colors;
 8026bce:	f107 030c 	add.w	r3, r7, #12
 8026bd2:	681b      	ldr	r3, [r3, #0]
 8026bd4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8026bd8:	f8c7 3430 	str.w	r3, [r7, #1072]	; 0x430
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
 8026bdc:	f107 0308 	add.w	r3, r7, #8
 8026be0:	681b      	ldr	r3, [r3, #0]
 8026be2:	3318      	adds	r3, #24
 8026be4:	f8c7 342c 	str.w	r3, [r7, #1068]	; 0x42c
  centerc0 = (minc0 + maxc0) >> 1;
 8026be8:	f107 0308 	add.w	r3, r7, #8
 8026bec:	681a      	ldr	r2, [r3, #0]
 8026bee:	f8d7 342c 	ldr.w	r3, [r7, #1068]	; 0x42c
 8026bf2:	4413      	add	r3, r2
 8026bf4:	105b      	asrs	r3, r3, #1
 8026bf6:	f8c7 3428 	str.w	r3, [r7, #1064]	; 0x428
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
 8026bfa:	1d3b      	adds	r3, r7, #4
 8026bfc:	681b      	ldr	r3, [r3, #0]
 8026bfe:	331c      	adds	r3, #28
 8026c00:	f8c7 3424 	str.w	r3, [r7, #1060]	; 0x424
  centerc1 = (minc1 + maxc1) >> 1;
 8026c04:	1d3b      	adds	r3, r7, #4
 8026c06:	681a      	ldr	r2, [r3, #0]
 8026c08:	f8d7 3424 	ldr.w	r3, [r7, #1060]	; 0x424
 8026c0c:	4413      	add	r3, r2
 8026c0e:	105b      	asrs	r3, r3, #1
 8026c10:	f8c7 3420 	str.w	r3, [r7, #1056]	; 0x420
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
 8026c14:	463b      	mov	r3, r7
 8026c16:	681b      	ldr	r3, [r3, #0]
 8026c18:	3318      	adds	r3, #24
 8026c1a:	f8c7 341c 	str.w	r3, [r7, #1052]	; 0x41c
  centerc2 = (minc2 + maxc2) >> 1;
 8026c1e:	463b      	mov	r3, r7
 8026c20:	681a      	ldr	r2, [r3, #0]
 8026c22:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
 8026c26:	4413      	add	r3, r2
 8026c28:	105b      	asrs	r3, r3, #1
 8026c2a:	f8c7 3418 	str.w	r3, [r7, #1048]	; 0x418
   *  2. its maximum squared-distance to any point in the update box.
   * Both of these can be found by considering only the corners of the box.
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;
 8026c2e:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8026c32:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c

  for (i = 0; i < numcolors; i++) {
 8026c36:	2300      	movs	r3, #0
 8026c38:	f8c7 3444 	str.w	r3, [r7, #1092]	; 0x444
 8026c3c:	e1a8      	b.n	8026f90 <find_nearby_colors+0x3de>
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
 8026c3e:	f107 030c 	add.w	r3, r7, #12
 8026c42:	681b      	ldr	r3, [r3, #0]
 8026c44:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026c48:	681a      	ldr	r2, [r3, #0]
 8026c4a:	f8d7 3444 	ldr.w	r3, [r7, #1092]	; 0x444
 8026c4e:	4413      	add	r3, r2
 8026c50:	781b      	ldrb	r3, [r3, #0]
 8026c52:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
    if (x < minc0) {
 8026c56:	f107 0308 	add.w	r3, r7, #8
 8026c5a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026c5e:	681b      	ldr	r3, [r3, #0]
 8026c60:	429a      	cmp	r2, r3
 8026c62:	da1d      	bge.n	8026ca0 <find_nearby_colors+0xee>
      tdist = (x - minc0) * C0_SCALE;
 8026c64:	f107 0308 	add.w	r3, r7, #8
 8026c68:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026c6c:	681b      	ldr	r3, [r3, #0]
 8026c6e:	1ad3      	subs	r3, r2, r3
 8026c70:	005b      	lsls	r3, r3, #1
 8026c72:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist = tdist*tdist;
 8026c76:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026c7a:	fb03 f303 	mul.w	r3, r3, r3
 8026c7e:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - maxc0) * C0_SCALE;
 8026c82:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026c86:	f8d7 342c 	ldr.w	r3, [r7, #1068]	; 0x42c
 8026c8a:	1ad3      	subs	r3, r2, r3
 8026c8c:	005b      	lsls	r3, r3, #1
 8026c8e:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist = tdist*tdist;
 8026c92:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026c96:	fb03 f303 	mul.w	r3, r3, r3
 8026c9a:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026c9e:	e04a      	b.n	8026d36 <find_nearby_colors+0x184>
    } else if (x > maxc0) {
 8026ca0:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026ca4:	f8d7 342c 	ldr.w	r3, [r7, #1068]	; 0x42c
 8026ca8:	429a      	cmp	r2, r3
 8026caa:	dd1d      	ble.n	8026ce8 <find_nearby_colors+0x136>
      tdist = (x - maxc0) * C0_SCALE;
 8026cac:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026cb0:	f8d7 342c 	ldr.w	r3, [r7, #1068]	; 0x42c
 8026cb4:	1ad3      	subs	r3, r2, r3
 8026cb6:	005b      	lsls	r3, r3, #1
 8026cb8:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist = tdist*tdist;
 8026cbc:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026cc0:	fb03 f303 	mul.w	r3, r3, r3
 8026cc4:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - minc0) * C0_SCALE;
 8026cc8:	f107 0308 	add.w	r3, r7, #8
 8026ccc:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026cd0:	681b      	ldr	r3, [r3, #0]
 8026cd2:	1ad3      	subs	r3, r2, r3
 8026cd4:	005b      	lsls	r3, r3, #1
 8026cd6:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist = tdist*tdist;
 8026cda:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026cde:	fb03 f303 	mul.w	r3, r3, r3
 8026ce2:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026ce6:	e026      	b.n	8026d36 <find_nearby_colors+0x184>
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
 8026ce8:	2300      	movs	r3, #0
 8026cea:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      if (x <= centerc0) {
 8026cee:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026cf2:	f8d7 3428 	ldr.w	r3, [r7, #1064]	; 0x428
 8026cf6:	429a      	cmp	r2, r3
 8026cf8:	dc0e      	bgt.n	8026d18 <find_nearby_colors+0x166>
	tdist = (x - maxc0) * C0_SCALE;
 8026cfa:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026cfe:	f8d7 342c 	ldr.w	r3, [r7, #1068]	; 0x42c
 8026d02:	1ad3      	subs	r3, r2, r3
 8026d04:	005b      	lsls	r3, r3, #1
 8026d06:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist = tdist*tdist;
 8026d0a:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026d0e:	fb03 f303 	mul.w	r3, r3, r3
 8026d12:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026d16:	e00e      	b.n	8026d36 <find_nearby_colors+0x184>
      } else {
	tdist = (x - minc0) * C0_SCALE;
 8026d18:	f107 0308 	add.w	r3, r7, #8
 8026d1c:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026d20:	681b      	ldr	r3, [r3, #0]
 8026d22:	1ad3      	subs	r3, r2, r3
 8026d24:	005b      	lsls	r3, r3, #1
 8026d26:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist = tdist*tdist;
 8026d2a:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026d2e:	fb03 f303 	mul.w	r3, r3, r3
 8026d32:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
 8026d36:	f107 030c 	add.w	r3, r7, #12
 8026d3a:	681b      	ldr	r3, [r3, #0]
 8026d3c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026d40:	3304      	adds	r3, #4
 8026d42:	681a      	ldr	r2, [r3, #0]
 8026d44:	f8d7 3444 	ldr.w	r3, [r7, #1092]	; 0x444
 8026d48:	4413      	add	r3, r2
 8026d4a:	781b      	ldrb	r3, [r3, #0]
 8026d4c:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
    if (x < minc1) {
 8026d50:	1d3b      	adds	r3, r7, #4
 8026d52:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026d56:	681b      	ldr	r3, [r3, #0]
 8026d58:	429a      	cmp	r2, r3
 8026d5a:	da26      	bge.n	8026daa <find_nearby_colors+0x1f8>
      tdist = (x - minc1) * C1_SCALE;
 8026d5c:	1d3b      	adds	r3, r7, #4
 8026d5e:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026d62:	681b      	ldr	r3, [r3, #0]
 8026d64:	1ad2      	subs	r2, r2, r3
 8026d66:	4613      	mov	r3, r2
 8026d68:	005b      	lsls	r3, r3, #1
 8026d6a:	4413      	add	r3, r2
 8026d6c:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist += tdist*tdist;
 8026d70:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026d74:	fb03 f303 	mul.w	r3, r3, r3
 8026d78:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
 8026d7c:	4413      	add	r3, r2
 8026d7e:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - maxc1) * C1_SCALE;
 8026d82:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026d86:	f8d7 3424 	ldr.w	r3, [r7, #1060]	; 0x424
 8026d8a:	1ad2      	subs	r2, r2, r3
 8026d8c:	4613      	mov	r3, r2
 8026d8e:	005b      	lsls	r3, r3, #1
 8026d90:	4413      	add	r3, r2
 8026d92:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist += tdist*tdist;
 8026d96:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026d9a:	fb03 f303 	mul.w	r3, r3, r3
 8026d9e:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026da2:	4413      	add	r3, r2
 8026da4:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026da8:	e059      	b.n	8026e5e <find_nearby_colors+0x2ac>
    } else if (x > maxc1) {
 8026daa:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026dae:	f8d7 3424 	ldr.w	r3, [r7, #1060]	; 0x424
 8026db2:	429a      	cmp	r2, r3
 8026db4:	dd26      	ble.n	8026e04 <find_nearby_colors+0x252>
      tdist = (x - maxc1) * C1_SCALE;
 8026db6:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026dba:	f8d7 3424 	ldr.w	r3, [r7, #1060]	; 0x424
 8026dbe:	1ad2      	subs	r2, r2, r3
 8026dc0:	4613      	mov	r3, r2
 8026dc2:	005b      	lsls	r3, r3, #1
 8026dc4:	4413      	add	r3, r2
 8026dc6:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist += tdist*tdist;
 8026dca:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026dce:	fb03 f303 	mul.w	r3, r3, r3
 8026dd2:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
 8026dd6:	4413      	add	r3, r2
 8026dd8:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - minc1) * C1_SCALE;
 8026ddc:	1d3b      	adds	r3, r7, #4
 8026dde:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026de2:	681b      	ldr	r3, [r3, #0]
 8026de4:	1ad2      	subs	r2, r2, r3
 8026de6:	4613      	mov	r3, r2
 8026de8:	005b      	lsls	r3, r3, #1
 8026dea:	4413      	add	r3, r2
 8026dec:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist += tdist*tdist;
 8026df0:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026df4:	fb03 f303 	mul.w	r3, r3, r3
 8026df8:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026dfc:	4413      	add	r3, r2
 8026dfe:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026e02:	e02c      	b.n	8026e5e <find_nearby_colors+0x2ac>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
 8026e04:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026e08:	f8d7 3420 	ldr.w	r3, [r7, #1056]	; 0x420
 8026e0c:	429a      	cmp	r2, r3
 8026e0e:	dc13      	bgt.n	8026e38 <find_nearby_colors+0x286>
	tdist = (x - maxc1) * C1_SCALE;
 8026e10:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026e14:	f8d7 3424 	ldr.w	r3, [r7, #1060]	; 0x424
 8026e18:	1ad2      	subs	r2, r2, r3
 8026e1a:	4613      	mov	r3, r2
 8026e1c:	005b      	lsls	r3, r3, #1
 8026e1e:	4413      	add	r3, r2
 8026e20:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist += tdist*tdist;
 8026e24:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026e28:	fb03 f303 	mul.w	r3, r3, r3
 8026e2c:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026e30:	4413      	add	r3, r2
 8026e32:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026e36:	e012      	b.n	8026e5e <find_nearby_colors+0x2ac>
      } else {
	tdist = (x - minc1) * C1_SCALE;
 8026e38:	1d3b      	adds	r3, r7, #4
 8026e3a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026e3e:	681b      	ldr	r3, [r3, #0]
 8026e40:	1ad2      	subs	r2, r2, r3
 8026e42:	4613      	mov	r3, r2
 8026e44:	005b      	lsls	r3, r3, #1
 8026e46:	4413      	add	r3, r2
 8026e48:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist += tdist*tdist;
 8026e4c:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026e50:	fb03 f303 	mul.w	r3, r3, r3
 8026e54:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026e58:	4413      	add	r3, r2
 8026e5a:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
 8026e5e:	f107 030c 	add.w	r3, r7, #12
 8026e62:	681b      	ldr	r3, [r3, #0]
 8026e64:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8026e68:	3308      	adds	r3, #8
 8026e6a:	681a      	ldr	r2, [r3, #0]
 8026e6c:	f8d7 3444 	ldr.w	r3, [r7, #1092]	; 0x444
 8026e70:	4413      	add	r3, r2
 8026e72:	781b      	ldrb	r3, [r3, #0]
 8026e74:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
    if (x < minc2) {
 8026e78:	463b      	mov	r3, r7
 8026e7a:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026e7e:	681b      	ldr	r3, [r3, #0]
 8026e80:	429a      	cmp	r2, r3
 8026e82:	da20      	bge.n	8026ec6 <find_nearby_colors+0x314>
      tdist = (x - minc2) * C2_SCALE;
 8026e84:	463b      	mov	r3, r7
 8026e86:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026e8a:	681b      	ldr	r3, [r3, #0]
 8026e8c:	1ad3      	subs	r3, r2, r3
 8026e8e:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist += tdist*tdist;
 8026e92:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026e96:	fb03 f303 	mul.w	r3, r3, r3
 8026e9a:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
 8026e9e:	4413      	add	r3, r2
 8026ea0:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - maxc2) * C2_SCALE;
 8026ea4:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026ea8:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
 8026eac:	1ad3      	subs	r3, r2, r3
 8026eae:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist += tdist*tdist;
 8026eb2:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026eb6:	fb03 f303 	mul.w	r3, r3, r3
 8026eba:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026ebe:	4413      	add	r3, r2
 8026ec0:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026ec4:	e04d      	b.n	8026f62 <find_nearby_colors+0x3b0>
    } else if (x > maxc2) {
 8026ec6:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026eca:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
 8026ece:	429a      	cmp	r2, r3
 8026ed0:	dd20      	ble.n	8026f14 <find_nearby_colors+0x362>
      tdist = (x - maxc2) * C2_SCALE;
 8026ed2:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026ed6:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
 8026eda:	1ad3      	subs	r3, r2, r3
 8026edc:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      min_dist += tdist*tdist;
 8026ee0:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026ee4:	fb03 f303 	mul.w	r3, r3, r3
 8026ee8:	f8d7 2438 	ldr.w	r2, [r7, #1080]	; 0x438
 8026eec:	4413      	add	r3, r2
 8026eee:	f8c7 3438 	str.w	r3, [r7, #1080]	; 0x438
      tdist = (x - minc2) * C2_SCALE;
 8026ef2:	463b      	mov	r3, r7
 8026ef4:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026ef8:	681b      	ldr	r3, [r3, #0]
 8026efa:	1ad3      	subs	r3, r2, r3
 8026efc:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
      max_dist += tdist*tdist;
 8026f00:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026f04:	fb03 f303 	mul.w	r3, r3, r3
 8026f08:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026f0c:	4413      	add	r3, r2
 8026f0e:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026f12:	e026      	b.n	8026f62 <find_nearby_colors+0x3b0>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
 8026f14:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026f18:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
 8026f1c:	429a      	cmp	r2, r3
 8026f1e:	dc10      	bgt.n	8026f42 <find_nearby_colors+0x390>
	tdist = (x - maxc2) * C2_SCALE;
 8026f20:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026f24:	f8d7 341c 	ldr.w	r3, [r7, #1052]	; 0x41c
 8026f28:	1ad3      	subs	r3, r2, r3
 8026f2a:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist += tdist*tdist;
 8026f2e:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026f32:	fb03 f303 	mul.w	r3, r3, r3
 8026f36:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026f3a:	4413      	add	r3, r2
 8026f3c:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
 8026f40:	e00f      	b.n	8026f62 <find_nearby_colors+0x3b0>
      } else {
	tdist = (x - minc2) * C2_SCALE;
 8026f42:	463b      	mov	r3, r7
 8026f44:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 8026f48:	681b      	ldr	r3, [r3, #0]
 8026f4a:	1ad3      	subs	r3, r2, r3
 8026f4c:	f8c7 3410 	str.w	r3, [r7, #1040]	; 0x410
	max_dist += tdist*tdist;
 8026f50:	f8d7 3410 	ldr.w	r3, [r7, #1040]	; 0x410
 8026f54:	fb03 f303 	mul.w	r3, r3, r3
 8026f58:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026f5c:	4413      	add	r3, r2
 8026f5e:	f8c7 3434 	str.w	r3, [r7, #1076]	; 0x434
      }
    }

    mindist[i] = min_dist;	/* save away the results */
 8026f62:	f107 0310 	add.w	r3, r7, #16
 8026f66:	f8d7 2444 	ldr.w	r2, [r7, #1092]	; 0x444
 8026f6a:	f8d7 1438 	ldr.w	r1, [r7, #1080]	; 0x438
 8026f6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    if (max_dist < minmaxdist)
 8026f72:	f8d7 2434 	ldr.w	r2, [r7, #1076]	; 0x434
 8026f76:	f8d7 343c 	ldr.w	r3, [r7, #1084]	; 0x43c
 8026f7a:	429a      	cmp	r2, r3
 8026f7c:	da03      	bge.n	8026f86 <find_nearby_colors+0x3d4>
      minmaxdist = max_dist;
 8026f7e:	f8d7 3434 	ldr.w	r3, [r7, #1076]	; 0x434
 8026f82:	f8c7 343c 	str.w	r3, [r7, #1084]	; 0x43c
  for (i = 0; i < numcolors; i++) {
 8026f86:	f8d7 3444 	ldr.w	r3, [r7, #1092]	; 0x444
 8026f8a:	3301      	adds	r3, #1
 8026f8c:	f8c7 3444 	str.w	r3, [r7, #1092]	; 0x444
 8026f90:	f8d7 2444 	ldr.w	r2, [r7, #1092]	; 0x444
 8026f94:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
 8026f98:	429a      	cmp	r2, r3
 8026f9a:	f6ff ae50 	blt.w	8026c3e <find_nearby_colors+0x8c>

  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
 8026f9e:	2300      	movs	r3, #0
 8026fa0:	f8c7 3440 	str.w	r3, [r7, #1088]	; 0x440
  for (i = 0; i < numcolors; i++) {
 8026fa4:	2300      	movs	r3, #0
 8026fa6:	f8c7 3444 	str.w	r3, [r7, #1092]	; 0x444
 8026faa:	e01b      	b.n	8026fe4 <find_nearby_colors+0x432>
    if (mindist[i] <= minmaxdist)
 8026fac:	f107 0310 	add.w	r3, r7, #16
 8026fb0:	f8d7 2444 	ldr.w	r2, [r7, #1092]	; 0x444
 8026fb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8026fb8:	f8d7 243c 	ldr.w	r2, [r7, #1084]	; 0x43c
 8026fbc:	429a      	cmp	r2, r3
 8026fbe:	db0c      	blt.n	8026fda <find_nearby_colors+0x428>
      colorlist[ncolors++] = (JSAMPLE) i;
 8026fc0:	f8d7 3440 	ldr.w	r3, [r7, #1088]	; 0x440
 8026fc4:	1c5a      	adds	r2, r3, #1
 8026fc6:	f8c7 2440 	str.w	r2, [r7, #1088]	; 0x440
 8026fca:	461a      	mov	r2, r3
 8026fcc:	f8d7 3450 	ldr.w	r3, [r7, #1104]	; 0x450
 8026fd0:	4413      	add	r3, r2
 8026fd2:	f8d7 2444 	ldr.w	r2, [r7, #1092]	; 0x444
 8026fd6:	b2d2      	uxtb	r2, r2
 8026fd8:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < numcolors; i++) {
 8026fda:	f8d7 3444 	ldr.w	r3, [r7, #1092]	; 0x444
 8026fde:	3301      	adds	r3, #1
 8026fe0:	f8c7 3444 	str.w	r3, [r7, #1092]	; 0x444
 8026fe4:	f8d7 2444 	ldr.w	r2, [r7, #1092]	; 0x444
 8026fe8:	f8d7 3430 	ldr.w	r3, [r7, #1072]	; 0x430
 8026fec:	429a      	cmp	r2, r3
 8026fee:	dbdd      	blt.n	8026fac <find_nearby_colors+0x3fa>
  }
  return ncolors;
 8026ff0:	f8d7 3440 	ldr.w	r3, [r7, #1088]	; 0x440
}
 8026ff4:	4618      	mov	r0, r3
 8026ff6:	f507 6789 	add.w	r7, r7, #1096	; 0x448
 8026ffa:	46bd      	mov	sp, r7
 8026ffc:	bc90      	pop	{r4, r7}
 8026ffe:	4770      	bx	lr

08027000 <find_best_colors>:
 * given the list of candidate colors prepared by find_nearby_colors.
 * Return the indexes of the closest entries in the bestcolor[] array.
 * This routine uses Thomas' incremental distance calculation method to
 * find the distance from a colormap entry to successive cells in the box.
 */
{
 8027000:	b4f0      	push	{r4, r5, r6, r7}
 8027002:	f5ad 7d12 	sub.w	sp, sp, #584	; 0x248
 8027006:	af00      	add	r7, sp, #0
 8027008:	f107 040c 	add.w	r4, r7, #12
 802700c:	6020      	str	r0, [r4, #0]
 802700e:	f107 0008 	add.w	r0, r7, #8
 8027012:	6001      	str	r1, [r0, #0]
 8027014:	1d39      	adds	r1, r7, #4
 8027016:	600a      	str	r2, [r1, #0]
 8027018:	463a      	mov	r2, r7
 802701a:	6013      	str	r3, [r2, #0]
  INT32 inc0, inc1, inc2;	/* initial values for increments */
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
 802701c:	f107 0414 	add.w	r4, r7, #20
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 8027020:	237f      	movs	r3, #127	; 0x7f
 8027022:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
 8027026:	e009      	b.n	802703c <find_best_colors+0x3c>
    *bptr++ = 0x7FFFFFFFL;
 8027028:	4623      	mov	r3, r4
 802702a:	1d1c      	adds	r4, r3, #4
 802702c:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8027030:	601a      	str	r2, [r3, #0]
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
 8027032:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 8027036:	3b01      	subs	r3, #1
 8027038:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
 802703c:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 8027040:	2b00      	cmp	r3, #0
 8027042:	daf1      	bge.n	8027028 <find_best_colors+0x28>
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
  
  for (i = 0; i < numcolors; i++) {
 8027044:	2300      	movs	r3, #0
 8027046:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
 802704a:	e0d9      	b.n	8027200 <find_best_colors+0x200>
    icolor = GETJSAMPLE(colorlist[i]);
 802704c:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 8027050:	f8d7 225c 	ldr.w	r2, [r7, #604]	; 0x25c
 8027054:	4413      	add	r3, r2
 8027056:	781b      	ldrb	r3, [r3, #0]
 8027058:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
 802705c:	f107 030c 	add.w	r3, r7, #12
 8027060:	681b      	ldr	r3, [r3, #0]
 8027062:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8027066:	681a      	ldr	r2, [r3, #0]
 8027068:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 802706c:	4413      	add	r3, r2
 802706e:	781b      	ldrb	r3, [r3, #0]
 8027070:	461a      	mov	r2, r3
 8027072:	f107 0308 	add.w	r3, r7, #8
 8027076:	681b      	ldr	r3, [r3, #0]
 8027078:	1a9b      	subs	r3, r3, r2
 802707a:	005b      	lsls	r3, r3, #1
 802707c:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    dist0 = inc0*inc0;
 8027080:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 8027084:	fb03 f303 	mul.w	r3, r3, r3
 8027088:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
 802708c:	f107 030c 	add.w	r3, r7, #12
 8027090:	681b      	ldr	r3, [r3, #0]
 8027092:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8027096:	3304      	adds	r3, #4
 8027098:	681a      	ldr	r2, [r3, #0]
 802709a:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 802709e:	4413      	add	r3, r2
 80270a0:	781b      	ldrb	r3, [r3, #0]
 80270a2:	461a      	mov	r2, r3
 80270a4:	1d3b      	adds	r3, r7, #4
 80270a6:	681b      	ldr	r3, [r3, #0]
 80270a8:	1a9a      	subs	r2, r3, r2
 80270aa:	4613      	mov	r3, r2
 80270ac:	005b      	lsls	r3, r3, #1
 80270ae:	4413      	add	r3, r2
 80270b0:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    dist0 += inc1*inc1;
 80270b4:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 80270b8:	fb03 f303 	mul.w	r3, r3, r3
 80270bc:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 80270c0:	4413      	add	r3, r2
 80270c2:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
 80270c6:	f107 030c 	add.w	r3, r7, #12
 80270ca:	681b      	ldr	r3, [r3, #0]
 80270cc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80270d0:	3308      	adds	r3, #8
 80270d2:	681a      	ldr	r2, [r3, #0]
 80270d4:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 80270d8:	4413      	add	r3, r2
 80270da:	781b      	ldrb	r3, [r3, #0]
 80270dc:	461a      	mov	r2, r3
 80270de:	463b      	mov	r3, r7
 80270e0:	681b      	ldr	r3, [r3, #0]
 80270e2:	1a9b      	subs	r3, r3, r2
 80270e4:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    dist0 += inc2*inc2;
 80270e8:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 80270ec:	fb03 f303 	mul.w	r3, r3, r3
 80270f0:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 80270f4:	4413      	add	r3, r2
 80270f6:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
 80270fa:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 80270fe:	3308      	adds	r3, #8
 8027100:	015b      	lsls	r3, r3, #5
 8027102:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
 8027106:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 802710a:	4613      	mov	r3, r2
 802710c:	005b      	lsls	r3, r3, #1
 802710e:	4413      	add	r3, r2
 8027110:	00db      	lsls	r3, r3, #3
 8027112:	3390      	adds	r3, #144	; 0x90
 8027114:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
 8027118:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 802711c:	3304      	adds	r3, #4
 802711e:	011b      	lsls	r3, r3, #4
 8027120:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
 8027124:	f107 0414 	add.w	r4, r7, #20
    cptr = bestcolor;
 8027128:	f8d7 3260 	ldr.w	r3, [r7, #608]	; 0x260
 802712c:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
    xx0 = inc0;
 8027130:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 8027134:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 8027138:	2303      	movs	r3, #3
 802713a:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
 802713e:	e056      	b.n	80271ee <find_best_colors+0x1ee>
      dist1 = dist0;
 8027140:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 8027144:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
      xx1 = inc1;
 8027148:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 802714c:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 8027150:	2307      	movs	r3, #7
 8027152:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
 8027156:	e034      	b.n	80271c2 <find_best_colors+0x1c2>
	dist2 = dist1;
 8027158:	f8d7 522c 	ldr.w	r5, [r7, #556]	; 0x22c
	xx2 = inc2;
 802715c:	f8d7 6214 	ldr.w	r6, [r7, #532]	; 0x214
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 8027160:	2303      	movs	r3, #3
 8027162:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
 8027166:	e016      	b.n	8027196 <find_best_colors+0x196>
	  if (dist2 < *bptr) {
 8027168:	6823      	ldr	r3, [r4, #0]
 802716a:	429d      	cmp	r5, r3
 802716c:	da06      	bge.n	802717c <find_best_colors+0x17c>
	    *bptr = dist2;
 802716e:	6025      	str	r5, [r4, #0]
	    *cptr = (JSAMPLE) icolor;
 8027170:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 8027174:	b2da      	uxtb	r2, r3
 8027176:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 802717a:	701a      	strb	r2, [r3, #0]
	  }
	  dist2 += xx2;
 802717c:	4435      	add	r5, r6
	  xx2 += 2 * STEP_C2 * STEP_C2;
 802717e:	3680      	adds	r6, #128	; 0x80
	  bptr++;
 8027180:	3404      	adds	r4, #4
	  cptr++;
 8027182:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 8027186:	3301      	adds	r3, #1
 8027188:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 802718c:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 8027190:	3b01      	subs	r3, #1
 8027192:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
 8027196:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
 802719a:	2b00      	cmp	r3, #0
 802719c:	dae4      	bge.n	8027168 <find_best_colors+0x168>
	}
	dist1 += xx1;
 802719e:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 80271a2:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 80271a6:	4413      	add	r3, r2
 80271a8:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
	xx1 += 2 * STEP_C1 * STEP_C1;
 80271ac:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 80271b0:	f503 7390 	add.w	r3, r3, #288	; 0x120
 80271b4:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
 80271b8:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 80271bc:	3b01      	subs	r3, #1
 80271be:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
 80271c2:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 80271c6:	2b00      	cmp	r3, #0
 80271c8:	dac6      	bge.n	8027158 <find_best_colors+0x158>
      }
      dist0 += xx0;
 80271ca:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 80271ce:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 80271d2:	4413      	add	r3, r2
 80271d4:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
      xx0 += 2 * STEP_C0 * STEP_C0;
 80271d8:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 80271dc:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80271e0:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
 80271e4:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80271e8:	3b01      	subs	r3, #1
 80271ea:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
 80271ee:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 80271f2:	2b00      	cmp	r3, #0
 80271f4:	daa4      	bge.n	8027140 <find_best_colors+0x140>
  for (i = 0; i < numcolors; i++) {
 80271f6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 80271fa:	3301      	adds	r3, #1
 80271fc:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
 8027200:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 8027204:	f8d7 3258 	ldr.w	r3, [r7, #600]	; 0x258
 8027208:	429a      	cmp	r2, r3
 802720a:	f6ff af1f 	blt.w	802704c <find_best_colors+0x4c>
    }
  }
}
 802720e:	bf00      	nop
 8027210:	bf00      	nop
 8027212:	f507 7712 	add.w	r7, r7, #584	; 0x248
 8027216:	46bd      	mov	sp, r7
 8027218:	bcf0      	pop	{r4, r5, r6, r7}
 802721a:	4770      	bx	lr

0802721c <fill_inverse_cmap>:
LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
 802721c:	b5b0      	push	{r4, r5, r7, lr}
 802721e:	b0f2      	sub	sp, #456	; 0x1c8
 8027220:	af04      	add	r7, sp, #16
 8027222:	f107 040c 	add.w	r4, r7, #12
 8027226:	6020      	str	r0, [r4, #0]
 8027228:	f107 0008 	add.w	r0, r7, #8
 802722c:	6001      	str	r1, [r0, #0]
 802722e:	1d39      	adds	r1, r7, #4
 8027230:	600a      	str	r2, [r1, #0]
 8027232:	463a      	mov	r2, r7
 8027234:	6013      	str	r3, [r2, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8027236:	f107 030c 	add.w	r3, r7, #12
 802723a:	681b      	ldr	r3, [r3, #0]
 802723c:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8027240:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
  hist3d histogram = cquantize->histogram;
 8027244:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8027248:	699b      	ldr	r3, [r3, #24]
 802724a:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
 802724e:	f107 0308 	add.w	r3, r7, #8
 8027252:	f107 0208 	add.w	r2, r7, #8
 8027256:	6812      	ldr	r2, [r2, #0]
 8027258:	1092      	asrs	r2, r2, #2
 802725a:	601a      	str	r2, [r3, #0]
  c1 >>= BOX_C1_LOG;
 802725c:	1d3b      	adds	r3, r7, #4
 802725e:	1d3a      	adds	r2, r7, #4
 8027260:	6812      	ldr	r2, [r2, #0]
 8027262:	10d2      	asrs	r2, r2, #3
 8027264:	601a      	str	r2, [r3, #0]
  c2 >>= BOX_C2_LOG;
 8027266:	463b      	mov	r3, r7
 8027268:	463a      	mov	r2, r7
 802726a:	6812      	ldr	r2, [r2, #0]
 802726c:	1092      	asrs	r2, r2, #2
 802726e:	601a      	str	r2, [r3, #0]

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
 8027270:	f107 0308 	add.w	r3, r7, #8
 8027274:	681b      	ldr	r3, [r3, #0]
 8027276:	015b      	lsls	r3, r3, #5
 8027278:	3304      	adds	r3, #4
 802727a:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
 802727e:	1d3b      	adds	r3, r7, #4
 8027280:	681b      	ldr	r3, [r3, #0]
 8027282:	015b      	lsls	r3, r3, #5
 8027284:	3302      	adds	r3, #2
 8027286:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
 802728a:	463b      	mov	r3, r7
 802728c:	681b      	ldr	r3, [r3, #0]
 802728e:	015b      	lsls	r3, r3, #5
 8027290:	3304      	adds	r3, #4
 8027292:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
  
  /* Determine which colormap entries are close enough to be candidates
   * for the nearest entry to some cell in the update box.
   */
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
 8027296:	f107 000c 	add.w	r0, r7, #12
 802729a:	f107 0394 	add.w	r3, r7, #148	; 0x94
 802729e:	9300      	str	r3, [sp, #0]
 80272a0:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 80272a4:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 80272a8:	f8d7 11a0 	ldr.w	r1, [r7, #416]	; 0x1a0
 80272ac:	6800      	ldr	r0, [r0, #0]
 80272ae:	f7ff fc80 	bl	8026bb2 <find_nearby_colors>
 80272b2:	f8c7 0194 	str.w	r0, [r7, #404]	; 0x194

  /* Determine the actually nearest colors. */
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
 80272b6:	f107 000c 	add.w	r0, r7, #12
 80272ba:	f107 0314 	add.w	r3, r7, #20
 80272be:	9302      	str	r3, [sp, #8]
 80272c0:	f107 0394 	add.w	r3, r7, #148	; 0x94
 80272c4:	9301      	str	r3, [sp, #4]
 80272c6:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 80272ca:	9300      	str	r3, [sp, #0]
 80272cc:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 80272d0:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 80272d4:	f8d7 11a0 	ldr.w	r1, [r7, #416]	; 0x1a0
 80272d8:	6800      	ldr	r0, [r0, #0]
 80272da:	f7ff fe91 	bl	8027000 <find_best_colors>
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
 80272de:	f107 0308 	add.w	r3, r7, #8
 80272e2:	f107 0208 	add.w	r2, r7, #8
 80272e6:	6812      	ldr	r2, [r2, #0]
 80272e8:	0092      	lsls	r2, r2, #2
 80272ea:	601a      	str	r2, [r3, #0]
  c1 <<= BOX_C1_LOG;
 80272ec:	1d3b      	adds	r3, r7, #4
 80272ee:	1d3a      	adds	r2, r7, #4
 80272f0:	6812      	ldr	r2, [r2, #0]
 80272f2:	00d2      	lsls	r2, r2, #3
 80272f4:	601a      	str	r2, [r3, #0]
  c2 <<= BOX_C2_LOG;
 80272f6:	463b      	mov	r3, r7
 80272f8:	463a      	mov	r2, r7
 80272fa:	6812      	ldr	r2, [r2, #0]
 80272fc:	0092      	lsls	r2, r2, #2
 80272fe:	601a      	str	r2, [r3, #0]
  cptr = bestcolor;
 8027300:	f107 0414 	add.w	r4, r7, #20
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 8027304:	2300      	movs	r3, #0
 8027306:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 802730a:	e03d      	b.n	8027388 <fill_inverse_cmap+0x16c>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802730c:	2300      	movs	r3, #0
 802730e:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
 8027312:	e030      	b.n	8027376 <fill_inverse_cmap+0x15a>
      cachep = & histogram[c0+ic0][c1+ic1][c2];
 8027314:	f107 0308 	add.w	r3, r7, #8
 8027318:	681a      	ldr	r2, [r3, #0]
 802731a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 802731e:	4413      	add	r3, r2
 8027320:	009b      	lsls	r3, r3, #2
 8027322:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 8027326:	4413      	add	r3, r2
 8027328:	681a      	ldr	r2, [r3, #0]
 802732a:	1d3b      	adds	r3, r7, #4
 802732c:	6819      	ldr	r1, [r3, #0]
 802732e:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 8027332:	440b      	add	r3, r1
 8027334:	019b      	lsls	r3, r3, #6
 8027336:	441a      	add	r2, r3
 8027338:	463b      	mov	r3, r7
 802733a:	681b      	ldr	r3, [r3, #0]
 802733c:	005b      	lsls	r3, r3, #1
 802733e:	18d5      	adds	r5, r2, r3
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 8027340:	2300      	movs	r3, #0
 8027342:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 8027346:	e00d      	b.n	8027364 <fill_inverse_cmap+0x148>
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
 8027348:	4623      	mov	r3, r4
 802734a:	1c5c      	adds	r4, r3, #1
 802734c:	781b      	ldrb	r3, [r3, #0]
 802734e:	b29a      	uxth	r2, r3
 8027350:	462b      	mov	r3, r5
 8027352:	1c9d      	adds	r5, r3, #2
 8027354:	3201      	adds	r2, #1
 8027356:	b292      	uxth	r2, r2
 8027358:	801a      	strh	r2, [r3, #0]
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
 802735a:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 802735e:	3301      	adds	r3, #1
 8027360:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 8027364:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 8027368:	2b03      	cmp	r3, #3
 802736a:	dded      	ble.n	8027348 <fill_inverse_cmap+0x12c>
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
 802736c:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 8027370:	3301      	adds	r3, #1
 8027372:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
 8027376:	f8d7 31b0 	ldr.w	r3, [r7, #432]	; 0x1b0
 802737a:	2b07      	cmp	r3, #7
 802737c:	ddca      	ble.n	8027314 <fill_inverse_cmap+0xf8>
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
 802737e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8027382:	3301      	adds	r3, #1
 8027384:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 8027388:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 802738c:	2b03      	cmp	r3, #3
 802738e:	ddbd      	ble.n	802730c <fill_inverse_cmap+0xf0>
      }
    }
  }
}
 8027390:	bf00      	nop
 8027392:	bf00      	nop
 8027394:	f507 77dc 	add.w	r7, r7, #440	; 0x1b8
 8027398:	46bd      	mov	sp, r7
 802739a:	bdb0      	pop	{r4, r5, r7, pc}

0802739c <pass2_no_dither>:

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
 802739c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80273a0:	b08a      	sub	sp, #40	; 0x28
 80273a2:	af00      	add	r7, sp, #0
 80273a4:	60f8      	str	r0, [r7, #12]
 80273a6:	60b9      	str	r1, [r7, #8]
 80273a8:	607a      	str	r2, [r7, #4]
 80273aa:	603b      	str	r3, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80273ac:	68fb      	ldr	r3, [r7, #12]
 80273ae:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80273b2:	61fb      	str	r3, [r7, #28]
  hist3d histogram = cquantize->histogram;
 80273b4:	69fb      	ldr	r3, [r7, #28]
 80273b6:	699b      	ldr	r3, [r3, #24]
 80273b8:	61bb      	str	r3, [r7, #24]
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 80273ba:	68fb      	ldr	r3, [r7, #12]
 80273bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80273be:	617b      	str	r3, [r7, #20]

  for (row = 0; row < num_rows; row++) {
 80273c0:	2300      	movs	r3, #0
 80273c2:	627b      	str	r3, [r7, #36]	; 0x24
 80273c4:	e042      	b.n	802744c <pass2_no_dither+0xb0>
    inptr = input_buf[row];
 80273c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80273c8:	009b      	lsls	r3, r3, #2
 80273ca:	68ba      	ldr	r2, [r7, #8]
 80273cc:	4413      	add	r3, r2
 80273ce:	681c      	ldr	r4, [r3, #0]
    outptr = output_buf[row];
 80273d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80273d2:	009b      	lsls	r3, r3, #2
 80273d4:	687a      	ldr	r2, [r7, #4]
 80273d6:	4413      	add	r3, r2
 80273d8:	681e      	ldr	r6, [r3, #0]
    for (col = width; col > 0; col--) {
 80273da:	697b      	ldr	r3, [r7, #20]
 80273dc:	623b      	str	r3, [r7, #32]
 80273de:	e02f      	b.n	8027440 <pass2_no_dither+0xa4>
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
 80273e0:	4623      	mov	r3, r4
 80273e2:	1c5c      	adds	r4, r3, #1
 80273e4:	781b      	ldrb	r3, [r3, #0]
 80273e6:	08db      	lsrs	r3, r3, #3
 80273e8:	b2db      	uxtb	r3, r3
 80273ea:	4699      	mov	r9, r3
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
 80273ec:	4623      	mov	r3, r4
 80273ee:	1c5c      	adds	r4, r3, #1
 80273f0:	781b      	ldrb	r3, [r3, #0]
 80273f2:	089b      	lsrs	r3, r3, #2
 80273f4:	b2db      	uxtb	r3, r3
 80273f6:	469a      	mov	sl, r3
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
 80273f8:	4623      	mov	r3, r4
 80273fa:	1c5c      	adds	r4, r3, #1
 80273fc:	781b      	ldrb	r3, [r3, #0]
 80273fe:	08db      	lsrs	r3, r3, #3
 8027400:	b2db      	uxtb	r3, r3
 8027402:	4698      	mov	r8, r3
      cachep = & histogram[c0][c1][c2];
 8027404:	464b      	mov	r3, r9
 8027406:	009b      	lsls	r3, r3, #2
 8027408:	69ba      	ldr	r2, [r7, #24]
 802740a:	4413      	add	r3, r2
 802740c:	681a      	ldr	r2, [r3, #0]
 802740e:	4653      	mov	r3, sl
 8027410:	019b      	lsls	r3, r3, #6
 8027412:	441a      	add	r2, r3
 8027414:	ea4f 0348 	mov.w	r3, r8, lsl #1
 8027418:	18d5      	adds	r5, r2, r3
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
 802741a:	882b      	ldrh	r3, [r5, #0]
 802741c:	2b00      	cmp	r3, #0
 802741e:	d105      	bne.n	802742c <pass2_no_dither+0x90>
	fill_inverse_cmap(cinfo, c0,c1,c2);
 8027420:	4643      	mov	r3, r8
 8027422:	4652      	mov	r2, sl
 8027424:	4649      	mov	r1, r9
 8027426:	68f8      	ldr	r0, [r7, #12]
 8027428:	f7ff fef8 	bl	802721c <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
 802742c:	882b      	ldrh	r3, [r5, #0]
 802742e:	b2da      	uxtb	r2, r3
 8027430:	4633      	mov	r3, r6
 8027432:	1c5e      	adds	r6, r3, #1
 8027434:	3a01      	subs	r2, #1
 8027436:	b2d2      	uxtb	r2, r2
 8027438:	701a      	strb	r2, [r3, #0]
    for (col = width; col > 0; col--) {
 802743a:	6a3b      	ldr	r3, [r7, #32]
 802743c:	3b01      	subs	r3, #1
 802743e:	623b      	str	r3, [r7, #32]
 8027440:	6a3b      	ldr	r3, [r7, #32]
 8027442:	2b00      	cmp	r3, #0
 8027444:	d1cc      	bne.n	80273e0 <pass2_no_dither+0x44>
  for (row = 0; row < num_rows; row++) {
 8027446:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8027448:	3301      	adds	r3, #1
 802744a:	627b      	str	r3, [r7, #36]	; 0x24
 802744c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802744e:	683b      	ldr	r3, [r7, #0]
 8027450:	429a      	cmp	r2, r3
 8027452:	dbb8      	blt.n	80273c6 <pass2_no_dither+0x2a>
    }
  }
}
 8027454:	bf00      	nop
 8027456:	bf00      	nop
 8027458:	3728      	adds	r7, #40	; 0x28
 802745a:	46bd      	mov	sp, r7
 802745c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08027460 <pass2_fs_dither>:

METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
 8027460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027464:	b09c      	sub	sp, #112	; 0x70
 8027466:	af00      	add	r7, sp, #0
 8027468:	6178      	str	r0, [r7, #20]
 802746a:	6139      	str	r1, [r7, #16]
 802746c:	60fa      	str	r2, [r7, #12]
 802746e:	60bb      	str	r3, [r7, #8]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8027470:	697b      	ldr	r3, [r7, #20]
 8027472:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8027476:	63fb      	str	r3, [r7, #60]	; 0x3c
  hist3d histogram = cquantize->histogram;
 8027478:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802747a:	699b      	ldr	r3, [r3, #24]
 802747c:	63bb      	str	r3, [r7, #56]	; 0x38
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
 802747e:	697b      	ldr	r3, [r7, #20]
 8027480:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8027482:	637b      	str	r3, [r7, #52]	; 0x34
  JSAMPLE *range_limit = cinfo->sample_range_limit;
 8027484:	697b      	ldr	r3, [r7, #20]
 8027486:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 802748a:	633b      	str	r3, [r7, #48]	; 0x30
  int *error_limit = cquantize->error_limiter;
 802748c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802748e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8027490:	62fb      	str	r3, [r7, #44]	; 0x2c
  JSAMPROW colormap0 = cinfo->colormap[0];
 8027492:	697b      	ldr	r3, [r7, #20]
 8027494:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8027498:	681b      	ldr	r3, [r3, #0]
 802749a:	62bb      	str	r3, [r7, #40]	; 0x28
  JSAMPROW colormap1 = cinfo->colormap[1];
 802749c:	697b      	ldr	r3, [r7, #20]
 802749e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80274a2:	685b      	ldr	r3, [r3, #4]
 80274a4:	627b      	str	r3, [r7, #36]	; 0x24
  JSAMPROW colormap2 = cinfo->colormap[2];
 80274a6:	697b      	ldr	r3, [r7, #20]
 80274a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80274ac:	689b      	ldr	r3, [r3, #8]
 80274ae:	623b      	str	r3, [r7, #32]
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
 80274b0:	2300      	movs	r3, #0
 80274b2:	647b      	str	r3, [r7, #68]	; 0x44
 80274b4:	e119      	b.n	80276ea <pass2_fs_dither+0x28a>
    inptr = input_buf[row];
 80274b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80274b8:	009b      	lsls	r3, r3, #2
 80274ba:	693a      	ldr	r2, [r7, #16]
 80274bc:	4413      	add	r3, r2
 80274be:	681b      	ldr	r3, [r3, #0]
 80274c0:	657b      	str	r3, [r7, #84]	; 0x54
    outptr = output_buf[row];
 80274c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80274c4:	009b      	lsls	r3, r3, #2
 80274c6:	68fa      	ldr	r2, [r7, #12]
 80274c8:	4413      	add	r3, r2
 80274ca:	681b      	ldr	r3, [r3, #0]
 80274cc:	653b      	str	r3, [r7, #80]	; 0x50
    if (cquantize->on_odd_row) {
 80274ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80274d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80274d2:	2b00      	cmp	r3, #0
 80274d4:	d020      	beq.n	8027518 <pass2_fs_dither+0xb8>
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
 80274d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80274d8:	4613      	mov	r3, r2
 80274da:	005b      	lsls	r3, r3, #1
 80274dc:	4413      	add	r3, r2
 80274de:	3b03      	subs	r3, #3
 80274e0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80274e2:	4413      	add	r3, r2
 80274e4:	657b      	str	r3, [r7, #84]	; 0x54
      outptr += width-1;
 80274e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80274e8:	3b01      	subs	r3, #1
 80274ea:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80274ec:	4413      	add	r3, r2
 80274ee:	653b      	str	r3, [r7, #80]	; 0x50
      dir = -1;
 80274f0:	f04f 33ff 	mov.w	r3, #4294967295
 80274f4:	64fb      	str	r3, [r7, #76]	; 0x4c
      dir3 = -3;
 80274f6:	f06f 0302 	mvn.w	r3, #2
 80274fa:	64bb      	str	r3, [r7, #72]	; 0x48
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
 80274fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80274fe:	6a19      	ldr	r1, [r3, #32]
 8027500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8027502:	1c5a      	adds	r2, r3, #1
 8027504:	4613      	mov	r3, r2
 8027506:	005b      	lsls	r3, r3, #1
 8027508:	4413      	add	r3, r2
 802750a:	005b      	lsls	r3, r3, #1
 802750c:	18cb      	adds	r3, r1, r3
 802750e:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = FALSE; /* flip for next time */
 8027510:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8027512:	2200      	movs	r2, #0
 8027514:	625a      	str	r2, [r3, #36]	; 0x24
 8027516:	e009      	b.n	802752c <pass2_fs_dither+0xcc>
    } else {
      /* work left to right in this row */
      dir = 1;
 8027518:	2301      	movs	r3, #1
 802751a:	64fb      	str	r3, [r7, #76]	; 0x4c
      dir3 = 3;
 802751c:	2303      	movs	r3, #3
 802751e:	64bb      	str	r3, [r7, #72]	; 0x48
      errorptr = cquantize->fserrors; /* => entry before first real column */
 8027520:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8027522:	6a1b      	ldr	r3, [r3, #32]
 8027524:	607b      	str	r3, [r7, #4]
      cquantize->on_odd_row = TRUE; /* flip for next time */
 8027526:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8027528:	2201      	movs	r2, #1
 802752a:	625a      	str	r2, [r3, #36]	; 0x24
    }
    /* Preset error values: no error propagated to first pixel from left */
    cur0 = cur1 = cur2 = 0;
 802752c:	2400      	movs	r4, #0
 802752e:	4625      	mov	r5, r4
 8027530:	462e      	mov	r6, r5
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
 8027532:	2300      	movs	r3, #0
 8027534:	667b      	str	r3, [r7, #100]	; 0x64
 8027536:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8027538:	66bb      	str	r3, [r7, #104]	; 0x68
 802753a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 802753c:	66fb      	str	r3, [r7, #108]	; 0x6c
    bpreverr0 = bpreverr1 = bpreverr2 = 0;
 802753e:	2300      	movs	r3, #0
 8027540:	65bb      	str	r3, [r7, #88]	; 0x58
 8027542:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8027544:	65fb      	str	r3, [r7, #92]	; 0x5c
 8027546:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8027548:	663b      	str	r3, [r7, #96]	; 0x60

    for (col = width; col > 0; col--) {
 802754a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802754c:	643b      	str	r3, [r7, #64]	; 0x40
 802754e:	e0b8      	b.n	80276c2 <pass2_fs_dither+0x262>
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
 8027550:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8027552:	005b      	lsls	r3, r3, #1
 8027554:	687a      	ldr	r2, [r7, #4]
 8027556:	4611      	mov	r1, r2
 8027558:	440b      	add	r3, r1
 802755a:	f9b3 3000 	ldrsh.w	r3, [r3]
 802755e:	4433      	add	r3, r6
 8027560:	3308      	adds	r3, #8
 8027562:	111e      	asrs	r6, r3, #4
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
 8027564:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8027566:	3301      	adds	r3, #1
 8027568:	005b      	lsls	r3, r3, #1
 802756a:	4611      	mov	r1, r2
 802756c:	440b      	add	r3, r1
 802756e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027572:	442b      	add	r3, r5
 8027574:	3308      	adds	r3, #8
 8027576:	111d      	asrs	r5, r3, #4
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
 8027578:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802757a:	3302      	adds	r3, #2
 802757c:	005b      	lsls	r3, r3, #1
 802757e:	4413      	add	r3, r2
 8027580:	f9b3 3000 	ldrsh.w	r3, [r3]
 8027584:	4423      	add	r3, r4
 8027586:	3308      	adds	r3, #8
 8027588:	111c      	asrs	r4, r3, #4
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
 802758a:	4633      	mov	r3, r6
 802758c:	009b      	lsls	r3, r3, #2
 802758e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8027590:	4413      	add	r3, r2
 8027592:	681e      	ldr	r6, [r3, #0]
      cur1 = error_limit[cur1];
 8027594:	462b      	mov	r3, r5
 8027596:	009b      	lsls	r3, r3, #2
 8027598:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802759a:	4413      	add	r3, r2
 802759c:	681d      	ldr	r5, [r3, #0]
      cur2 = error_limit[cur2];
 802759e:	4623      	mov	r3, r4
 80275a0:	009b      	lsls	r3, r3, #2
 80275a2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80275a4:	4413      	add	r3, r2
 80275a6:	681c      	ldr	r4, [r3, #0]
      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
 80275a8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80275aa:	781b      	ldrb	r3, [r3, #0]
 80275ac:	441e      	add	r6, r3
      cur1 += GETJSAMPLE(inptr[1]);
 80275ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80275b0:	3301      	adds	r3, #1
 80275b2:	781b      	ldrb	r3, [r3, #0]
 80275b4:	441d      	add	r5, r3
      cur2 += GETJSAMPLE(inptr[2]);
 80275b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80275b8:	3302      	adds	r3, #2
 80275ba:	781b      	ldrb	r3, [r3, #0]
 80275bc:	441c      	add	r4, r3
      cur0 = GETJSAMPLE(range_limit[cur0]);
 80275be:	4632      	mov	r2, r6
 80275c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80275c2:	4413      	add	r3, r2
 80275c4:	781b      	ldrb	r3, [r3, #0]
 80275c6:	461e      	mov	r6, r3
      cur1 = GETJSAMPLE(range_limit[cur1]);
 80275c8:	462a      	mov	r2, r5
 80275ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80275cc:	4413      	add	r3, r2
 80275ce:	781b      	ldrb	r3, [r3, #0]
 80275d0:	461d      	mov	r5, r3
      cur2 = GETJSAMPLE(range_limit[cur2]);
 80275d2:	4622      	mov	r2, r4
 80275d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80275d6:	4413      	add	r3, r2
 80275d8:	781b      	ldrb	r3, [r3, #0]
 80275da:	461c      	mov	r4, r3
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
 80275dc:	10f3      	asrs	r3, r6, #3
 80275de:	009b      	lsls	r3, r3, #2
 80275e0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80275e2:	4413      	add	r3, r2
 80275e4:	681a      	ldr	r2, [r3, #0]
 80275e6:	10ab      	asrs	r3, r5, #2
 80275e8:	019b      	lsls	r3, r3, #6
 80275ea:	441a      	add	r2, r3
 80275ec:	10e3      	asrs	r3, r4, #3
 80275ee:	005b      	lsls	r3, r3, #1
 80275f0:	4413      	add	r3, r2
 80275f2:	61fb      	str	r3, [r7, #28]
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
 80275f4:	69fb      	ldr	r3, [r7, #28]
 80275f6:	881b      	ldrh	r3, [r3, #0]
 80275f8:	2b00      	cmp	r3, #0
 80275fa:	d105      	bne.n	8027608 <pass2_fs_dither+0x1a8>
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
 80275fc:	10f1      	asrs	r1, r6, #3
 80275fe:	10aa      	asrs	r2, r5, #2
 8027600:	10e3      	asrs	r3, r4, #3
 8027602:	6978      	ldr	r0, [r7, #20]
 8027604:	f7ff fe0a 	bl	802721c <fill_inverse_cmap>
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
 8027608:	69fb      	ldr	r3, [r7, #28]
 802760a:	881b      	ldrh	r3, [r3, #0]
 802760c:	f103 38ff 	add.w	r8, r3, #4294967295
	*outptr = (JSAMPLE) pixcode;
 8027610:	fa5f f288 	uxtb.w	r2, r8
 8027614:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8027616:	701a      	strb	r2, [r3, #0]
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
 8027618:	4642      	mov	r2, r8
 802761a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802761c:	4413      	add	r3, r2
 802761e:	781b      	ldrb	r3, [r3, #0]
 8027620:	1af6      	subs	r6, r6, r3
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
 8027622:	4642      	mov	r2, r8
 8027624:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8027626:	4413      	add	r3, r2
 8027628:	781b      	ldrb	r3, [r3, #0]
 802762a:	1aed      	subs	r5, r5, r3
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
 802762c:	4642      	mov	r2, r8
 802762e:	6a3b      	ldr	r3, [r7, #32]
 8027630:	4413      	add	r3, r2
 8027632:	781b      	ldrb	r3, [r3, #0]
 8027634:	1ae4      	subs	r4, r4, r3
       * Add these into the running sums, and simultaneously shift the
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
 8027636:	4630      	mov	r0, r6
	delta = cur0 * 2;
 8027638:	ea4f 0846 	mov.w	r8, r6, lsl #1
	cur0 += delta;		/* form error * 3 */
 802763c:	4446      	add	r6, r8
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
 802763e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8027640:	b29a      	uxth	r2, r3
 8027642:	b2b3      	uxth	r3, r6
 8027644:	4413      	add	r3, r2
 8027646:	b29b      	uxth	r3, r3
 8027648:	b21b      	sxth	r3, r3
 802764a:	6879      	ldr	r1, [r7, #4]
 802764c:	460a      	mov	r2, r1
 802764e:	8013      	strh	r3, [r2, #0]
	cur0 += delta;		/* form error * 5 */
 8027650:	4446      	add	r6, r8
	bpreverr0 = belowerr0 + cur0;
 8027652:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8027654:	4433      	add	r3, r6
 8027656:	663b      	str	r3, [r7, #96]	; 0x60
	belowerr0 = bnexterr;
 8027658:	66f8      	str	r0, [r7, #108]	; 0x6c
	cur0 += delta;		/* form error * 7 */
 802765a:	4446      	add	r6, r8
	bnexterr = cur1;	/* Process component 1 */
 802765c:	4628      	mov	r0, r5
	delta = cur1 * 2;
 802765e:	ea4f 0845 	mov.w	r8, r5, lsl #1
	cur1 += delta;		/* form error * 3 */
 8027662:	4445      	add	r5, r8
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
 8027664:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8027666:	b29a      	uxth	r2, r3
 8027668:	b2ab      	uxth	r3, r5
 802766a:	4413      	add	r3, r2
 802766c:	b29a      	uxth	r2, r3
 802766e:	1c8b      	adds	r3, r1, #2
 8027670:	b212      	sxth	r2, r2
 8027672:	801a      	strh	r2, [r3, #0]
	cur1 += delta;		/* form error * 5 */
 8027674:	4445      	add	r5, r8
	bpreverr1 = belowerr1 + cur1;
 8027676:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8027678:	442b      	add	r3, r5
 802767a:	65fb      	str	r3, [r7, #92]	; 0x5c
	belowerr1 = bnexterr;
 802767c:	66b8      	str	r0, [r7, #104]	; 0x68
	cur1 += delta;		/* form error * 7 */
 802767e:	4445      	add	r5, r8
	bnexterr = cur2;	/* Process component 2 */
 8027680:	4620      	mov	r0, r4
	delta = cur2 * 2;
 8027682:	ea4f 0844 	mov.w	r8, r4, lsl #1
	cur2 += delta;		/* form error * 3 */
 8027686:	4444      	add	r4, r8
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
 8027688:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 802768a:	b29a      	uxth	r2, r3
 802768c:	b2a3      	uxth	r3, r4
 802768e:	4413      	add	r3, r2
 8027690:	b29a      	uxth	r2, r3
 8027692:	1d0b      	adds	r3, r1, #4
 8027694:	b212      	sxth	r2, r2
 8027696:	801a      	strh	r2, [r3, #0]
	cur2 += delta;		/* form error * 5 */
 8027698:	4444      	add	r4, r8
	bpreverr2 = belowerr2 + cur2;
 802769a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802769c:	4423      	add	r3, r4
 802769e:	65bb      	str	r3, [r7, #88]	; 0x58
	belowerr2 = bnexterr;
 80276a0:	6678      	str	r0, [r7, #100]	; 0x64
	cur2 += delta;		/* form error * 7 */
 80276a2:	4444      	add	r4, r8
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
 80276a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80276a6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80276a8:	4413      	add	r3, r2
 80276aa:	657b      	str	r3, [r7, #84]	; 0x54
      outptr += dir;
 80276ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80276ae:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80276b0:	4413      	add	r3, r2
 80276b2:	653b      	str	r3, [r7, #80]	; 0x50
      errorptr += dir3;		/* advance errorptr to current column */
 80276b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80276b6:	005b      	lsls	r3, r3, #1
 80276b8:	18cb      	adds	r3, r1, r3
 80276ba:	607b      	str	r3, [r7, #4]
    for (col = width; col > 0; col--) {
 80276bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80276be:	3b01      	subs	r3, #1
 80276c0:	643b      	str	r3, [r7, #64]	; 0x40
 80276c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80276c4:	2b00      	cmp	r3, #0
 80276c6:	f47f af43 	bne.w	8027550 <pass2_fs_dither+0xf0>
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
 80276ca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80276cc:	b21b      	sxth	r3, r3
 80276ce:	6879      	ldr	r1, [r7, #4]
 80276d0:	460a      	mov	r2, r1
 80276d2:	8013      	strh	r3, [r2, #0]
    errorptr[1] = (FSERROR) bpreverr1;
 80276d4:	1c8b      	adds	r3, r1, #2
 80276d6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80276d8:	b212      	sxth	r2, r2
 80276da:	801a      	strh	r2, [r3, #0]
    errorptr[2] = (FSERROR) bpreverr2;
 80276dc:	1d0b      	adds	r3, r1, #4
 80276de:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80276e0:	b212      	sxth	r2, r2
 80276e2:	801a      	strh	r2, [r3, #0]
  for (row = 0; row < num_rows; row++) {
 80276e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80276e6:	3301      	adds	r3, #1
 80276e8:	647b      	str	r3, [r7, #68]	; 0x44
 80276ea:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80276ec:	68bb      	ldr	r3, [r7, #8]
 80276ee:	429a      	cmp	r2, r3
 80276f0:	f6ff aee1 	blt.w	80274b6 <pass2_fs_dither+0x56>
  }
}
 80276f4:	bf00      	nop
 80276f6:	bf00      	nop
 80276f8:	3770      	adds	r7, #112	; 0x70
 80276fa:	46bd      	mov	sp, r7
 80276fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08027700 <init_error_limit>:
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
 8027700:	b580      	push	{r7, lr}
 8027702:	b086      	sub	sp, #24
 8027704:	af00      	add	r7, sp, #0
 8027706:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8027708:	687b      	ldr	r3, [r7, #4]
 802770a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 802770e:	60fb      	str	r3, [r7, #12]
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
 8027710:	687b      	ldr	r3, [r7, #4]
 8027712:	685b      	ldr	r3, [r3, #4]
 8027714:	681b      	ldr	r3, [r3, #0]
 8027716:	f240 72fc 	movw	r2, #2044	; 0x7fc
 802771a:	2101      	movs	r1, #1
 802771c:	6878      	ldr	r0, [r7, #4]
 802771e:	4798      	blx	r3
 8027720:	60b8      	str	r0, [r7, #8]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
 8027722:	68bb      	ldr	r3, [r7, #8]
 8027724:	f503 737f 	add.w	r3, r3, #1020	; 0x3fc
 8027728:	60bb      	str	r3, [r7, #8]
  cquantize->error_limiter = table;
 802772a:	68fb      	ldr	r3, [r7, #12]
 802772c:	68ba      	ldr	r2, [r7, #8]
 802772e:	629a      	str	r2, [r3, #40]	; 0x28

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
 8027730:	2300      	movs	r3, #0
 8027732:	613b      	str	r3, [r7, #16]
  for (in = 0; in < STEPSIZE; in++, out++) {
 8027734:	2300      	movs	r3, #0
 8027736:	617b      	str	r3, [r7, #20]
 8027738:	e016      	b.n	8027768 <init_error_limit+0x68>
    table[in] = out; table[-in] = -out;
 802773a:	697b      	ldr	r3, [r7, #20]
 802773c:	009b      	lsls	r3, r3, #2
 802773e:	68ba      	ldr	r2, [r7, #8]
 8027740:	4413      	add	r3, r2
 8027742:	693a      	ldr	r2, [r7, #16]
 8027744:	601a      	str	r2, [r3, #0]
 8027746:	697a      	ldr	r2, [r7, #20]
 8027748:	4613      	mov	r3, r2
 802774a:	079b      	lsls	r3, r3, #30
 802774c:	1a9b      	subs	r3, r3, r2
 802774e:	009b      	lsls	r3, r3, #2
 8027750:	461a      	mov	r2, r3
 8027752:	68bb      	ldr	r3, [r7, #8]
 8027754:	4413      	add	r3, r2
 8027756:	693a      	ldr	r2, [r7, #16]
 8027758:	4252      	negs	r2, r2
 802775a:	601a      	str	r2, [r3, #0]
  for (in = 0; in < STEPSIZE; in++, out++) {
 802775c:	697b      	ldr	r3, [r7, #20]
 802775e:	3301      	adds	r3, #1
 8027760:	617b      	str	r3, [r7, #20]
 8027762:	693b      	ldr	r3, [r7, #16]
 8027764:	3301      	adds	r3, #1
 8027766:	613b      	str	r3, [r7, #16]
 8027768:	697b      	ldr	r3, [r7, #20]
 802776a:	2b0f      	cmp	r3, #15
 802776c:	dde5      	ble.n	802773a <init_error_limit+0x3a>
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 802776e:	e01f      	b.n	80277b0 <init_error_limit+0xb0>
    table[in] = out; table[-in] = -out;
 8027770:	697b      	ldr	r3, [r7, #20]
 8027772:	009b      	lsls	r3, r3, #2
 8027774:	68ba      	ldr	r2, [r7, #8]
 8027776:	4413      	add	r3, r2
 8027778:	693a      	ldr	r2, [r7, #16]
 802777a:	601a      	str	r2, [r3, #0]
 802777c:	697a      	ldr	r2, [r7, #20]
 802777e:	4613      	mov	r3, r2
 8027780:	079b      	lsls	r3, r3, #30
 8027782:	1a9b      	subs	r3, r3, r2
 8027784:	009b      	lsls	r3, r3, #2
 8027786:	461a      	mov	r2, r3
 8027788:	68bb      	ldr	r3, [r7, #8]
 802778a:	4413      	add	r3, r2
 802778c:	693a      	ldr	r2, [r7, #16]
 802778e:	4252      	negs	r2, r2
 8027790:	601a      	str	r2, [r3, #0]
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
 8027792:	697b      	ldr	r3, [r7, #20]
 8027794:	3301      	adds	r3, #1
 8027796:	617b      	str	r3, [r7, #20]
 8027798:	697b      	ldr	r3, [r7, #20]
 802779a:	f003 0301 	and.w	r3, r3, #1
 802779e:	2b00      	cmp	r3, #0
 80277a0:	bf0c      	ite	eq
 80277a2:	2301      	moveq	r3, #1
 80277a4:	2300      	movne	r3, #0
 80277a6:	b2db      	uxtb	r3, r3
 80277a8:	461a      	mov	r2, r3
 80277aa:	693b      	ldr	r3, [r7, #16]
 80277ac:	4413      	add	r3, r2
 80277ae:	613b      	str	r3, [r7, #16]
 80277b0:	697b      	ldr	r3, [r7, #20]
 80277b2:	2b2f      	cmp	r3, #47	; 0x2f
 80277b4:	dddc      	ble.n	8027770 <init_error_limit+0x70>
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
 80277b6:	e013      	b.n	80277e0 <init_error_limit+0xe0>
    table[in] = out; table[-in] = -out;
 80277b8:	697b      	ldr	r3, [r7, #20]
 80277ba:	009b      	lsls	r3, r3, #2
 80277bc:	68ba      	ldr	r2, [r7, #8]
 80277be:	4413      	add	r3, r2
 80277c0:	693a      	ldr	r2, [r7, #16]
 80277c2:	601a      	str	r2, [r3, #0]
 80277c4:	697a      	ldr	r2, [r7, #20]
 80277c6:	4613      	mov	r3, r2
 80277c8:	079b      	lsls	r3, r3, #30
 80277ca:	1a9b      	subs	r3, r3, r2
 80277cc:	009b      	lsls	r3, r3, #2
 80277ce:	461a      	mov	r2, r3
 80277d0:	68bb      	ldr	r3, [r7, #8]
 80277d2:	4413      	add	r3, r2
 80277d4:	693a      	ldr	r2, [r7, #16]
 80277d6:	4252      	negs	r2, r2
 80277d8:	601a      	str	r2, [r3, #0]
  for (; in <= MAXJSAMPLE; in++) {
 80277da:	697b      	ldr	r3, [r7, #20]
 80277dc:	3301      	adds	r3, #1
 80277de:	617b      	str	r3, [r7, #20]
 80277e0:	697b      	ldr	r3, [r7, #20]
 80277e2:	2bff      	cmp	r3, #255	; 0xff
 80277e4:	dde8      	ble.n	80277b8 <init_error_limit+0xb8>
  }
#undef STEPSIZE
}
 80277e6:	bf00      	nop
 80277e8:	bf00      	nop
 80277ea:	3718      	adds	r7, #24
 80277ec:	46bd      	mov	sp, r7
 80277ee:	bd80      	pop	{r7, pc}

080277f0 <finish_pass1>:
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
 80277f0:	b580      	push	{r7, lr}
 80277f2:	b084      	sub	sp, #16
 80277f4:	af00      	add	r7, sp, #0
 80277f6:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 80277f8:	687b      	ldr	r3, [r7, #4]
 80277fa:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 80277fe:	60fb      	str	r3, [r7, #12]

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
 8027800:	68fb      	ldr	r3, [r7, #12]
 8027802:	691a      	ldr	r2, [r3, #16]
 8027804:	687b      	ldr	r3, [r7, #4]
 8027806:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  select_colors(cinfo, cquantize->desired);
 802780a:	68fb      	ldr	r3, [r7, #12]
 802780c:	695b      	ldr	r3, [r3, #20]
 802780e:	4619      	mov	r1, r3
 8027810:	6878      	ldr	r0, [r7, #4]
 8027812:	f7ff f978 	bl	8026b06 <select_colors>
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
 8027816:	68fb      	ldr	r3, [r7, #12]
 8027818:	2201      	movs	r2, #1
 802781a:	61da      	str	r2, [r3, #28]
}
 802781c:	bf00      	nop
 802781e:	3710      	adds	r7, #16
 8027820:	46bd      	mov	sp, r7
 8027822:	bd80      	pop	{r7, pc}

08027824 <finish_pass2>:


METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
 8027824:	b480      	push	{r7}
 8027826:	b083      	sub	sp, #12
 8027828:	af00      	add	r7, sp, #0
 802782a:	6078      	str	r0, [r7, #4]
  /* no work */
}
 802782c:	bf00      	nop
 802782e:	370c      	adds	r7, #12
 8027830:	46bd      	mov	sp, r7
 8027832:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027836:	4770      	bx	lr

08027838 <start_pass_2_quant>:
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
 8027838:	b580      	push	{r7, lr}
 802783a:	b086      	sub	sp, #24
 802783c:	af00      	add	r7, sp, #0
 802783e:	6078      	str	r0, [r7, #4]
 8027840:	6039      	str	r1, [r7, #0]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8027842:	687b      	ldr	r3, [r7, #4]
 8027844:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 8027848:	613b      	str	r3, [r7, #16]
  hist3d histogram = cquantize->histogram;
 802784a:	693b      	ldr	r3, [r7, #16]
 802784c:	699b      	ldr	r3, [r3, #24]
 802784e:	60fb      	str	r3, [r7, #12]
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 8027850:	687b      	ldr	r3, [r7, #4]
 8027852:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8027856:	2b00      	cmp	r3, #0
 8027858:	d003      	beq.n	8027862 <start_pass_2_quant+0x2a>
    cinfo->dither_mode = JDITHER_FS;
 802785a:	687b      	ldr	r3, [r7, #4]
 802785c:	2202      	movs	r2, #2
 802785e:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  if (is_pre_scan) {
 8027862:	683b      	ldr	r3, [r7, #0]
 8027864:	2b00      	cmp	r3, #0
 8027866:	d009      	beq.n	802787c <start_pass_2_quant+0x44>
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
 8027868:	693b      	ldr	r3, [r7, #16]
 802786a:	4a44      	ldr	r2, [pc, #272]	; (802797c <start_pass_2_quant+0x144>)
 802786c:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass1;
 802786e:	693b      	ldr	r3, [r7, #16]
 8027870:	4a43      	ldr	r2, [pc, #268]	; (8027980 <start_pass_2_quant+0x148>)
 8027872:	609a      	str	r2, [r3, #8]
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
 8027874:	693b      	ldr	r3, [r7, #16]
 8027876:	2201      	movs	r2, #1
 8027878:	61da      	str	r2, [r3, #28]
 802787a:	e060      	b.n	802793e <start_pass_2_quant+0x106>
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
 802787c:	687b      	ldr	r3, [r7, #4]
 802787e:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8027882:	2b02      	cmp	r3, #2
 8027884:	d103      	bne.n	802788e <start_pass_2_quant+0x56>
      cquantize->pub.color_quantize = pass2_fs_dither;
 8027886:	693b      	ldr	r3, [r7, #16]
 8027888:	4a3e      	ldr	r2, [pc, #248]	; (8027984 <start_pass_2_quant+0x14c>)
 802788a:	605a      	str	r2, [r3, #4]
 802788c:	e002      	b.n	8027894 <start_pass_2_quant+0x5c>
    else
      cquantize->pub.color_quantize = pass2_no_dither;
 802788e:	693b      	ldr	r3, [r7, #16]
 8027890:	4a3d      	ldr	r2, [pc, #244]	; (8027988 <start_pass_2_quant+0x150>)
 8027892:	605a      	str	r2, [r3, #4]
    cquantize->pub.finish_pass = finish_pass2;
 8027894:	693b      	ldr	r3, [r7, #16]
 8027896:	4a3d      	ldr	r2, [pc, #244]	; (802798c <start_pass_2_quant+0x154>)
 8027898:	609a      	str	r2, [r3, #8]

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
 802789a:	687b      	ldr	r3, [r7, #4]
 802789c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80278a0:	617b      	str	r3, [r7, #20]
    if (i < 1)
 80278a2:	697b      	ldr	r3, [r7, #20]
 80278a4:	2b00      	cmp	r3, #0
 80278a6:	dc0c      	bgt.n	80278c2 <start_pass_2_quant+0x8a>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
 80278a8:	687b      	ldr	r3, [r7, #4]
 80278aa:	681b      	ldr	r3, [r3, #0]
 80278ac:	223a      	movs	r2, #58	; 0x3a
 80278ae:	615a      	str	r2, [r3, #20]
 80278b0:	687b      	ldr	r3, [r7, #4]
 80278b2:	681b      	ldr	r3, [r3, #0]
 80278b4:	2201      	movs	r2, #1
 80278b6:	619a      	str	r2, [r3, #24]
 80278b8:	687b      	ldr	r3, [r7, #4]
 80278ba:	681b      	ldr	r3, [r3, #0]
 80278bc:	681b      	ldr	r3, [r3, #0]
 80278be:	6878      	ldr	r0, [r7, #4]
 80278c0:	4798      	blx	r3
    if (i > MAXNUMCOLORS)
 80278c2:	697b      	ldr	r3, [r7, #20]
 80278c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80278c8:	dd0d      	ble.n	80278e6 <start_pass_2_quant+0xae>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 80278ca:	687b      	ldr	r3, [r7, #4]
 80278cc:	681b      	ldr	r3, [r3, #0]
 80278ce:	223b      	movs	r2, #59	; 0x3b
 80278d0:	615a      	str	r2, [r3, #20]
 80278d2:	687b      	ldr	r3, [r7, #4]
 80278d4:	681b      	ldr	r3, [r3, #0]
 80278d6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80278da:	619a      	str	r2, [r3, #24]
 80278dc:	687b      	ldr	r3, [r7, #4]
 80278de:	681b      	ldr	r3, [r3, #0]
 80278e0:	681b      	ldr	r3, [r3, #0]
 80278e2:	6878      	ldr	r0, [r7, #4]
 80278e4:	4798      	blx	r3

    if (cinfo->dither_mode == JDITHER_FS) {
 80278e6:	687b      	ldr	r3, [r7, #4]
 80278e8:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 80278ec:	2b02      	cmp	r3, #2
 80278ee:	d126      	bne.n	802793e <start_pass_2_quant+0x106>
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
 80278f0:	687b      	ldr	r3, [r7, #4]
 80278f2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80278f4:	4613      	mov	r3, r2
 80278f6:	005b      	lsls	r3, r3, #1
 80278f8:	4413      	add	r3, r2
 80278fa:	005b      	lsls	r3, r3, #1
 80278fc:	330c      	adds	r3, #12
 80278fe:	60bb      	str	r3, [r7, #8]
				   (3 * SIZEOF(FSERROR)));
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
 8027900:	693b      	ldr	r3, [r7, #16]
 8027902:	6a1b      	ldr	r3, [r3, #32]
 8027904:	2b00      	cmp	r3, #0
 8027906:	d109      	bne.n	802791c <start_pass_2_quant+0xe4>
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 8027908:	687b      	ldr	r3, [r7, #4]
 802790a:	685b      	ldr	r3, [r3, #4]
 802790c:	685b      	ldr	r3, [r3, #4]
 802790e:	68ba      	ldr	r2, [r7, #8]
 8027910:	2101      	movs	r1, #1
 8027912:	6878      	ldr	r0, [r7, #4]
 8027914:	4798      	blx	r3
 8027916:	4602      	mov	r2, r0
 8027918:	693b      	ldr	r3, [r7, #16]
 802791a:	621a      	str	r2, [r3, #32]
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      FMEMZERO((void FAR *) cquantize->fserrors, arraysize);
 802791c:	693b      	ldr	r3, [r7, #16]
 802791e:	6a1b      	ldr	r3, [r3, #32]
 8027920:	68ba      	ldr	r2, [r7, #8]
 8027922:	2100      	movs	r1, #0
 8027924:	4618      	mov	r0, r3
 8027926:	f000 fcab 	bl	8028280 <memset>
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
 802792a:	693b      	ldr	r3, [r7, #16]
 802792c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802792e:	2b00      	cmp	r3, #0
 8027930:	d102      	bne.n	8027938 <start_pass_2_quant+0x100>
	init_error_limit(cinfo);
 8027932:	6878      	ldr	r0, [r7, #4]
 8027934:	f7ff fee4 	bl	8027700 <init_error_limit>
      cquantize->on_odd_row = FALSE;
 8027938:	693b      	ldr	r3, [r7, #16]
 802793a:	2200      	movs	r2, #0
 802793c:	625a      	str	r2, [r3, #36]	; 0x24
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
 802793e:	693b      	ldr	r3, [r7, #16]
 8027940:	69db      	ldr	r3, [r3, #28]
 8027942:	2b00      	cmp	r3, #0
 8027944:	d016      	beq.n	8027974 <start_pass_2_quant+0x13c>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 8027946:	2300      	movs	r3, #0
 8027948:	617b      	str	r3, [r7, #20]
 802794a:	e00d      	b.n	8027968 <start_pass_2_quant+0x130>
      FMEMZERO((void FAR *) histogram[i],
 802794c:	697b      	ldr	r3, [r7, #20]
 802794e:	009b      	lsls	r3, r3, #2
 8027950:	68fa      	ldr	r2, [r7, #12]
 8027952:	4413      	add	r3, r2
 8027954:	681b      	ldr	r3, [r3, #0]
 8027956:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 802795a:	2100      	movs	r1, #0
 802795c:	4618      	mov	r0, r3
 802795e:	f000 fc8f 	bl	8028280 <memset>
    for (i = 0; i < HIST_C0_ELEMS; i++) {
 8027962:	697b      	ldr	r3, [r7, #20]
 8027964:	3301      	adds	r3, #1
 8027966:	617b      	str	r3, [r7, #20]
 8027968:	697b      	ldr	r3, [r7, #20]
 802796a:	2b1f      	cmp	r3, #31
 802796c:	ddee      	ble.n	802794c <start_pass_2_quant+0x114>
	       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
 802796e:	693b      	ldr	r3, [r7, #16]
 8027970:	2200      	movs	r2, #0
 8027972:	61da      	str	r2, [r3, #28]
  }
}
 8027974:	bf00      	nop
 8027976:	3718      	adds	r7, #24
 8027978:	46bd      	mov	sp, r7
 802797a:	bd80      	pop	{r7, pc}
 802797c:	080263ad 	.word	0x080263ad
 8027980:	080277f1 	.word	0x080277f1
 8027984:	08027461 	.word	0x08027461
 8027988:	0802739d 	.word	0x0802739d
 802798c:	08027825 	.word	0x08027825

08027990 <new_color_map_2_quant>:
 * Switch to a new external colormap between output passes.
 */

METHODDEF(void)
new_color_map_2_quant (j_decompress_ptr cinfo)
{
 8027990:	b480      	push	{r7}
 8027992:	b085      	sub	sp, #20
 8027994:	af00      	add	r7, sp, #0
 8027996:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
 8027998:	687b      	ldr	r3, [r7, #4]
 802799a:	f8d3 31e0 	ldr.w	r3, [r3, #480]	; 0x1e0
 802799e:	60fb      	str	r3, [r7, #12]

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
 80279a0:	68fb      	ldr	r3, [r7, #12]
 80279a2:	2201      	movs	r2, #1
 80279a4:	61da      	str	r2, [r3, #28]
}
 80279a6:	bf00      	nop
 80279a8:	3714      	adds	r7, #20
 80279aa:	46bd      	mov	sp, r7
 80279ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279b0:	4770      	bx	lr
	...

080279b4 <jinit_2pass_quantizer>:
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
 80279b4:	b590      	push	{r4, r7, lr}
 80279b6:	b087      	sub	sp, #28
 80279b8:	af00      	add	r7, sp, #0
 80279ba:	6078      	str	r0, [r7, #4]
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 80279bc:	687b      	ldr	r3, [r7, #4]
 80279be:	685b      	ldr	r3, [r3, #4]
 80279c0:	681b      	ldr	r3, [r3, #0]
 80279c2:	222c      	movs	r2, #44	; 0x2c
 80279c4:	2101      	movs	r1, #1
 80279c6:	6878      	ldr	r0, [r7, #4]
 80279c8:	4798      	blx	r3
 80279ca:	6138      	str	r0, [r7, #16]
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
 80279cc:	687b      	ldr	r3, [r7, #4]
 80279ce:	693a      	ldr	r2, [r7, #16]
 80279d0:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
  cquantize->pub.start_pass = start_pass_2_quant;
 80279d4:	693b      	ldr	r3, [r7, #16]
 80279d6:	4a4f      	ldr	r2, [pc, #316]	; (8027b14 <jinit_2pass_quantizer+0x160>)
 80279d8:	601a      	str	r2, [r3, #0]
  cquantize->pub.new_color_map = new_color_map_2_quant;
 80279da:	693b      	ldr	r3, [r7, #16]
 80279dc:	4a4e      	ldr	r2, [pc, #312]	; (8027b18 <jinit_2pass_quantizer+0x164>)
 80279de:	60da      	str	r2, [r3, #12]
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
 80279e0:	693b      	ldr	r3, [r7, #16]
 80279e2:	2200      	movs	r2, #0
 80279e4:	621a      	str	r2, [r3, #32]
  cquantize->error_limiter = NULL;
 80279e6:	693b      	ldr	r3, [r7, #16]
 80279e8:	2200      	movs	r2, #0
 80279ea:	629a      	str	r2, [r3, #40]	; 0x28

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
 80279ec:	687b      	ldr	r3, [r7, #4]
 80279ee:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80279f0:	2b03      	cmp	r3, #3
 80279f2:	d008      	beq.n	8027a06 <jinit_2pass_quantizer+0x52>
    ERREXIT(cinfo, JERR_NOTIMPL);
 80279f4:	687b      	ldr	r3, [r7, #4]
 80279f6:	681b      	ldr	r3, [r3, #0]
 80279f8:	2230      	movs	r2, #48	; 0x30
 80279fa:	615a      	str	r2, [r3, #20]
 80279fc:	687b      	ldr	r3, [r7, #4]
 80279fe:	681b      	ldr	r3, [r3, #0]
 8027a00:	681b      	ldr	r3, [r3, #0]
 8027a02:	6878      	ldr	r0, [r7, #4]
 8027a04:	4798      	blx	r3

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
 8027a06:	687b      	ldr	r3, [r7, #4]
 8027a08:	685b      	ldr	r3, [r3, #4]
 8027a0a:	681b      	ldr	r3, [r3, #0]
 8027a0c:	2280      	movs	r2, #128	; 0x80
 8027a0e:	2101      	movs	r1, #1
 8027a10:	6878      	ldr	r0, [r7, #4]
 8027a12:	4798      	blx	r3
 8027a14:	4602      	mov	r2, r0
 8027a16:	693b      	ldr	r3, [r7, #16]
 8027a18:	619a      	str	r2, [r3, #24]
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 8027a1a:	2300      	movs	r3, #0
 8027a1c:	617b      	str	r3, [r7, #20]
 8027a1e:	e011      	b.n	8027a44 <jinit_2pass_quantizer+0x90>
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
 8027a20:	687b      	ldr	r3, [r7, #4]
 8027a22:	685b      	ldr	r3, [r3, #4]
 8027a24:	685b      	ldr	r3, [r3, #4]
 8027a26:	693a      	ldr	r2, [r7, #16]
 8027a28:	6991      	ldr	r1, [r2, #24]
 8027a2a:	697a      	ldr	r2, [r7, #20]
 8027a2c:	0092      	lsls	r2, r2, #2
 8027a2e:	188c      	adds	r4, r1, r2
 8027a30:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8027a34:	2101      	movs	r1, #1
 8027a36:	6878      	ldr	r0, [r7, #4]
 8027a38:	4798      	blx	r3
 8027a3a:	4603      	mov	r3, r0
 8027a3c:	6023      	str	r3, [r4, #0]
  for (i = 0; i < HIST_C0_ELEMS; i++) {
 8027a3e:	697b      	ldr	r3, [r7, #20]
 8027a40:	3301      	adds	r3, #1
 8027a42:	617b      	str	r3, [r7, #20]
 8027a44:	697b      	ldr	r3, [r7, #20]
 8027a46:	2b1f      	cmp	r3, #31
 8027a48:	ddea      	ble.n	8027a20 <jinit_2pass_quantizer+0x6c>
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
 8027a4a:	693b      	ldr	r3, [r7, #16]
 8027a4c:	2201      	movs	r2, #1
 8027a4e:	61da      	str	r2, [r3, #28]

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
 8027a50:	687b      	ldr	r3, [r7, #4]
 8027a52:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8027a54:	2b00      	cmp	r3, #0
 8027a56:	d033      	beq.n	8027ac0 <jinit_2pass_quantizer+0x10c>
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
 8027a58:	687b      	ldr	r3, [r7, #4]
 8027a5a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8027a5c:	60fb      	str	r3, [r7, #12]
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
 8027a5e:	68fb      	ldr	r3, [r7, #12]
 8027a60:	2b07      	cmp	r3, #7
 8027a62:	dc0c      	bgt.n	8027a7e <jinit_2pass_quantizer+0xca>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
 8027a64:	687b      	ldr	r3, [r7, #4]
 8027a66:	681b      	ldr	r3, [r3, #0]
 8027a68:	223a      	movs	r2, #58	; 0x3a
 8027a6a:	615a      	str	r2, [r3, #20]
 8027a6c:	687b      	ldr	r3, [r7, #4]
 8027a6e:	681b      	ldr	r3, [r3, #0]
 8027a70:	2208      	movs	r2, #8
 8027a72:	619a      	str	r2, [r3, #24]
 8027a74:	687b      	ldr	r3, [r7, #4]
 8027a76:	681b      	ldr	r3, [r3, #0]
 8027a78:	681b      	ldr	r3, [r3, #0]
 8027a7a:	6878      	ldr	r0, [r7, #4]
 8027a7c:	4798      	blx	r3
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
 8027a7e:	68fb      	ldr	r3, [r7, #12]
 8027a80:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8027a84:	dd0d      	ble.n	8027aa2 <jinit_2pass_quantizer+0xee>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
 8027a86:	687b      	ldr	r3, [r7, #4]
 8027a88:	681b      	ldr	r3, [r3, #0]
 8027a8a:	223b      	movs	r2, #59	; 0x3b
 8027a8c:	615a      	str	r2, [r3, #20]
 8027a8e:	687b      	ldr	r3, [r7, #4]
 8027a90:	681b      	ldr	r3, [r3, #0]
 8027a92:	f44f 7280 	mov.w	r2, #256	; 0x100
 8027a96:	619a      	str	r2, [r3, #24]
 8027a98:	687b      	ldr	r3, [r7, #4]
 8027a9a:	681b      	ldr	r3, [r3, #0]
 8027a9c:	681b      	ldr	r3, [r3, #0]
 8027a9e:	6878      	ldr	r0, [r7, #4]
 8027aa0:	4798      	blx	r3
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
 8027aa2:	687b      	ldr	r3, [r7, #4]
 8027aa4:	685b      	ldr	r3, [r3, #4]
 8027aa6:	689c      	ldr	r4, [r3, #8]
 8027aa8:	68fa      	ldr	r2, [r7, #12]
 8027aaa:	2303      	movs	r3, #3
 8027aac:	2101      	movs	r1, #1
 8027aae:	6878      	ldr	r0, [r7, #4]
 8027ab0:	47a0      	blx	r4
 8027ab2:	4602      	mov	r2, r0
 8027ab4:	693b      	ldr	r3, [r7, #16]
 8027ab6:	611a      	str	r2, [r3, #16]
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
 8027ab8:	693b      	ldr	r3, [r7, #16]
 8027aba:	68fa      	ldr	r2, [r7, #12]
 8027abc:	615a      	str	r2, [r3, #20]
 8027abe:	e002      	b.n	8027ac6 <jinit_2pass_quantizer+0x112>
  } else
    cquantize->sv_colormap = NULL;
 8027ac0:	693b      	ldr	r3, [r7, #16]
 8027ac2:	2200      	movs	r2, #0
 8027ac4:	611a      	str	r2, [r3, #16]

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
 8027ac6:	687b      	ldr	r3, [r7, #4]
 8027ac8:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8027acc:	2b00      	cmp	r3, #0
 8027ace:	d003      	beq.n	8027ad8 <jinit_2pass_quantizer+0x124>
    cinfo->dither_mode = JDITHER_FS;
 8027ad0:	687b      	ldr	r3, [r7, #4]
 8027ad2:	2202      	movs	r2, #2
 8027ad4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
  /* Allocate Floyd-Steinberg workspace if necessary.
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
 8027ad8:	687b      	ldr	r3, [r7, #4]
 8027ada:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8027ade:	2b02      	cmp	r3, #2
 8027ae0:	d113      	bne.n	8027b0a <jinit_2pass_quantizer+0x156>
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 8027ae2:	687b      	ldr	r3, [r7, #4]
 8027ae4:	685b      	ldr	r3, [r3, #4]
 8027ae6:	685c      	ldr	r4, [r3, #4]
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 8027ae8:	687b      	ldr	r3, [r7, #4]
 8027aea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 8027aec:	4613      	mov	r3, r2
 8027aee:	005b      	lsls	r3, r3, #1
 8027af0:	4413      	add	r3, r2
 8027af2:	005b      	lsls	r3, r3, #1
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
 8027af4:	330c      	adds	r3, #12
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
 8027af6:	461a      	mov	r2, r3
 8027af8:	2101      	movs	r1, #1
 8027afa:	6878      	ldr	r0, [r7, #4]
 8027afc:	47a0      	blx	r4
 8027afe:	4602      	mov	r2, r0
 8027b00:	693b      	ldr	r3, [r7, #16]
 8027b02:	621a      	str	r2, [r3, #32]
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
 8027b04:	6878      	ldr	r0, [r7, #4]
 8027b06:	f7ff fdfb 	bl	8027700 <init_error_limit>
  }
}
 8027b0a:	bf00      	nop
 8027b0c:	371c      	adds	r7, #28
 8027b0e:	46bd      	mov	sp, r7
 8027b10:	bd90      	pop	{r4, r7, pc}
 8027b12:	bf00      	nop
 8027b14:	08027839 	.word	0x08027839
 8027b18:	08027991 	.word	0x08027991

08027b1c <jdiv_round_up>:

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
 8027b1c:	b480      	push	{r7}
 8027b1e:	b083      	sub	sp, #12
 8027b20:	af00      	add	r7, sp, #0
 8027b22:	6078      	str	r0, [r7, #4]
 8027b24:	6039      	str	r1, [r7, #0]
  return (a + b - 1L) / b;
 8027b26:	687a      	ldr	r2, [r7, #4]
 8027b28:	683b      	ldr	r3, [r7, #0]
 8027b2a:	4413      	add	r3, r2
 8027b2c:	1e5a      	subs	r2, r3, #1
 8027b2e:	683b      	ldr	r3, [r7, #0]
 8027b30:	fb92 f3f3 	sdiv	r3, r2, r3
}
 8027b34:	4618      	mov	r0, r3
 8027b36:	370c      	adds	r7, #12
 8027b38:	46bd      	mov	sp, r7
 8027b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b3e:	4770      	bx	lr

08027b40 <jround_up>:

GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
 8027b40:	b480      	push	{r7}
 8027b42:	b083      	sub	sp, #12
 8027b44:	af00      	add	r7, sp, #0
 8027b46:	6078      	str	r0, [r7, #4]
 8027b48:	6039      	str	r1, [r7, #0]
  a += b - 1L;
 8027b4a:	683b      	ldr	r3, [r7, #0]
 8027b4c:	3b01      	subs	r3, #1
 8027b4e:	687a      	ldr	r2, [r7, #4]
 8027b50:	4413      	add	r3, r2
 8027b52:	607b      	str	r3, [r7, #4]
  return a - (a % b);
 8027b54:	687b      	ldr	r3, [r7, #4]
 8027b56:	683a      	ldr	r2, [r7, #0]
 8027b58:	fb93 f2f2 	sdiv	r2, r3, r2
 8027b5c:	6839      	ldr	r1, [r7, #0]
 8027b5e:	fb01 f202 	mul.w	r2, r1, r2
 8027b62:	1a9b      	subs	r3, r3, r2
 8027b64:	687a      	ldr	r2, [r7, #4]
 8027b66:	1ad3      	subs	r3, r2, r3
}
 8027b68:	4618      	mov	r0, r3
 8027b6a:	370c      	adds	r7, #12
 8027b6c:	46bd      	mov	sp, r7
 8027b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b72:	4770      	bx	lr

08027b74 <jcopy_sample_rows>:
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
 8027b74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027b76:	b085      	sub	sp, #20
 8027b78:	af00      	add	r7, sp, #0
 8027b7a:	60f8      	str	r0, [r7, #12]
 8027b7c:	60b9      	str	r1, [r7, #8]
 8027b7e:	607a      	str	r2, [r7, #4]
 8027b80:	603b      	str	r3, [r7, #0]
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
 8027b82:	6afd      	ldr	r5, [r7, #44]	; 0x2c
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
 8027b84:	68bb      	ldr	r3, [r7, #8]
 8027b86:	009b      	lsls	r3, r3, #2
 8027b88:	68fa      	ldr	r2, [r7, #12]
 8027b8a:	4413      	add	r3, r2
 8027b8c:	60fb      	str	r3, [r7, #12]
  output_array += dest_row;
 8027b8e:	683b      	ldr	r3, [r7, #0]
 8027b90:	009b      	lsls	r3, r3, #2
 8027b92:	687a      	ldr	r2, [r7, #4]
 8027b94:	4413      	add	r3, r2
 8027b96:	607b      	str	r3, [r7, #4]

  for (row = num_rows; row > 0; row--) {
 8027b98:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8027b9a:	e00c      	b.n	8027bb6 <jcopy_sample_rows+0x42>
    inptr = *input_array++;
 8027b9c:	68fb      	ldr	r3, [r7, #12]
 8027b9e:	1d1a      	adds	r2, r3, #4
 8027ba0:	60fa      	str	r2, [r7, #12]
 8027ba2:	6819      	ldr	r1, [r3, #0]
    outptr = *output_array++;
 8027ba4:	687b      	ldr	r3, [r7, #4]
 8027ba6:	1d1a      	adds	r2, r3, #4
 8027ba8:	607a      	str	r2, [r7, #4]
 8027baa:	681e      	ldr	r6, [r3, #0]
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
 8027bac:	462a      	mov	r2, r5
 8027bae:	4630      	mov	r0, r6
 8027bb0:	f000 fb58 	bl	8028264 <memcpy>
  for (row = num_rows; row > 0; row--) {
 8027bb4:	3c01      	subs	r4, #1
 8027bb6:	2c00      	cmp	r4, #0
 8027bb8:	dcf0      	bgt.n	8027b9c <jcopy_sample_rows+0x28>
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
#endif
  }
}
 8027bba:	bf00      	nop
 8027bbc:	bf00      	nop
 8027bbe:	3714      	adds	r7, #20
 8027bc0:	46bd      	mov	sp, r7
 8027bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}

08027bc4 <jcopy_block_row>:

GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
 8027bc4:	b580      	push	{r7, lr}
 8027bc6:	b084      	sub	sp, #16
 8027bc8:	af00      	add	r7, sp, #0
 8027bca:	60f8      	str	r0, [r7, #12]
 8027bcc:	60b9      	str	r1, [r7, #8]
 8027bce:	607a      	str	r2, [r7, #4]
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
 8027bd0:	687b      	ldr	r3, [r7, #4]
 8027bd2:	01db      	lsls	r3, r3, #7
 8027bd4:	461a      	mov	r2, r3
 8027bd6:	68f9      	ldr	r1, [r7, #12]
 8027bd8:	68b8      	ldr	r0, [r7, #8]
 8027bda:	f000 fb43 	bl	8028264 <memcpy>
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}
 8027bde:	bf00      	nop
 8027be0:	3710      	adds	r7, #16
 8027be2:	46bd      	mov	sp, r7
 8027be4:	bd80      	pop	{r7, pc}
	...

08027be8 <MX_USB_HOST_Init>:
/**
  * Init USB host library, add supported class and start the library
  * @retval None
  */
void MX_USB_HOST_Init(void)
{
 8027be8:	b580      	push	{r7, lr}
 8027bea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_HOST_Init_PreTreatment */

  /* USER CODE END USB_HOST_Init_PreTreatment */

  /* Init host Library, add supported class and start the library. */
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 8027bec:	2201      	movs	r2, #1
 8027bee:	490e      	ldr	r1, [pc, #56]	; (8027c28 <MX_USB_HOST_Init+0x40>)
 8027bf0:	480e      	ldr	r0, [pc, #56]	; (8027c2c <MX_USB_HOST_Init+0x44>)
 8027bf2:	f7df fc93 	bl	800751c <USBH_Init>
 8027bf6:	4603      	mov	r3, r0
 8027bf8:	2b00      	cmp	r3, #0
 8027bfa:	d001      	beq.n	8027c00 <MX_USB_HOST_Init+0x18>
  {
    Error_Handler();
 8027bfc:	f7d9 fd78 	bl	80016f0 <Error_Handler>
  }
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MSC_CLASS) != USBH_OK)
 8027c00:	490b      	ldr	r1, [pc, #44]	; (8027c30 <MX_USB_HOST_Init+0x48>)
 8027c02:	480a      	ldr	r0, [pc, #40]	; (8027c2c <MX_USB_HOST_Init+0x44>)
 8027c04:	f7df fd18 	bl	8007638 <USBH_RegisterClass>
 8027c08:	4603      	mov	r3, r0
 8027c0a:	2b00      	cmp	r3, #0
 8027c0c:	d001      	beq.n	8027c12 <MX_USB_HOST_Init+0x2a>
  {
    Error_Handler();
 8027c0e:	f7d9 fd6f 	bl	80016f0 <Error_Handler>
  }
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 8027c12:	4806      	ldr	r0, [pc, #24]	; (8027c2c <MX_USB_HOST_Init+0x44>)
 8027c14:	f7df fd9c 	bl	8007750 <USBH_Start>
 8027c18:	4603      	mov	r3, r0
 8027c1a:	2b00      	cmp	r3, #0
 8027c1c:	d001      	beq.n	8027c22 <MX_USB_HOST_Init+0x3a>
  {
    Error_Handler();
 8027c1e:	f7d9 fd67 	bl	80016f0 <Error_Handler>
  }
  /* USER CODE BEGIN USB_HOST_Init_PostTreatment */

  /* USER CODE END USB_HOST_Init_PostTreatment */
}
 8027c22:	bf00      	nop
 8027c24:	bd80      	pop	{r7, pc}
 8027c26:	bf00      	nop
 8027c28:	08027c49 	.word	0x08027c49
 8027c2c:	20000dd0 	.word	0x20000dd0
 8027c30:	2000000c 	.word	0x2000000c

08027c34 <MX_USB_HOST_Process>:

/*
 * Background task
 */
void MX_USB_HOST_Process(void)
{
 8027c34:	b580      	push	{r7, lr}
 8027c36:	af00      	add	r7, sp, #0
  /* USB Host Background task */
  USBH_Process(&hUsbHostFS);
 8027c38:	4802      	ldr	r0, [pc, #8]	; (8027c44 <MX_USB_HOST_Process+0x10>)
 8027c3a:	f7df fd99 	bl	8007770 <USBH_Process>
}
 8027c3e:	bf00      	nop
 8027c40:	bd80      	pop	{r7, pc}
 8027c42:	bf00      	nop
 8027c44:	20000dd0 	.word	0x20000dd0

08027c48 <USBH_UserProcess>:
/*
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
 8027c48:	b480      	push	{r7}
 8027c4a:	b083      	sub	sp, #12
 8027c4c:	af00      	add	r7, sp, #0
 8027c4e:	6078      	str	r0, [r7, #4]
 8027c50:	460b      	mov	r3, r1
 8027c52:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
 8027c54:	78fb      	ldrb	r3, [r7, #3]
 8027c56:	3b01      	subs	r3, #1
 8027c58:	2b04      	cmp	r3, #4
 8027c5a:	d819      	bhi.n	8027c90 <USBH_UserProcess+0x48>
 8027c5c:	a201      	add	r2, pc, #4	; (adr r2, 8027c64 <USBH_UserProcess+0x1c>)
 8027c5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027c62:	bf00      	nop
 8027c64:	08027c91 	.word	0x08027c91
 8027c68:	08027c81 	.word	0x08027c81
 8027c6c:	08027c91 	.word	0x08027c91
 8027c70:	08027c89 	.word	0x08027c89
 8027c74:	08027c79 	.word	0x08027c79
  {
  case HOST_USER_SELECT_CONFIGURATION:
  break;

  case HOST_USER_DISCONNECTION:
  Appli_state = APPLICATION_DISCONNECT;
 8027c78:	4b09      	ldr	r3, [pc, #36]	; (8027ca0 <USBH_UserProcess+0x58>)
 8027c7a:	2203      	movs	r2, #3
 8027c7c:	701a      	strb	r2, [r3, #0]
  break;
 8027c7e:	e008      	b.n	8027c92 <USBH_UserProcess+0x4a>

  case HOST_USER_CLASS_ACTIVE:
  Appli_state = APPLICATION_READY;
 8027c80:	4b07      	ldr	r3, [pc, #28]	; (8027ca0 <USBH_UserProcess+0x58>)
 8027c82:	2202      	movs	r2, #2
 8027c84:	701a      	strb	r2, [r3, #0]
  break;
 8027c86:	e004      	b.n	8027c92 <USBH_UserProcess+0x4a>

  case HOST_USER_CONNECTION:
  Appli_state = APPLICATION_START;
 8027c88:	4b05      	ldr	r3, [pc, #20]	; (8027ca0 <USBH_UserProcess+0x58>)
 8027c8a:	2201      	movs	r2, #1
 8027c8c:	701a      	strb	r2, [r3, #0]
  break;
 8027c8e:	e000      	b.n	8027c92 <USBH_UserProcess+0x4a>

  default:
  break;
 8027c90:	bf00      	nop
  }
  /* USER CODE END CALL_BACK_1 */
}
 8027c92:	bf00      	nop
 8027c94:	370c      	adds	r7, #12
 8027c96:	46bd      	mov	sp, r7
 8027c98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027c9c:	4770      	bx	lr
 8027c9e:	bf00      	nop
 8027ca0:	200002e8 	.word	0x200002e8

08027ca4 <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
 8027ca4:	b580      	push	{r7, lr}
 8027ca6:	b08a      	sub	sp, #40	; 0x28
 8027ca8:	af00      	add	r7, sp, #0
 8027caa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8027cac:	f107 0314 	add.w	r3, r7, #20
 8027cb0:	2200      	movs	r2, #0
 8027cb2:	601a      	str	r2, [r3, #0]
 8027cb4:	605a      	str	r2, [r3, #4]
 8027cb6:	609a      	str	r2, [r3, #8]
 8027cb8:	60da      	str	r2, [r3, #12]
 8027cba:	611a      	str	r2, [r3, #16]
  if(hcdHandle->Instance==USB_OTG_FS)
 8027cbc:	687b      	ldr	r3, [r7, #4]
 8027cbe:	681b      	ldr	r3, [r3, #0]
 8027cc0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8027cc4:	d13a      	bne.n	8027d3c <HAL_HCD_MspInit+0x98>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8027cc6:	2300      	movs	r3, #0
 8027cc8:	613b      	str	r3, [r7, #16]
 8027cca:	4b1e      	ldr	r3, [pc, #120]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027ccc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8027cce:	4a1d      	ldr	r2, [pc, #116]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027cd0:	f043 0301 	orr.w	r3, r3, #1
 8027cd4:	6313      	str	r3, [r2, #48]	; 0x30
 8027cd6:	4b1b      	ldr	r3, [pc, #108]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027cd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8027cda:	f003 0301 	and.w	r3, r3, #1
 8027cde:	613b      	str	r3, [r7, #16]
 8027ce0:	693b      	ldr	r3, [r7, #16]
    /**USB_OTG_FS GPIO Configuration
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8027ce2:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8027ce6:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8027ce8:	2302      	movs	r3, #2
 8027cea:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8027cec:	2300      	movs	r3, #0
 8027cee:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8027cf0:	2303      	movs	r3, #3
 8027cf2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8027cf4:	230a      	movs	r3, #10
 8027cf6:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8027cf8:	f107 0314 	add.w	r3, r7, #20
 8027cfc:	4619      	mov	r1, r3
 8027cfe:	4812      	ldr	r0, [pc, #72]	; (8027d48 <HAL_HCD_MspInit+0xa4>)
 8027d00:	f7da f862 	bl	8001dc8 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8027d04:	4b0f      	ldr	r3, [pc, #60]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027d06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8027d08:	4a0e      	ldr	r2, [pc, #56]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027d0a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8027d0e:	6353      	str	r3, [r2, #52]	; 0x34
 8027d10:	2300      	movs	r3, #0
 8027d12:	60fb      	str	r3, [r7, #12]
 8027d14:	4b0b      	ldr	r3, [pc, #44]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027d16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8027d18:	4a0a      	ldr	r2, [pc, #40]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027d1a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8027d1e:	6453      	str	r3, [r2, #68]	; 0x44
 8027d20:	4b08      	ldr	r3, [pc, #32]	; (8027d44 <HAL_HCD_MspInit+0xa0>)
 8027d22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8027d24:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8027d28:	60fb      	str	r3, [r7, #12]
 8027d2a:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8027d2c:	2200      	movs	r2, #0
 8027d2e:	2100      	movs	r1, #0
 8027d30:	2043      	movs	r0, #67	; 0x43
 8027d32:	f7da f812 	bl	8001d5a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8027d36:	2043      	movs	r0, #67	; 0x43
 8027d38:	f7da f82b 	bl	8001d92 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8027d3c:	bf00      	nop
 8027d3e:	3728      	adds	r7, #40	; 0x28
 8027d40:	46bd      	mov	sp, r7
 8027d42:	bd80      	pop	{r7, pc}
 8027d44:	40023800 	.word	0x40023800
 8027d48:	40020000 	.word	0x40020000

08027d4c <HAL_HCD_SOF_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
 8027d4c:	b580      	push	{r7, lr}
 8027d4e:	b082      	sub	sp, #8
 8027d50:	af00      	add	r7, sp, #0
 8027d52:	6078      	str	r0, [r7, #4]
  USBH_LL_IncTimer(hhcd->pData);
 8027d54:	687b      	ldr	r3, [r7, #4]
 8027d56:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
 8027d5a:	4618      	mov	r0, r3
 8027d5c:	f7e0 f8db 	bl	8007f16 <USBH_LL_IncTimer>
}
 8027d60:	bf00      	nop
 8027d62:	3708      	adds	r7, #8
 8027d64:	46bd      	mov	sp, r7
 8027d66:	bd80      	pop	{r7, pc}

08027d68 <HAL_HCD_Connect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
 8027d68:	b580      	push	{r7, lr}
 8027d6a:	b082      	sub	sp, #8
 8027d6c:	af00      	add	r7, sp, #0
 8027d6e:	6078      	str	r0, [r7, #4]
  USBH_LL_Connect(hhcd->pData);
 8027d70:	687b      	ldr	r3, [r7, #4]
 8027d72:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
 8027d76:	4618      	mov	r0, r3
 8027d78:	f7e0 f913 	bl	8007fa2 <USBH_LL_Connect>
}
 8027d7c:	bf00      	nop
 8027d7e:	3708      	adds	r7, #8
 8027d80:	46bd      	mov	sp, r7
 8027d82:	bd80      	pop	{r7, pc}

08027d84 <HAL_HCD_Disconnect_Callback>:
  * @brief  SOF callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
 8027d84:	b580      	push	{r7, lr}
 8027d86:	b082      	sub	sp, #8
 8027d88:	af00      	add	r7, sp, #0
 8027d8a:	6078      	str	r0, [r7, #4]
  USBH_LL_Disconnect(hhcd->pData);
 8027d8c:	687b      	ldr	r3, [r7, #4]
 8027d8e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
 8027d92:	4618      	mov	r0, r3
 8027d94:	f7e0 f91c 	bl	8007fd0 <USBH_LL_Disconnect>
}
 8027d98:	bf00      	nop
 8027d9a:	3708      	adds	r7, #8
 8027d9c:	46bd      	mov	sp, r7
 8027d9e:	bd80      	pop	{r7, pc}

08027da0 <HAL_HCD_HC_NotifyURBChange_Callback>:
  * @param  chnum: channel number
  * @param  urb_state: state
  * @retval None
  */
void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
 8027da0:	b480      	push	{r7}
 8027da2:	b083      	sub	sp, #12
 8027da4:	af00      	add	r7, sp, #0
 8027da6:	6078      	str	r0, [r7, #4]
 8027da8:	460b      	mov	r3, r1
 8027daa:	70fb      	strb	r3, [r7, #3]
 8027dac:	4613      	mov	r3, r2
 8027dae:	70bb      	strb	r3, [r7, #2]
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 8027db0:	bf00      	nop
 8027db2:	370c      	adds	r7, #12
 8027db4:	46bd      	mov	sp, r7
 8027db6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027dba:	4770      	bx	lr

08027dbc <HAL_HCD_PortEnabled_Callback>:
* @brief  Port Port Enabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
 8027dbc:	b580      	push	{r7, lr}
 8027dbe:	b082      	sub	sp, #8
 8027dc0:	af00      	add	r7, sp, #0
 8027dc2:	6078      	str	r0, [r7, #4]
  USBH_LL_PortEnabled(hhcd->pData);
 8027dc4:	687b      	ldr	r3, [r7, #4]
 8027dc6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
 8027dca:	4618      	mov	r0, r3
 8027dcc:	f7e0 f8cd 	bl	8007f6a <USBH_LL_PortEnabled>
}
 8027dd0:	bf00      	nop
 8027dd2:	3708      	adds	r7, #8
 8027dd4:	46bd      	mov	sp, r7
 8027dd6:	bd80      	pop	{r7, pc}

08027dd8 <HAL_HCD_PortDisabled_Callback>:
  * @brief  Port Port Disabled callback.
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
 8027dd8:	b580      	push	{r7, lr}
 8027dda:	b082      	sub	sp, #8
 8027ddc:	af00      	add	r7, sp, #0
 8027dde:	6078      	str	r0, [r7, #4]
  USBH_LL_PortDisabled(hhcd->pData);
 8027de0:	687b      	ldr	r3, [r7, #4]
 8027de2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
 8027de6:	4618      	mov	r0, r3
 8027de8:	f7e0 f8cd 	bl	8007f86 <USBH_LL_PortDisabled>
}
 8027dec:	bf00      	nop
 8027dee:	3708      	adds	r7, #8
 8027df0:	46bd      	mov	sp, r7
 8027df2:	bd80      	pop	{r7, pc}

08027df4 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
 8027df4:	b580      	push	{r7, lr}
 8027df6:	b082      	sub	sp, #8
 8027df8:	af00      	add	r7, sp, #0
 8027dfa:	6078      	str	r0, [r7, #4]
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
 8027dfc:	687b      	ldr	r3, [r7, #4]
 8027dfe:	f893 33cc 	ldrb.w	r3, [r3, #972]	; 0x3cc
 8027e02:	2b01      	cmp	r3, #1
 8027e04:	d12a      	bne.n	8027e5c <USBH_LL_Init+0x68>
  /* Link the driver to the stack. */
  hhcd_USB_OTG_FS.pData = phost;
 8027e06:	4a18      	ldr	r2, [pc, #96]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e08:	687b      	ldr	r3, [r7, #4]
 8027e0a:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
  phost->pData = &hhcd_USB_OTG_FS;
 8027e0e:	687b      	ldr	r3, [r7, #4]
 8027e10:	4a15      	ldr	r2, [pc, #84]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e12:	f8c3 23d0 	str.w	r2, [r3, #976]	; 0x3d0

  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8027e16:	4b14      	ldr	r3, [pc, #80]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e18:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8027e1c:	601a      	str	r2, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 8;
 8027e1e:	4b12      	ldr	r3, [pc, #72]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e20:	2208      	movs	r2, #8
 8027e22:	609a      	str	r2, [r3, #8]
  hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
 8027e24:	4b10      	ldr	r3, [pc, #64]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e26:	2201      	movs	r2, #1
 8027e28:	60da      	str	r2, [r3, #12]
  hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8027e2a:	4b0f      	ldr	r3, [pc, #60]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e2c:	2200      	movs	r2, #0
 8027e2e:	611a      	str	r2, [r3, #16]
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 8027e30:	4b0d      	ldr	r3, [pc, #52]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e32:	2202      	movs	r2, #2
 8027e34:	619a      	str	r2, [r3, #24]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8027e36:	4b0c      	ldr	r3, [pc, #48]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e38:	2200      	movs	r2, #0
 8027e3a:	61da      	str	r2, [r3, #28]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 8027e3c:	480a      	ldr	r0, [pc, #40]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e3e:	f7da f960 	bl	8002102 <HAL_HCD_Init>
 8027e42:	4603      	mov	r3, r0
 8027e44:	2b00      	cmp	r3, #0
 8027e46:	d001      	beq.n	8027e4c <USBH_LL_Init+0x58>
  {
    Error_Handler( );
 8027e48:	f7d9 fc52 	bl	80016f0 <Error_Handler>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
 8027e4c:	4806      	ldr	r0, [pc, #24]	; (8027e68 <USBH_LL_Init+0x74>)
 8027e4e:	f7da fd44 	bl	80028da <HAL_HCD_GetCurrentFrame>
 8027e52:	4603      	mov	r3, r0
 8027e54:	4619      	mov	r1, r3
 8027e56:	6878      	ldr	r0, [r7, #4]
 8027e58:	f7e0 f84e 	bl	8007ef8 <USBH_LL_SetTimer>
  }
  return USBH_OK;
 8027e5c:	2300      	movs	r3, #0
}
 8027e5e:	4618      	mov	r0, r3
 8027e60:	3708      	adds	r7, #8
 8027e62:	46bd      	mov	sp, r7
 8027e64:	bd80      	pop	{r7, pc}
 8027e66:	bf00      	nop
 8027e68:	200011a8 	.word	0x200011a8

08027e6c <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 8027e6c:	b580      	push	{r7, lr}
 8027e6e:	b084      	sub	sp, #16
 8027e70:	af00      	add	r7, sp, #0
 8027e72:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027e74:	2300      	movs	r3, #0
 8027e76:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 8027e78:	2300      	movs	r3, #0
 8027e7a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Start(phost->pData);
 8027e7c:	687b      	ldr	r3, [r7, #4]
 8027e7e:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027e82:	4618      	mov	r0, r3
 8027e84:	f7da fcb3 	bl	80027ee <HAL_HCD_Start>
 8027e88:	4603      	mov	r3, r0
 8027e8a:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 8027e8c:	7bfb      	ldrb	r3, [r7, #15]
 8027e8e:	4618      	mov	r0, r3
 8027e90:	f000 f982 	bl	8028198 <USBH_Get_USB_Status>
 8027e94:	4603      	mov	r3, r0
 8027e96:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027e98:	7bbb      	ldrb	r3, [r7, #14]
}
 8027e9a:	4618      	mov	r0, r3
 8027e9c:	3710      	adds	r7, #16
 8027e9e:	46bd      	mov	sp, r7
 8027ea0:	bd80      	pop	{r7, pc}

08027ea2 <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 8027ea2:	b580      	push	{r7, lr}
 8027ea4:	b084      	sub	sp, #16
 8027ea6:	af00      	add	r7, sp, #0
 8027ea8:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027eaa:	2300      	movs	r3, #0
 8027eac:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 8027eae:	2300      	movs	r3, #0
 8027eb0:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_Stop(phost->pData);
 8027eb2:	687b      	ldr	r3, [r7, #4]
 8027eb4:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027eb8:	4618      	mov	r0, r3
 8027eba:	f7da fcbb 	bl	8002834 <HAL_HCD_Stop>
 8027ebe:	4603      	mov	r3, r0
 8027ec0:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 8027ec2:	7bfb      	ldrb	r3, [r7, #15]
 8027ec4:	4618      	mov	r0, r3
 8027ec6:	f000 f967 	bl	8028198 <USBH_Get_USB_Status>
 8027eca:	4603      	mov	r3, r0
 8027ecc:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027ece:	7bbb      	ldrb	r3, [r7, #14]
}
 8027ed0:	4618      	mov	r0, r3
 8027ed2:	3710      	adds	r7, #16
 8027ed4:	46bd      	mov	sp, r7
 8027ed6:	bd80      	pop	{r7, pc}

08027ed8 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 8027ed8:	b580      	push	{r7, lr}
 8027eda:	b084      	sub	sp, #16
 8027edc:	af00      	add	r7, sp, #0
 8027ede:	6078      	str	r0, [r7, #4]
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
 8027ee0:	2301      	movs	r3, #1
 8027ee2:	73fb      	strb	r3, [r7, #15]

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 8027ee4:	687b      	ldr	r3, [r7, #4]
 8027ee6:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027eea:	4618      	mov	r0, r3
 8027eec:	f7da fd03 	bl	80028f6 <HAL_HCD_GetCurrentSpeed>
 8027ef0:	4603      	mov	r3, r0
 8027ef2:	2b02      	cmp	r3, #2
 8027ef4:	d00c      	beq.n	8027f10 <USBH_LL_GetSpeed+0x38>
 8027ef6:	2b02      	cmp	r3, #2
 8027ef8:	d80d      	bhi.n	8027f16 <USBH_LL_GetSpeed+0x3e>
 8027efa:	2b00      	cmp	r3, #0
 8027efc:	d002      	beq.n	8027f04 <USBH_LL_GetSpeed+0x2c>
 8027efe:	2b01      	cmp	r3, #1
 8027f00:	d003      	beq.n	8027f0a <USBH_LL_GetSpeed+0x32>
 8027f02:	e008      	b.n	8027f16 <USBH_LL_GetSpeed+0x3e>
  {
  case 0 :
    speed = USBH_SPEED_HIGH;
 8027f04:	2300      	movs	r3, #0
 8027f06:	73fb      	strb	r3, [r7, #15]
    break;
 8027f08:	e008      	b.n	8027f1c <USBH_LL_GetSpeed+0x44>

  case 1 :
    speed = USBH_SPEED_FULL;
 8027f0a:	2301      	movs	r3, #1
 8027f0c:	73fb      	strb	r3, [r7, #15]
    break;
 8027f0e:	e005      	b.n	8027f1c <USBH_LL_GetSpeed+0x44>

  case 2 :
    speed = USBH_SPEED_LOW;
 8027f10:	2302      	movs	r3, #2
 8027f12:	73fb      	strb	r3, [r7, #15]
    break;
 8027f14:	e002      	b.n	8027f1c <USBH_LL_GetSpeed+0x44>

  default:
   speed = USBH_SPEED_FULL;
 8027f16:	2301      	movs	r3, #1
 8027f18:	73fb      	strb	r3, [r7, #15]
    break;
 8027f1a:	bf00      	nop
  }
  return  speed;
 8027f1c:	7bfb      	ldrb	r3, [r7, #15]
}
 8027f1e:	4618      	mov	r0, r3
 8027f20:	3710      	adds	r7, #16
 8027f22:	46bd      	mov	sp, r7
 8027f24:	bd80      	pop	{r7, pc}

08027f26 <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
 8027f26:	b580      	push	{r7, lr}
 8027f28:	b084      	sub	sp, #16
 8027f2a:	af00      	add	r7, sp, #0
 8027f2c:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f2e:	2300      	movs	r3, #0
 8027f30:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 8027f32:	2300      	movs	r3, #0
 8027f34:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_ResetPort(phost->pData);
 8027f36:	687b      	ldr	r3, [r7, #4]
 8027f38:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027f3c:	4618      	mov	r0, r3
 8027f3e:	f7da fc96 	bl	800286e <HAL_HCD_ResetPort>
 8027f42:	4603      	mov	r3, r0
 8027f44:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 8027f46:	7bfb      	ldrb	r3, [r7, #15]
 8027f48:	4618      	mov	r0, r3
 8027f4a:	f000 f925 	bl	8028198 <USBH_Get_USB_Status>
 8027f4e:	4603      	mov	r3, r0
 8027f50:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027f52:	7bbb      	ldrb	r3, [r7, #14]
}
 8027f54:	4618      	mov	r0, r3
 8027f56:	3710      	adds	r7, #16
 8027f58:	46bd      	mov	sp, r7
 8027f5a:	bd80      	pop	{r7, pc}

08027f5c <USBH_LL_GetLastXferSize>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 8027f5c:	b580      	push	{r7, lr}
 8027f5e:	b082      	sub	sp, #8
 8027f60:	af00      	add	r7, sp, #0
 8027f62:	6078      	str	r0, [r7, #4]
 8027f64:	460b      	mov	r3, r1
 8027f66:	70fb      	strb	r3, [r7, #3]
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 8027f68:	687b      	ldr	r3, [r7, #4]
 8027f6a:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027f6e:	78fa      	ldrb	r2, [r7, #3]
 8027f70:	4611      	mov	r1, r2
 8027f72:	4618      	mov	r0, r3
 8027f74:	f7da fc9d 	bl	80028b2 <HAL_HCD_HC_GetXferCount>
 8027f78:	4603      	mov	r3, r0
}
 8027f7a:	4618      	mov	r0, r3
 8027f7c:	3708      	adds	r7, #8
 8027f7e:	46bd      	mov	sp, r7
 8027f80:	bd80      	pop	{r7, pc}

08027f82 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8027f82:	b590      	push	{r4, r7, lr}
 8027f84:	b089      	sub	sp, #36	; 0x24
 8027f86:	af04      	add	r7, sp, #16
 8027f88:	6078      	str	r0, [r7, #4]
 8027f8a:	4608      	mov	r0, r1
 8027f8c:	4611      	mov	r1, r2
 8027f8e:	461a      	mov	r2, r3
 8027f90:	4603      	mov	r3, r0
 8027f92:	70fb      	strb	r3, [r7, #3]
 8027f94:	460b      	mov	r3, r1
 8027f96:	70bb      	strb	r3, [r7, #2]
 8027f98:	4613      	mov	r3, r2
 8027f9a:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027f9c:	2300      	movs	r3, #0
 8027f9e:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 8027fa0:	2300      	movs	r3, #0
 8027fa2:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8027fa4:	687b      	ldr	r3, [r7, #4]
 8027fa6:	f8d3 03d0 	ldr.w	r0, [r3, #976]	; 0x3d0
 8027faa:	787c      	ldrb	r4, [r7, #1]
 8027fac:	78ba      	ldrb	r2, [r7, #2]
 8027fae:	78f9      	ldrb	r1, [r7, #3]
 8027fb0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8027fb2:	9302      	str	r3, [sp, #8]
 8027fb4:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8027fb8:	9301      	str	r3, [sp, #4]
 8027fba:	f897 3020 	ldrb.w	r3, [r7, #32]
 8027fbe:	9300      	str	r3, [sp, #0]
 8027fc0:	4623      	mov	r3, r4
 8027fc2:	f7da f900 	bl	80021c6 <HAL_HCD_HC_Init>
 8027fc6:	4603      	mov	r3, r0
 8027fc8:	73fb      	strb	r3, [r7, #15]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
 8027fca:	7bfb      	ldrb	r3, [r7, #15]
 8027fcc:	4618      	mov	r0, r3
 8027fce:	f000 f8e3 	bl	8028198 <USBH_Get_USB_Status>
 8027fd2:	4603      	mov	r3, r0
 8027fd4:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8027fd6:	7bbb      	ldrb	r3, [r7, #14]
}
 8027fd8:	4618      	mov	r0, r3
 8027fda:	3714      	adds	r7, #20
 8027fdc:	46bd      	mov	sp, r7
 8027fde:	bd90      	pop	{r4, r7, pc}

08027fe0 <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 8027fe0:	b580      	push	{r7, lr}
 8027fe2:	b084      	sub	sp, #16
 8027fe4:	af00      	add	r7, sp, #0
 8027fe6:	6078      	str	r0, [r7, #4]
 8027fe8:	460b      	mov	r3, r1
 8027fea:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8027fec:	2300      	movs	r3, #0
 8027fee:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 8027ff0:	2300      	movs	r3, #0
 8027ff2:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 8027ff4:	687b      	ldr	r3, [r7, #4]
 8027ff6:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8027ffa:	78fa      	ldrb	r2, [r7, #3]
 8027ffc:	4611      	mov	r1, r2
 8027ffe:	4618      	mov	r0, r3
 8028000:	f7da f970 	bl	80022e4 <HAL_HCD_HC_Halt>
 8028004:	4603      	mov	r3, r0
 8028006:	73fb      	strb	r3, [r7, #15]

  usb_status = USBH_Get_USB_Status(hal_status);
 8028008:	7bfb      	ldrb	r3, [r7, #15]
 802800a:	4618      	mov	r0, r3
 802800c:	f000 f8c4 	bl	8028198 <USBH_Get_USB_Status>
 8028010:	4603      	mov	r3, r0
 8028012:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028014:	7bbb      	ldrb	r3, [r7, #14]
}
 8028016:	4618      	mov	r0, r3
 8028018:	3710      	adds	r7, #16
 802801a:	46bd      	mov	sp, r7
 802801c:	bd80      	pop	{r7, pc}

0802801e <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
 802801e:	b590      	push	{r4, r7, lr}
 8028020:	b089      	sub	sp, #36	; 0x24
 8028022:	af04      	add	r7, sp, #16
 8028024:	6078      	str	r0, [r7, #4]
 8028026:	4608      	mov	r0, r1
 8028028:	4611      	mov	r1, r2
 802802a:	461a      	mov	r2, r3
 802802c:	4603      	mov	r3, r0
 802802e:	70fb      	strb	r3, [r7, #3]
 8028030:	460b      	mov	r3, r1
 8028032:	70bb      	strb	r3, [r7, #2]
 8028034:	4613      	mov	r3, r2
 8028036:	707b      	strb	r3, [r7, #1]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028038:	2300      	movs	r3, #0
 802803a:	73fb      	strb	r3, [r7, #15]
  USBH_StatusTypeDef usb_status = USBH_OK;
 802803c:	2300      	movs	r3, #0
 802803e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8028040:	687b      	ldr	r3, [r7, #4]
 8028042:	f8d3 03d0 	ldr.w	r0, [r3, #976]	; 0x3d0
 8028046:	787c      	ldrb	r4, [r7, #1]
 8028048:	78ba      	ldrb	r2, [r7, #2]
 802804a:	78f9      	ldrb	r1, [r7, #3]
 802804c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8028050:	9303      	str	r3, [sp, #12]
 8028052:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8028054:	9302      	str	r3, [sp, #8]
 8028056:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8028058:	9301      	str	r3, [sp, #4]
 802805a:	f897 3020 	ldrb.w	r3, [r7, #32]
 802805e:	9300      	str	r3, [sp, #0]
 8028060:	4623      	mov	r3, r4
 8028062:	f7da f963 	bl	800232c <HAL_HCD_HC_SubmitRequest>
 8028066:	4603      	mov	r3, r0
 8028068:	73fb      	strb	r3, [r7, #15]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
 802806a:	7bfb      	ldrb	r3, [r7, #15]
 802806c:	4618      	mov	r0, r3
 802806e:	f000 f893 	bl	8028198 <USBH_Get_USB_Status>
 8028072:	4603      	mov	r3, r0
 8028074:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028076:	7bbb      	ldrb	r3, [r7, #14]
}
 8028078:	4618      	mov	r0, r3
 802807a:	3714      	adds	r7, #20
 802807c:	46bd      	mov	sp, r7
 802807e:	bd90      	pop	{r4, r7, pc}

08028080 <USBH_LL_GetURBState>:
  *            @arg URB_NYET
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 8028080:	b580      	push	{r7, lr}
 8028082:	b082      	sub	sp, #8
 8028084:	af00      	add	r7, sp, #0
 8028086:	6078      	str	r0, [r7, #4]
 8028088:	460b      	mov	r3, r1
 802808a:	70fb      	strb	r3, [r7, #3]
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 802808c:	687b      	ldr	r3, [r7, #4]
 802808e:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8028092:	78fa      	ldrb	r2, [r7, #3]
 8028094:	4611      	mov	r1, r2
 8028096:	4618      	mov	r0, r3
 8028098:	f7da fbf7 	bl	800288a <HAL_HCD_HC_GetURBState>
 802809c:	4603      	mov	r3, r0
}
 802809e:	4618      	mov	r0, r3
 80280a0:	3708      	adds	r7, #8
 80280a2:	46bd      	mov	sp, r7
 80280a4:	bd80      	pop	{r7, pc}

080280a6 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Inactive
  *           1 : VBUS Active
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 80280a6:	b580      	push	{r7, lr}
 80280a8:	b082      	sub	sp, #8
 80280aa:	af00      	add	r7, sp, #0
 80280ac:	6078      	str	r0, [r7, #4]
 80280ae:	460b      	mov	r3, r1
 80280b0:	70fb      	strb	r3, [r7, #3]
      /* USER CODE BEGIN DRIVE_LOW_CHARGE_FOR_FS */

      /* USER CODE END DRIVE_LOW_CHARGE_FOR_FS */
    }
  }
  HAL_Delay(200);
 80280b2:	20c8      	movs	r0, #200	; 0xc8
 80280b4:	f7d9 fd52 	bl	8001b5c <HAL_Delay>
  return USBH_OK;
 80280b8:	2300      	movs	r3, #0
}
 80280ba:	4618      	mov	r0, r3
 80280bc:	3708      	adds	r7, #8
 80280be:	46bd      	mov	sp, r7
 80280c0:	bd80      	pop	{r7, pc}

080280c2 <USBH_LL_SetToggle>:
  * @param  pipe: Pipe index
  * @param  toggle: toggle (0/1)
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
 80280c2:	b480      	push	{r7}
 80280c4:	b085      	sub	sp, #20
 80280c6:	af00      	add	r7, sp, #0
 80280c8:	6078      	str	r0, [r7, #4]
 80280ca:	460b      	mov	r3, r1
 80280cc:	70fb      	strb	r3, [r7, #3]
 80280ce:	4613      	mov	r3, r2
 80280d0:	70bb      	strb	r3, [r7, #2]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 80280d2:	687b      	ldr	r3, [r7, #4]
 80280d4:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 80280d8:	60fb      	str	r3, [r7, #12]

  if(pHandle->hc[pipe].ep_is_in)
 80280da:	78fb      	ldrb	r3, [r7, #3]
 80280dc:	68fa      	ldr	r2, [r7, #12]
 80280de:	212c      	movs	r1, #44	; 0x2c
 80280e0:	fb01 f303 	mul.w	r3, r1, r3
 80280e4:	4413      	add	r3, r2
 80280e6:	333b      	adds	r3, #59	; 0x3b
 80280e8:	781b      	ldrb	r3, [r3, #0]
 80280ea:	2b00      	cmp	r3, #0
 80280ec:	d009      	beq.n	8028102 <USBH_LL_SetToggle+0x40>
  {
    pHandle->hc[pipe].toggle_in = toggle;
 80280ee:	78fb      	ldrb	r3, [r7, #3]
 80280f0:	68fa      	ldr	r2, [r7, #12]
 80280f2:	212c      	movs	r1, #44	; 0x2c
 80280f4:	fb01 f303 	mul.w	r3, r1, r3
 80280f8:	4413      	add	r3, r2
 80280fa:	3354      	adds	r3, #84	; 0x54
 80280fc:	78ba      	ldrb	r2, [r7, #2]
 80280fe:	701a      	strb	r2, [r3, #0]
 8028100:	e008      	b.n	8028114 <USBH_LL_SetToggle+0x52>
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
 8028102:	78fb      	ldrb	r3, [r7, #3]
 8028104:	68fa      	ldr	r2, [r7, #12]
 8028106:	212c      	movs	r1, #44	; 0x2c
 8028108:	fb01 f303 	mul.w	r3, r1, r3
 802810c:	4413      	add	r3, r2
 802810e:	3355      	adds	r3, #85	; 0x55
 8028110:	78ba      	ldrb	r2, [r7, #2]
 8028112:	701a      	strb	r2, [r3, #0]
  }

  return USBH_OK;
 8028114:	2300      	movs	r3, #0
}
 8028116:	4618      	mov	r0, r3
 8028118:	3714      	adds	r7, #20
 802811a:	46bd      	mov	sp, r7
 802811c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028120:	4770      	bx	lr

08028122 <USBH_LL_GetToggle>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval toggle (0/1)
  */
uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 8028122:	b480      	push	{r7}
 8028124:	b085      	sub	sp, #20
 8028126:	af00      	add	r7, sp, #0
 8028128:	6078      	str	r0, [r7, #4]
 802812a:	460b      	mov	r3, r1
 802812c:	70fb      	strb	r3, [r7, #3]
  uint8_t toggle = 0;
 802812e:	2300      	movs	r3, #0
 8028130:	73fb      	strb	r3, [r7, #15]
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 8028132:	687b      	ldr	r3, [r7, #4]
 8028134:	f8d3 33d0 	ldr.w	r3, [r3, #976]	; 0x3d0
 8028138:	60bb      	str	r3, [r7, #8]

  if(pHandle->hc[pipe].ep_is_in)
 802813a:	78fb      	ldrb	r3, [r7, #3]
 802813c:	68ba      	ldr	r2, [r7, #8]
 802813e:	212c      	movs	r1, #44	; 0x2c
 8028140:	fb01 f303 	mul.w	r3, r1, r3
 8028144:	4413      	add	r3, r2
 8028146:	333b      	adds	r3, #59	; 0x3b
 8028148:	781b      	ldrb	r3, [r3, #0]
 802814a:	2b00      	cmp	r3, #0
 802814c:	d009      	beq.n	8028162 <USBH_LL_GetToggle+0x40>
  {
    toggle = pHandle->hc[pipe].toggle_in;
 802814e:	78fb      	ldrb	r3, [r7, #3]
 8028150:	68ba      	ldr	r2, [r7, #8]
 8028152:	212c      	movs	r1, #44	; 0x2c
 8028154:	fb01 f303 	mul.w	r3, r1, r3
 8028158:	4413      	add	r3, r2
 802815a:	3354      	adds	r3, #84	; 0x54
 802815c:	781b      	ldrb	r3, [r3, #0]
 802815e:	73fb      	strb	r3, [r7, #15]
 8028160:	e008      	b.n	8028174 <USBH_LL_GetToggle+0x52>
  }
  else
  {
    toggle = pHandle->hc[pipe].toggle_out;
 8028162:	78fb      	ldrb	r3, [r7, #3]
 8028164:	68ba      	ldr	r2, [r7, #8]
 8028166:	212c      	movs	r1, #44	; 0x2c
 8028168:	fb01 f303 	mul.w	r3, r1, r3
 802816c:	4413      	add	r3, r2
 802816e:	3355      	adds	r3, #85	; 0x55
 8028170:	781b      	ldrb	r3, [r3, #0]
 8028172:	73fb      	strb	r3, [r7, #15]
  }
  return toggle;
 8028174:	7bfb      	ldrb	r3, [r7, #15]
}
 8028176:	4618      	mov	r0, r3
 8028178:	3714      	adds	r7, #20
 802817a:	46bd      	mov	sp, r7
 802817c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028180:	4770      	bx	lr

08028182 <USBH_Delay>:
  * @brief  Delay routine for the USB Host Library
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
 8028182:	b580      	push	{r7, lr}
 8028184:	b082      	sub	sp, #8
 8028186:	af00      	add	r7, sp, #0
 8028188:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
 802818a:	6878      	ldr	r0, [r7, #4]
 802818c:	f7d9 fce6 	bl	8001b5c <HAL_Delay>
}
 8028190:	bf00      	nop
 8028192:	3708      	adds	r7, #8
 8028194:	46bd      	mov	sp, r7
 8028196:	bd80      	pop	{r7, pc}

08028198 <USBH_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBH_StatusTypeDef USBH_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8028198:	b480      	push	{r7}
 802819a:	b085      	sub	sp, #20
 802819c:	af00      	add	r7, sp, #0
 802819e:	4603      	mov	r3, r0
 80281a0:	71fb      	strb	r3, [r7, #7]
  USBH_StatusTypeDef usb_status = USBH_OK;
 80281a2:	2300      	movs	r3, #0
 80281a4:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 80281a6:	79fb      	ldrb	r3, [r7, #7]
 80281a8:	2b03      	cmp	r3, #3
 80281aa:	d817      	bhi.n	80281dc <USBH_Get_USB_Status+0x44>
 80281ac:	a201      	add	r2, pc, #4	; (adr r2, 80281b4 <USBH_Get_USB_Status+0x1c>)
 80281ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80281b2:	bf00      	nop
 80281b4:	080281c5 	.word	0x080281c5
 80281b8:	080281cb 	.word	0x080281cb
 80281bc:	080281d1 	.word	0x080281d1
 80281c0:	080281d7 	.word	0x080281d7
  {
    case HAL_OK :
      usb_status = USBH_OK;
 80281c4:	2300      	movs	r3, #0
 80281c6:	73fb      	strb	r3, [r7, #15]
    break;
 80281c8:	e00b      	b.n	80281e2 <USBH_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBH_FAIL;
 80281ca:	2302      	movs	r3, #2
 80281cc:	73fb      	strb	r3, [r7, #15]
    break;
 80281ce:	e008      	b.n	80281e2 <USBH_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBH_BUSY;
 80281d0:	2301      	movs	r3, #1
 80281d2:	73fb      	strb	r3, [r7, #15]
    break;
 80281d4:	e005      	b.n	80281e2 <USBH_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBH_FAIL;
 80281d6:	2302      	movs	r3, #2
 80281d8:	73fb      	strb	r3, [r7, #15]
    break;
 80281da:	e002      	b.n	80281e2 <USBH_Get_USB_Status+0x4a>
    default :
      usb_status = USBH_FAIL;
 80281dc:	2302      	movs	r3, #2
 80281de:	73fb      	strb	r3, [r7, #15]
    break;
 80281e0:	bf00      	nop
  }
  return usb_status;
 80281e2:	7bfb      	ldrb	r3, [r7, #15]
}
 80281e4:	4618      	mov	r0, r3
 80281e6:	3714      	adds	r7, #20
 80281e8:	46bd      	mov	sp, r7
 80281ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281ee:	4770      	bx	lr

080281f0 <__errno>:
 80281f0:	4b01      	ldr	r3, [pc, #4]	; (80281f8 <__errno+0x8>)
 80281f2:	6818      	ldr	r0, [r3, #0]
 80281f4:	4770      	bx	lr
 80281f6:	bf00      	nop
 80281f8:	2000002c 	.word	0x2000002c

080281fc <__libc_init_array>:
 80281fc:	b570      	push	{r4, r5, r6, lr}
 80281fe:	4d0d      	ldr	r5, [pc, #52]	; (8028234 <__libc_init_array+0x38>)
 8028200:	4c0d      	ldr	r4, [pc, #52]	; (8028238 <__libc_init_array+0x3c>)
 8028202:	1b64      	subs	r4, r4, r5
 8028204:	10a4      	asrs	r4, r4, #2
 8028206:	2600      	movs	r6, #0
 8028208:	42a6      	cmp	r6, r4
 802820a:	d109      	bne.n	8028220 <__libc_init_array+0x24>
 802820c:	4d0b      	ldr	r5, [pc, #44]	; (802823c <__libc_init_array+0x40>)
 802820e:	4c0c      	ldr	r4, [pc, #48]	; (8028240 <__libc_init_array+0x44>)
 8028210:	f000 fc5e 	bl	8028ad0 <_init>
 8028214:	1b64      	subs	r4, r4, r5
 8028216:	10a4      	asrs	r4, r4, #2
 8028218:	2600      	movs	r6, #0
 802821a:	42a6      	cmp	r6, r4
 802821c:	d105      	bne.n	802822a <__libc_init_array+0x2e>
 802821e:	bd70      	pop	{r4, r5, r6, pc}
 8028220:	f855 3b04 	ldr.w	r3, [r5], #4
 8028224:	4798      	blx	r3
 8028226:	3601      	adds	r6, #1
 8028228:	e7ee      	b.n	8028208 <__libc_init_array+0xc>
 802822a:	f855 3b04 	ldr.w	r3, [r5], #4
 802822e:	4798      	blx	r3
 8028230:	3601      	adds	r6, #1
 8028232:	e7f2      	b.n	802821a <__libc_init_array+0x1e>
 8028234:	0802b190 	.word	0x0802b190
 8028238:	0802b190 	.word	0x0802b190
 802823c:	0802b190 	.word	0x0802b190
 8028240:	0802b194 	.word	0x0802b194

08028244 <malloc>:
 8028244:	4b02      	ldr	r3, [pc, #8]	; (8028250 <malloc+0xc>)
 8028246:	4601      	mov	r1, r0
 8028248:	6818      	ldr	r0, [r3, #0]
 802824a:	f000 b871 	b.w	8028330 <_malloc_r>
 802824e:	bf00      	nop
 8028250:	2000002c 	.word	0x2000002c

08028254 <free>:
 8028254:	4b02      	ldr	r3, [pc, #8]	; (8028260 <free+0xc>)
 8028256:	4601      	mov	r1, r0
 8028258:	6818      	ldr	r0, [r3, #0]
 802825a:	f000 b819 	b.w	8028290 <_free_r>
 802825e:	bf00      	nop
 8028260:	2000002c 	.word	0x2000002c

08028264 <memcpy>:
 8028264:	440a      	add	r2, r1
 8028266:	4291      	cmp	r1, r2
 8028268:	f100 33ff 	add.w	r3, r0, #4294967295
 802826c:	d100      	bne.n	8028270 <memcpy+0xc>
 802826e:	4770      	bx	lr
 8028270:	b510      	push	{r4, lr}
 8028272:	f811 4b01 	ldrb.w	r4, [r1], #1
 8028276:	f803 4f01 	strb.w	r4, [r3, #1]!
 802827a:	4291      	cmp	r1, r2
 802827c:	d1f9      	bne.n	8028272 <memcpy+0xe>
 802827e:	bd10      	pop	{r4, pc}

08028280 <memset>:
 8028280:	4402      	add	r2, r0
 8028282:	4603      	mov	r3, r0
 8028284:	4293      	cmp	r3, r2
 8028286:	d100      	bne.n	802828a <memset+0xa>
 8028288:	4770      	bx	lr
 802828a:	f803 1b01 	strb.w	r1, [r3], #1
 802828e:	e7f9      	b.n	8028284 <memset+0x4>

08028290 <_free_r>:
 8028290:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8028292:	2900      	cmp	r1, #0
 8028294:	d048      	beq.n	8028328 <_free_r+0x98>
 8028296:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802829a:	9001      	str	r0, [sp, #4]
 802829c:	2b00      	cmp	r3, #0
 802829e:	f1a1 0404 	sub.w	r4, r1, #4
 80282a2:	bfb8      	it	lt
 80282a4:	18e4      	addlt	r4, r4, r3
 80282a6:	f000 f8cd 	bl	8028444 <__malloc_lock>
 80282aa:	4a20      	ldr	r2, [pc, #128]	; (802832c <_free_r+0x9c>)
 80282ac:	9801      	ldr	r0, [sp, #4]
 80282ae:	6813      	ldr	r3, [r2, #0]
 80282b0:	4615      	mov	r5, r2
 80282b2:	b933      	cbnz	r3, 80282c2 <_free_r+0x32>
 80282b4:	6063      	str	r3, [r4, #4]
 80282b6:	6014      	str	r4, [r2, #0]
 80282b8:	b003      	add	sp, #12
 80282ba:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80282be:	f000 b8c7 	b.w	8028450 <__malloc_unlock>
 80282c2:	42a3      	cmp	r3, r4
 80282c4:	d90b      	bls.n	80282de <_free_r+0x4e>
 80282c6:	6821      	ldr	r1, [r4, #0]
 80282c8:	1862      	adds	r2, r4, r1
 80282ca:	4293      	cmp	r3, r2
 80282cc:	bf04      	itt	eq
 80282ce:	681a      	ldreq	r2, [r3, #0]
 80282d0:	685b      	ldreq	r3, [r3, #4]
 80282d2:	6063      	str	r3, [r4, #4]
 80282d4:	bf04      	itt	eq
 80282d6:	1852      	addeq	r2, r2, r1
 80282d8:	6022      	streq	r2, [r4, #0]
 80282da:	602c      	str	r4, [r5, #0]
 80282dc:	e7ec      	b.n	80282b8 <_free_r+0x28>
 80282de:	461a      	mov	r2, r3
 80282e0:	685b      	ldr	r3, [r3, #4]
 80282e2:	b10b      	cbz	r3, 80282e8 <_free_r+0x58>
 80282e4:	42a3      	cmp	r3, r4
 80282e6:	d9fa      	bls.n	80282de <_free_r+0x4e>
 80282e8:	6811      	ldr	r1, [r2, #0]
 80282ea:	1855      	adds	r5, r2, r1
 80282ec:	42a5      	cmp	r5, r4
 80282ee:	d10b      	bne.n	8028308 <_free_r+0x78>
 80282f0:	6824      	ldr	r4, [r4, #0]
 80282f2:	4421      	add	r1, r4
 80282f4:	1854      	adds	r4, r2, r1
 80282f6:	42a3      	cmp	r3, r4
 80282f8:	6011      	str	r1, [r2, #0]
 80282fa:	d1dd      	bne.n	80282b8 <_free_r+0x28>
 80282fc:	681c      	ldr	r4, [r3, #0]
 80282fe:	685b      	ldr	r3, [r3, #4]
 8028300:	6053      	str	r3, [r2, #4]
 8028302:	4421      	add	r1, r4
 8028304:	6011      	str	r1, [r2, #0]
 8028306:	e7d7      	b.n	80282b8 <_free_r+0x28>
 8028308:	d902      	bls.n	8028310 <_free_r+0x80>
 802830a:	230c      	movs	r3, #12
 802830c:	6003      	str	r3, [r0, #0]
 802830e:	e7d3      	b.n	80282b8 <_free_r+0x28>
 8028310:	6825      	ldr	r5, [r4, #0]
 8028312:	1961      	adds	r1, r4, r5
 8028314:	428b      	cmp	r3, r1
 8028316:	bf04      	itt	eq
 8028318:	6819      	ldreq	r1, [r3, #0]
 802831a:	685b      	ldreq	r3, [r3, #4]
 802831c:	6063      	str	r3, [r4, #4]
 802831e:	bf04      	itt	eq
 8028320:	1949      	addeq	r1, r1, r5
 8028322:	6021      	streq	r1, [r4, #0]
 8028324:	6054      	str	r4, [r2, #4]
 8028326:	e7c7      	b.n	80282b8 <_free_r+0x28>
 8028328:	b003      	add	sp, #12
 802832a:	bd30      	pop	{r4, r5, pc}
 802832c:	200002ec 	.word	0x200002ec

08028330 <_malloc_r>:
 8028330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028332:	1ccd      	adds	r5, r1, #3
 8028334:	f025 0503 	bic.w	r5, r5, #3
 8028338:	3508      	adds	r5, #8
 802833a:	2d0c      	cmp	r5, #12
 802833c:	bf38      	it	cc
 802833e:	250c      	movcc	r5, #12
 8028340:	2d00      	cmp	r5, #0
 8028342:	4606      	mov	r6, r0
 8028344:	db01      	blt.n	802834a <_malloc_r+0x1a>
 8028346:	42a9      	cmp	r1, r5
 8028348:	d903      	bls.n	8028352 <_malloc_r+0x22>
 802834a:	230c      	movs	r3, #12
 802834c:	6033      	str	r3, [r6, #0]
 802834e:	2000      	movs	r0, #0
 8028350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8028352:	f000 f877 	bl	8028444 <__malloc_lock>
 8028356:	4921      	ldr	r1, [pc, #132]	; (80283dc <_malloc_r+0xac>)
 8028358:	680a      	ldr	r2, [r1, #0]
 802835a:	4614      	mov	r4, r2
 802835c:	b99c      	cbnz	r4, 8028386 <_malloc_r+0x56>
 802835e:	4f20      	ldr	r7, [pc, #128]	; (80283e0 <_malloc_r+0xb0>)
 8028360:	683b      	ldr	r3, [r7, #0]
 8028362:	b923      	cbnz	r3, 802836e <_malloc_r+0x3e>
 8028364:	4621      	mov	r1, r4
 8028366:	4630      	mov	r0, r6
 8028368:	f000 f83c 	bl	80283e4 <_sbrk_r>
 802836c:	6038      	str	r0, [r7, #0]
 802836e:	4629      	mov	r1, r5
 8028370:	4630      	mov	r0, r6
 8028372:	f000 f837 	bl	80283e4 <_sbrk_r>
 8028376:	1c43      	adds	r3, r0, #1
 8028378:	d123      	bne.n	80283c2 <_malloc_r+0x92>
 802837a:	230c      	movs	r3, #12
 802837c:	6033      	str	r3, [r6, #0]
 802837e:	4630      	mov	r0, r6
 8028380:	f000 f866 	bl	8028450 <__malloc_unlock>
 8028384:	e7e3      	b.n	802834e <_malloc_r+0x1e>
 8028386:	6823      	ldr	r3, [r4, #0]
 8028388:	1b5b      	subs	r3, r3, r5
 802838a:	d417      	bmi.n	80283bc <_malloc_r+0x8c>
 802838c:	2b0b      	cmp	r3, #11
 802838e:	d903      	bls.n	8028398 <_malloc_r+0x68>
 8028390:	6023      	str	r3, [r4, #0]
 8028392:	441c      	add	r4, r3
 8028394:	6025      	str	r5, [r4, #0]
 8028396:	e004      	b.n	80283a2 <_malloc_r+0x72>
 8028398:	6863      	ldr	r3, [r4, #4]
 802839a:	42a2      	cmp	r2, r4
 802839c:	bf0c      	ite	eq
 802839e:	600b      	streq	r3, [r1, #0]
 80283a0:	6053      	strne	r3, [r2, #4]
 80283a2:	4630      	mov	r0, r6
 80283a4:	f000 f854 	bl	8028450 <__malloc_unlock>
 80283a8:	f104 000b 	add.w	r0, r4, #11
 80283ac:	1d23      	adds	r3, r4, #4
 80283ae:	f020 0007 	bic.w	r0, r0, #7
 80283b2:	1ac2      	subs	r2, r0, r3
 80283b4:	d0cc      	beq.n	8028350 <_malloc_r+0x20>
 80283b6:	1a1b      	subs	r3, r3, r0
 80283b8:	50a3      	str	r3, [r4, r2]
 80283ba:	e7c9      	b.n	8028350 <_malloc_r+0x20>
 80283bc:	4622      	mov	r2, r4
 80283be:	6864      	ldr	r4, [r4, #4]
 80283c0:	e7cc      	b.n	802835c <_malloc_r+0x2c>
 80283c2:	1cc4      	adds	r4, r0, #3
 80283c4:	f024 0403 	bic.w	r4, r4, #3
 80283c8:	42a0      	cmp	r0, r4
 80283ca:	d0e3      	beq.n	8028394 <_malloc_r+0x64>
 80283cc:	1a21      	subs	r1, r4, r0
 80283ce:	4630      	mov	r0, r6
 80283d0:	f000 f808 	bl	80283e4 <_sbrk_r>
 80283d4:	3001      	adds	r0, #1
 80283d6:	d1dd      	bne.n	8028394 <_malloc_r+0x64>
 80283d8:	e7cf      	b.n	802837a <_malloc_r+0x4a>
 80283da:	bf00      	nop
 80283dc:	200002ec 	.word	0x200002ec
 80283e0:	200002f0 	.word	0x200002f0

080283e4 <_sbrk_r>:
 80283e4:	b538      	push	{r3, r4, r5, lr}
 80283e6:	4d06      	ldr	r5, [pc, #24]	; (8028400 <_sbrk_r+0x1c>)
 80283e8:	2300      	movs	r3, #0
 80283ea:	4604      	mov	r4, r0
 80283ec:	4608      	mov	r0, r1
 80283ee:	602b      	str	r3, [r5, #0]
 80283f0:	f7d9 fa5e 	bl	80018b0 <_sbrk>
 80283f4:	1c43      	adds	r3, r0, #1
 80283f6:	d102      	bne.n	80283fe <_sbrk_r+0x1a>
 80283f8:	682b      	ldr	r3, [r5, #0]
 80283fa:	b103      	cbz	r3, 80283fe <_sbrk_r+0x1a>
 80283fc:	6023      	str	r3, [r4, #0]
 80283fe:	bd38      	pop	{r3, r4, r5, pc}
 8028400:	200014ac 	.word	0x200014ac

08028404 <siprintf>:
 8028404:	b40e      	push	{r1, r2, r3}
 8028406:	b500      	push	{lr}
 8028408:	b09c      	sub	sp, #112	; 0x70
 802840a:	ab1d      	add	r3, sp, #116	; 0x74
 802840c:	9002      	str	r0, [sp, #8]
 802840e:	9006      	str	r0, [sp, #24]
 8028410:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8028414:	4809      	ldr	r0, [pc, #36]	; (802843c <siprintf+0x38>)
 8028416:	9107      	str	r1, [sp, #28]
 8028418:	9104      	str	r1, [sp, #16]
 802841a:	4909      	ldr	r1, [pc, #36]	; (8028440 <siprintf+0x3c>)
 802841c:	f853 2b04 	ldr.w	r2, [r3], #4
 8028420:	9105      	str	r1, [sp, #20]
 8028422:	6800      	ldr	r0, [r0, #0]
 8028424:	9301      	str	r3, [sp, #4]
 8028426:	a902      	add	r1, sp, #8
 8028428:	f000 f874 	bl	8028514 <_svfiprintf_r>
 802842c:	9b02      	ldr	r3, [sp, #8]
 802842e:	2200      	movs	r2, #0
 8028430:	701a      	strb	r2, [r3, #0]
 8028432:	b01c      	add	sp, #112	; 0x70
 8028434:	f85d eb04 	ldr.w	lr, [sp], #4
 8028438:	b003      	add	sp, #12
 802843a:	4770      	bx	lr
 802843c:	2000002c 	.word	0x2000002c
 8028440:	ffff0208 	.word	0xffff0208

08028444 <__malloc_lock>:
 8028444:	4801      	ldr	r0, [pc, #4]	; (802844c <__malloc_lock+0x8>)
 8028446:	f000 baf9 	b.w	8028a3c <__retarget_lock_acquire_recursive>
 802844a:	bf00      	nop
 802844c:	200014b4 	.word	0x200014b4

08028450 <__malloc_unlock>:
 8028450:	4801      	ldr	r0, [pc, #4]	; (8028458 <__malloc_unlock+0x8>)
 8028452:	f000 baf4 	b.w	8028a3e <__retarget_lock_release_recursive>
 8028456:	bf00      	nop
 8028458:	200014b4 	.word	0x200014b4

0802845c <__ssputs_r>:
 802845c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028460:	688e      	ldr	r6, [r1, #8]
 8028462:	429e      	cmp	r6, r3
 8028464:	4682      	mov	sl, r0
 8028466:	460c      	mov	r4, r1
 8028468:	4690      	mov	r8, r2
 802846a:	461f      	mov	r7, r3
 802846c:	d838      	bhi.n	80284e0 <__ssputs_r+0x84>
 802846e:	898a      	ldrh	r2, [r1, #12]
 8028470:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8028474:	d032      	beq.n	80284dc <__ssputs_r+0x80>
 8028476:	6825      	ldr	r5, [r4, #0]
 8028478:	6909      	ldr	r1, [r1, #16]
 802847a:	eba5 0901 	sub.w	r9, r5, r1
 802847e:	6965      	ldr	r5, [r4, #20]
 8028480:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8028484:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8028488:	3301      	adds	r3, #1
 802848a:	444b      	add	r3, r9
 802848c:	106d      	asrs	r5, r5, #1
 802848e:	429d      	cmp	r5, r3
 8028490:	bf38      	it	cc
 8028492:	461d      	movcc	r5, r3
 8028494:	0553      	lsls	r3, r2, #21
 8028496:	d531      	bpl.n	80284fc <__ssputs_r+0xa0>
 8028498:	4629      	mov	r1, r5
 802849a:	f7ff ff49 	bl	8028330 <_malloc_r>
 802849e:	4606      	mov	r6, r0
 80284a0:	b950      	cbnz	r0, 80284b8 <__ssputs_r+0x5c>
 80284a2:	230c      	movs	r3, #12
 80284a4:	f8ca 3000 	str.w	r3, [sl]
 80284a8:	89a3      	ldrh	r3, [r4, #12]
 80284aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80284ae:	81a3      	strh	r3, [r4, #12]
 80284b0:	f04f 30ff 	mov.w	r0, #4294967295
 80284b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80284b8:	6921      	ldr	r1, [r4, #16]
 80284ba:	464a      	mov	r2, r9
 80284bc:	f7ff fed2 	bl	8028264 <memcpy>
 80284c0:	89a3      	ldrh	r3, [r4, #12]
 80284c2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80284c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80284ca:	81a3      	strh	r3, [r4, #12]
 80284cc:	6126      	str	r6, [r4, #16]
 80284ce:	6165      	str	r5, [r4, #20]
 80284d0:	444e      	add	r6, r9
 80284d2:	eba5 0509 	sub.w	r5, r5, r9
 80284d6:	6026      	str	r6, [r4, #0]
 80284d8:	60a5      	str	r5, [r4, #8]
 80284da:	463e      	mov	r6, r7
 80284dc:	42be      	cmp	r6, r7
 80284de:	d900      	bls.n	80284e2 <__ssputs_r+0x86>
 80284e0:	463e      	mov	r6, r7
 80284e2:	4632      	mov	r2, r6
 80284e4:	6820      	ldr	r0, [r4, #0]
 80284e6:	4641      	mov	r1, r8
 80284e8:	f000 faaa 	bl	8028a40 <memmove>
 80284ec:	68a3      	ldr	r3, [r4, #8]
 80284ee:	6822      	ldr	r2, [r4, #0]
 80284f0:	1b9b      	subs	r3, r3, r6
 80284f2:	4432      	add	r2, r6
 80284f4:	60a3      	str	r3, [r4, #8]
 80284f6:	6022      	str	r2, [r4, #0]
 80284f8:	2000      	movs	r0, #0
 80284fa:	e7db      	b.n	80284b4 <__ssputs_r+0x58>
 80284fc:	462a      	mov	r2, r5
 80284fe:	f000 fab9 	bl	8028a74 <_realloc_r>
 8028502:	4606      	mov	r6, r0
 8028504:	2800      	cmp	r0, #0
 8028506:	d1e1      	bne.n	80284cc <__ssputs_r+0x70>
 8028508:	6921      	ldr	r1, [r4, #16]
 802850a:	4650      	mov	r0, sl
 802850c:	f7ff fec0 	bl	8028290 <_free_r>
 8028510:	e7c7      	b.n	80284a2 <__ssputs_r+0x46>
	...

08028514 <_svfiprintf_r>:
 8028514:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028518:	4698      	mov	r8, r3
 802851a:	898b      	ldrh	r3, [r1, #12]
 802851c:	061b      	lsls	r3, r3, #24
 802851e:	b09d      	sub	sp, #116	; 0x74
 8028520:	4607      	mov	r7, r0
 8028522:	460d      	mov	r5, r1
 8028524:	4614      	mov	r4, r2
 8028526:	d50e      	bpl.n	8028546 <_svfiprintf_r+0x32>
 8028528:	690b      	ldr	r3, [r1, #16]
 802852a:	b963      	cbnz	r3, 8028546 <_svfiprintf_r+0x32>
 802852c:	2140      	movs	r1, #64	; 0x40
 802852e:	f7ff feff 	bl	8028330 <_malloc_r>
 8028532:	6028      	str	r0, [r5, #0]
 8028534:	6128      	str	r0, [r5, #16]
 8028536:	b920      	cbnz	r0, 8028542 <_svfiprintf_r+0x2e>
 8028538:	230c      	movs	r3, #12
 802853a:	603b      	str	r3, [r7, #0]
 802853c:	f04f 30ff 	mov.w	r0, #4294967295
 8028540:	e0d1      	b.n	80286e6 <_svfiprintf_r+0x1d2>
 8028542:	2340      	movs	r3, #64	; 0x40
 8028544:	616b      	str	r3, [r5, #20]
 8028546:	2300      	movs	r3, #0
 8028548:	9309      	str	r3, [sp, #36]	; 0x24
 802854a:	2320      	movs	r3, #32
 802854c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8028550:	f8cd 800c 	str.w	r8, [sp, #12]
 8028554:	2330      	movs	r3, #48	; 0x30
 8028556:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8028700 <_svfiprintf_r+0x1ec>
 802855a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 802855e:	f04f 0901 	mov.w	r9, #1
 8028562:	4623      	mov	r3, r4
 8028564:	469a      	mov	sl, r3
 8028566:	f813 2b01 	ldrb.w	r2, [r3], #1
 802856a:	b10a      	cbz	r2, 8028570 <_svfiprintf_r+0x5c>
 802856c:	2a25      	cmp	r2, #37	; 0x25
 802856e:	d1f9      	bne.n	8028564 <_svfiprintf_r+0x50>
 8028570:	ebba 0b04 	subs.w	fp, sl, r4
 8028574:	d00b      	beq.n	802858e <_svfiprintf_r+0x7a>
 8028576:	465b      	mov	r3, fp
 8028578:	4622      	mov	r2, r4
 802857a:	4629      	mov	r1, r5
 802857c:	4638      	mov	r0, r7
 802857e:	f7ff ff6d 	bl	802845c <__ssputs_r>
 8028582:	3001      	adds	r0, #1
 8028584:	f000 80aa 	beq.w	80286dc <_svfiprintf_r+0x1c8>
 8028588:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802858a:	445a      	add	r2, fp
 802858c:	9209      	str	r2, [sp, #36]	; 0x24
 802858e:	f89a 3000 	ldrb.w	r3, [sl]
 8028592:	2b00      	cmp	r3, #0
 8028594:	f000 80a2 	beq.w	80286dc <_svfiprintf_r+0x1c8>
 8028598:	2300      	movs	r3, #0
 802859a:	f04f 32ff 	mov.w	r2, #4294967295
 802859e:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80285a2:	f10a 0a01 	add.w	sl, sl, #1
 80285a6:	9304      	str	r3, [sp, #16]
 80285a8:	9307      	str	r3, [sp, #28]
 80285aa:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80285ae:	931a      	str	r3, [sp, #104]	; 0x68
 80285b0:	4654      	mov	r4, sl
 80285b2:	2205      	movs	r2, #5
 80285b4:	f814 1b01 	ldrb.w	r1, [r4], #1
 80285b8:	4851      	ldr	r0, [pc, #324]	; (8028700 <_svfiprintf_r+0x1ec>)
 80285ba:	f7d7 fe11 	bl	80001e0 <memchr>
 80285be:	9a04      	ldr	r2, [sp, #16]
 80285c0:	b9d8      	cbnz	r0, 80285fa <_svfiprintf_r+0xe6>
 80285c2:	06d0      	lsls	r0, r2, #27
 80285c4:	bf44      	itt	mi
 80285c6:	2320      	movmi	r3, #32
 80285c8:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80285cc:	0711      	lsls	r1, r2, #28
 80285ce:	bf44      	itt	mi
 80285d0:	232b      	movmi	r3, #43	; 0x2b
 80285d2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80285d6:	f89a 3000 	ldrb.w	r3, [sl]
 80285da:	2b2a      	cmp	r3, #42	; 0x2a
 80285dc:	d015      	beq.n	802860a <_svfiprintf_r+0xf6>
 80285de:	9a07      	ldr	r2, [sp, #28]
 80285e0:	4654      	mov	r4, sl
 80285e2:	2000      	movs	r0, #0
 80285e4:	f04f 0c0a 	mov.w	ip, #10
 80285e8:	4621      	mov	r1, r4
 80285ea:	f811 3b01 	ldrb.w	r3, [r1], #1
 80285ee:	3b30      	subs	r3, #48	; 0x30
 80285f0:	2b09      	cmp	r3, #9
 80285f2:	d94e      	bls.n	8028692 <_svfiprintf_r+0x17e>
 80285f4:	b1b0      	cbz	r0, 8028624 <_svfiprintf_r+0x110>
 80285f6:	9207      	str	r2, [sp, #28]
 80285f8:	e014      	b.n	8028624 <_svfiprintf_r+0x110>
 80285fa:	eba0 0308 	sub.w	r3, r0, r8
 80285fe:	fa09 f303 	lsl.w	r3, r9, r3
 8028602:	4313      	orrs	r3, r2
 8028604:	9304      	str	r3, [sp, #16]
 8028606:	46a2      	mov	sl, r4
 8028608:	e7d2      	b.n	80285b0 <_svfiprintf_r+0x9c>
 802860a:	9b03      	ldr	r3, [sp, #12]
 802860c:	1d19      	adds	r1, r3, #4
 802860e:	681b      	ldr	r3, [r3, #0]
 8028610:	9103      	str	r1, [sp, #12]
 8028612:	2b00      	cmp	r3, #0
 8028614:	bfbb      	ittet	lt
 8028616:	425b      	neglt	r3, r3
 8028618:	f042 0202 	orrlt.w	r2, r2, #2
 802861c:	9307      	strge	r3, [sp, #28]
 802861e:	9307      	strlt	r3, [sp, #28]
 8028620:	bfb8      	it	lt
 8028622:	9204      	strlt	r2, [sp, #16]
 8028624:	7823      	ldrb	r3, [r4, #0]
 8028626:	2b2e      	cmp	r3, #46	; 0x2e
 8028628:	d10c      	bne.n	8028644 <_svfiprintf_r+0x130>
 802862a:	7863      	ldrb	r3, [r4, #1]
 802862c:	2b2a      	cmp	r3, #42	; 0x2a
 802862e:	d135      	bne.n	802869c <_svfiprintf_r+0x188>
 8028630:	9b03      	ldr	r3, [sp, #12]
 8028632:	1d1a      	adds	r2, r3, #4
 8028634:	681b      	ldr	r3, [r3, #0]
 8028636:	9203      	str	r2, [sp, #12]
 8028638:	2b00      	cmp	r3, #0
 802863a:	bfb8      	it	lt
 802863c:	f04f 33ff 	movlt.w	r3, #4294967295
 8028640:	3402      	adds	r4, #2
 8028642:	9305      	str	r3, [sp, #20]
 8028644:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 8028710 <_svfiprintf_r+0x1fc>
 8028648:	7821      	ldrb	r1, [r4, #0]
 802864a:	2203      	movs	r2, #3
 802864c:	4650      	mov	r0, sl
 802864e:	f7d7 fdc7 	bl	80001e0 <memchr>
 8028652:	b140      	cbz	r0, 8028666 <_svfiprintf_r+0x152>
 8028654:	2340      	movs	r3, #64	; 0x40
 8028656:	eba0 000a 	sub.w	r0, r0, sl
 802865a:	fa03 f000 	lsl.w	r0, r3, r0
 802865e:	9b04      	ldr	r3, [sp, #16]
 8028660:	4303      	orrs	r3, r0
 8028662:	3401      	adds	r4, #1
 8028664:	9304      	str	r3, [sp, #16]
 8028666:	f814 1b01 	ldrb.w	r1, [r4], #1
 802866a:	4826      	ldr	r0, [pc, #152]	; (8028704 <_svfiprintf_r+0x1f0>)
 802866c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8028670:	2206      	movs	r2, #6
 8028672:	f7d7 fdb5 	bl	80001e0 <memchr>
 8028676:	2800      	cmp	r0, #0
 8028678:	d038      	beq.n	80286ec <_svfiprintf_r+0x1d8>
 802867a:	4b23      	ldr	r3, [pc, #140]	; (8028708 <_svfiprintf_r+0x1f4>)
 802867c:	bb1b      	cbnz	r3, 80286c6 <_svfiprintf_r+0x1b2>
 802867e:	9b03      	ldr	r3, [sp, #12]
 8028680:	3307      	adds	r3, #7
 8028682:	f023 0307 	bic.w	r3, r3, #7
 8028686:	3308      	adds	r3, #8
 8028688:	9303      	str	r3, [sp, #12]
 802868a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802868c:	4433      	add	r3, r6
 802868e:	9309      	str	r3, [sp, #36]	; 0x24
 8028690:	e767      	b.n	8028562 <_svfiprintf_r+0x4e>
 8028692:	fb0c 3202 	mla	r2, ip, r2, r3
 8028696:	460c      	mov	r4, r1
 8028698:	2001      	movs	r0, #1
 802869a:	e7a5      	b.n	80285e8 <_svfiprintf_r+0xd4>
 802869c:	2300      	movs	r3, #0
 802869e:	3401      	adds	r4, #1
 80286a0:	9305      	str	r3, [sp, #20]
 80286a2:	4619      	mov	r1, r3
 80286a4:	f04f 0c0a 	mov.w	ip, #10
 80286a8:	4620      	mov	r0, r4
 80286aa:	f810 2b01 	ldrb.w	r2, [r0], #1
 80286ae:	3a30      	subs	r2, #48	; 0x30
 80286b0:	2a09      	cmp	r2, #9
 80286b2:	d903      	bls.n	80286bc <_svfiprintf_r+0x1a8>
 80286b4:	2b00      	cmp	r3, #0
 80286b6:	d0c5      	beq.n	8028644 <_svfiprintf_r+0x130>
 80286b8:	9105      	str	r1, [sp, #20]
 80286ba:	e7c3      	b.n	8028644 <_svfiprintf_r+0x130>
 80286bc:	fb0c 2101 	mla	r1, ip, r1, r2
 80286c0:	4604      	mov	r4, r0
 80286c2:	2301      	movs	r3, #1
 80286c4:	e7f0      	b.n	80286a8 <_svfiprintf_r+0x194>
 80286c6:	ab03      	add	r3, sp, #12
 80286c8:	9300      	str	r3, [sp, #0]
 80286ca:	462a      	mov	r2, r5
 80286cc:	4b0f      	ldr	r3, [pc, #60]	; (802870c <_svfiprintf_r+0x1f8>)
 80286ce:	a904      	add	r1, sp, #16
 80286d0:	4638      	mov	r0, r7
 80286d2:	f3af 8000 	nop.w
 80286d6:	1c42      	adds	r2, r0, #1
 80286d8:	4606      	mov	r6, r0
 80286da:	d1d6      	bne.n	802868a <_svfiprintf_r+0x176>
 80286dc:	89ab      	ldrh	r3, [r5, #12]
 80286de:	065b      	lsls	r3, r3, #25
 80286e0:	f53f af2c 	bmi.w	802853c <_svfiprintf_r+0x28>
 80286e4:	9809      	ldr	r0, [sp, #36]	; 0x24
 80286e6:	b01d      	add	sp, #116	; 0x74
 80286e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80286ec:	ab03      	add	r3, sp, #12
 80286ee:	9300      	str	r3, [sp, #0]
 80286f0:	462a      	mov	r2, r5
 80286f2:	4b06      	ldr	r3, [pc, #24]	; (802870c <_svfiprintf_r+0x1f8>)
 80286f4:	a904      	add	r1, sp, #16
 80286f6:	4638      	mov	r0, r7
 80286f8:	f000 f87a 	bl	80287f0 <_printf_i>
 80286fc:	e7eb      	b.n	80286d6 <_svfiprintf_r+0x1c2>
 80286fe:	bf00      	nop
 8028700:	0802b154 	.word	0x0802b154
 8028704:	0802b15e 	.word	0x0802b15e
 8028708:	00000000 	.word	0x00000000
 802870c:	0802845d 	.word	0x0802845d
 8028710:	0802b15a 	.word	0x0802b15a

08028714 <_printf_common>:
 8028714:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028718:	4616      	mov	r6, r2
 802871a:	4699      	mov	r9, r3
 802871c:	688a      	ldr	r2, [r1, #8]
 802871e:	690b      	ldr	r3, [r1, #16]
 8028720:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8028724:	4293      	cmp	r3, r2
 8028726:	bfb8      	it	lt
 8028728:	4613      	movlt	r3, r2
 802872a:	6033      	str	r3, [r6, #0]
 802872c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8028730:	4607      	mov	r7, r0
 8028732:	460c      	mov	r4, r1
 8028734:	b10a      	cbz	r2, 802873a <_printf_common+0x26>
 8028736:	3301      	adds	r3, #1
 8028738:	6033      	str	r3, [r6, #0]
 802873a:	6823      	ldr	r3, [r4, #0]
 802873c:	0699      	lsls	r1, r3, #26
 802873e:	bf42      	ittt	mi
 8028740:	6833      	ldrmi	r3, [r6, #0]
 8028742:	3302      	addmi	r3, #2
 8028744:	6033      	strmi	r3, [r6, #0]
 8028746:	6825      	ldr	r5, [r4, #0]
 8028748:	f015 0506 	ands.w	r5, r5, #6
 802874c:	d106      	bne.n	802875c <_printf_common+0x48>
 802874e:	f104 0a19 	add.w	sl, r4, #25
 8028752:	68e3      	ldr	r3, [r4, #12]
 8028754:	6832      	ldr	r2, [r6, #0]
 8028756:	1a9b      	subs	r3, r3, r2
 8028758:	42ab      	cmp	r3, r5
 802875a:	dc26      	bgt.n	80287aa <_printf_common+0x96>
 802875c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8028760:	1e13      	subs	r3, r2, #0
 8028762:	6822      	ldr	r2, [r4, #0]
 8028764:	bf18      	it	ne
 8028766:	2301      	movne	r3, #1
 8028768:	0692      	lsls	r2, r2, #26
 802876a:	d42b      	bmi.n	80287c4 <_printf_common+0xb0>
 802876c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8028770:	4649      	mov	r1, r9
 8028772:	4638      	mov	r0, r7
 8028774:	47c0      	blx	r8
 8028776:	3001      	adds	r0, #1
 8028778:	d01e      	beq.n	80287b8 <_printf_common+0xa4>
 802877a:	6823      	ldr	r3, [r4, #0]
 802877c:	68e5      	ldr	r5, [r4, #12]
 802877e:	6832      	ldr	r2, [r6, #0]
 8028780:	f003 0306 	and.w	r3, r3, #6
 8028784:	2b04      	cmp	r3, #4
 8028786:	bf08      	it	eq
 8028788:	1aad      	subeq	r5, r5, r2
 802878a:	68a3      	ldr	r3, [r4, #8]
 802878c:	6922      	ldr	r2, [r4, #16]
 802878e:	bf0c      	ite	eq
 8028790:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8028794:	2500      	movne	r5, #0
 8028796:	4293      	cmp	r3, r2
 8028798:	bfc4      	itt	gt
 802879a:	1a9b      	subgt	r3, r3, r2
 802879c:	18ed      	addgt	r5, r5, r3
 802879e:	2600      	movs	r6, #0
 80287a0:	341a      	adds	r4, #26
 80287a2:	42b5      	cmp	r5, r6
 80287a4:	d11a      	bne.n	80287dc <_printf_common+0xc8>
 80287a6:	2000      	movs	r0, #0
 80287a8:	e008      	b.n	80287bc <_printf_common+0xa8>
 80287aa:	2301      	movs	r3, #1
 80287ac:	4652      	mov	r2, sl
 80287ae:	4649      	mov	r1, r9
 80287b0:	4638      	mov	r0, r7
 80287b2:	47c0      	blx	r8
 80287b4:	3001      	adds	r0, #1
 80287b6:	d103      	bne.n	80287c0 <_printf_common+0xac>
 80287b8:	f04f 30ff 	mov.w	r0, #4294967295
 80287bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80287c0:	3501      	adds	r5, #1
 80287c2:	e7c6      	b.n	8028752 <_printf_common+0x3e>
 80287c4:	18e1      	adds	r1, r4, r3
 80287c6:	1c5a      	adds	r2, r3, #1
 80287c8:	2030      	movs	r0, #48	; 0x30
 80287ca:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80287ce:	4422      	add	r2, r4
 80287d0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80287d4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80287d8:	3302      	adds	r3, #2
 80287da:	e7c7      	b.n	802876c <_printf_common+0x58>
 80287dc:	2301      	movs	r3, #1
 80287de:	4622      	mov	r2, r4
 80287e0:	4649      	mov	r1, r9
 80287e2:	4638      	mov	r0, r7
 80287e4:	47c0      	blx	r8
 80287e6:	3001      	adds	r0, #1
 80287e8:	d0e6      	beq.n	80287b8 <_printf_common+0xa4>
 80287ea:	3601      	adds	r6, #1
 80287ec:	e7d9      	b.n	80287a2 <_printf_common+0x8e>
	...

080287f0 <_printf_i>:
 80287f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80287f4:	460c      	mov	r4, r1
 80287f6:	4691      	mov	r9, r2
 80287f8:	7e27      	ldrb	r7, [r4, #24]
 80287fa:	990c      	ldr	r1, [sp, #48]	; 0x30
 80287fc:	2f78      	cmp	r7, #120	; 0x78
 80287fe:	4680      	mov	r8, r0
 8028800:	469a      	mov	sl, r3
 8028802:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8028806:	d807      	bhi.n	8028818 <_printf_i+0x28>
 8028808:	2f62      	cmp	r7, #98	; 0x62
 802880a:	d80a      	bhi.n	8028822 <_printf_i+0x32>
 802880c:	2f00      	cmp	r7, #0
 802880e:	f000 80d8 	beq.w	80289c2 <_printf_i+0x1d2>
 8028812:	2f58      	cmp	r7, #88	; 0x58
 8028814:	f000 80a3 	beq.w	802895e <_printf_i+0x16e>
 8028818:	f104 0642 	add.w	r6, r4, #66	; 0x42
 802881c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8028820:	e03a      	b.n	8028898 <_printf_i+0xa8>
 8028822:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8028826:	2b15      	cmp	r3, #21
 8028828:	d8f6      	bhi.n	8028818 <_printf_i+0x28>
 802882a:	a001      	add	r0, pc, #4	; (adr r0, 8028830 <_printf_i+0x40>)
 802882c:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 8028830:	08028889 	.word	0x08028889
 8028834:	0802889d 	.word	0x0802889d
 8028838:	08028819 	.word	0x08028819
 802883c:	08028819 	.word	0x08028819
 8028840:	08028819 	.word	0x08028819
 8028844:	08028819 	.word	0x08028819
 8028848:	0802889d 	.word	0x0802889d
 802884c:	08028819 	.word	0x08028819
 8028850:	08028819 	.word	0x08028819
 8028854:	08028819 	.word	0x08028819
 8028858:	08028819 	.word	0x08028819
 802885c:	080289a9 	.word	0x080289a9
 8028860:	080288cd 	.word	0x080288cd
 8028864:	0802898b 	.word	0x0802898b
 8028868:	08028819 	.word	0x08028819
 802886c:	08028819 	.word	0x08028819
 8028870:	080289cb 	.word	0x080289cb
 8028874:	08028819 	.word	0x08028819
 8028878:	080288cd 	.word	0x080288cd
 802887c:	08028819 	.word	0x08028819
 8028880:	08028819 	.word	0x08028819
 8028884:	08028993 	.word	0x08028993
 8028888:	680b      	ldr	r3, [r1, #0]
 802888a:	1d1a      	adds	r2, r3, #4
 802888c:	681b      	ldr	r3, [r3, #0]
 802888e:	600a      	str	r2, [r1, #0]
 8028890:	f104 0642 	add.w	r6, r4, #66	; 0x42
 8028894:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8028898:	2301      	movs	r3, #1
 802889a:	e0a3      	b.n	80289e4 <_printf_i+0x1f4>
 802889c:	6825      	ldr	r5, [r4, #0]
 802889e:	6808      	ldr	r0, [r1, #0]
 80288a0:	062e      	lsls	r6, r5, #24
 80288a2:	f100 0304 	add.w	r3, r0, #4
 80288a6:	d50a      	bpl.n	80288be <_printf_i+0xce>
 80288a8:	6805      	ldr	r5, [r0, #0]
 80288aa:	600b      	str	r3, [r1, #0]
 80288ac:	2d00      	cmp	r5, #0
 80288ae:	da03      	bge.n	80288b8 <_printf_i+0xc8>
 80288b0:	232d      	movs	r3, #45	; 0x2d
 80288b2:	426d      	negs	r5, r5
 80288b4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80288b8:	485e      	ldr	r0, [pc, #376]	; (8028a34 <_printf_i+0x244>)
 80288ba:	230a      	movs	r3, #10
 80288bc:	e019      	b.n	80288f2 <_printf_i+0x102>
 80288be:	f015 0f40 	tst.w	r5, #64	; 0x40
 80288c2:	6805      	ldr	r5, [r0, #0]
 80288c4:	600b      	str	r3, [r1, #0]
 80288c6:	bf18      	it	ne
 80288c8:	b22d      	sxthne	r5, r5
 80288ca:	e7ef      	b.n	80288ac <_printf_i+0xbc>
 80288cc:	680b      	ldr	r3, [r1, #0]
 80288ce:	6825      	ldr	r5, [r4, #0]
 80288d0:	1d18      	adds	r0, r3, #4
 80288d2:	6008      	str	r0, [r1, #0]
 80288d4:	0628      	lsls	r0, r5, #24
 80288d6:	d501      	bpl.n	80288dc <_printf_i+0xec>
 80288d8:	681d      	ldr	r5, [r3, #0]
 80288da:	e002      	b.n	80288e2 <_printf_i+0xf2>
 80288dc:	0669      	lsls	r1, r5, #25
 80288de:	d5fb      	bpl.n	80288d8 <_printf_i+0xe8>
 80288e0:	881d      	ldrh	r5, [r3, #0]
 80288e2:	4854      	ldr	r0, [pc, #336]	; (8028a34 <_printf_i+0x244>)
 80288e4:	2f6f      	cmp	r7, #111	; 0x6f
 80288e6:	bf0c      	ite	eq
 80288e8:	2308      	moveq	r3, #8
 80288ea:	230a      	movne	r3, #10
 80288ec:	2100      	movs	r1, #0
 80288ee:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80288f2:	6866      	ldr	r6, [r4, #4]
 80288f4:	60a6      	str	r6, [r4, #8]
 80288f6:	2e00      	cmp	r6, #0
 80288f8:	bfa2      	ittt	ge
 80288fa:	6821      	ldrge	r1, [r4, #0]
 80288fc:	f021 0104 	bicge.w	r1, r1, #4
 8028900:	6021      	strge	r1, [r4, #0]
 8028902:	b90d      	cbnz	r5, 8028908 <_printf_i+0x118>
 8028904:	2e00      	cmp	r6, #0
 8028906:	d04d      	beq.n	80289a4 <_printf_i+0x1b4>
 8028908:	4616      	mov	r6, r2
 802890a:	fbb5 f1f3 	udiv	r1, r5, r3
 802890e:	fb03 5711 	mls	r7, r3, r1, r5
 8028912:	5dc7      	ldrb	r7, [r0, r7]
 8028914:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8028918:	462f      	mov	r7, r5
 802891a:	42bb      	cmp	r3, r7
 802891c:	460d      	mov	r5, r1
 802891e:	d9f4      	bls.n	802890a <_printf_i+0x11a>
 8028920:	2b08      	cmp	r3, #8
 8028922:	d10b      	bne.n	802893c <_printf_i+0x14c>
 8028924:	6823      	ldr	r3, [r4, #0]
 8028926:	07df      	lsls	r7, r3, #31
 8028928:	d508      	bpl.n	802893c <_printf_i+0x14c>
 802892a:	6923      	ldr	r3, [r4, #16]
 802892c:	6861      	ldr	r1, [r4, #4]
 802892e:	4299      	cmp	r1, r3
 8028930:	bfde      	ittt	le
 8028932:	2330      	movle	r3, #48	; 0x30
 8028934:	f806 3c01 	strble.w	r3, [r6, #-1]
 8028938:	f106 36ff 	addle.w	r6, r6, #4294967295
 802893c:	1b92      	subs	r2, r2, r6
 802893e:	6122      	str	r2, [r4, #16]
 8028940:	f8cd a000 	str.w	sl, [sp]
 8028944:	464b      	mov	r3, r9
 8028946:	aa03      	add	r2, sp, #12
 8028948:	4621      	mov	r1, r4
 802894a:	4640      	mov	r0, r8
 802894c:	f7ff fee2 	bl	8028714 <_printf_common>
 8028950:	3001      	adds	r0, #1
 8028952:	d14c      	bne.n	80289ee <_printf_i+0x1fe>
 8028954:	f04f 30ff 	mov.w	r0, #4294967295
 8028958:	b004      	add	sp, #16
 802895a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802895e:	4835      	ldr	r0, [pc, #212]	; (8028a34 <_printf_i+0x244>)
 8028960:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 8028964:	6823      	ldr	r3, [r4, #0]
 8028966:	680e      	ldr	r6, [r1, #0]
 8028968:	061f      	lsls	r7, r3, #24
 802896a:	f856 5b04 	ldr.w	r5, [r6], #4
 802896e:	600e      	str	r6, [r1, #0]
 8028970:	d514      	bpl.n	802899c <_printf_i+0x1ac>
 8028972:	07d9      	lsls	r1, r3, #31
 8028974:	bf44      	itt	mi
 8028976:	f043 0320 	orrmi.w	r3, r3, #32
 802897a:	6023      	strmi	r3, [r4, #0]
 802897c:	b91d      	cbnz	r5, 8028986 <_printf_i+0x196>
 802897e:	6823      	ldr	r3, [r4, #0]
 8028980:	f023 0320 	bic.w	r3, r3, #32
 8028984:	6023      	str	r3, [r4, #0]
 8028986:	2310      	movs	r3, #16
 8028988:	e7b0      	b.n	80288ec <_printf_i+0xfc>
 802898a:	6823      	ldr	r3, [r4, #0]
 802898c:	f043 0320 	orr.w	r3, r3, #32
 8028990:	6023      	str	r3, [r4, #0]
 8028992:	2378      	movs	r3, #120	; 0x78
 8028994:	4828      	ldr	r0, [pc, #160]	; (8028a38 <_printf_i+0x248>)
 8028996:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 802899a:	e7e3      	b.n	8028964 <_printf_i+0x174>
 802899c:	065e      	lsls	r6, r3, #25
 802899e:	bf48      	it	mi
 80289a0:	b2ad      	uxthmi	r5, r5
 80289a2:	e7e6      	b.n	8028972 <_printf_i+0x182>
 80289a4:	4616      	mov	r6, r2
 80289a6:	e7bb      	b.n	8028920 <_printf_i+0x130>
 80289a8:	680b      	ldr	r3, [r1, #0]
 80289aa:	6826      	ldr	r6, [r4, #0]
 80289ac:	6960      	ldr	r0, [r4, #20]
 80289ae:	1d1d      	adds	r5, r3, #4
 80289b0:	600d      	str	r5, [r1, #0]
 80289b2:	0635      	lsls	r5, r6, #24
 80289b4:	681b      	ldr	r3, [r3, #0]
 80289b6:	d501      	bpl.n	80289bc <_printf_i+0x1cc>
 80289b8:	6018      	str	r0, [r3, #0]
 80289ba:	e002      	b.n	80289c2 <_printf_i+0x1d2>
 80289bc:	0671      	lsls	r1, r6, #25
 80289be:	d5fb      	bpl.n	80289b8 <_printf_i+0x1c8>
 80289c0:	8018      	strh	r0, [r3, #0]
 80289c2:	2300      	movs	r3, #0
 80289c4:	6123      	str	r3, [r4, #16]
 80289c6:	4616      	mov	r6, r2
 80289c8:	e7ba      	b.n	8028940 <_printf_i+0x150>
 80289ca:	680b      	ldr	r3, [r1, #0]
 80289cc:	1d1a      	adds	r2, r3, #4
 80289ce:	600a      	str	r2, [r1, #0]
 80289d0:	681e      	ldr	r6, [r3, #0]
 80289d2:	6862      	ldr	r2, [r4, #4]
 80289d4:	2100      	movs	r1, #0
 80289d6:	4630      	mov	r0, r6
 80289d8:	f7d7 fc02 	bl	80001e0 <memchr>
 80289dc:	b108      	cbz	r0, 80289e2 <_printf_i+0x1f2>
 80289de:	1b80      	subs	r0, r0, r6
 80289e0:	6060      	str	r0, [r4, #4]
 80289e2:	6863      	ldr	r3, [r4, #4]
 80289e4:	6123      	str	r3, [r4, #16]
 80289e6:	2300      	movs	r3, #0
 80289e8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80289ec:	e7a8      	b.n	8028940 <_printf_i+0x150>
 80289ee:	6923      	ldr	r3, [r4, #16]
 80289f0:	4632      	mov	r2, r6
 80289f2:	4649      	mov	r1, r9
 80289f4:	4640      	mov	r0, r8
 80289f6:	47d0      	blx	sl
 80289f8:	3001      	adds	r0, #1
 80289fa:	d0ab      	beq.n	8028954 <_printf_i+0x164>
 80289fc:	6823      	ldr	r3, [r4, #0]
 80289fe:	079b      	lsls	r3, r3, #30
 8028a00:	d413      	bmi.n	8028a2a <_printf_i+0x23a>
 8028a02:	68e0      	ldr	r0, [r4, #12]
 8028a04:	9b03      	ldr	r3, [sp, #12]
 8028a06:	4298      	cmp	r0, r3
 8028a08:	bfb8      	it	lt
 8028a0a:	4618      	movlt	r0, r3
 8028a0c:	e7a4      	b.n	8028958 <_printf_i+0x168>
 8028a0e:	2301      	movs	r3, #1
 8028a10:	4632      	mov	r2, r6
 8028a12:	4649      	mov	r1, r9
 8028a14:	4640      	mov	r0, r8
 8028a16:	47d0      	blx	sl
 8028a18:	3001      	adds	r0, #1
 8028a1a:	d09b      	beq.n	8028954 <_printf_i+0x164>
 8028a1c:	3501      	adds	r5, #1
 8028a1e:	68e3      	ldr	r3, [r4, #12]
 8028a20:	9903      	ldr	r1, [sp, #12]
 8028a22:	1a5b      	subs	r3, r3, r1
 8028a24:	42ab      	cmp	r3, r5
 8028a26:	dcf2      	bgt.n	8028a0e <_printf_i+0x21e>
 8028a28:	e7eb      	b.n	8028a02 <_printf_i+0x212>
 8028a2a:	2500      	movs	r5, #0
 8028a2c:	f104 0619 	add.w	r6, r4, #25
 8028a30:	e7f5      	b.n	8028a1e <_printf_i+0x22e>
 8028a32:	bf00      	nop
 8028a34:	0802b165 	.word	0x0802b165
 8028a38:	0802b176 	.word	0x0802b176

08028a3c <__retarget_lock_acquire_recursive>:
 8028a3c:	4770      	bx	lr

08028a3e <__retarget_lock_release_recursive>:
 8028a3e:	4770      	bx	lr

08028a40 <memmove>:
 8028a40:	4288      	cmp	r0, r1
 8028a42:	b510      	push	{r4, lr}
 8028a44:	eb01 0402 	add.w	r4, r1, r2
 8028a48:	d902      	bls.n	8028a50 <memmove+0x10>
 8028a4a:	4284      	cmp	r4, r0
 8028a4c:	4623      	mov	r3, r4
 8028a4e:	d807      	bhi.n	8028a60 <memmove+0x20>
 8028a50:	1e43      	subs	r3, r0, #1
 8028a52:	42a1      	cmp	r1, r4
 8028a54:	d008      	beq.n	8028a68 <memmove+0x28>
 8028a56:	f811 2b01 	ldrb.w	r2, [r1], #1
 8028a5a:	f803 2f01 	strb.w	r2, [r3, #1]!
 8028a5e:	e7f8      	b.n	8028a52 <memmove+0x12>
 8028a60:	4402      	add	r2, r0
 8028a62:	4601      	mov	r1, r0
 8028a64:	428a      	cmp	r2, r1
 8028a66:	d100      	bne.n	8028a6a <memmove+0x2a>
 8028a68:	bd10      	pop	{r4, pc}
 8028a6a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8028a6e:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8028a72:	e7f7      	b.n	8028a64 <memmove+0x24>

08028a74 <_realloc_r>:
 8028a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028a76:	4607      	mov	r7, r0
 8028a78:	4614      	mov	r4, r2
 8028a7a:	460e      	mov	r6, r1
 8028a7c:	b921      	cbnz	r1, 8028a88 <_realloc_r+0x14>
 8028a7e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8028a82:	4611      	mov	r1, r2
 8028a84:	f7ff bc54 	b.w	8028330 <_malloc_r>
 8028a88:	b922      	cbnz	r2, 8028a94 <_realloc_r+0x20>
 8028a8a:	f7ff fc01 	bl	8028290 <_free_r>
 8028a8e:	4625      	mov	r5, r4
 8028a90:	4628      	mov	r0, r5
 8028a92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8028a94:	f000 f814 	bl	8028ac0 <_malloc_usable_size_r>
 8028a98:	42a0      	cmp	r0, r4
 8028a9a:	d20f      	bcs.n	8028abc <_realloc_r+0x48>
 8028a9c:	4621      	mov	r1, r4
 8028a9e:	4638      	mov	r0, r7
 8028aa0:	f7ff fc46 	bl	8028330 <_malloc_r>
 8028aa4:	4605      	mov	r5, r0
 8028aa6:	2800      	cmp	r0, #0
 8028aa8:	d0f2      	beq.n	8028a90 <_realloc_r+0x1c>
 8028aaa:	4631      	mov	r1, r6
 8028aac:	4622      	mov	r2, r4
 8028aae:	f7ff fbd9 	bl	8028264 <memcpy>
 8028ab2:	4631      	mov	r1, r6
 8028ab4:	4638      	mov	r0, r7
 8028ab6:	f7ff fbeb 	bl	8028290 <_free_r>
 8028aba:	e7e9      	b.n	8028a90 <_realloc_r+0x1c>
 8028abc:	4635      	mov	r5, r6
 8028abe:	e7e7      	b.n	8028a90 <_realloc_r+0x1c>

08028ac0 <_malloc_usable_size_r>:
 8028ac0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8028ac4:	1f18      	subs	r0, r3, #4
 8028ac6:	2b00      	cmp	r3, #0
 8028ac8:	bfbc      	itt	lt
 8028aca:	580b      	ldrlt	r3, [r1, r0]
 8028acc:	18c0      	addlt	r0, r0, r3
 8028ace:	4770      	bx	lr

08028ad0 <_init>:
 8028ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028ad2:	bf00      	nop
 8028ad4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028ad6:	bc08      	pop	{r3}
 8028ad8:	469e      	mov	lr, r3
 8028ada:	4770      	bx	lr

08028adc <_fini>:
 8028adc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028ade:	bf00      	nop
 8028ae0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8028ae2:	bc08      	pop	{r3}
 8028ae4:	469e      	mov	lr, r3
 8028ae6:	4770      	bx	lr
